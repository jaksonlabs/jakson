/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ALLOC_H
#define ALLOC_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>

BEGIN_DECL

/**
 * Allocates <code>num</code> elements of size <code>sizeof(type)</code> using the allocator <code>alloc</code> and
 * creates a new stack variable <code>type *name</code>.
 */
#define ALLOC_MALLOC(type, name, num, alloc)                                                                          \
    type *name = alloc_malloc(alloc, num *sizeof(type))

/**
 * Invokes a free operation in <code>alloc</code> allocator to free up memory assigned to pointer <code>name</code>
 */
#define ALLOC_FREE(name, alloc)                                                                                       \
    alloc_free(alloc, name)

typedef struct allocator {
        /**
         *  Implementation-specific data (private fields etc.)
         *  This pointer may point to NULL.
         */
        void *extra;

        /**
         *  Error information
         */
        err err;

        /**
         *  Implementation to call memory allocation.
         */
        void *(*malloc)(allocator *self, size_t size);

        /**
         *  Implementation to call memory re-allocation.
         */
        void *(*realloc)(allocator *self, void *ptr, size_t size);

        /**
         *  Implementation to call freeing up memory.
         *  Depending on the strategy, freeing up memory might be lazy.
         */
        void (*free)(allocator *self, void *ptr);

        /**
         *  Perform a deep copy of this allocator including implementation-specific data stored in 'extra'
         *
         * @param dst non-null target in which 'self' should be cloned
         * @param self non-null source which should be clones in 'dst'
         */
        void (*clone)(allocator *dst, const allocator *self);
} allocator;

/**
 * Returns standard c-lib allocator (malloc, realloc, free)
 *
 * @param alloc must be non-null
 * @return STATUS_OK in case of non-null parameter alloc, STATUS_NULLPTR otherwise
 */
bool alloc_create_std(allocator *alloc);

/**
 * Creates a new allocator 'dst' with default constructor (in case of 'this' is null), or as copy of
 * 'this' (in case 'this' is non-null)
 * @param dst non-null destination in which the allocator should be stored
 * @param self possibly null-pointer to an allocator implementation
 * @return a value unequal to STATUS_OK in case the operation is not successful
 */
bool alloc_this_or_std(allocator *dst, const allocator *self);

/**
 * Performs a deep copy of the allocator 'src' into the allocator 'dst'.
 *
 * @param dst non-null pointer to allocator implementation (of same implementation as src)
 * @param src non-null pointer to allocator implementation (of same implementation as dst)
 * @return STATUS_OK in case of success, otherwise a value unequal to STATUS_OK describing the ERROR
 */
bool alloc_clone(allocator *dst, const allocator *src);

/**
 * Invokes memory allocation of 'size' bytes using the allocator 'alloc'.
 *
 * If allocation fails, the system may panic.
 *
 * @param alloc non-null pointer to allocator implementation
 * @param size number of bytes requested
 * @return non-null pointer to memory allocated with 'alloc'
 */
void *alloc_malloc(allocator *alloc, size_t size);

/**
 * Invokes memory re-allocation for pointer 'ptr' (that is managed by 'alloc') to size 'size' in bytes.
 *
 * @param alloc non-null pointer to allocator implementation
 * @param ptr non-null pointer manged by 'alloc'
 * @param size new number of bytes for 'ptr'
 * @return non-null pointer that points to reallocated memory for 'ptr'
 */
void *alloc_realloc(allocator *alloc, void *ptr, size_t size);

/**
 * Invokes memory freeing for pointer 'ptr' (that is managed by 'alloc').
 * Depending on the implementation, this operation might be lazy.
 *
 * @param alloc non-null pointer to allocator implementation
 * @param ptr non-null pointer manged by 'alloc'
 * @return STATUS_OK if success, STATUS_NULLPTR if <code>alloc</code> or <code>ptr</ptr> is <b>NULL</b>
 */
bool alloc_free(allocator *alloc, void *ptr);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ALLOC_TRACER_H
#define ALLOC_TRACER_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include "alloc.h"

BEGIN_DECL

/**
 * Returns standard c-lib allocator (malloc, realloc, free) that collects some statistics
 * for inspection purposes. Generally, this implementation is slow and should not be used
 * in productive mode
 *
 * @param alloc must be non-null
 * @return STATUS_OK in case of non-null parameter alloc, STATUS_NULLPTR otherwise
 */
int trace_alloc_create(allocator *alloc);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ARCHIVE_H
#define ARCHIVE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <memblock.h>
#include <memfile.h>
#include <pack.h>
#include <column_doc.h>
#include <archive_io.h>
#include <archive_int.h>

BEGIN_DECL

typedef struct archive {
        archive_info info;
        char *disk_file_path;
        string_table string_table;
        record_table record_table;
        err err;
        struct sid_to_offset *query_index_string_id_to_offset;
        struct string_cache *string_id_cache;
        archive_query *default_query;
} archive;

typedef struct archive_callback {
        void (*begin_create_from_model)();
        void (*end_create_from_model)();
        void (*begin_create_from_json)();
        void (*end_create_from_json)();
        void (*begin_archive_stream_from_json)();
        void (*end_archive_stream_from_json)();
        void (*begin_write_archive_file_to_disk)();
        void (*end_write_archive_file_to_disk)();
        void (*begin_load_archive)();
        void (*end_load_archive)();
        void (*begin_setup_string_dict_ionary)();
        void (*end_setup_string_dict_ionary)();
        void (*begin_parse_json)();
        void (*end_parse_json)();
        void (*begin_test_json)();
        void (*end_test_json)();
        void (*begin_import_json)();
        void (*end_import_json)();
        void (*begin_cleanup)();
        void (*end_cleanup)();
        void (*begin_write_string_table)();
        void (*end_write_string_table)();
        void (*begin_write_record_table)();
        void (*end_write_record_table)();
        void (*skip_string_id_index_baking)();
        void (*begin_string_id_index_baking)();
        void (*end_string_id_index_baking)();
} archive_callback;

DEFINE_GET_ERROR_FUNCTION(archive, archive, archive);

bool archive_from_json(archive *out, const char *file, err *err, const char *json_string, packer_e compressor, str_dict_tag_e dictionary, size_t num_async_dic_threads, bool read_optimized, bool bake_string_id_index, archive_callback *callback);
bool archive_stream_from_json(memblock **stream, err *err, const char *json_string, packer_e compressor, str_dict_tag_e dictionary, size_t num_async_dic_threads, bool read_optimized, bool bake_id_index, archive_callback *callback);
bool archive_from_model(memblock **stream, err *err, column_doc *model, packer_e compressor, bool bake_string_id_index, archive_callback *callback);
bool archive_write(FILE *file, const memblock *stream);
bool archive_load(memblock **stream, FILE *file);
bool archive_print(FILE *file, err *err, memblock *stream);
bool archive_open(archive *out, const char *file_path);
bool archive_get_info(archive_info *info, const archive *archive);
bool archive_close(archive *archive);
bool archive_drop_indexes(archive *archive);
bool archive_query_run(archive_query *query, archive *archive);
bool archive_has_query_index_string_id_to_offset(bool *state, archive *archive);
bool archive_hash_query_string_id_cache(bool *has_cache, archive *archive);
bool archive_drop_query_string_id_cache(archive *archive);
struct string_cache *archive_get_query_string_id_cache(archive *archive);
archive_query *archive_query_default(archive *archive);

/**
 * Creates a new <code>archive_io_context</code> to access the archives underlying file for unsafe operations.
 *
 * An unsafe operation directly seeks randomly in the underlying file. To avoid creation of multiple file
 * descriptors while at the same time allow to access unsafe operations in a multi-threading environment, an
 * <code>archive_io_context</code> is used. Roughly, such a context is a regular FILE that is protected by a lock.
 *
 * @param archive The archive
 * @return a heap-allocated instance of <code>archive_io_context</code>, or NULL if not successful
 */
archive_io_context *archive_io_context_create(archive *archive);

END_DECL

#endif/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CACHE_H
#define CACHE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>
#include <archive_query.h>

BEGIN_DECL

typedef struct sid_cache_stats {
        size_t num_hits;
        size_t num_misses;
        size_t num_evicted;
} sid_cache_stats;

bool string_id_cache_create_lru(struct string_cache **cache, archive *archive);
bool string_id_cache_create_lru_ex(struct string_cache **cache, archive *archive, size_t capacity);
bool string_id_cache_get_error(err *err, const struct string_cache *cache);
bool string_id_cache_get_size(size_t *size, const struct string_cache *cache);
char *string_id_cache_get(struct string_cache *cache, archive_field_sid_t id);
bool string_id_cache_get_statistics(sid_cache_stats *statistics, struct string_cache *cache);
bool string_id_cache_reset_statistics(struct string_cache *cache);
bool string_id_cache_drop(struct string_cache *cache);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ARCHIVE_DOC_CONVERTER_H
#define ARCHIVE_DOC_CONVERTER_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <encoded_doc.h>

BEGIN_DECL

bool archive_converter(encoded_doc_list *collection, archive *archive);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef INTERNALS_ARCHIVE_H
#define INTERNALS_ARCHIVE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <memfile.h>
#include <types.h>
#include <unique_id.h>
#include <pack.h>

BEGIN_DECL

typedef struct __attribute__((packed)) archive_header {
        char magic[9];
        u8 version;
        offset_t root_object_header_offset;
        offset_t string_id_to_offset_index_offset;
} archive_header;

typedef struct __attribute__((packed)) record_header {
        char marker;
        u8 flags;
        u64 record_size;
} record_header;

typedef struct __attribute__((packed)) object_header {
        char marker;
        unique_id_t oid;
        u32 flags;
} object_header;

typedef struct __attribute__((packed)) prop_header {
        char marker;
        u32 num_entries;
} prop_header;

typedef union __attribute__((packed)) string_tab_flags {
        struct {
                u8 compressor_none
                        : 1;
                u8 compressed_huffman
                        : 1;
        } bits;
        u8 value;
} string_tab_flags_u;

typedef struct __attribute__((packed)) string_table_header {
        char marker;
        u32 num_entries;
        u8 flags;
        offset_t first_entry;
        offset_t compressor_extra_size;
} string_table_header;

typedef struct __attribute__((packed)) object_array_header {
        char marker;
        u8 num_entries;
} object_array_header;

typedef struct __attribute__((packed)) column_group_header {
        char marker;
        u32 num_columns;
        u32 num_objects;
} column_group_header;

typedef struct __attribute__((packed)) column_header {
        char marker;
        archive_field_sid_t column_name;
        char value_type;
        u32 num_entries;
} column_header;

typedef union object_flags {
        struct {
                u32 has_null_props
                        : 1;
                u32 has_bool_props
                        : 1;
                u32 has_int8_props
                        : 1;
                u32 has_int16_props
                        : 1;
                u32 has_int32_props
                        : 1;
                u32 has_int64_props
                        : 1;
                u32 has_uint8_props
                        : 1;
                u32 has_uint16_props
                        : 1;
                u32 has_uint32_props
                        : 1;
                u32 has_uint64_props
                        : 1;
                u32 has_float_props
                        : 1;
                u32 has_string_props
                        : 1;
                u32 has_object_props
                        : 1;
                u32 has_null_array_props
                        : 1;
                u32 has_bool_array_props
                        : 1;
                u32 has_int8_array_props
                        : 1;
                u32 has_int16_array_props
                        : 1;
                u32 has_int32_array_props
                        : 1;
                u32 has_int64_array_props
                        : 1;
                u32 has_uint8_array_props
                        : 1;
                u32 has_uint16_array_props
                        : 1;
                u32 has_uint32_array_props
                        : 1;
                u32 has_uint64_array_props
                        : 1;
                u32 has_float_array_props
                        : 1;
                u32 has_string_array_props
                        : 1;
                u32 has_object_array_props
                        : 1;
                u32 RESERVED_27
                        : 1;
                u32 RESERVED_28
                        : 1;
                u32 RESERVED_29
                        : 1;
                u32 RESERVED_30
                        : 1;
                u32 RESERVED_31
                        : 1;
                u32 RESERVED_32
                        : 1;
        } bits;
        u32 value;
} object_flags_u;

typedef struct archive_prop_offs {
        offset_t nulls;
        offset_t bools;
        offset_t int8s;
        offset_t int16s;
        offset_t int32s;
        offset_t int64s;
        offset_t uint8s;
        offset_t uint16s;
        offset_t uint32s;
        offset_t uint64s;
        offset_t floats;
        offset_t strings;
        offset_t objects;
        offset_t null_arrays;
        offset_t bool_arrays;
        offset_t int8_arrays;
        offset_t int16_arrays;
        offset_t int32_arrays;
        offset_t int64_arrays;
        offset_t uint8_arrays;
        offset_t uint16_arrays;
        offset_t uint32_arrays;
        offset_t uint64_arrays;
        offset_t float_arrays;
        offset_t string_arrays;
        offset_t object_arrays;
} archive_prop_offs;

typedef struct fixed_prop {
        prop_header *header;
        const archive_field_sid_t *keys;
        const void *values;
} fixed_prop;

typedef struct table_prop {
        prop_header *header;
        const archive_field_sid_t *keys;
        const offset_t *group_offs;
} table_prop;

typedef struct var_prop {
        prop_header *header;
        const archive_field_sid_t *keys;
        const offset_t *offsets;
        const void *values;
} var_prop;

typedef struct array_prop {
        prop_header *header;
        const archive_field_sid_t *keys;
        const u32 *lengths;
        offset_t values_begin;
} array_prop;

typedef struct null_prop {
        prop_header *header;
        const archive_field_sid_t *keys;
} null_prop;

typedef enum archive_marker {
        MARKER_TYPE_OBJECT_BEGIN = 0,
        MARKER_TYPE_OBJECT_END = 1,
        MARKER_TYPE_PROP_NULL = 2,
        MARKER_TYPE_PROP_BOOLEAN = 3,
        MARKER_TYPE_PROP_INT8 = 4,
        MARKER_TYPE_PROP_INT16 = 5,
        MARKER_TYPE_PROP_INT32 = 6,
        MARKER_TYPE_PROP_INT64 = 7,
        MARKER_TYPE_PROP_UINT8 = 8,
        MARKER_TYPE_PROP_UINT16 = 9,
        MARKER_TYPE_PROP_UINT32 = 10,
        MARKER_TYPE_PROP_UINT64 = 11,
        MARKER_TYPE_PROP_REAL = 12,
        MARKER_TYPE_PROP_TEXT = 13,
        MARKER_TYPE_PROP_OBJECT = 14,
        MARKER_TYPE_PROP_NULL_ARRAY = 15,
        MARKER_TYPE_PROP_BOOLEAN_ARRAY = 16,
        MARKER_TYPE_PROP_INT8_ARRAY = 17,
        MARKER_TYPE_PROP_INT16_ARRAY = 18,
        MARKER_TYPE_PROP_INT32_ARRAY = 19,
        MARKER_TYPE_PROP_INT64_ARRAY = 20,
        MARKER_TYPE_PROP_UINT8_ARRAY = 21,
        MARKER_TYPE_PROP_UINT16_ARRAY = 22,
        MARKER_TYPE_PROP_UINT32_ARRAY = 23,
        MARKER_TYPE_PROP_UINT64_ARRAY = 24,
        MARKER_TYPE_PROP_REAL_ARRAY = 25,
        MARKER_TYPE_PROP_TEXT_ARRAY = 26,
        MARKER_TYPE_PROP_OBJECT_ARRAY = 27,
        MARKER_TYPE_EMBEDDED_STR_DIC = 28,
        MARKER_TYPE_EMBEDDED_UNCOMP_STR = 29,
        MARKER_TYPE_COLUMN_GROUP = 30,
        MARKER_TYPE_COLUMN = 31,
        MARKER_TYPE_HUFFMAN_DIC_ENTRY = 32,
        MARKER_TYPE_RECORD_HEADER = 33,
} archive_marker_e;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"

static archive_header this_file_header = {.version = CARBON_ARCHIVE_VERSION, .root_object_header_offset = 0};

static struct {
        archive_marker_e type;
        char symbol;
} global_marker_symbols[] =
        {{MARKER_TYPE_OBJECT_BEGIN,        MARKER_SYMBOL_OBJECT_BEGIN},
         {MARKER_TYPE_OBJECT_END,          MARKER_SYMBOL_OBJECT_END},
         {MARKER_TYPE_PROP_NULL,           MARKER_SYMBOL_PROP_NULL},
         {MARKER_TYPE_PROP_BOOLEAN,        MARKER_SYMBOL_PROP_BOOLEAN},
         {MARKER_TYPE_PROP_INT8,           MARKER_SYMBOL_PROP_INT8},
         {MARKER_TYPE_PROP_INT16,          MARKER_SYMBOL_PROP_INT16},
         {MARKER_TYPE_PROP_INT32,          MARKER_SYMBOL_PROP_INT32},
         {MARKER_TYPE_PROP_INT64,          MARKER_SYMBOL_PROP_INT64},
         {MARKER_TYPE_PROP_UINT8,          MARKER_SYMBOL_PROP_UINT8},
         {MARKER_TYPE_PROP_UINT16,         MARKER_SYMBOL_PROP_UINT16},
         {MARKER_TYPE_PROP_UINT32,         MARKER_SYMBOL_PROP_UINT32},
         {MARKER_TYPE_PROP_UINT64,         MARKER_SYMBOL_PROP_UINT64},
         {MARKER_TYPE_PROP_REAL,           MARKER_SYMBOL_PROP_REAL},
         {MARKER_TYPE_PROP_TEXT,           MARKER_SYMBOL_PROP_TEXT},
         {MARKER_TYPE_PROP_OBJECT,         MARKER_SYMBOL_PROP_OBJECT},
         {MARKER_TYPE_PROP_NULL_ARRAY,     MARKER_SYMBOL_PROP_NULL_ARRAY},
         {MARKER_TYPE_PROP_BOOLEAN_ARRAY,  MARKER_SYMBOL_PROP_BOOLEAN_ARRAY},
         {MARKER_TYPE_PROP_INT8_ARRAY,     MARKER_SYMBOL_PROP_INT8_ARRAY},
         {MARKER_TYPE_PROP_INT16_ARRAY,    MARKER_SYMBOL_PROP_INT16_ARRAY},
         {MARKER_TYPE_PROP_INT32_ARRAY,    MARKER_SYMBOL_PROP_INT32_ARRAY},
         {MARKER_TYPE_PROP_INT64_ARRAY,    MARKER_SYMBOL_PROP_INT64_ARRAY},
         {MARKER_TYPE_PROP_UINT8_ARRAY,    MARKER_SYMBOL_PROP_UINT8_ARRAY},
         {MARKER_TYPE_PROP_UINT16_ARRAY,   MARKER_SYMBOL_PROP_UINT16_ARRAY},
         {MARKER_TYPE_PROP_UINT32_ARRAY,   MARKER_SYMBOL_PROP_UINT32_ARRAY},
         {MARKER_TYPE_PROP_UINT64_ARRAY,   MARKER_SYMBOL_PROP_UINT64_ARRAY},
         {MARKER_TYPE_PROP_REAL_ARRAY,     MARKER_SYMBOL_PROP_REAL_ARRAY},
         {MARKER_TYPE_PROP_TEXT_ARRAY,     MARKER_SYMBOL_PROP_TEXT_ARRAY},
         {MARKER_TYPE_PROP_OBJECT_ARRAY,   MARKER_SYMBOL_PROP_OBJECT_ARRAY},
         {MARKER_TYPE_EMBEDDED_STR_DIC,    MARKER_SYMBOL_EMBEDDED_STR_DIC},
         {MARKER_TYPE_EMBEDDED_UNCOMP_STR, MARKER_SYMBOL_EMBEDDED_STR},
         {MARKER_TYPE_COLUMN_GROUP,        MARKER_SYMBOL_COLUMN_GROUP},
         {MARKER_TYPE_COLUMN,              MARKER_SYMBOL_COLUMN},
         {MARKER_TYPE_HUFFMAN_DIC_ENTRY,   MARKER_SYMBOL_HUFFMAN_DIC_ENTRY},
         {MARKER_TYPE_RECORD_HEADER,       MARKER_SYMBOL_RECORD_HEADER}};

static struct {
        archive_field_e value_type;
        archive_marker_e marker;
} global_value_array_marker_mapping[] =
        {{FIELD_NULL,    MARKER_TYPE_PROP_NULL_ARRAY},
         {FIELD_BOOLEAN, MARKER_TYPE_PROP_BOOLEAN_ARRAY},
         {FIELD_INT8,    MARKER_TYPE_PROP_INT8_ARRAY},
         {FIELD_INT16,   MARKER_TYPE_PROP_INT16_ARRAY},
         {FIELD_INT32,   MARKER_TYPE_PROP_INT32_ARRAY},
         {FIELD_INT64,   MARKER_TYPE_PROP_INT64_ARRAY},
         {FIELD_UINT8,   MARKER_TYPE_PROP_UINT8_ARRAY},
         {FIELD_UINT16,  MARKER_TYPE_PROP_UINT16_ARRAY},
         {FIELD_UINT32,  MARKER_TYPE_PROP_UINT32_ARRAY},
         {FIELD_UINT64,  MARKER_TYPE_PROP_UINT64_ARRAY},
         {FIELD_FLOAT,   MARKER_TYPE_PROP_REAL_ARRAY},
         {FIELD_STRING,  MARKER_TYPE_PROP_TEXT_ARRAY},
         {FIELD_OBJECT,  MARKER_TYPE_PROP_OBJECT_ARRAY}}, valueMarkerMapping[] =
        {{FIELD_NULL,    MARKER_TYPE_PROP_NULL},
         {FIELD_BOOLEAN, MARKER_TYPE_PROP_BOOLEAN},
         {FIELD_INT8,    MARKER_TYPE_PROP_INT8},
         {FIELD_INT16,   MARKER_TYPE_PROP_INT16},
         {FIELD_INT32,   MARKER_TYPE_PROP_INT32},
         {FIELD_INT64,   MARKER_TYPE_PROP_INT64},
         {FIELD_UINT8,   MARKER_TYPE_PROP_UINT8},
         {FIELD_UINT16,  MARKER_TYPE_PROP_UINT16},
         {FIELD_UINT32,  MARKER_TYPE_PROP_UINT32},
         {FIELD_UINT64,  MARKER_TYPE_PROP_UINT64},
         {FIELD_FLOAT,   MARKER_TYPE_PROP_REAL},
         {FIELD_STRING,  MARKER_TYPE_PROP_TEXT},
         {FIELD_OBJECT,  MARKER_TYPE_PROP_OBJECT}};

#pragma GCC diagnostic pop

typedef struct record_flags {
        struct {
                u8 is_sorted
                        : 1;
                u8 RESERVED_2
                        : 1;
                u8 RESERVED_3
                        : 1;
                u8 RESERVED_4
                        : 1;
                u8 RESERVED_5
                        : 1;
                u8 RESERVED_6
                        : 1;
                u8 RESERVED_7
                        : 1;
                u8 RESERVED_8
                        : 1;
        } bits;
        u8 value;
} record_flags;

typedef struct string_table {
        packer compressor;
        offset_t first_entry_off;
        u32 num_embeddded_strings;
} string_table;

typedef struct record_table {
        record_flags flags;
        memblock *record_db;
} record_table;

typedef struct archive_info {
        size_t string_table_size;
        size_t record_table_size;
        size_t string_id_index_size;
        u32 num_embeddded_strings;
} archive_info;

typedef struct __attribute__((packed)) string_entry_header {
        char marker;
        offset_t next_entry_off;
        archive_field_sid_t string_id;
        u32 string_len;
} string_entry_header;

void int_read_prop_offsets(archive_prop_offs *prop_offsets, memfile *memfile, const object_flags_u *flags);
void int_embedded_fixed_props_read(fixed_prop *prop, memfile *memfile);
void int_embedded_var_props_read(var_prop *prop, memfile *memfile);
void int_embedded_null_props_read(null_prop *prop, memfile *memfile);
void int_embedded_array_props_read(array_prop *prop, memfile *memfile);
void int_embedded_table_props_read(table_prop *prop, memfile *memfile);
archive_field_e int_get_value_type_of_char(char c);
archive_field_e int_marker_to_field_type(char symbol);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef IO_CONTEXT_H
#define IO_CONTEXT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>

BEGIN_DECL

bool io_context_create(archive_io_context **context, err *err, const char *file_path);
err *io_context_get_error(archive_io_context *context);
FILE *io_context_lock_and_access(archive_io_context *context);
bool io_context_unlock(archive_io_context *context);
bool io_context_drop(archive_io_context *context);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ARCHIVE_ITER_H
#define ARCHIVE_ITER_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <jakson/archive.h>

BEGIN_DECL

typedef enum prop_iter_state {
        PROP_ITER_INIT,
        PROP_ITER_NULLS,
        PROP_ITER_BOOLS,
        PROP_ITER_INT8S,
        PROP_ITER_INT16S,
        PROP_ITER_INT32S,
        PROP_ITER_INT64S,
        PROP_ITER_UINT8S,
        PROP_ITER_UINT16S,
        PROP_ITER_UINT32S,
        PROP_ITER_UINT64S,
        PROP_ITER_FLOATS,
        PROP_ITER_STRINGS,
        PROP_ITER_OBJECTS,
        PROP_ITER_NULL_ARRAYS,
        PROP_ITER_BOOL_ARRAYS,
        PROP_ITER_INT8_ARRAYS,
        PROP_ITER_INT16_ARRAYS,
        PROP_ITER_INT32_ARRAYS,
        PROP_ITER_INT64_ARRAYS,
        PROP_ITER_UINT8_ARRAYS,
        PROP_ITER_UINT16_ARRAYS,
        PROP_ITER_UINT32_ARRAYS,
        PROP_ITER_UINT64_ARRAYS,
        PROP_ITER_FLOAT_ARRAYS,
        PROP_ITER_STRING_ARRAYS,
        PROP_ITER_OBJECT_ARRAYS,
        PROP_ITER_DONE
} prop_iter_state_e;

typedef struct archive_object {
        unique_id_t object_id;                  /* unique object id */
        offset_t offset;                        /* this objects header offset */
        archive_prop_offs prop_offsets;  /* per-property type offset in the record table byte stream */
        offset_t next_obj_off;                  /* offset to next object in list, or NULL if no such exists */
        memfile memfile;
        err err;
} archive_object;

typedef enum prop_iter_mode {
        PROP_ITER_MODE_OBJECT,
        PROP_ITER_MODE_COLLECTION,
} prop_iter_mode_e;

typedef struct object_iter_state {
        fixed_prop prop_group_header;    /* type, num props and keys */
        offset_t current_prop_group_off;
        offset_t prop_data_off;
        const archive_field_sid_t *keys;                /* current property key in this iteration */
        enum archive_field_type type;                   /* property basic value type (e.g., int8, or object) */
        bool is_array;                          /* flag indicating that property is an array type */
} object_iter_state;

typedef struct collection_iter_state {
        offset_t collection_start_off;
        u32 num_column_groups;
        u32 current_column_group_idx;
        const archive_field_sid_t *column_group_keys;
        const offset_t *column_group_offsets;

        struct {
                u32 num_columns;
                u32 num_objects;
                const unique_id_t *object_ids;
                const offset_t *column_offs;
                struct {
                        u32 idx;
                        archive_field_sid_t name;
                        enum archive_field_type type;
                        u32 num_elem;
                        const offset_t *elem_offsets;
                        const u32 *elem_positions;
                        struct {
                                u32 idx;
                                u32 array_length;
                                const void *array_base;
                        } current_entry;
                } current_column;
        } current_column_group;
} collection_iter_state;

typedef struct archive_value_vector {
        prop_iter *prop_iter;            /* pointer to property iterator that created this iterator */
        memfile record_table_memfile;    /* iterator-local read-only memfile on archive record table */
        enum archive_field_type prop_type;              /* property basic value type (e.g., int8, or object) */
        bool is_array;                          /* flag indicating whether value type is an array or not */
        offset_t data_off;                      /* offset in memfile where type-dependent data begins */
        u32 value_max_idx;                      /* maximum index of a value callable by 'at' functions */
        err err;                         /* ERROR information */
        unique_id_t object_id;                  /* current object id */
        const archive_field_sid_t *keys;
        union {
                struct {
                        const offset_t *offsets;
                        archive_object object;
                } object;
                struct {
                        union {
                                const archive_field_i8_t *int8s;
                                const archive_field_i16_t *int16s;
                                const archive_field_i32_t *int32s;
                                const archive_field_i64_t *int64s;
                                const archive_field_u8_t *uint8s;
                                const archive_field_u16_t *uint16s;
                                const archive_field_u32_t *uint32s;
                                const archive_field_u64_t *uint64s;
                                const archive_field_number_t *numbers;
                                const archive_field_sid_t *strings;
                                const archive_field_boolean_t *booleans;
                        } values;
                } basic;
                struct {
                        union {
                                const u32 *array_lengths;
                                const u32 *num_nulls_contained;
                        } meta;

                        union {
                                const archive_field_i8_t *int8s_base;
                                const archive_field_i16_t *int16s_base;
                                const archive_field_i32_t *int32s_base;
                                const archive_field_i64_t *int64s_base;
                                const archive_field_u8_t *uint8s_base;
                                const archive_field_u16_t *uint16s_base;
                                const archive_field_u32_t *uint32s_base;
                                const archive_field_u64_t *uint64s_base;
                                const archive_field_number_t *numbers_base;
                                const archive_field_sid_t *strings_base;
                                const archive_field_boolean_t *booleans_base;
                        } values;
                } arrays;
        } data;
} archive_value_vector;

typedef struct prop_iter {
        archive_object object;                 /* current object */
        memfile record_table_memfile;          /* iterator-local read-only memfile on archive record table */
        u16 mask;                                     /* user-defined mask which properties to include */
        prop_iter_mode_e mode;                     /* determines whether to iterating over object or collection */
        err err;                               /* ERROR information */
        prop_iter_state_e prop_cursor;             /* current property type in iteration */
        object_iter_state mode_object;
        collection_iter_state mode_collection;
} prop_iter;

typedef struct independent_iter_state {
        memfile record_table_memfile;           /* iterator-local read-only memfile on archive record table */
        collection_iter_state state;            /* iterator-local state */
        err err;                                /* ERROR information */
} independent_iter_state;

typedef struct column_object_iter {
        memfile memfile;
        collection_iter_state entry_state;
        archive_object obj;
        offset_t next_obj_off;
        err err;
} column_object_iter;

#define ARCHIVE_ITER_MASK_PRIMITIVES             (1 << 1)
#define ARCHIVE_ITER_MASK_ARRAYS                 (1 << 2)

#define ARCHIVE_ITER_MASK_INT8                   (1 << 3)
#define ARCHIVE_ITER_MASK_INT16                  (1 << 4)
#define ARCHIVE_ITER_MASK_INT32                  (1 << 5)
#define ARCHIVE_ITER_MASK_INT64                  (1 << 6)
#define ARCHIVE_ITER_MASK_UINT8                  (1 << 7)
#define ARCHIVE_ITER_MASK_UINT16                 (1 << 8)
#define ARCHIVE_ITER_MASK_UINT32                 (1 << 9)
#define ARCHIVE_ITER_MASK_UINT64                 (1 << 10)
#define ARCHIVE_ITER_MASK_NUMBER                 (1 << 11)
#define ARCHIVE_ITER_MASK_STRING                 (1 << 12)
#define ARCHIVE_ITER_MASK_BOOLEAN                (1 << 13)
#define ARCHIVE_ITER_MASK_NULL                   (1 << 14)
#define ARCHIVE_ITER_MASK_OBJECT                 (1 << 15)

#define ARCHIVE_ITER_MASK_INTEGER               ARCHIVE_ITER_MASK_INT8       |                                 \
                                                    ARCHIVE_ITER_MASK_INT16      |                                 \
                                                    ARCHIVE_ITER_MASK_INT32      |                                 \
                                                    ARCHIVE_ITER_MASK_INT64      |                                 \
                                                    ARCHIVE_ITER_MASK_UINT8      |                                 \
                                                    ARCHIVE_ITER_MASK_UINT16     |                                 \
                                                    ARCHIVE_ITER_MASK_UINT32     |                                 \
                                                    ARCHIVE_ITER_MASK_UINT64

#define ARCHIVE_ITER_MASK_ANY                   ARCHIVE_ITER_MASK_PRIMITIVES |                                 \
                                                    ARCHIVE_ITER_MASK_ARRAYS     |                                 \
                                                    ARCHIVE_ITER_MASK_INTEGER    |                                 \
                                                    ARCHIVE_ITER_MASK_NUMBER     |                                 \
                                                    ARCHIVE_ITER_MASK_STRING     |                                 \
                                                    ARCHIVE_ITER_MASK_BOOLEAN    |                                 \
                                                    ARCHIVE_ITER_MASK_NULL       |                                 \
                                                    ARCHIVE_ITER_MASK_OBJECT

DEFINE_GET_ERROR_FUNCTION(archive_value_vector, archive_value_vector, iter)

DEFINE_GET_ERROR_FUNCTION(archive_prop_iter, prop_iter, iter)

DEFINE_GET_ERROR_FUNCTION(archive_collection_iter, independent_iter_state, iter)

DEFINE_GET_ERROR_FUNCTION(archive_column_group_iter, independent_iter_state, iter)

DEFINE_GET_ERROR_FUNCTION(archive_column_iter, independent_iter_state, iter)

DEFINE_GET_ERROR_FUNCTION(archive_column_entry_iter, independent_iter_state, iter)

DEFINE_GET_ERROR_FUNCTION(archive_column_entry_object_iter, column_object_iter, iter)

DEFINE_GET_ERROR_FUNCTION(archive_object, archive_object, obj)

bool archive_prop_iter_from_archive(prop_iter *iter, err *err, u16 mask, archive *archive);
bool archive_prop_iter_from_object(prop_iter *iter, u16 mask, err *err, const archive_object *obj);
bool archive_value_vector_from_prop_iter(archive_value_vector *value, err *err, prop_iter *prop_iter);
bool archive_prop_iter_next(prop_iter_mode_e *type, archive_value_vector *value_vector, independent_iter_state *collection_iter, prop_iter *prop_iter);
const archive_field_sid_t *archive_collection_iter_get_keys(u32 *num_keys, independent_iter_state *iter);
bool archive_collection_next_column_group(independent_iter_state *group_iter, independent_iter_state *iter);
const unique_id_t *archive_column_group_get_object_ids(u32 *num_objects, independent_iter_state *iter);
bool archive_column_group_next_column(independent_iter_state *column_iter, independent_iter_state *iter);
bool archive_column_get_name(archive_field_sid_t *name, enum archive_field_type *type, independent_iter_state *column_iter);
const u32 * archive_column_get_entry_positions(u32 *num_entry, independent_iter_state *column_iter);
bool archive_column_next_entry(independent_iter_state *entry_iter, independent_iter_state *iter);
bool archive_column_entry_get_type(enum archive_field_type *type, independent_iter_state *entry);

#define DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(built_in_type, name)                                            \
const built_in_type *                                                                                      \
archive_column_entry_get_##name(u32 *array_length, independent_iter_state *entry);

DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_i8_t, int8s);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_i16_t, int16s);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_i32_t, int32s);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_i64_t, int64s);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u8_t, uint8s);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u16_t, uint16s);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u32_t, uint32s);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u64_t, uint64s);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_sid_t, strings);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_number_t, numbers);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_boolean_t, booleans);
DEFINE_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(archive_field_u32_t, nulls);

bool archive_column_entry_get_objects(column_object_iter *iter, independent_iter_state *entry);
const archive_object *archive_column_entry_object_iter_next_object(column_object_iter *iter);
bool archive_object_get_object_id(unique_id_t *id, const archive_object *object);
bool archive_object_get_prop_iter(prop_iter *iter, const archive_object *object);
bool archive_value_vector_get_object_id(unique_id_t *id, const archive_value_vector *iter);
const archive_field_sid_t *archive_value_vector_get_keys(u32 *num_keys, archive_value_vector *iter);
bool archive_value_vector_get_basic_type(enum archive_field_type *type, const archive_value_vector *value);
bool archive_value_vector_is_array_type(bool *is_array, const archive_value_vector *value);
bool archive_value_vector_get_length(u32 *length, const archive_value_vector *value);
bool archive_value_vector_is_of_objects(bool *is_object, archive_value_vector *value);
bool archive_value_vector_get_object_at(archive_object *object, u32 idx, archive_value_vector *value);

#define DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(name)                                                            \
bool                                                                                                       \
archive_value_vector_is_##name(bool *type_match, archive_value_vector *value);

DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(int8);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(int16);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(int32);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(int64);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(uint8);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(uint16);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(uint32);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(uint64);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(string_buffer);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(number);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(boolean);
DEFINE_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(null);

#define DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(name, built_in_type)                                            \
const built_in_type *                                                                                      \
archive_value_vector_get_##name(u32 *num_values, archive_value_vector *value);

DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(int8s, archive_field_i8_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(int16s, archive_field_i16_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(int32s, archive_field_i32_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(int64s, archive_field_i64_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(uint8s, archive_field_u8_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(uint16s, archive_field_u16_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(uint32s, archive_field_u32_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(uint64s, archive_field_u64_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(strings, archive_field_sid_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(numbers, archive_field_number_t)
DEFINE_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(booleans, archive_field_boolean_t)

const archive_field_u32_t *archive_value_vector_get_null_arrays(u32 *num_values, archive_value_vector *value);

#define DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(name, built_in_type)                                         \
const built_in_type *                                                                                      \
archive_value_vector_get_##name##_arrays_at(u32 *array_length, u32 idx,                                                \
                                               archive_value_vector *value);                                    \


DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(int8, archive_field_i8_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(int16, archive_field_i16_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(int32, archive_field_i32_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(int64, archive_field_i64_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(uint8, archive_field_u8_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(uint16, archive_field_u16_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(uint32, archive_field_u32_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(uint64, archive_field_u64_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(string_buffer, archive_field_sid_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(number, archive_field_number_t);
DEFINE_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(boolean, archive_field_boolean_t);

void archive_int_reset_carbon_object_mem_file(archive_object *object);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRING_PRED_H
#define STRING_PRED_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>

BEGIN_DECL

typedef bool (*string_pred_func_t)(size_t *idxs_matching, size_t *num_matching, char **strings, size_t num_strings, void *capture);

typedef struct string_pred {
        string_pred_func_t func;
        i64 limit;
} string_pred;

BUILT_IN(static bool) string_pred_validate(err *err, const string_pred *pred)
{
        DEBUG_ERROR_IF_NULL(pred);
        ERROR_IF_NOT_IMPLEMENTED(err, pred, func)
        return true;
}

BUILT_IN(static bool) string_pred_eval(const string_pred *pred, size_t *idxs_matching,
                                               size_t *num_matching, char **strings, size_t num_strings, void *capture)
{
        JAK_ASSERT(pred);
        JAK_ASSERT(idxs_matching);
        JAK_ASSERT(num_matching);
        JAK_ASSERT(strings);
        JAK_ASSERT(pred->func);
        return pred->func(idxs_matching, num_matching, strings, num_strings, capture);
}

BUILT_IN(static bool) string_pred_get_limit(i64 *limit, const string_pred *pred)
{
        DEBUG_ERROR_IF_NULL(limit);
        DEBUG_ERROR_IF_NULL(pred);
        *limit = pred->limit;
        return true;
}

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef QUERY_H
#define QUERY_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/archive.h>
#include <archive_strid_it.h>
#include <archive_pred.h>
#include <hash_table.h>

BEGIN_DECL

typedef struct archive_query {
        archive *archive;
        archive_io_context *context;
        err err;
} archive_query;

DEFINE_GET_ERROR_FUNCTION(query, archive_query, query)

bool query_create(archive_query *query, archive *archive);
bool query_drop(archive_query *query);
bool query_scan_strids(strid_iter *it, archive_query *query);
bool query_create_index_string_id_to_offset(struct sid_to_offset **index, archive_query *query);
void query_drop_index_string_id_to_offset(struct sid_to_offset *index);
bool query_index_id_to_offset_serialize(FILE *file, err *err, struct sid_to_offset *index);
bool query_index_id_to_offset_deserialize(struct sid_to_offset **index, err *err, const char *file_path, offset_t offset);
char *query_fetch_string_by_id(archive_query *query, archive_field_sid_t id);
char *query_fetch_string_by_id_nocache(archive_query *query, archive_field_sid_t id);
char **query_fetch_strings_by_offset(archive_query *query, offset_t *offs, u32 *strlens, size_t num_offs);
archive_field_sid_t *query_find_ids(size_t *num_found, archive_query *query, const string_pred *pred, void *capture, i64 limit);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRID_ITER_H
#define STRID_ITER_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>
#include <jakson/archive.h>

BEGIN_DECL

typedef struct strid_info {
        archive_field_sid_t id;
        u32 strlen;
        offset_t offset;
} strid_info;

typedef struct strid_iter {
        FILE *disk_file;
        bool is_open;
        offset_t disk_offset;
        strid_info vector[100000];
} strid_iter;

bool strid_iter_open(strid_iter *it, err *err, archive *archive);
bool strid_iter_next(bool *success, strid_info **info, err *err, size_t *info_length, strid_iter *it);
bool strid_iter_close(strid_iter *it);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ARCHIVE_VISITOR_H
#define ARCHIVE_VISITOR_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jakson/archive/archive_it.h>

typedef struct path_entry {
        archive_field_sid_t key;
        u32 idx;
} path_entry;

typedef struct archive_visitor_desc {
        int visit_mask;                 /** bitmask of 'ARCHIVE_ITER_MASK_XXX' */
} archive_visitor_desc;

typedef enum visit_policy {
        VISIT_INCLUDE, VISIT_EXCLUDE,
} visit_policy_e;

typedef const vector ofType(path_entry) *path_stack_t;

#define DEFINE_VISIT_BASIC_TYPE_PAIRS(name, built_in_type)                                                             \
void (*visit_##name##_pairs) (archive *archive, path_stack_t path, unique_id_t id,                              \
                              const archive_field_sid_t *keys, const built_in_type *values, u32 num_pairs,                     \
                              void *capture);

#define DEFINE_VISIT_ARRAY_TYPE_PAIRS(name, built_in_type)                                                             \
visit_policy_e (*visit_enter_##name##_array_pairs)(archive *archive, path_stack_t path,                      \
                                                        unique_id_t id, const archive_field_sid_t *keys,                       \
                                                        u32 num_pairs,                                                 \
                                                        void *capture);                                                \
                                                                                                                       \
void (*visit_enter_##name##_array_pair)(archive *archive, path_stack_t path, unique_id_t id,                    \
                                        archive_field_sid_t key, u32 entry_idx, u32 num_elems,                                 \
                                        void *capture);                                                                \
                                                                                                                       \
void (*visit_##name##_array_pair) (archive *archive, path_stack_t path, unique_id_t id,                         \
                                   archive_field_sid_t key, u32 entry_idx, u32 max_entries,                                    \
                                   const built_in_type *array, u32 array_length, void *capture);                       \
                                                                                                                       \
void (*visit_leave_##name##_array_pair)(archive *archive, path_stack_t path, unique_id_t id,                    \
                                        u32 pair_idx, u32 num_pairs, void *capture);                                   \
                                                                                                                       \
void (*visit_leave_##name##_array_pairs)(archive *archive, path_stack_t path, unique_id_t id,                   \
                                         void *capture);

#define DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(name, built_in_type)                                                     \
    void (*visit_object_array_object_property_##name)(archive *archive, path_stack_t path,                      \
                                               unique_id_t parent_id,                                                  \
                                               archive_field_sid_t key,                                                        \
                                               unique_id_t nested_object_id,                                           \
                                               archive_field_sid_t nested_key,                                                 \
                                               const built_in_type *nested_values,                                     \
                                               u32 num_nested_values, void *capture);

typedef struct archive_visitor {
        void (*visit_root_object)(archive *archive, unique_id_t id, void *capture);
        void (*before_visit_starts)(archive *archive, void *capture);
        void (*after_visit_ends)(archive *archive, void *capture);
        visit_policy_e (*before_object_visit)(archive *archive, path_stack_t path, unique_id_t parent_id, unique_id_t value_id, u32 object_idx, u32 num_objects, archive_field_sid_t key, void *capture);
        void (*after_object_visit)(archive *archive, path_stack_t path, unique_id_t id, u32 object_idx, u32 num_objects, void *capture);
        void (*first_prop_type_group)(archive *archive, path_stack_t path, unique_id_t id, const archive_field_sid_t *keys, enum archive_field_type type, bool is_array, u32 num_pairs, void *capture);
        void (*next_prop_type_group)(archive *archive, path_stack_t path, unique_id_t id, const archive_field_sid_t *keys, enum archive_field_type type, bool is_array, u32 num_pairs, void *capture);
        void (*visit_null_pairs)(archive *archive, path_stack_t path, unique_id_t id, const archive_field_sid_t *keys, u32 num_pairs, void *capture);

        DEFINE_VISIT_BASIC_TYPE_PAIRS(int8, archive_field_i8_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(int16, archive_field_i16_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(int32, archive_field_i32_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(int64, archive_field_i64_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(uint8, archive_field_u8_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(uint16, archive_field_u16_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(uint32, archive_field_u32_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(uint64, archive_field_u64_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(number, archive_field_number_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(string_buffer, archive_field_sid_t);
        DEFINE_VISIT_BASIC_TYPE_PAIRS(boolean, archive_field_boolean_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(int8, archive_field_i8_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(int16, archive_field_i16_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(int32, archive_field_i32_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(int64, archive_field_i64_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(uint8, archive_field_u8_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(uint16, archive_field_u16_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(uint32, archive_field_u32_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(uint64, archive_field_u64_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(number, archive_field_number_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(string_buffer, archive_field_sid_t);
        DEFINE_VISIT_ARRAY_TYPE_PAIRS(boolean, archive_field_boolean_t);

        visit_policy_e (*visit_enter_null_array_pairs)(archive *archive, path_stack_t path, unique_id_t id, const archive_field_sid_t *keys, u32 num_pairs, void *capture);
        void (*visit_enter_null_array_pair)(archive *archive, path_stack_t path, unique_id_t id, archive_field_sid_t key, u32 entry_idx, u32 num_elems, void *capture);
        void (*visit_null_array_pair)(archive *archive, path_stack_t path, unique_id_t id, archive_field_sid_t key, u32 entry_idx, u32 max_entries, archive_field_u32_t num_nulls, void *capture);
        void (*visit_leave_null_array_pair)(archive *archive, path_stack_t path, unique_id_t id, u32 pair_idx, u32 num_pairs, void *capture);
        void (*visit_leave_null_array_pairs)(archive *archive, path_stack_t path, unique_id_t id, void *capture);
        visit_policy_e (*before_visit_object_array)(archive *archive, path_stack_t path, unique_id_t parent_id, archive_field_sid_t key, void *capture);
        void (*before_visit_object_array_objects)(bool *skip_group_object_ids, archive *archive, path_stack_t path, unique_id_t parent_id, archive_field_sid_t key, const unique_id_t *group_object_ids, u32 num_group_object_ids, void *capture);
        visit_policy_e (*before_visit_object_array_object_property)(archive *archive, path_stack_t path, unique_id_t parent_id, archive_field_sid_t key, archive_field_sid_t nested_key, enum archive_field_type nested_value_type, void *capture);

        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(int8s, archive_field_i8_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(int16s, archive_field_i16_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(int32s, archive_field_i32_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(int64s, archive_field_i64_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(uint8s, archive_field_u8_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(uint16s, archive_field_u16_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(uint32s, archive_field_u32_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(uint64s, archive_field_u64_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(numbers, archive_field_number_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(strings, archive_field_sid_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(booleans, archive_field_boolean_t);
        DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP(nulls, archive_field_u32_t);

        visit_policy_e (*before_object_array_object_property_object)(archive *archive, path_stack_t path, unique_id_t parent_id, archive_field_sid_t key, unique_id_t nested_object_id, archive_field_sid_t nested_key, u32 nested_value_object_id, void *capture);
        void (*visit_object_property)(archive *archive, path_stack_t path, unique_id_t parent_id, archive_field_sid_t key, enum archive_field_type type, bool is_array_type, void *capture);
        void (*visit_object_array_prop)(archive *archive, path_stack_t path, unique_id_t parent_id, archive_field_sid_t key, enum archive_field_type type, void *capture);
        bool (*get_column_entry_count)(archive *archive, path_stack_t path, archive_field_sid_t key, enum archive_field_type type, u32 count, void *capture);
} archive_visitor;

bool archive_visit_archive(archive *archive, const archive_visitor_desc *desc, archive_visitor *visitor, void *capture);
bool archive_visitor_print_path(FILE *file, archive *archive, const vector ofType(path_entry) *path_stack);
void archive_visitor_path_to_string(char path_buffer[2048], archive *archive, const vector ofType(path_entry) *path_stack);
bool archive_visitor_path_compare(const vector ofType(path_entry) *path, archive_field_sid_t *group_name, const char *path_str, archive *archive);

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ASYNC_H
#define ASYNC_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdlib.h>

#include <stdinc.h>
#include <jakson/error.h>

BEGIN_DECL

#define ASYNC_MSG_UNKNOWN_HINT "Unknown threading hint"

typedef uint_fast16_t thread_id_t;

typedef void (*for_body_func_t)(const void *start, size_t width, size_t len, void *args, thread_id_t tid);
typedef void (*map_body_func_t)(void *dst, const void *src, size_t src_width, size_t dst_width, size_t len, void *args);
typedef void(*pred_func_t)(size_t *matching_positions, size_t *num_matching_positions, const void *src, size_t width, size_t len, void *args, size_t position_offset_to_add);

typedef enum threading_hint {
        THREADING_HINT_SINGLE, THREADING_HINT_MULTI
} threading_hint;

typedef struct async_func_proxy {
        for_body_func_t function;
        const void *start;
        size_t width;
        size_t len;
        thread_id_t tid;
        void *args;
} async_func_proxy;

typedef struct filter_arg {
        size_t num_positions;
        size_t *src_positions;
        const void *start;
        size_t len;
        size_t width;
        void *args;
        pred_func_t pred;
        size_t position_offset_to_add;
} filter_arg;

typedef struct map_args {
        map_body_func_t map_func;
        void *dst;
        const void *src;
        size_t dst_width;
        void *args;
} map_args;

typedef struct gather_scatter_args {
        const size_t *idx;
        const void *src;
        void *dst;
} gather_scatter_args;

void *async_for_proxy_function(void *args);

#define PARALLEL_ERROR(msg, retval)                                                                             \
{                                                                                                                      \
    perror(msg);                                                                                                       \
    return retval;                                                                                                     \
}

#define ASYNC_MATCH(forSingle, forMulti)                                                                            \
{                                                                                                                      \
    if (LIKELY(hint == THREADING_HINT_MULTI)) {                                             \
        return (forMulti);                                                                                             \
    } else if (hint == THREADING_HINT_SINGLE) {                                                           \
        return (forSingle);                                                                                            \
    } else PARALLEL_ERROR(ASYNC_MSG_UNKNOWN_HINT, false);                                                    \
}

bool for(const void *base, size_t width, size_t len, for_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads);
bool map(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width, map_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads);
bool gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len, threading_hint hint, uint_fast16_t num_threads);
bool gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num, threading_hint hint, uint_fast16_t num_threads);
bool scatter(void *dst, const void *src, size_t width, const size_t *idx, size_t num, threading_hint hint, uint_fast16_t num_threads);
bool shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx, const size_t *src_idx, size_t idxLen, threading_hint hint);
bool filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len, pred_func_t pred, void *args, threading_hint hint, uint_fast16_t num_threads);
bool filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len, pred_func_t pred, void *args, threading_hint hint, size_t num_threads);

bool sync_for(const void *base, size_t width, size_t len, for_body_func_t f, void *args);
bool async_for(const void *base, size_t width, size_t len, for_body_func_t f, void *args, uint_fast16_t num_threads);
bool async_map_exec(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width, map_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads);
bool sync_gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len);
bool async_gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len, uint_fast16_t num_threads);
bool sync_gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num);
bool int_async_gather_adr_func(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num, uint_fast16_t num_threads);
bool sync_scatter(void *dst, const void *src, size_t width, const size_t *idx, size_t num);
bool sync_scatter_func(void *dst, const void *src, size_t width, const size_t *idx, size_t num, uint_fast16_t num_threads);
bool sync_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx, const size_t *src_idx, size_t idx_len);
bool async_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx, const size_t *src_idx, size_t idx_len);
bool async_filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len, pred_func_t pred, void *args);
bool int_async_filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len, pred_func_t pred, void *args, uint_fast16_t num_threads);
bool int_sync_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len, pred_func_t pred, void *args);
bool async_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len, pred_func_t pred, void *args, size_t num_threads);

bool for(const void *base, size_t width, size_t len, for_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads);
bool map(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width, map_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads);
bool gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len, threading_hint hint, uint_fast16_t num_threads);
bool gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num, threading_hint hint, uint_fast16_t num_threads);
bool scatter(void *dst, const void *src, size_t width, const size_t *idx, size_t num, threading_hint hint, uint_fast16_t num_threads);
bool shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx, const size_t *src_idx, size_t idx_len, threading_hint hint);
bool filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len, pred_func_t pred, void *args, threading_hint hint, uint_fast16_t num_threads);
bool filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len, pred_func_t pred, void *args, threading_hint hint, size_t num_threads);
bool sync_for(const void *base, size_t width, size_t len, for_body_func_t f, void *args);
bool async_for(const void *base, size_t width, size_t len, for_body_func_t f, void *args, uint_fast16_t num_threads);

void map_proxy(const void *src, size_t src_width, size_t len, void *args, thread_id_t tid);
bool async_map_exec(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width, map_body_func_t f, void *args, threading_hint hint, uint_fast16_t num_threads);
void int_async_gather(const void *start, size_t width, size_t len, void *args, thread_id_t tid);

bool sync_gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len);
bool async_gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len, uint_fast16_t num_threads);
bool sync_gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num);
void async_gather_adr_func(const void *start, size_t width, size_t len, void *args, thread_id_t tid);
bool int_async_gather_adr_func(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num, uint_fast16_t num_threads);
void async_scatter(const void *start, size_t width, size_t len, void *args, thread_id_t tid);
bool sync_scatter(void *dst, const void *src, size_t width, const size_t *idx, size_t num);
bool sync_scatter_func(void *dst, const void *src, size_t width, const size_t *idx, size_t num, uint_fast16_t num_threads);
bool sync_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx, const size_t *src_idx, size_t idx_len);
bool async_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx, const size_t *src_idx, size_t idx_len);

bool int_sync_filter_late(size_t *positions, size_t *num_positions, const void *source, size_t width, size_t length, pred_func_t predicate, void *arguments);
void *int_sync_filter_procy_func(void *args);

bool async_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len, pred_func_t pred, void *args, size_t num_threads);
bool async_filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len, pred_func_t pred, void *args);
bool int_async_filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len, pred_func_t pred, void *args, uint_fast16_t num_threads);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef BITMAP_H
#define BITMAP_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>

BEGIN_DECL

typedef struct bitmap {
        vector ofType(u64) data;
        u16 num_bits;
} bitmap;

bool bitmap_create(bitmap *bitmap, u16 num_bits);
bool bitmap_cpy(bitmap *dst, const bitmap *src);
bool bitmap_drop(bitmap *map);
size_t bitmap_nbits(const bitmap *map);
bool bitmap_clear(bitmap *map);
bool bitmap_set(bitmap *map, u16 bit_position, bool on);
bool bitmap_get(bitmap *map, u16 bit_position);
bool bitmap_lshift(bitmap *map);
bool bitmap_print(FILE *file, const bitmap *map);
bool bitmap_blocks(u32 **blocks, u32 *num_blocks, const bitmap *map);
void bitmap_print_bits(FILE *file, u32 n);
void bitmap_print_bits_in_char(FILE *file, char n);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef BLOOM_H
#define BLOOM_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <bitmap.h>
#include <hash.h>

BEGIN_DECL

#define BLOOM_SET(filter, key, key_size)                                                                           \
({                                                                                                                     \
    size_t nbits = bitmap_nbits(filter);                                                                           \
    size_t b0 = HASH_ADDITIVE(key_size, key) % nbits;                                                              \
    size_t b1 = HASH_XOR(key_size, key) % nbits;                                                                   \
    size_t b2 = HASH_ROT(key_size, key) % nbits;                                                                   \
    size_t b3 = HASH_SAX(key_size, key) % nbits;                                                                   \
    bitmap_set(filter, b0, true);                                                                                  \
    bitmap_set(filter, b1, true);                                                                                  \
    bitmap_set(filter, b2, true);                                                                                  \
    bitmap_set(filter, b3, true);                                                                                  \
})

#define BLOOM_TEST(filter, key, key_size)                                                                          \
({                                                                                                                     \
    size_t nbits = bitmap_nbits(filter);                                                                           \
    size_t b0 = HASH_ADDITIVE(key_size, key) % nbits;                                                              \
    size_t b1 = HASH_XOR(key_size, key) % nbits;                                                                   \
    size_t b2 = HASH_ROT(key_size, key) % nbits;                                                                   \
    size_t b3 = HASH_SAX(key_size, key) % nbits;                                                                   \
    bool b0set = bitmap_get(filter, b0);                                                                           \
    bool b1set = bitmap_get(filter, b1);                                                                           \
    bool b2set = bitmap_get(filter, b2);                                                                           \
    bool b3set = bitmap_get(filter, b3);                                                                           \
    (b0set && b1set && b2set && b3set);                                                                                \
})

#define BLOOM_TEST_AND_SET(filter, key, key_size)                                                                  \
({                                                                                                                     \
    size_t nbits = bitmap_nbits(filter);                                                                           \
    size_t b0 = HASH_ADDITIVE(key_size, key) % nbits;                                                              \
    size_t b1 = HASH_XOR(key_size, key) % nbits;                                                                   \
    size_t b2 = HASH_ROT(key_size, key) % nbits;         \
    size_t b3 = HASH_SAX(key_size, key) % nbits;         \
    bool b0set = bitmap_get(filter, b0);                    \
    bool b1set = bitmap_get(filter, b1);                    \
    bool b2set = bitmap_get(filter, b2);                    \
    bool b3set = bitmap_get(filter, b3);                    \
    bitmap_set(filter, b0, true);                           \
    bitmap_set(filter, b1, true);                           \
    bitmap_set(filter, b2, true);                           \
    bitmap_set(filter, b3, true);                           \
    (b0set && b1set && b2set && b3set);                     \
})

bool bloom_create(bitmap *filter, size_t size);
bool bloom_drop(bitmap *filter);
bool bloom_clear(bitmap *filter);
size_t bloom_nbits(bitmap *filter);

unsigned bloom_nhashs();

END_DECL

#endif/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_H
#define CARBON_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <memblock.h>
#include <memfile.h>
#include <unique_id.h>
#include <string_buffer.h>
#include <spinlock.h>
#include <vector.h>
#include <stdinc.h>
#include <alloc.h>
#include <bitmap.h>
#include <bloom.h>
#include <jakson/archive.h>
#include <archive_it.h>
#include <archive_visitor.h>
#include <archive_converter.h>
#include <encoded_doc.h>
#include <stdinc.h>
#include <utils_convert.h>
#include <column_doc.h>
#include <doc.h>
#include <jakson/error.h>
#include <hash_table.h>
#include <hash.h>
#include <huffman.h>
#include <json.h>
#include <memblock.h>
#include <memfile.h>
#include <unique_id.h>
#include <utils_sort.h>
#include <async.h>
#include <slicelist.h>
#include <spinlock.h>
#include <string_dict.h>
#include <str_hash.h>
#include <archive_strid_it.h>
#include <archive_cache.h>
#include <time.h>
#include <types.h>
#include <archive_query.h>
#include <vector.h>
#include <alloc_trace.h>
#include <encode_async.h>
#include <encode_sync.h>
#include <str_hash_mem.h>
#include <pred_contains.h>
#include <pred_equals.h>
#include <jakson/carbon/printers.h>
#include <uintvar_stream.h>

BEGIN_DECL

typedef struct carbon {
        memblock *memblock;
        memfile memfile;

        struct {
                spinlock write_lock;
                bool commit_lock;
                bool is_latest;
        } versioning;

        err err;
} carbon;

typedef struct carbon_revise {
        carbon *original;
        carbon *revised_doc;
        err err;
} carbon_revise;

typedef struct carbon_binary {
        const char *mime_type;
        u64 mime_type_strlen;
        const void *blob;
        u64 blob_len;
} carbon_binary;

typedef struct carbon_new {
        err err;
        carbon original;
        carbon_revise revision_context;
        carbon_array_it *content_it;
        carbon_insert *inserter;
        /* options shrink or compact (or both) documents, see
         * CARBON_KEEP, CARBON_SHRINK, CARBON_COMPACT, and CARBON_OPTIMIZE  */
        int mode;
} carbon_new;

typedef enum carbon_container_type {
        CARBON_OBJECT, CARBON_ARRAY, CARBON_COLUMN
} carbon_container_e;

typedef enum carbon_printer_impl {
        JSON_EXTENDED, JSON_COMPACT
} carbon_printer_impl_e;

#define CARBON_MARKER_KEY_NOKEY '?'
#define CARBON_MARKER_KEY_AUTOKEY '*'
#define CARBON_MARKER_KEY_UKEY '+'
#define CARBON_MARKER_KEY_IKEY '-'
#define CARBON_MARKER_KEY_SKEY '!'

typedef enum carbon_key_type {
        /* no key, no revision number */
        CARBON_KEY_NOKEY = CARBON_MARKER_KEY_NOKEY,
        /* auto-generated 64bit unsigned integer key */
        CARBON_KEY_AUTOKEY = CARBON_MARKER_KEY_AUTOKEY,
        /* user-defined 64bit unsigned integer key */
        CARBON_KEY_UKEY = CARBON_MARKER_KEY_UKEY,
        /* user-defined 64bit signed integer key */
        CARBON_KEY_IKEY = CARBON_MARKER_KEY_IKEY,
        /* user-defined n-char string_buffer key */
        CARBON_KEY_SKEY = CARBON_MARKER_KEY_SKEY
} carbon_key_e;

#define CARBON_NIL_STR "_nil"
#define CARBON_MARKER_NULL 'n'
#define CARBON_MARKER_TRUE 't'
#define CARBON_MARKER_FALSE 'f'
#define CARBON_MARKER_STRING 's'
#define CARBON_MARKER_U8 'c'
#define CARBON_MARKER_U16 'd'
#define CARBON_MARKER_U32 'i'
#define CARBON_MARKER_U64 'l'
#define CARBON_MARKER_I8 'C'
#define CARBON_MARKER_I16 'D'
#define CARBON_MARKER_I32 'I'
#define CARBON_MARKER_I64 'L'
#define CARBON_MARKER_FLOAT 'r'
#define CARBON_MARKER_BINARY 'b'
#define CARBON_MARKER_CUSTOM_BINARY 'x'
#define CARBON_MARKER_OBJECT_BEGIN '{'
#define CARBON_MARKER_OBJECT_END '}'
#define CARBON_MARKER_ARRAY_BEGIN '['
#define CARBON_MARKER_ARRAY_END ']'
#define CARBON_MARKER_COLUMN_U8 '1'
#define CARBON_MARKER_COLUMN_U16 '2'
#define CARBON_MARKER_COLUMN_U32 '3'
#define CARBON_MARKER_COLUMN_U64 '4'
#define CARBON_MARKER_COLUMN_I8 '5'
#define CARBON_MARKER_COLUMN_I16 '6'
#define CARBON_MARKER_COLUMN_I32 '7'
#define CARBON_MARKER_COLUMN_I64 '8'
#define CARBON_MARKER_COLUMN_FLOAT 'R'
#define CARBON_MARKER_COLUMN_BOOLEAN 'B'

DEFINE_ERROR_GETTER(carbon);
DEFINE_ERROR_GETTER(carbon_new);

#define CARBON_KEEP              0x0
#define CARBON_SHRINK            0x1
#define CARBON_COMPACT           0x2
#define CARBON_OPTIMIZE          (CARBON_SHRINK | CARBON_COMPACT)

/**
 * Constructs a new context in which a new document can be created. The parameter <b>options</b> controls
 * how reserved spaces should be handled after document creation is done. Set <code>options</code> to
 * <code>CARBON_KEEP</code> for no optimization. With this option, all capacities (i.e., additional ununsed but free
 * space) in containers (objects, arrays, and columns) are kept and tailing free space after the document is
 * kept, too. Use this option to optimize for "insertion-heavy" documents since keeping all capacities lowerst the
 * probability of reallocations and memory movements. Set <b>options</b> to <code>CARBON_COMPACT</code> if capacities in
 * containers should be removed after creation, and <code>CARBON_COMPACT</code> to remove tailing free space. Use
 * <code>CARBON_OPTIMIZE</code> to use both <code>CARBON_SHRINK</code> and <code>CARBON_COMPACT</code>.
 *
 * As a rule of thumb for <b>options</b>. The resulting document...
 * <ul>
 *  <li>...will be updated heavily where updates may change the type-width of fields, will be target of many inserts
 *  containers, use <code>CARBON_KEEP</code>. The document will have a notable portion of reserved memory contained;
 *  insertions or updates will, however, not require immediately reallocation or memory movements.</li>
 *  <li>...will <i>not</i> be target of insertion of strings or blob fields in the near future, use
 *      <code>CARBON_SHRINK</code>. The document will not have padding reserved memory at the end, which means that
 *      a realloction will be required once the document grows (e.g., a container must be englarged). Typically,
 *      document growth is handled with container capacities (see <code>CARBON_COMPACT</code>). However, insertions
 *      of variable-length data (i.e., strings and blobs) may require container enlargement. In this case, having
 *      padding reserved memory at the end of the document lowers the risk of a reallocation.</li>
 *  <li>...will <i>not</i> not be target of insertion operations or update operations that changes a fields type-width
 *      in the near future. In simpler words, if a document is updated and each such update keeps the (byte) size
 *      of the field, use <code>CARBON_COMPACT</code>. This option will remove all capacities in containers.</li>
 *  <li>...is read-mostly, or updates will not change the type or type-width of fields, use <code>CARBON_OPTIMIZE</code>.
 *      The document will have the smallest memory footprint possible.</li>
 * </ul>
 */
carbon_insert *carbon_create_begin(carbon_new *context, carbon *doc, carbon_key_e type, int options);
bool carbon_create_end(carbon_new *context);
bool carbon_create_empty(carbon *doc, carbon_key_e type);
bool carbon_create_empty_ex(carbon *doc, carbon_key_e type, u64 doc_cap, u64 array_cap);
bool carbon_from_json(carbon *doc, const char *json, carbon_key_e type, const void *key, err *err);
bool carbon_drop(carbon *doc);

const void *carbon_raw_data(u64 *len, carbon *doc);

bool carbon_is_up_to_date(carbon *doc);
bool carbon_key_type(carbon_key_e *out, carbon *doc);
const void *carbon_key_raw_value(u64 *len, carbon_key_e *type, carbon *doc);
bool carbon_key_signed_value(i64 *key, carbon *doc);
bool carbon_key_unsigned_value(u64 *key, carbon *doc);
const char *carbon_key_string_value(u64 *len, carbon *doc);
bool carbon_has_key(carbon_key_e type);
bool carbon_key_is_unsigned(carbon_key_e type);
bool carbon_key_is_signed(carbon_key_e type);
bool carbon_key_is_string(carbon_key_e type);
bool carbon_clone(carbon *clone, carbon *doc);
bool carbon_commit_hash(u64 *hash, carbon *doc);

bool carbon_to_str(string_buffer *dst, carbon_printer_impl_e printer, carbon *doc);
const char *carbon_to_json_extended(string_buffer *dst, carbon *doc);
const char *carbon_to_json_compact(string_buffer *dst, carbon *doc);
char *carbon_to_json_extended_dup(carbon *doc);
char *carbon_to_json_compact_dup(carbon *doc);
bool carbon_read_begin(carbon_array_it *it, carbon *doc);
bool carbon_read_end(carbon_array_it *it);
bool carbon_print(FILE *file, carbon_printer_impl_e printer, carbon *doc);
bool carbon_hexdump_print(FILE *file, carbon *doc);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements an (read-/write) iterator for (JSON) arrays in carbon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_ARRAY_IT_H
#define CARBON_ARRAY_IT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <vector.h>
#include <spinlock.h>
#include <jakson/carbon.h>
#include <jakson/carbon/field.h>

BEGIN_DECL

typedef struct field_access {
        carbon_field_type_e it_field_type;

        const void *it_field_data;
        u64 it_field_len;

        const char *it_mime_type;
        u64 it_mime_type_strlen;

        bool nested_array_it_is_created;
        bool nested_array_it_accessed;

        bool nested_object_it_is_created;
        bool nested_object_it_accessed;

        bool nested_column_it_is_created;

        carbon_array_it *nested_array_it;
        carbon_column_it *nested_column_it;
        carbon_object_it *nested_object_it;
} field_access;

typedef struct carbon_array_it {
        memfile memfile;
        offset_t payload_start;
        spinlock lock;
        err err;

        /* in case of modifications (updates, inserts, deletes), the number of bytes that are added resp. removed */
        i64 mod_size;
        bool array_end_reached;

        vector ofType(offset_t) history;
        field_access field_access;
        offset_t field_offset;
} carbon_array_it;

DEFINE_ERROR_GETTER(carbon_array_it);

#define DECLARE_IN_PLACE_UPDATE_FUNCTION(type_name)                                                                    \
bool carbon_array_it_update_in_place_##type_name(carbon_array_it *it, ##type_name value);

DECLARE_IN_PLACE_UPDATE_FUNCTION(u8)
DECLARE_IN_PLACE_UPDATE_FUNCTION(u16)
DECLARE_IN_PLACE_UPDATE_FUNCTION(u32)
DECLARE_IN_PLACE_UPDATE_FUNCTION(u64)
DECLARE_IN_PLACE_UPDATE_FUNCTION(i8)
DECLARE_IN_PLACE_UPDATE_FUNCTION(i16)
DECLARE_IN_PLACE_UPDATE_FUNCTION(i32)
DECLARE_IN_PLACE_UPDATE_FUNCTION(i64)
DECLARE_IN_PLACE_UPDATE_FUNCTION(float)

bool carbon_array_it_update_in_place_true(carbon_array_it *it);
bool carbon_array_it_update_in_place_false(carbon_array_it *it);
bool carbon_array_it_update_in_place_null(carbon_array_it *it);

/**
 * Constructs a new array iterator in a carbon document, where <code>payload_start</code> is a memory offset
 * that starts with the first (potentially empty) array entry. If there is some data before the array contents
 * (e.g., a header), <code>payload_start</code> must not include this data.
 */
bool carbon_array_it_create(carbon_array_it *it, memfile *memfile, err *err, offset_t payload_start);
bool carbon_array_it_copy(carbon_array_it *dst, carbon_array_it *src);
bool carbon_array_it_clone(carbon_array_it *dst, carbon_array_it *src);
bool carbon_array_it_set_mode(carbon_array_it *it);
bool carbon_array_it_length(u64 *len, carbon_array_it *it);
bool carbon_array_it_is_empty(carbon_array_it *it);

/**
 * Drops the iterator.
 */
bool carbon_array_it_drop(carbon_array_it *it);

/**
 * Locks the iterator with a spinlock. A call to <code>carbon_array_it_unlock</code> is required for unlocking.
 */
bool carbon_array_it_lock(carbon_array_it *it);

/**
 * Unlocks the iterator
 */
bool carbon_array_it_unlock(carbon_array_it *it);

/**
 * Positions the iterator at the beginning of this array.
 */
bool carbon_array_it_rewind(carbon_array_it *it);

/**
 * Positions the iterator to the slot after the current element, potentially pointing to next element.
 * The function returns true, if the slot is non-empty, and false otherwise.
 */
bool carbon_array_it_next(carbon_array_it *it);
bool carbon_array_it_has_next(carbon_array_it *it);
bool carbon_array_it_is_unit(carbon_array_it *it);
bool carbon_array_it_prev(carbon_array_it *it);

offset_t carbon_array_it_memfilepos(carbon_array_it *it);
offset_t carbon_array_it_tell(carbon_array_it *it);
bool carbon_int_array_it_offset(offset_t *off, carbon_array_it *it);
bool carbon_array_it_fast_forward(carbon_array_it *it);

bool carbon_array_it_field_type(carbon_field_type_e *type, carbon_array_it *it);
bool carbon_array_it_u8_value(u8 *value, carbon_array_it *it);
bool carbon_array_it_u16_value(u16 *value, carbon_array_it *it);
bool carbon_array_it_u32_value(u32 *value, carbon_array_it *it);
bool carbon_array_it_u64_value(u64 *value, carbon_array_it *it);
bool carbon_array_it_i8_value(i8 *value, carbon_array_it *it);
bool carbon_array_it_i16_value(i16 *value, carbon_array_it *it);
bool carbon_array_it_i32_value(i32 *value, carbon_array_it *it);
bool carbon_array_it_i64_value(i64 *value, carbon_array_it *it);
bool carbon_array_it_float_value_nullable(bool *is_null_in, float *value, carbon_array_it *it);
bool carbon_array_it_signed_value(bool *is_null_in, i64 *value, carbon_array_it *it);
bool carbon_array_it_unsigned_value(bool *is_null_in, u64 *value, carbon_array_it *it);
const char *carbon_array_it_string_value(u64 *strlen, carbon_array_it *it);
bool carbon_array_it_binary_value(carbon_binary *out, carbon_array_it *it);
carbon_array_it *carbon_array_it_array_value(carbon_array_it *it_in);
carbon_object_it *carbon_array_it_object_value(carbon_array_it *it_in);
carbon_column_it *carbon_array_it_column_value(carbon_array_it *it_in);

/**
 * Inserts a new element at the current position of the iterator.
 */
bool carbon_array_it_insert_begin(carbon_insert *inserter, carbon_array_it *it);
bool carbon_array_it_insert_end(carbon_insert *inserter);
bool carbon_array_it_remove(carbon_array_it *it);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements an (read-/write) iterator for (JSON) arrays in carbon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_COLUMN_IT_H
#define CARBON_COLUMN_IT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <spinlock.h>
#include <jakson/carbon/field.h>
#include <jakson/carbon.h>

BEGIN_DECL

typedef struct carbon_column_it {
        memfile memfile;

        offset_t num_and_capacity_start_offset;
        offset_t column_start_offset;

        err err;
        carbon_field_type_e type;

        /* in case of modifications (updates, inserts, deletes), the number of bytes that are added resp. removed */
        i64 mod_size;

        u32 column_capacity;
        u32 column_num_elements;

        spinlock lock;
} carbon_column_it;

bool carbon_column_it_create(carbon_column_it *it, memfile *memfile, err *err, offset_t column_start_offset);
bool carbon_column_it_clone(carbon_column_it *dst, carbon_column_it *src);

bool carbon_column_it_insert(carbon_insert *inserter, carbon_column_it *it);
bool carbon_column_it_fast_forward(carbon_column_it *it);
offset_t carbon_column_it_memfilepos(carbon_column_it *it);
offset_t carbon_column_it_tell(carbon_column_it *it, u32 elem_idx);

const void *carbon_column_it_values(carbon_field_type_e *type, u32 *nvalues, carbon_column_it *it);
bool carbon_column_it_values_info(carbon_field_type_e *type, u32 *nvalues, carbon_column_it *it);

bool carbon_column_it_value_is_null(carbon_column_it *it, u32 pos);

const u8 *carbon_column_it_boolean_values(u32 *nvalues, carbon_column_it *it);
const u8 *carbon_column_it_u8_values(u32 *nvalues, carbon_column_it *it);
const u16 *carbon_column_it_u16_values(u32 *nvalues, carbon_column_it *it);
const u32 *carbon_column_it_u32_values(u32 *nvalues, carbon_column_it *it);
const u64 *carbon_column_it_u64_values(u32 *nvalues, carbon_column_it *it);
const i8 *carbon_column_it_i8_values(u32 *nvalues, carbon_column_it *it);
const i16 *carbon_column_it_i16_values(u32 *nvalues, carbon_column_it *it);
const i32 *carbon_column_it_i32_values(u32 *nvalues, carbon_column_it *it);
const i64 *carbon_column_it_i64_values(u32 *nvalues, carbon_column_it *it);
const float *carbon_column_it_float_values(u32 *nvalues, carbon_column_it *it);

bool carbon_column_it_remove(carbon_column_it *it, u32 pos);

bool carbon_column_it_update_set_null(carbon_column_it *it, u32 pos);
bool carbon_column_it_update_set_true(carbon_column_it *it, u32 pos);
bool carbon_column_it_update_set_false(carbon_column_it *it, u32 pos);
bool carbon_column_it_update_set_u8(carbon_column_it *it, u32 pos, u8 value);
bool carbon_column_it_update_set_u16(carbon_column_it *it, u32 pos, u16 value);
bool carbon_column_it_update_set_u32(carbon_column_it *it, u32 pos, u32 value);
bool carbon_column_it_update_set_u64(carbon_column_it *it, u32 pos, u64 value);
bool carbon_column_it_update_set_i8(carbon_column_it *it, u32 pos, i8 value);
bool carbon_column_it_update_set_i16(carbon_column_it *it, u32 pos, i16 value);
bool carbon_column_it_update_set_i32(carbon_column_it *it, u32 pos, i32 value);
bool carbon_column_it_update_set_i64(carbon_column_it *it, u32 pos, i64 value);
bool carbon_column_it_update_set_float(carbon_column_it *it, u32 pos, float value);

/**
 * Locks the iterator with a spinlock. A call to <code>carbon_column_it_unlock</code> is required for unlocking.
 */
bool carbon_column_it_lock(carbon_column_it *it);

/**
 * Unlocks the iterator
 */
bool carbon_column_it_unlock(carbon_column_it *it);

/**
 * Positions the iterator at the beginning of this array.
 */
bool carbon_column_it_rewind(carbon_column_it *it);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#ifndef CARBON_COMMIT_HASH_H
#define CARBON_COMMIT_HASH_H

#include <stdinc.h>
#include <jakson/error.h>
#include <memfile.h>
#include <string_buffer.h>

BEGIN_DECL

bool carbon_commit_hash_create(memfile *file);
bool carbon_commit_hash_skip(memfile *file);
bool carbon_commit_hash_read(u64 *commit_hash, memfile *file);
bool carbon_commit_hash_peek(u64 *commit_hash, memfile *file);
bool carbon_commit_hash_update(memfile *file, const char *base, u64 len);
bool carbon_commit_hash_compute(u64 *commit_hash, const void *base, u64 len);
const char *carbon_commit_hash_to_str(string_buffer *dst, u64 commit_hash);
bool carbon_commit_hash_append_to_str(string_buffer *dst, u64 commit_hash);
u64 carbon_commit_hash_from_str(const char *commit_str, err *err);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements the document format itself
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_DOT_H
#define CARBON_DOT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <types.h>
#include <string_buffer.h>
#include <jakson/carbon/array_it.h>
#include <jakson/carbon/column_it.h>
#include <jakson/carbon/object_it.h>

BEGIN_DECL

typedef enum carbon_dot_node {
        DOT_NODE_ARRAY_IDX,
        DOT_NODE_KEY_NAME
} carbon_dot_node;

typedef struct carbon_dot_node {
        carbon_dot_node type;
        union {
                char *string_buffer;
                u32 idx;
        } identifier;
} carbon_dot_node;

typedef struct carbon_dot_path {
        carbon_dot_node nodes[256];
        u32 path_len;
        err err;
} carbon_dot_path;

typedef enum carbon_path_status {
        CARBON_PATH_RESOLVED,
        CARBON_PATH_EMPTY_DOC,
        CARBON_PATH_NOSUCHINDEX,
        CARBON_PATH_NOSUCHKEY,
        CARBON_PATH_NOTTRAVERSABLE,
        CARBON_PATH_NOCONTAINER,
        CARBON_PATH_NOTANOBJECT,
        CARBON_PATH_NONESTING,
        CARBON_PATH_INTERNAL
} carbon_path_status_e;

DEFINE_ERROR_GETTER(carbon_dot_path)

bool carbon_dot_path_create(carbon_dot_path *path);
bool carbon_dot_path_from_string(carbon_dot_path *path, const char *path_string);
bool carbon_dot_path_drop(carbon_dot_path *path);

bool carbon_dot_path_add_key(carbon_dot_path *dst, const char *key);
bool carbon_dot_path_add_nkey(carbon_dot_path *dst, const char *key, size_t len);
bool carbon_dot_path_add_idx(carbon_dot_path *dst, u32 idx);
bool carbon_dot_path_len(u32 *len, const carbon_dot_path *path);
bool carbon_dot_path_is_empty(const carbon_dot_path *path);
bool carbon_dot_path_type_at(carbon_dot_node *type_out, u32 pos, const carbon_dot_path *path);
bool carbon_dot_path_idx_at(u32 *idx, u32 pos, const carbon_dot_path *path);
const char *carbon_dot_path_key_at(u32 pos, const carbon_dot_path *path);

bool carbon_dot_path_to_str(string_buffer *sb, carbon_dot_path *path);
bool carbon_dot_path_fprint(FILE *file, carbon_dot_path *path);
bool carbon_dot_path_print(carbon_dot_path *path);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <jakson/carbon.h>

#ifndef CARBON_FIELD_H
#define CARBON_FIELD_H

typedef enum carbon_field_type {
        /* constants */
        CARBON_FIELD_TYPE_NULL = CARBON_MARKER_NULL, /* null */
        CARBON_FIELD_TYPE_TRUE = CARBON_MARKER_TRUE, /* true */
        CARBON_FIELD_TYPE_FALSE = CARBON_MARKER_FALSE, /* false */

        /* containers */
        CARBON_FIELD_TYPE_OBJECT = CARBON_MARKER_OBJECT_BEGIN, /* object */
        CARBON_FIELD_TYPE_ARRAY = CARBON_MARKER_ARRAY_BEGIN, /* variable-type array of elements of varying type */
        CARBON_FIELD_TYPE_COLUMN_U8 = CARBON_MARKER_COLUMN_U8, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_U16 = CARBON_MARKER_COLUMN_U16, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_U32 = CARBON_MARKER_COLUMN_U32, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_U64 = CARBON_MARKER_COLUMN_U64, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_I8 = CARBON_MARKER_COLUMN_I8, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_I16 = CARBON_MARKER_COLUMN_I16, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_I32 = CARBON_MARKER_COLUMN_I32, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_I64 = CARBON_MARKER_COLUMN_I64, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_FLOAT = CARBON_MARKER_COLUMN_FLOAT, /* fixed-type array of elements of particular type */
        CARBON_FIELD_TYPE_COLUMN_BOOLEAN = CARBON_MARKER_COLUMN_BOOLEAN, /* fixed-type array of elements of particular type */

        /* character strings */
        CARBON_FIELD_TYPE_STRING = CARBON_MARKER_STRING, /* UTF-8 string_buffer */

        /* numbers */
        CARBON_FIELD_TYPE_NUMBER_U8 = CARBON_MARKER_U8, /* 8bit unsigned integer */
        CARBON_FIELD_TYPE_NUMBER_U16 = CARBON_MARKER_U16, /* 16bit unsigned integer */
        CARBON_FIELD_TYPE_NUMBER_U32 = CARBON_MARKER_U32, /* 32bit unsigned integer */
        CARBON_FIELD_TYPE_NUMBER_U64 = CARBON_MARKER_U64, /* 64bit unsigned integer */
        CARBON_FIELD_TYPE_NUMBER_I8 = CARBON_MARKER_I8, /* 8bit signed integer */
        CARBON_FIELD_TYPE_NUMBER_I16 = CARBON_MARKER_I16, /* 16bit signed integer */
        CARBON_FIELD_TYPE_NUMBER_I32 = CARBON_MARKER_I32, /* 32bit signed integer */
        CARBON_FIELD_TYPE_NUMBER_I64 = CARBON_MARKER_I64, /* 64bit signed integer */
        CARBON_FIELD_TYPE_NUMBER_FLOAT = CARBON_MARKER_FLOAT, /* 32bit float */

        /* binary data */
        CARBON_FIELD_TYPE_BINARY = CARBON_MARKER_BINARY, /* arbitrary binary object with known mime type */
        CARBON_FIELD_TYPE_BINARY_CUSTOM = CARBON_MARKER_CUSTOM_BINARY, /* arbitrary binary object with unknown mime type*/
} carbon_field_type_e;

typedef enum carbon_column_type {
        CARBON_COLUMN_TYPE_U8,
        CARBON_COLUMN_TYPE_U16,
        CARBON_COLUMN_TYPE_U32,
        CARBON_COLUMN_TYPE_U64,
        CARBON_COLUMN_TYPE_I8,
        CARBON_COLUMN_TYPE_I16,
        CARBON_COLUMN_TYPE_I32,
        CARBON_COLUMN_TYPE_I64,
        CARBON_COLUMN_TYPE_FLOAT,
        CARBON_COLUMN_TYPE_BOOLEAN
} carbon_column_type_e;

typedef enum carbon_field_class {
        CARBON_FIELD_CLASS_CONSTANT,
        CARBON_FIELD_CLASS_NUMBER,
        CARBON_FIELD_CLASS_CHARACTER_STRING,
        CARBON_FIELD_CLASS_BINARY_STRING,
        CARBON_FIELD_CLASS_CONTAINER
} carbon_field_class_e;

typedef enum carbon_constant {
        CARBON_CONSTANT_TRUE,
        CARBON_CONSTANT_FALSE,
        CARBON_CONSTANT_NULL
} carbon_constant_e;

#define CARBON_FIELD_TYPE_NULL_STR "null"
#define CARBON_FIELD_TYPE_TRUE_STR "boolean-true"
#define CARBON_FIELD_TYPE_FALSE_STR "boolean-false"
#define CARBON_FIELD_TYPE_OBJECT_STR "object"
#define CARBON_FIELD_TYPE_ARRAY_STR "array"
#define CARBON_FIELD_TYPE_COLUMN_U8_STR "column-u8"
#define CARBON_FIELD_TYPE_COLUMN_U16_STR "column-u16"
#define CARBON_FIELD_TYPE_COLUMN_U32_STR "column-u32"
#define CARBON_FIELD_TYPE_COLUMN_U64_STR "column-u64"
#define CARBON_FIELD_TYPE_COLUMN_I8_STR "column-i8"
#define CARBON_FIELD_TYPE_COLUMN_I16_STR "column-i16"
#define CARBON_FIELD_TYPE_COLUMN_I32_STR "column-i32"
#define CARBON_FIELD_TYPE_COLUMN_I64_STR "column-i64"
#define CARBON_FIELD_TYPE_COLUMN_FLOAT_STR "column-float"
#define CARBON_FIELD_TYPE_COLUMN_BOOLEAN_STR "column-boolean"
#define CARBON_FIELD_TYPE_STRING_STR "string_buffer"
#define CARBON_FIELD_TYPE_BINARY_STR "binary"
#define CARBON_FIELD_TYPE_NUMBER_U8_STR "number-u8"
#define CARBON_FIELD_TYPE_NUMBER_U16_STR "number-u16"
#define CARBON_FIELD_TYPE_NUMBER_U32_STR "number-u32"
#define CARBON_FIELD_TYPE_NUMBER_U64_STR "number-u64"
#define CARBON_FIELD_TYPE_NUMBER_I8_STR "number-i8"
#define CARBON_FIELD_TYPE_NUMBER_I16_STR "number-i16"
#define CARBON_FIELD_TYPE_NUMBER_I32_STR "number-i32"
#define CARBON_FIELD_TYPE_NUMBER_I64_STR "number-i64"
#define CARBON_FIELD_TYPE_NUMBER_FLOAT_STR "number-float"

BEGIN_DECL

const char *carbon_field_type_str(err *err, carbon_field_type_e type);

bool carbon_field_type_is_traversable(carbon_field_type_e type);
bool carbon_field_type_is_signed(carbon_field_type_e type);
bool carbon_field_type_is_unsigned(carbon_field_type_e type);
bool carbon_field_type_is_floating(carbon_field_type_e type);
bool carbon_field_type_is_number(carbon_field_type_e type);
bool carbon_field_type_is_integer(carbon_field_type_e type);
bool carbon_field_type_is_binary(carbon_field_type_e type);
bool carbon_field_type_is_boolean(carbon_field_type_e type);
bool carbon_field_type_is_array(carbon_field_type_e type);
bool carbon_field_type_is_column(carbon_field_type_e type);
bool carbon_field_type_is_object(carbon_field_type_e type);
bool carbon_field_type_is_null(carbon_field_type_e type);
bool carbon_field_type_is_string(carbon_field_type_e type);
bool carbon_field_type_is_constant(carbon_field_type_e type);

carbon_field_class_e carbon_field_type_get_class(carbon_field_type_e type, err *err);

bool carbon_field_skip(memfile *file);
bool carbon_field_skip_object(memfile *file);
bool carbon_field_skip_array(memfile *file);
bool carbon_field_skip_column(memfile *file);
bool carbon_field_skip_binary(memfile *file);
bool carbon_field_skip_custom_binary(memfile *file);
bool carbon_field_skip_string(memfile *file);
bool carbon_field_skip_float(memfile *file);
bool carbon_field_skip_boolean(memfile *file);
bool carbon_field_skip_null(memfile *file);
bool carbon_field_skip_8(memfile *file);
bool carbon_field_skip_16(memfile *file);
bool carbon_field_skip_32(memfile *file);
bool carbon_field_skip_64(memfile *file);

carbon_field_type_e carbon_field_type_for_column(carbon_column_type_e type);
carbon_field_type_e carbon_field_type_column_entry_to_regular_type(carbon_field_type_e type, bool is_null, bool is_true);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_FIND_H
#define CARBON_FIND_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <jakson/carbon.h>
#include <jakson/carbon/column_it.h>
#include <jakson/carbon/array_it.h>
#include <jakson/carbon/object_it.h>
#include <jakson/carbon/dot.h>
#include <jakson/carbon/path.h>

BEGIN_DECL

typedef struct carbon_find {
        carbon *doc;
        carbon_field_type_e type;
        err err;
        carbon_path_evaluator path_evaluater;

        bool value_is_nulled;

        union {
                carbon_array_it *array_it;
                carbon_column_it *column_it;
                carbon_object_it *object_it;
                bool boolean;
                u64 unsigned_number;
                i64 signed_number;
                float float_number;

                struct {
                        const char *base;
                        u64 len;
                } string_buffer;

                carbon_binary binary;
        } value;
} carbon_find;

DEFINE_ERROR_GETTER(carbon_find)

bool carbon_find_begin(carbon_find *out, const char *dot_path, carbon *doc);
bool carbon_find_end(carbon_find *find);
bool carbon_find_create(carbon_find *find, carbon_dot_path *path, carbon *doc);
bool carbon_find_drop(carbon_find *find);

bool carbon_find_has_result(carbon_find *find);
const char *carbon_find_result_to_str(string_buffer *dst_str, carbon_printer_impl_e print_type, carbon_find *find);
const char *carbon_find_result_to_json_compact(string_buffer *dst_str, carbon_find *find);
char *carbon_find_result_to_json_compact_dup(carbon_find *find);

bool carbon_find_result_type(carbon_field_type_e *type, carbon_find *find);

carbon_array_it *carbon_find_result_array(carbon_find *find);
carbon_object_it *carbon_find_result_object(carbon_find *find);
carbon_column_it *carbon_find_result_column(carbon_find *find);
bool carbon_find_result_boolean(bool *out, carbon_find *find);
bool carbon_find_result_unsigned(u64 *out, carbon_find *find);
bool carbon_find_result_signed(i64 *out, carbon_find *find);
bool carbon_find_result_float(float *out, carbon_find *find);
const char *carbon_find_result_string(u64 *str_len, carbon_find *find);
carbon_binary *carbon_find_result_binary(carbon_find *find);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_GET_H
#define CARBON_GET_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>
#include <jakson/carbon.h>

BEGIN_DECL

u64 carbon_get_or_default_unsigned(carbon *doc, const char *path, u64 default_val);
i64 carbon_get_or_default_signed(carbon *doc, const char *path, i64 default_val);
float carbon_get_or_default_float(carbon *doc, const char *path, float default_val);
bool carbon_get_or_default_boolean(carbon *doc, const char *path, bool default_val);
const char *carbon_get_or_default_string(u64 *len_out, carbon *doc, const char *path, const char *default_val);
carbon_binary *carbon_get_or_default_binary(carbon *doc, const char *path, carbon_binary *default_val);
carbon_array_it *carbon_get_array_or_null(carbon *doc, const char *path);
carbon_column_it *carbon_get_column_or_null(carbon *doc, const char *path);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements the document format itself
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_INSERT_H
#define CARBON_INSERT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <memblock.h>
#include <memfile.h>
#include <spinlock.h>
#include <jakson/carbon.h>
#include <jakson/carbon/internal.h>

BEGIN_DECL

bool carbon_int_insert_create_for_array(carbon_insert *inserter, carbon_array_it *context);
bool carbon_int_insert_create_for_column(carbon_insert *inserter, carbon_column_it *context);
bool carbon_int_insert_create_for_object(carbon_insert *inserter, carbon_object_it *context);

bool carbon_insert_null(carbon_insert *inserter);
bool carbon_insert_true(carbon_insert *inserter);
bool carbon_insert_false(carbon_insert *inserter);
bool carbon_insert_u8(carbon_insert *inserter, u8 value);
bool carbon_insert_u16(carbon_insert *inserter, u16 value);
bool carbon_insert_u32(carbon_insert *inserter, u32 value);
bool carbon_insert_u64(carbon_insert *inserter, u64 value);
bool carbon_insert_i8(carbon_insert *inserter, i8 value);
bool carbon_insert_i16(carbon_insert *inserter, i16 value);
bool carbon_insert_i32(carbon_insert *inserter, i32 value);
bool carbon_insert_i64(carbon_insert *inserter, i64 value);
bool carbon_insert_unsigned(carbon_insert *inserter, u64 value);
bool carbon_insert_signed(carbon_insert *inserter, i64 value);
bool carbon_insert_float(carbon_insert *inserter, float value);
bool carbon_insert_string(carbon_insert *inserter, const char *value);
bool carbon_insert_nchar(carbon_insert *inserter, const char *value, u64 value_len);
/**
 * Inserts a user-defined binary string_buffer <code>value</code> of <code>nbytes</code> bytes along with a (mime) type annotation.
 * The type annotation is automatically found if <code>file_ext</code> is non-null and known to the system. If it is
 * not known or null, the non-empty <code>user_type</code> string_buffer is used to encode the mime annotation. In case
 * <code>user_type</code> is null (or empty) and <code>file_ext</code> is null (or not known), the mime type is set to
 * <code>application/octet-stream</code>, which encodes arbitrary binary data.
 */
bool carbon_insert_binary(carbon_insert *inserter, const void *value, size_t nbytes, const char *file_ext, const char *user_type);

carbon_insert *carbon_insert_object_begin(carbon_insert_object_state *out, carbon_insert *inserter, u64 object_capacity);
bool carbon_insert_object_end(carbon_insert_object_state *state);

carbon_insert *carbon_insert_array_begin(carbon_insert_array_state *state_out, carbon_insert *inserter_in, u64 array_capacity);
bool carbon_insert_array_end(carbon_insert_array_state *state_in);

carbon_insert *carbon_insert_column_begin(carbon_insert_column_state *state_out, carbon_insert *inserter_in, carbon_column_type_e type, u64 column_capacity);
bool carbon_insert_column_end(carbon_insert_column_state *state_in);

bool carbon_insert_prop_null(carbon_insert *inserter, const char *key);
bool carbon_insert_prop_true(carbon_insert *inserter, const char *key);
bool carbon_insert_prop_false(carbon_insert *inserter, const char *key);
bool carbon_insert_prop_u8(carbon_insert *inserter, const char *key, u8 value);
bool carbon_insert_prop_u16(carbon_insert *inserter, const char *key, u16 value);
bool carbon_insert_prop_u32(carbon_insert *inserter, const char *key, u32 value);
bool carbon_insert_prop_u64(carbon_insert *inserter, const char *key, u64 value);
bool carbon_insert_prop_i8(carbon_insert *inserter, const char *key, i8 value);
bool carbon_insert_prop_i16(carbon_insert *inserter, const char *key, i16 value);
bool carbon_insert_prop_i32(carbon_insert *inserter, const char *key, i32 value);
bool carbon_insert_prop_i64(carbon_insert *inserter, const char *key, i64 value);
bool carbon_insert_prop_unsigned(carbon_insert *inserter, const char *key, u64 value);
bool carbon_insert_prop_signed(carbon_insert *inserter, const char *key, i64 value);
bool carbon_insert_prop_float(carbon_insert *inserter, const char *key, float value);
bool carbon_insert_prop_string(carbon_insert *inserter, const char *key, const char *value);
bool carbon_insert_prop_nchar(carbon_insert *inserter, const char *key, const char *value, u64 value_len);
bool carbon_insert_prop_binary(carbon_insert *inserter, const char *key, const void *value, size_t nbytes, const char *file_ext, const char *user_type);

carbon_insert *carbon_insert_prop_object_begin(carbon_insert_object_state *out, carbon_insert *inserter, const char *key, u64 object_capacity);
u64 carbon_insert_prop_object_end(carbon_insert_object_state *state);

carbon_insert *carbon_insert_prop_array_begin(carbon_insert_array_state *state, carbon_insert *inserter, const char *key, u64 array_capacity);
u64 carbon_insert_prop_array_end(carbon_insert_array_state *state);

carbon_insert *carbon_insert_prop_column_begin(carbon_insert_column_state *state_out, carbon_insert *inserter_in, const char *key, carbon_column_type_e type, u64 column_capacity);
u64 carbon_insert_prop_column_end(carbon_insert_column_state *state_in);

bool carbon_insert_drop(carbon_insert *inserter);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file is for internal usage only; do not call these functions from outside
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_INT_H
#define CARBON_INT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <memfile.h>
#include <uintvar_stream.h>
#include <json.h>
#include <jakson/carbon/internal.h>
#include <jakson/carbon/field.h>
#include <jakson/carbon/array_it.h>

BEGIN_DECL

typedef struct carbon_insert {
        carbon_container_e context_type;
        union {
                carbon_array_it *array;
                carbon_column_it *column;
                carbon_object_it *object;
        } context;

        memfile memfile;
        offset_t position;
        err err;
} carbon_insert;

typedef struct carbon_insert_array_state {
        carbon_insert *parent_inserter;
        carbon_array_it *nested_array;
        carbon_insert nested_inserter;
        offset_t array_begin, array_end;
} carbon_insert_array_state;

typedef struct carbon_insert_object_state {
        carbon_insert *parent_inserter;
        carbon_object_it *it;
        carbon_insert inserter;
        offset_t object_begin, object_end;
} carbon_insert_object_state;

typedef struct carbon_insert_column_state {
        carbon_insert *parent_inserter;
        carbon_field_type_e type;
        carbon_column_it *nested_column;
        carbon_insert nested_inserter;
        offset_t column_begin, column_end;
} carbon_insert_column_state;

bool carbon_int_insert_object(memfile *memfile, size_t nbytes);
bool carbon_int_insert_array(memfile *memfile, size_t nbytes);
bool carbon_int_insert_column(memfile *memfile_in, err *err_in, carbon_column_type_e type, size_t capactity);

/**
 * Returns the number of bytes required to store a field type including its type marker in a byte sequence.
 */
size_t carbon_int_get_type_size_encoded(carbon_field_type_e type);

/**
 * Returns the number of bytes required to store a field value of a particular type exclusing its type marker.
 */
size_t carbon_int_get_type_value_size(carbon_field_type_e type);

bool carbon_int_array_it_next(bool *is_empty_slot, bool *is_array_end, carbon_array_it *it);
bool carbon_int_array_it_refresh(bool *is_empty_slot, bool *is_array_end, carbon_array_it *it);
bool carbon_int_array_it_field_type_read(carbon_array_it *it);
bool carbon_int_array_skip_contents(bool *is_empty_slot, bool *is_array_end, carbon_array_it *it);

bool carbon_int_object_it_next(bool *is_empty_slot, bool *is_object_end, carbon_object_it *it);
bool carbon_int_object_it_refresh(bool *is_empty_slot, bool *is_object_end, carbon_object_it *it);
bool carbon_int_object_it_prop_key_access(carbon_object_it *it);
bool carbon_int_object_it_prop_value_skip(carbon_object_it *it);
bool carbon_int_object_it_prop_skip(carbon_object_it *it);
bool carbon_int_object_skip_contents(bool *is_empty_slot, bool *is_array_end, carbon_object_it *it);
bool carbon_int_field_data_access(memfile *file, err *err, field_access *field_access);

offset_t carbon_int_column_get_payload_off(carbon_column_it *it);
offset_t carbon_int_payload_after_header(carbon *doc);

u64 carbon_int_header_get_commit_hash(carbon *doc);

void carbon_int_history_push(vector ofType(offset_t) *vec, offset_t off);
void carbon_int_history_clear(vector ofType(offset_t) *vec);
offset_t carbon_int_history_pop(vector ofType(offset_t) *vec);
offset_t carbon_int_history_peek(vector ofType(offset_t) *vec);
bool carbon_int_history_has(vector ofType(offset_t) *vec);

bool carbon_int_field_access_create(field_access *field);
bool carbon_int_field_access_clone(field_access *dst, field_access *src);
bool carbon_int_field_access_drop(field_access *field);
bool carbon_int_field_auto_close(field_access *it);
bool carbon_int_field_access_object_it_opened(field_access *field);
bool carbon_int_field_access_array_it_opened(field_access *field);
bool carbon_int_field_access_column_it_opened(field_access *field);
bool carbon_int_field_access_field_type(carbon_field_type_e *type, field_access *field);
bool carbon_int_field_access_u8_value(u8 *value, field_access *field, err *err);
bool carbon_int_field_access_u16_value(u16 *value, field_access *field, err *err);
bool carbon_int_field_access_u32_value(u32 *value, field_access *field, err *err);
bool carbon_int_field_access_u64_value(u64 *value, field_access *field, err *err);
bool carbon_int_field_access_i8_value(i8 *value, field_access *field, err *err);
bool carbon_int_field_access_i16_value(i16 *value, field_access *field, err *err);
bool carbon_int_field_access_i32_value(i32 *value, field_access *field, err *err);
bool carbon_int_field_access_i64_value(i64 *value, field_access *field, err *err);
bool carbon_int_field_access_float_value_nullable(bool *is_null_in, float *value, field_access *field, err *err);
bool carbon_int_field_access_signed_value(bool *is_null_in, i64 *value, field_access *field, err *err);
bool carbon_int_field_access_unsigned_value(bool *is_null_in, u64 *value, field_access *field, err *err);
const char *carbon_int_field_access_string_value(u64 *strlen, field_access *field, err *err);
bool carbon_int_field_access_binary_value(carbon_binary *out, field_access *field, err *err);
carbon_array_it *carbon_int_field_access_array_value(field_access *field, err *err);
carbon_object_it *carbon_int_field_access_object_value(field_access *field, err *err);
carbon_column_it *carbon_int_field_access_column_value(field_access *field, err *err);

void carbon_int_auto_close_nested_array_it(field_access *field);
void carbon_int_auto_close_nested_object_it(field_access *field);
void carbon_int_auto_close_nested_column_it(field_access *field);

bool carbon_int_field_remove(memfile *memfile, err *err, carbon_field_type_e type);

/**
 * For <code>mode</code>, see <code>carbon_create_begin</code>
 */
bool carbon_int_from_json(carbon *doc, const json *data, carbon_key_e key_type, const void *primary_key, int mode);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_KEY_H
#define CARBON_KEY_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <jakson/carbon.h>
#include <memfile.h>

BEGIN_DECL

bool carbon_key_create(memfile *file, carbon_key_e type, err *err);
bool carbon_key_skip(carbon_key_e *out, memfile *file);
bool carbon_key_read_type(carbon_key_e *out, memfile *file);
bool carbon_key_write_unsigned(memfile *file, u64 key);
bool carbon_key_write_signed(memfile *file, i64 key);
bool carbon_key_write_string(memfile *file, const char *key);
bool carbon_key_update_string(memfile *file, const char *key);
bool carbon_key_update_string_wnchar(memfile *file, const char *key, size_t length);
const void *carbon_key_read(u64 *len, carbon_key_e *out, memfile *file);
const char *carbon_key_type_str(carbon_key_e type);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_MEDIA_H
#define CARBON_MEDIA_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <memfile.h>
#include <jakson/carbon.h>
#include <jakson/carbon/field.h>

BEGIN_DECL

typedef u8 media_type; /* byte to determine type at hand (e.g., JSON array, string_buffer, null, ...) */

static struct mime_type {
        const char *type;
        const char *ext;

} global_mime_type_register[] = { /* the entries in this list must be sorted by extension! */
        {"application/vnd.lotus-1-2-3",                                               "123"},
        {"text/vnd.in3d.3dml",                                                        "3dml"},
        {"video/3gpp2",                                                               "3g2"},
        {"video/3gpp",                                                                "3gp"},
        {"application/x-7z-compressed",                                               "7z"},
        {"application/x-authorware-bin",                                              "aab"},
        {"audio/x-aac",                                                               "aac"},
        {"application/x-authorware-map",                                              "aam"},
        {"application/x-authorware-seg",                                              "aas"},
        {"application/x-abiword",                                                     "abw"},
        {"application/pkix-attr-cert",                                                "ac"},
        {"application/vnd.americandynamics.acc",                                      "acc"},
        {"application/x-ace-compressed",                                              "ace"},
        {"application/vnd.acucobol",                                                  "acu"},
        {"audio/adpcm",                                                               "adp"},
        {"application/vnd.audiograph",                                                "aep"},
        {"application/vnd.ibm.modcap",                                                "afp"},
        {"application/vnd.ahead.space",                                               "ahead"},
        {"application/postscript",                                                    "ai"},
        {"audio/x-aiff",                                                              "aif"},
        {"application/vnd.adobe.air-application-installer-package+zip",               "air"},
        {"application/vnd.dvb.ait",                                                   "ait"},
        {"application/vnd.amiga.ami",                                                 "ami"},
        {"application/vnd.android.package-archive",                                   "apk"},
        {"application/x-ms-application",                                              "application"},
        {"application/vnd.lotus-approach",                                            "apr"},
        {"video/x-ms-asf",                                                            "asf"},
        {"application/vnd.accpac.simply.aso",                                         "aso"},
        {"application/vnd.acucorp",                                                   "atc"},
        {"application/atom+xml",                                                      "atom"},
        {"application/atomcat+xml",                                                   "atomcat"},
        {"application/atomsvc+xml",                                                   "atomsvc"},
        {"application/vnd.antix.game-component",                                      "atx"},
        {"audio/basic",                                                               "au"},
        {"video/x-msvideo",                                                           "avi"},
        {"application/applixware",                                                    "aw"},
        {"application/vnd.airzip.filesecure.azf",                                     "azf"},
        {"application/vnd.airzip.filesecure.azs",                                     "azs"},
        {"application/vnd.amazon.ebook",                                              "azw"},
        {"application/x-bcpio",                                                       "bcpio"},
        {"application/x-font-bdf",                                                    "bdf"},
        {"application/vnd.syncml.dm+wbxml",                                           "bdm"},
        {"application/vnd.realvnc.bed",                                               "bed"},
        {"application/vnd.fujitsu.oasysprs",                                          "bh2"},
        {"application/octet-stream",                                                  "bin"},
        {"application/vnd.bmi",                                                       "bmi"},
        {"image/bmp",                                                                 "bmp"},
        {"application/vnd.previewsystems.box",                                        "box"},
        {"image/prs.btif",                                                            "btif"},
        {"application/x-bzip",                                                        "bz"},
        {"application/x-bzip2",                                                       "bz2"},
        {"text/x-c",                                                                  "c"},
        {"application/vnd.cluetrust.cartomobile-config",                              "c11amc"},
        {"application/vnd.cluetrust.cartomobile-config-pkg",                          "c11amz"},
        {"application/vnd.clonk.c4group",                                             "c4g"},
        {"application/vnd.ms-cab-compressed",                                         "cab"},
        {"application/vnd.curl.car",                                                  "car"},
        {"application/vnd.ms-pki.seccat",                                             "cat"},
        {"application/vnd.contact.cmsg",                                              "cdbcmsg"},
        {"application/vnd.mediastation.cdkey",                                        "cdkey"},
        {"application/cdmi-capability",                                               "cdmia"},
        {"application/cdmi-container",                                                "cdmic"},
        {"application/cdmi-domain",                                                   "cdmid"},
        {"application/cdmi-object",                                                   "cdmio"},
        {"application/cdmi-queue",                                                    "cdmiq"},
        {"chemical/x-cdx",                                                            "cdx"},
        {"application/vnd.chemdraw+xml",                                              "cdxml"},
        {"application/vnd.cinderella",                                                "cdy"},
        {"application/pkix-cert",                                                     "cer"},
        {"image/cgm",                                                                 "cgm"},
        {"application/x-chat",                                                        "chat"},
        {"application/vnd.ms-htmlhelp",                                               "chm"},
        {"application/vnd.kde.kchart",                                                "chrt"},
        {"chemical/x-cif",                                                            "cif"},
        {"application/vnd.anser-web-certificate-issue-initiation",                    "cii"},
        {"application/vnd.ms-artgalry",                                               "cil"},
        {"application/vnd.claymore",                                                  "cla"},
        {"application/java-vm",                                                       "class"},
        {"application/vnd.crick.clicker.keyboard",                                    "clkk"},
        {"application/vnd.crick.clicker.palette",                                     "clkp"},
        {"application/vnd.crick.clicker.template",                                    "clkt"},
        {"application/vnd.crick.clicker.wordbank",                                    "clkw"},
        {"application/vnd.crick.clicker",                                             "clkx"},
        {"application/x-msclip",                                                      "clp"},
        {"application/vnd.cosmocaller",                                               "cmc"},
        {"chemical/x-cmdf",                                                           "cmdf"},
        {"chemical/x-cml",                                                            "cml"},
        {"application/vnd.yellowriver-custom-menu",                                   "cmp"},
        {"image/x-cmx",                                                               "cmx"},
        {"application/vnd.rim.cod",                                                   "cod"},
        {"application/x-cpio",                                                        "cpio"},
        {"application/mac-compactpro",                                                "cpt"},
        {"application/x-mscardfile",                                                  "crd"},
        {"application/pkix-crl",                                                      "crl"},
        {"application/vnd.rig.cryptonote",                                            "cryptonote"},
        {"application/x-csh",                                                         "csh"},
        {"chemical/x-csml",                                                           "csml"},
        {"application/vnd.commonspace",                                               "csp"},
        {"text/css",                                                                  "css"},
        {"text/csv",                                                                  "csv"},
        {"application/cu-seeme",                                                      "cu"},
        {"text/vnd.curl",                                                             "curl"},
        {"application/prs.cww",                                                       "cww"},
        {"model/vnd.collada+xml",                                                     "dae"},
        {"application/vnd.mobius.daf",                                                "daf"},
        {"application/davmount+xml",                                                  "davmount"},
        {"text/vnd.curl.dcurl",                                                       "dcurl"},
        {"application/vnd.oma.dd2+xml",                                               "dd2"},
        {"application/vnd.fujixerox.ddd",                                             "ddd"},
        {"application/x-debian-package",                                              "deb"},
        {"application/x-x509-ca-cert",                                                "der"},
        {"application/vnd.dreamfactory",                                              "dfac"},
        {"application/x-director",                                                    "dir"},
        {"application/vnd.mobius.dis",                                                "dis"},
        {"image/vnd.djvu",                                                            "djvu"},
        {"application/x-apple-diskimage",                                             "dmg"},
        {"application/vnd.dna",                                                       "dna"},
        {"application/msword",                                                        "doc"},
        {"application/vnd.ms-word.document.macroenabled.12",                          "docm"},
        {"application/vnd.openxmlformats-officedocument.wordprocessingml.document",   "docx"},
        {"application/vnd.ms-word.template.macroenabled.12",                          "dotm"},
        {"application/vnd.openxmlformats-officedocument.wordprocessingml.template",   "dotx"},
        {"application/vnd.osgi.dp",                                                   "dp"},
        {"application/vnd.dpgraph",                                                   "dpg"},
        {"audio/vnd.dra",                                                             "dra"},
        {"text/prs.lines.tag",                                                        "dsc"},
        {"application/dssc+der",                                                      "dssc"},
        {"application/x-dtbook+xml",                                                  "dtb"},
        {"application/xml-dtd",                                                       "dtd"},
        {"audio/vnd.dts",                                                             "dts"},
        {"audio/vnd.dts.hd",                                                          "dtshd"},
        {"application/x-dvi",                                                         "dvi"},
        {"model/vnd.dwf",                                                             "dwf"},
        {"image/vnd.dwg",                                                             "dwg"},
        {"image/vnd.dxf",                                                             "dxf"},
        {"application/vnd.spotfire.dxp",                                              "dxp"},
        {"audio/vnd.nuera.ecelp4800",                                                 "ecelp4800"},
        {"audio/vnd.nuera.ecelp7470",                                                 "ecelp7470"},
        {"audio/vnd.nuera.ecelp9600",                                                 "ecelp9600"},
        {"application/vnd.novadigm.edm",                                              "edm"},
        {"application/vnd.novadigm.edx",                                              "edx"},
        {"application/vnd.picsel",                                                    "efif"},
        {"application/vnd.pg.osasli",                                                 "ei6"},
        {"message/rfc822",                                                            "eml"},
        {"application/emma+xml",                                                      "emma"},
        {"audio/vnd.digital-winds",                                                   "eol"},
        {"application/vnd.ms-fontobject",                                             "eot"},
        {"application/epub+zip",                                                      "epub"},
        {"application/ecmascript",                                                    "es"},
        {"application/vnd.eszigno3+xml",                                              "es3"},
        {"application/vnd.epson.esf",                                                 "esf"},
        {"text/x-setext",                                                             "etx"},
        {"application/x-msdownload",                                                  "exe"},
        {"application/exi",                                                           "exi"},
        {"application/vnd.novadigm.ext",                                              "ext"},
        {"application/vnd.ezpix-album",                                               "ez2"},
        {"application/vnd.ezpix-package",                                             "ez3"},
        {"text/x-fortran",                                                            "f"},
        {"video/x-f4v",                                                               "f4v"},
        {"image/vnd.fastbidsheet",                                                    "fbs"},
        {"application/vnd.isac.fcs",                                                  "fcs"},
        {"application/vnd.fdf",                                                       "fdf"},
        {"application/vnd.denovo.fcselayout-link",                                    "fe_launch"},
        {"application/vnd.fujitsu.oasysgp",                                           "fg5"},
        {"image/x-freehand",                                                          "fh"},
        {"application/x-xfig",                                                        "fig"},
        {"video/x-fli",                                                               "fli"},
        {"application/vnd.micrografx.flo",                                            "flo"},
        {"video/x-flv",                                                               "flv"},
        {"application/vnd.kde.kivio",                                                 "flw"},
        {"text/vnd.fmi.flexstor",                                                     "flx"},
        {"text/vnd.fly",                                                              "fly"},
        {"application/vnd.framemaker",                                                "fm"},
        {"application/vnd.frogans.fnc",                                               "fnc"},
        {"image/vnd.fpx",                                                             "fpx"},
        {"application/vnd.fsc.weblaunch",                                             "fsc"},
        {"image/vnd.fst",                                                             "fst"},
        {"application/vnd.fluxtime.clip",                                             "ftc"},
        {"application/vnd.anser-web-funds-transfer-initiation",                       "fti"},
        {"video/vnd.fvt",                                                             "fvt"},
        {"application/vnd.adobe.fxp",                                                 "fxp"},
        {"application/vnd.fuzzysheet",                                                "fzs"},
        {"application/vnd.geoplan",                                                   "g2w"},
        {"image/g3fax",                                                               "g3"},
        {"application/vnd.geospace",                                                  "g3w"},
        {"application/vnd.groove-account",                                            "gac"},
        {"model/vnd.gdl",                                                             "gdl"},
        {"application/vnd.dynageo",                                                   "geo"},
        {"application/vnd.geometry-explorer",                                         "gex"},
        {"application/vnd.geogebra.file",                                             "ggb"},
        {"application/vnd.geogebra.tool",                                             "ggt"},
        {"application/vnd.groove-help",                                               "ghf"},
        {"image/gif",                                                                 "gif"},
        {"application/vnd.groove-identity-message",                                   "gim"},
        {"application/vnd.gmx",                                                       "gmx"},
        {"application/x-gnumeric",                                                    "gnumeric"},
        {"application/vnd.flographit",                                                "gph"},
        {"application/vnd.grafeq",                                                    "gqf"},
        {"application/srgs",                                                          "gram"},
        {"application/vnd.groove-injector",                                           "grv"},
        {"application/srgs+xml",                                                      "grxml"},
        {"application/x-font-ghostscript",                                            "gsf"},
        {"application/x-gtar",                                                        "gtar"},
        {"application/vnd.groove-tool-message",                                       "gtm"},
        {"model/vnd.gtw",                                                             "gtw"},
        {"text/vnd.graphviz",                                                         "gv"},
        {"application/vnd.geonext",                                                   "gxt"},
        {"video/h261",                                                                "h261"},
        {"video/h263",                                                                "h263"},
        {"video/h264",                                                                "h264"},
        {"application/vnd.hal+xml",                                                   "hal"},
        {"application/vnd.hbci",                                                      "hbci"},
        {"application/x-hdf",                                                         "hdf"},
        {"application/winhlp",                                                        "hlp"},
        {"application/vnd.hp-hpgl",                                                   "hpgl"},
        {"application/vnd.hp-hpid",                                                   "hpid"},
        {"application/vnd.hp-hps",                                                    "hps"},
        {"application/mac-binhex40",                                                  "hqx"},
        {"application/vnd.kenameaapp",                                                "htke"},
        {"text/html",                                                                 "html"},
        {"application/vnd.yamaha.hv-dic",                                             "hvd"},
        {"application/vnd.yamaha.hv-voice",                                           "hvp"},
        {"application/vnd.yamaha.hv-script",                                          "hvs"},
        {"application/vnd.intergeo",                                                  "i2g"},
        {"application/vnd.iccprofile",                                                "icc"},
        {"x-conference/x-cooltalk",                                                   "ice"},
        {"image/x-icon",                                                              "ico"},
        {"text/calendar",                                                             "ics"},
        {"image/ief",                                                                 "ief"},
        {"application/vnd.shana.informed.formdata",                                   "ifm"},
        {"application/vnd.igloader",                                                  "igl"},
        {"application/vnd.insors.igm",                                                "igm"},
        {"model/iges",                                                                "igs"},
        {"application/vnd.micrografx.igx",                                            "igx"},
        {"application/vnd.shana.informed.interchange",                                "iif"},
        {"application/vnd.accpac.simply.imp",                                         "imp"},
        {"application/vnd.ms-ims",                                                    "ims"},
        {"application/ipfix",                                                         "ipfix"},
        {"application/vnd.shana.informed.package",                                    "ipk"},
        {"application/vnd.ibm.rights-management",                                     "irm"},
        {"application/vnd.irepository.package+xml",                                   "irp"},
        {"application/vnd.shana.informed.formtemplate",                               "itp"},
        {"application/vnd.immervision-ivp",                                           "ivp"},
        {"application/vnd.immervision-ivu",                                           "ivu"},
        {"text/vnd.sun.j2me.app-descriptor",                                          "jad"},
        {"application/vnd.jam",                                                       "jam"},
        {"application/java-archive",                                                  "jar"},
        {"text/x-java-source",                                                        "java"},
        {"application/vnd.jisp",                                                      "jisp"},
        {"application/vnd.hp-jlyt",                                                   "jlt"},
        {"application/x-java-jnlp-file",                                              "jnlp"},
        {"application/vnd.joost.joda-archive",                                        "joda"},
        {"image/jpeg",                                                                "jpeg"},
        {"video/jpeg",                                                                "jpgv"},
        {"video/jpm",                                                                 "jpm"},
        {"application/javascript",                                                    "js"},
        {"application/json",                                                          "json"},
        {"application/vnd.kde.karbon",                                                "karbon"},
        {"application/vnd.kde.kformula",                                              "kfo"},
        {"application/vnd.kidspiration",                                              "kia"},
        {"application/vnd.google-earth.kml+xml",                                      "kml"},
        {"application/vnd.google-earth.kmz",                                          "kmz"},
        {"application/vnd.kinar",                                                     "kne"},
        {"application/vnd.kde.kontour",                                               "kon"},
        {"application/vnd.kde.kpresenter",                                            "kpr"},
        {"application/vnd.kde.kspread",                                               "ksp"},
        {"image/ktx",                                                                 "ktx"},
        {"application/vnd.kahootz",                                                   "ktz"},
        {"application/vnd.kde.kword",                                                 "kwd"},
        {"application/vnd.las.las+xml",                                               "lasxml"},
        {"application/x-latex",                                                       "latex"},
        {"application/vnd.llamagraphics.life-balance.desktop",                        "lbd"},
        {"application/vnd.llamagraphics.life-balance.exchange+xml",                   "lbe"},
        {"application/vnd.hhe.lesson-player",                                         "les"},
        {"application/vnd.route66.link66+xml",                                        "link66"},
        {"application/vnd.ms-lrm",                                                    "lrm"},
        {"application/vnd.frogans.ltf",                                               "ltf"},
        {"audio/vnd.lucent.voice",                                                    "lvp"},
        {"application/vnd.lotus-wordpro",                                             "lwp"},
        {"application/mp21",                                                          "m21"},
        {"audio/x-mpegurl",                                                           "m3u"},
        {"application/vnd.apple.mpegurl",                                             "m3u8"},
        {"video/x-m4v",                                                               "m4v"},
        {"application/mathematica",                                                   "ma"},
        {"application/mads+xml",                                                      "mads"},
        {"application/vnd.ecowin.chart",                                              "mag"},
        {"application/mathml+xml",                                                    "mathml"},
        {"application/vnd.mobius.mbk",                                                "mbk"},
        {"application/mbox",                                                          "mbox"},
        {"application/vnd.medcalcdata",                                               "mc1"},
        {"application/vnd.mcd",                                                       "mcd"},
        {"text/vnd.curl.mcurl",                                                       "mcurl"},
        {"application/x-msaccess",                                                    "mdb"},
        {"image/vnd.ms-modi",                                                         "mdi"},
        {"application/metalink4+xml",                                                 "meta4"},
        {"application/mets+xml",                                                      "mets"},
        {"application/vnd.mfmp",                                                      "mfm"},
        {"application/vnd.osgeo.mapguide.package",                                    "mgp"},
        {"application/vnd.proteus.magazine",                                          "mgz"},
        {"audio/midi",                                                                "mid"},
        {"application/vnd.mif",                                                       "mif"},
        {"video/mj2",                                                                 "mj2"},
        {"application/vnd.dolby.mlp",                                                 "mlp"},
        {"application/vnd.chipnuts.karaoke-mmd",                                      "mmd"},
        {"application/vnd.smaf",                                                      "mmf"},
        {"image/vnd.fujixerox.edmics-mmr",                                            "mmr"},
        {"application/x-msmoney",                                                     "mny"},
        {"application/mods+xml",                                                      "mods"},
        {"video/x-sgi-movie",                                                         "movie"},
        {"application/mp4",                                                           "mp4"},
        {"application/vnd.mophun.certificate",                                        "mpc"},
        {"video/mpeg",                                                                "mpeg"},
        {"audio/mpeg",                                                                "mpga"},
        {"application/vnd.apple.installer+xml",                                       "mpkg"},
        {"application/vnd.blueice.multipass",                                         "mpm"},
        {"application/vnd.mophun.application",                                        "mpn"},
        {"application/vnd.ms-project",                                                "mpp"},
        {"application/vnd.ibm.minipay",                                               "mpy"},
        {"application/vnd.mobius.mqy",                                                "mqy"},
        {"application/marc",                                                          "mrc"},
        {"application/marcxml+xml",                                                   "mrcx"},
        {"application/mediaservercontrol+xml",                                        "mscml"},
        {"application/vnd.mseq",                                                      "mseq"},
        {"application/vnd.epson.msf",                                                 "msf"},
        {"model/mesh",                                                                "msh"},
        {"application/vnd.mobius.msl",                                                "msl"},
        {"application/vnd.muvee.style",                                               "msty"},
        {"model/vnd.mts",                                                             "mts"},
        {"application/vnd.musician",                                                  "mus"},
        {"application/vnd.recordare.musicxml+xml",                                    "musicxml"},
        {"application/x-msmediaview",                                                 "mvb"},
        {"application/vnd.mfer",                                                      "mwf"},
        {"application/mxf",                                                           "mxf"},
        {"application/vnd.recordare.musicxml",                                        "mxl"},
        {"application/xv+xml",                                                        "mxml"},
        {"application/vnd.triscape.mxs",                                              "mxs"},
        {"video/vnd.mpegurl",                                                         "mxu"},
        {"application/vnd.nokia.n-gage.symbian.install",                              "n-gage"},
        {"text/n3",                                                                   "n3"},
        {"application/vnd.wolfram.player",                                            "nbp"},
        {"application/x-netcdf",                                                      "nc"},
        {"application/x-dtbncx+xml",                                                  "ncx"},
        {"application/vnd.nokia.n-gage.data",                                         "ngdat"},
        {"application/vnd.neurolanguage.nlu",                                         "nlu"},
        {"application/vnd.enliven",                                                   "nml"},
        {"application/vnd.noblenet-directory",                                        "nnd"},
        {"application/vnd.noblenet-sealer",                                           "nns"},
        {"application/vnd.noblenet-web",                                              "nnw"},
        {"image/vnd.net-fpx",                                                         "npx"},
        {"application/vnd.lotus-notes",                                               "nsf"},
        {"application/vnd.fujitsu.oasys2",                                            "oa2"},
        {"application/vnd.fujitsu.oasys3",                                            "oa3"},
        {"application/vnd.fujitsu.oasys",                                             "oas"},
        {"application/x-msbinder",                                                    "obd"},
        {"application/oda",                                                           "oda"},
        {"application/vnd.oasis.opendocument.database",                               "odb"},
        {"application/vnd.oasis.opendocument.chart",                                  "odc"},
        {"application/vnd.oasis.opendocument.formula",                                "odf"},
        {"application/vnd.oasis.opendocument.formula-template",                       "odft"},
        {"application/vnd.oasis.opendocument.graphics",                               "odg"},
        {"application/vnd.oasis.opendocument.image",                                  "odi"},
        {"application/vnd.oasis.opendocument.text-master",                            "odm"},
        {"application/vnd.oasis.opendocument.presentation",                           "odp"},
        {"application/vnd.oasis.opendocument.spreadsheet",                            "ods"},
        {"application/vnd.oasis.opendocument.text",                                   "odt"},
        {"audio/ogg",                                                                 "oga"},
        {"video/ogg",                                                                 "ogv"},
        {"application/ogg",                                                           "ogx"},
        {"application/onenote",                                                       "onetoc"},
        {"application/oebps-package+xml",                                             "opf"},
        {"application/vnd.lotus-organizer",                                           "org"},
        {"application/vnd.yamaha.openscoreformat",                                    "osf"},
        {"application/vnd.yamaha.openscoreformat.osfpvg+xml",                         "osfpvg"},
        {"application/vnd.oasis.opendocument.chart-template",                         "otc"},
        {"application/x-font-otf",                                                    "otf"},
        {"application/vnd.oasis.opendocument.graphics-template",                      "otg"},
        {"application/vnd.oasis.opendocument.text-web",                               "oth"},
        {"application/vnd.oasis.opendocument.image-template",                         "oti"},
        {"application/vnd.oasis.opendocument.presentation-template",                  "otp"},
        {"application/vnd.oasis.opendocument.spreadsheet-template",                   "ots"},
        {"application/vnd.oasis.opendocument.text-template",                          "ott"},
        {"application/vnd.openofficeorg.extension",                                   "oxt"},
        {"text/x-pascal",                                                             "p"},
        {"application/pkcs10",                                                        "p10"},
        {"application/x-pkcs12",                                                      "p12"},
        {"application/x-pkcs7-certificates",                                          "p7b"},
        {"application/pkcs7-mime",                                                    "p7m"},
        {"application/x-pkcs7-certreqresp",                                           "p7r"},
        {"application/pkcs7-signature",                                               "p7s"},
        {"application/pkcs8",                                                         "p8"},
        {"text/plain-bas",                                                            "par"},
        {"application/vnd.pawaafile",                                                 "paw"},
        {"application/vnd.powerbuilder6",                                             "pbd"},
        {"image/x-portable-bitmap",                                                   "pbm"},
        {"application/x-font-pcf",                                                    "pcf"},
        {"application/vnd.hp-pcl",                                                    "pcl"},
        {"application/vnd.hp-pclxl",                                                  "pclxl"},
        {"application/vnd.curl.pcurl",                                                "pcurl"},
        {"image/x-pcx",                                                               "pcx"},
        {"application/vnd.palm",                                                      "pdb"},
        {"application/pdf",                                                           "pdf"},
        {"application/x-font-type1",                                                  "pfa"},
        {"application/font-tdpfr",                                                    "pfr"},
        {"image/x-portable-graymap",                                                  "pgm"},
        {"application/x-chess-pgn",                                                   "pgn"},
        {"application/pgp-encrypted",                                                 "pgp"},
        {"image/x-pict",                                                              "pic"},
        {"image/pjpeg",                                                               "pjpeg"},
        {"application/pkixcmp",                                                       "pki"},
        {"application/pkix-pkipath",                                                  "pkipath"},
        {"application/vnd.3gpp.pic-bw-large",                                         "plb"},
        {"application/vnd.mobius.plc",                                                "plc"},
        {"application/vnd.pocketlearn",                                               "plf"},
        {"application/pls+xml",                                                       "pls"},
        {"application/vnd.ctc-posml",                                                 "pml"},
        {"image/png",                                                                 "png"},
        {"image/x-portable-anymap",                                                   "pnm"},
        {"application/vnd.macports.portpkg",                                          "portpkg"},
        {"application/vnd.ms-powerpoint.template.macroenabled.12",                    "potm"},
        {"application/vnd.openxmlformats-officedocument.presentationml.template",     "potx"},
        {"application/vnd.ms-powerpoint.addin.macroenabled.12",                       "ppam"},
        {"application/vnd.cups-ppd",                                                  "ppd"},
        {"image/x-portable-pixmap",                                                   "ppm"},
        {"application/vnd.ms-powerpoint.slideshow.macroenabled.12",                   "ppsm"},
        {"application/vnd.openxmlformats-officedocument.presentationml.slideshow",    "ppsx"},
        {"application/vnd.ms-powerpoint",                                             "ppt"},
        {"application/vnd.ms-powerpoint.presentation.macroenabled.12",                "pptm"},
        {"application/vnd.openxmlformats-officedocument.presentationml.presentation", "pptx"},
        {"application/x-mobipocket-ebook",                                            "prc"},
        {"application/vnd.lotus-freelance",                                           "pre"},
        {"application/pics-rules",                                                    "prf"},
        {"application/vnd.3gpp.pic-bw-small",                                         "psb"},
        {"image/vnd.adobe.photoshop",                                                 "psd"},
        {"application/x-font-linux-psf",                                              "psf"},
        {"application/pskc+xml",                                                      "pskcxml"},
        {"application/vnd.pvi.ptid1",                                                 "ptid"},
        {"application/x-mspublisher",                                                 "pub"},
        {"application/vnd.3gpp.pic-bw-var",                                           "pvb"},
        {"application/vnd.3m.post-it-notes",                                          "pwn"},
        {"audio/vnd.ms-playready.media.pya",                                          "pya"},
        {"video/vnd.ms-playready.media.pyv",                                          "pyv"},
        {"application/vnd.epson.quickanime",                                          "qam"},
        {"application/vnd.intu.qbo",                                                  "qbo"},
        {"application/vnd.intu.qfx",                                                  "qfx"},
        {"application/vnd.publishare-delta-tree",                                     "qps"},
        {"video/quicktime",                                                           "qt"},
        {"application/vnd.quark.quarkxpress",                                         "qxd"},
        {"audio/x-pn-realaudio",                                                      "ram"},
        {"application/x-rar-compressed",                                              "rar"},
        {"image/x-cmu-raster",                                                        "ras"},
        {"application/vnd.ipunplugged.rcprofile",                                     "rcprofile"},
        {"application/rdf+xml",                                                       "rdf"},
        {"application/vnd.data-vision.rdz",                                           "rdz"},
        {"application/vnd.businessobjects",                                           "rep"},
        {"application/x-dtbresource+xml",                                             "res"},
        {"image/x-rgb",                                                               "rgb"},
        {"application/reginfo+xml",                                                   "rif"},
        {"audio/vnd.rip",                                                             "rip"},
        {"application/resource-lists+xml",                                            "rl"},
        {"image/vnd.fujixerox.edmics-rlc",                                            "rlc"},
        {"application/resource-lists-diff+xml",                                       "rld"},
        {"application/vnd.rn-realmedia",                                              "rm"},
        {"audio/x-pn-realaudio-plugin",                                               "rmp"},
        {"application/vnd.jcp.javame.midlet-rms",                                     "rms"},
        {"application/relax-ng-compact-syntax",                                       "rnc"},
        {"application/vnd.cloanto.rp9",                                               "rp9"},
        {"application/vnd.nokia.radio-presets",                                       "rpss"},
        {"application/vnd.nokia.radio-preset",                                        "rpst"},
        {"application/sparql-query",                                                  "rq"},
        {"application/rls-services+xml",                                              "rs"},
        {"application/rsd+xml",                                                       "rsd"},
        {"application/rss+xml",                                                       "rss"},
        {"application/rtf",                                                           "rtf"},
        {"text/richtext",                                                             "rtx"},
        {"text/x-asm",                                                                "s"},
        {"application/vnd.yamaha.smaf-audio",                                         "saf"},
        {"application/sbml+xml",                                                      "sbml"},
        {"application/vnd.ibm.secure-container",                                      "sc"},
        {"application/x-msschedule",                                                  "scd"},
        {"application/vnd.lotus-screencam",                                           "scm"},
        {"application/scvp-cv-request",                                               "scq"},
        {"application/scvp-cv-response",                                              "scs"},
        {"text/vnd.curl.scurl",                                                       "scurl"},
        {"application/vnd.stardivision.draw",                                         "sda"},
        {"application/vnd.stardivision.calc",                                         "sdc"},
        {"application/vnd.stardivision.impress",                                      "sdd"},
        {"application/vnd.solent.sdkm+xml",                                           "sdkm"},
        {"application/sdp",                                                           "sdp"},
        {"application/vnd.stardivision.writer",                                       "sdw"},
        {"application/vnd.seemail",                                                   "see"},
        {"application/vnd.fdsn.seed",                                                 "seed"},
        {"application/vnd.sema",                                                      "sema"},
        {"application/vnd.semd",                                                      "semd"},
        {"application/vnd.semf",                                                      "semf"},
        {"application/java-serialized-object",                                        "ser"},
        {"application/set-payment-initiation",                                        "setpay"},
        {"application/set-registration-initiation",                                   "setreg"},
        {"application/vnd.hydrostatix.sof-data",                                      "sfd-hdstx"},
        {"application/vnd.spotfire.sfs",                                              "sfs"},
        {"application/vnd.stardivision.writer-global",                                "sgl"},
        {"text/sgml",                                                                 "sgml"},
        {"application/x-sh",                                                          "sh"},
        {"application/x-shar",                                                        "shar"},
        {"application/shf+xml",                                                       "shf"},
        {"application/vnd.symbian.install",                                           "sis"},
        {"application/x-stuffit",                                                     "sit"},
        {"application/x-stuffitx",                                                    "sitx"},
        {"application/vnd.koan",                                                      "skp"},
        {"application/vnd.ms-powerpoint.slide.macroenabled.12",                       "sldm"},
        {"application/vnd.openxmlformats-officedocument.presentationml.slide",        "sldx"},
        {"application/vnd.epson.salt",                                                "slt"},
        {"application/vnd.stepmania.stepchart",                                       "sm"},
        {"application/vnd.stardivision.math",                                         "smf"},
        {"application/smil+xml",                                                      "smi"},
        {"application/x-font-snf",                                                    "snf"},
        {"application/vnd.yamaha.smaf-phrase",                                        "spf"},
        {"application/x-futuresplash",                                                "spl"},
        {"text/vnd.in3d.spot",                                                        "spot"},
        {"application/scvp-vp-response",                                              "spp"},
        {"application/scvp-vp-request",                                               "spq"},
        {"application/x-wais-source",                                                 "src"},
        {"application/sru+xml",                                                       "sru"},
        {"application/sparql-results+xml",                                            "srx"},
        {"application/vnd.kodak-descriptor",                                          "sse"},
        {"application/vnd.epson.ssf",                                                 "ssf"},
        {"application/ssml+xml",                                                      "ssml"},
        {"application/vnd.sailingtracker.track",                                      "st"},
        {"application/vnd.sun.xml.calc.template",                                     "stc"},
        {"application/vnd.sun.xml.draw.template",                                     "std"},
        {"application/vnd.wt.stf",                                                    "stf"},
        {"application/vnd.sun.xml.impress.template",                                  "sti"},
        {"application/hyperstudio",                                                   "stk"},
        {"application/vnd.ms-pki.stl",                                                "stl"},
        {"application/vnd.pg.format",                                                 "str"},
        {"application/vnd.sun.xml.writer.template",                                   "stw"},
        {"image/vnd.dvb.subtitle",                                                    "sub"},
        {"application/vnd.sus-calendar",                                              "sus"},
        {"application/x-sv4cpio",                                                     "sv4cpio"},
        {"application/x-sv4crc",                                                      "sv4crc"},
        {"application/vnd.dvb.service",                                               "svc"},
        {"application/vnd.svd",                                                       "svd"},
        {"image/svg+xml",                                                             "svg"},
        {"application/x-shockwave-flash",                                             "swf"},
        {"application/vnd.aristanetworks.swi",                                        "swi"},
        {"application/vnd.sun.xml.calc",                                              "sxc"},
        {"application/vnd.sun.xml.draw",                                              "sxd"},
        {"application/vnd.sun.xml.writer.global",                                     "sxg"},
        {"application/vnd.sun.xml.impress",                                           "sxi"},
        {"application/vnd.sun.xml.math",                                              "sxm"},
        {"application/vnd.sun.xml.writer",                                            "sxw"},
        {"text/troff",                                                                "t"},
        {"application/vnd.tao.intent-module-archive",                                 "tao"},
        {"application/x-tar",                                                         "tar"},
        {"application/vnd.3gpp2.tcap",                                                "tcap"},
        {"application/x-tcl",                                                         "tcl"},
        {"application/vnd.smart.teacher",                                             "teacher"},
        {"application/tei+xml",                                                       "tei"},
        {"application/x-tex",                                                         "tex"},
        {"application/x-texinfo",                                                     "texinfo"},
        {"application/thraud+xml",                                                    "tfi"},
        {"application/x-tex-tfm",                                                     "tfm"},
        {"application/vnd.ms-officetheme",                                            "thmx"},
        {"image/tiff",                                                                "tiff"},
        {"application/vnd.tmobile-livetv",                                            "tmo"},
        {"application/x-bittorrent",                                                  "torrent"},
        {"application/vnd.groove-tool-template",                                      "tpl"},
        {"application/vnd.trid.tpt",                                                  "tpt"},
        {"application/vnd.trueapp",                                                   "tra"},
        {"application/x-msterminal",                                                  "trm"},
        {"application/timestamped-data",                                              "tsd"},
        {"text/tab-separated-values",                                                 "tsv"},
        {"application/x-font-ttf",                                                    "ttf"},
        {"text/turtle",                                                               "ttl"},
        {"application/vnd.simtech-mindmapper",                                        "twd"},
        {"application/vnd.genomatix.tuxedo",                                          "txd"},
        {"application/vnd.mobius.txf",                                                "txf"},
        {"text/plain",                                                                "txt"},
        {"application/vnd.ufdl",                                                      "ufd"},
        {"application/vnd.umajin",                                                    "umj"},
        {"application/vnd.unity",                                                     "unityweb"},
        {"application/vnd.uoml+xml",                                                  "uoml"},
        {"text/uri-list",                                                             "uri"},
        {"application/x-ustar",                                                       "ustar"},
        {"application/vnd.uiq.theme",                                                 "utz"},
        {"text/x-uuencode",                                                           "uu"},
        {"audio/vnd.dece.audio",                                                      "uva"},
        {"video/vnd.dece.hd",                                                         "uvh"},
        {"image/vnd.dece.graphic",                                                    "uvi"},
        {"video/vnd.dece.mobile",                                                     "uvm"},
        {"video/vnd.dece.pd",                                                         "uvp"},
        {"video/vnd.dece.sd",                                                         "uvs"},
        {"video/vnd.uvvu.mp4",                                                        "uvu"},
        {"video/vnd.dece.video",                                                      "uvv"},
        {"application/x-cdlink",                                                      "vcd"},
        {"text/x-vcard",                                                              "vcf"},
        {"application/vnd.groove-vcard",                                              "vcg"},
        {"text/x-vcalendar",                                                          "vcs"},
        {"application/vnd.vcx",                                                       "vcx"},
        {"application/vnd.visionary",                                                 "vis"},
        {"video/vnd.vivo",                                                            "viv"},
        {"application/vnd.visio",                                                     "vsd"},
        {"application/vnd.visio2013",                                                 "vsdx"},
        {"application/vnd.vsf",                                                       "vsf"},
        {"model/vnd.vtu",                                                             "vtu"},
        {"application/voicexml+xml",                                                  "vxml"},
        {"application/x-doom",                                                        "wad"},
        {"audio/x-wav",                                                               "wav"},
        {"audio/x-ms-wax",                                                            "wax"},
        {"image/vnd.wap.wbmp",                                                        "wbmp"},
        {"application/vnd.criticaltools.wbs+xml",                                     "wbs"},
        {"application/vnd.wap.wbxml",                                                 "wbxml"},
        {"audio/webm",                                                                "weba"},
        {"video/webm",                                                                "webm"},
        {"image/webp",                                                                "webp"},
        {"application/vnd.pmi.widget",                                                "wg"},
        {"application/widget",                                                        "wgt"},
        {"video/x-ms-wm",                                                             "wm"},
        {"audio/x-ms-wma",                                                            "wma"},
        {"application/x-ms-wmd",                                                      "wmd"},
        {"application/x-msmetafile",                                                  "wmf"},
        {"text/vnd.wap.wml",                                                          "wml"},
        {"application/vnd.wap.wmlc",                                                  "wmlc"},
        {"text/vnd.wap.wmlscript",                                                    "wmls"},
        {"application/vnd.wap.wmlscriptc",                                            "wmlsc"},
        {"video/x-ms-wmv",                                                            "wmv"},
        {"video/x-ms-wmx",                                                            "wmx"},
        {"application/x-ms-wmz",                                                      "wmz"},
        {"application/x-font-woff",                                                   "woff"},
        {"application/vnd.wordperfect",                                               "wpd"},
        {"application/vnd.ms-wpl",                                                    "wpl"},
        {"application/vnd.ms-works",                                                  "wps"},
        {"application/vnd.wqd",                                                       "wqd"},
        {"application/x-mswrite",                                                     "wri"},
        {"model/vrml",                                                                "wrl"},
        {"application/wsdl+xml",                                                      "wsdl"},
        {"application/wspolicy+xml",                                                  "wspolicy"},
        {"application/vnd.webturbo",                                                  "wtb"},
        {"video/x-ms-wvx",                                                            "wvx"},
        {"application/vnd.hzn-3d-crossword",                                          "x3d"},
        {"application/x-silverlight-app",                                             "xap"},
        {"application/vnd.xara",                                                      "xar"},
        {"application/x-ms-xbap",                                                     "xbap"},
        {"application/vnd.fujixerox.docuworks.binder",                                "xbd"},
        {"image/x-xbitmap",                                                           "xbm"},
        {"application/xcap-diff+xml",                                                 "xdf"},
        {"application/vnd.syncml.dm+xml",                                             "xdm"},
        {"application/vnd.adobe.xdp+xml",                                             "xdp"},
        {"application/dssc+xml",                                                      "xdssc"},
        {"application/vnd.fujixerox.docuworks",                                       "xdw"},
        {"application/xenc+xml",                                                      "xenc"},
        {"application/patch-ops-ERROR+xml",                                           "xer"},
        {"application/vnd.adobe.xfdf",                                                "xfdf"},
        {"application/vnd.xfdl",                                                      "xfdl"},
        {"application/xhtml+xml",                                                     "xhtml"},
        {"image/vnd.xiff",                                                            "xif"},
        {"application/vnd.ms-excel.addin.macroenabled.12",                            "xlam"},
        {"application/vnd.ms-excel",                                                  "xls"},
        {"application/vnd.ms-excel.sheet.binary.macroenabled.12",                     "xlsb"},
        {"application/vnd.ms-excel.sheet.macroenabled.12",                            "xlsm"},
        {"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",         "xlsx"},
        {"application/vnd.ms-excel.template.macroenabled.12",                         "xltm"},
        {"application/vnd.openxmlformats-officedocument.spreadsheetml.template",      "xltx"},
        {"application/xml",                                                           "xml"},
        {"application/vnd.olpc-sugar",                                                "xo"},
        {"application/xop+xml",                                                       "xop"},
        {"application/x-xpinstall",                                                   "xpi"},
        {"image/x-xpixmap",                                                           "xpm"},
        {"application/vnd.is-xpr",                                                    "xpr"},
        {"application/vnd.ms-xpsdocument",                                            "xps"},
        {"application/vnd.intercon.formnet",                                          "xpw"},
        {"application/xslt+xml",                                                      "xslt"},
        {"application/vnd.syncml+xml",                                                "xsm"},
        {"application/xspf+xml",                                                      "xspf"},
        {"application/vnd.mozilla.xul+xml",                                           "xul"},
        {"image/x-xwindowdump",                                                       "xwd"},
        {"chemical/x-xyz",                                                            "xyz"},
        {"text/yaml",                                                                 "yaml"},
        {"application/yang",                                                          "yang"},
        {"application/yin+xml",                                                       "yin"},
        {"application/vnd.zzazz.deck+xml",                                            "zaz"},
        {"application/zip",                                                           "zip"},
        {"application/vnd.zul",                                                       "zir"},
        {"application/vnd.handheld-entertainment+xml",                                "zmm"},
};

static const u32 _global_mime_type_register = (u32) ARRAY_LENGTH(global_mime_type_register);

bool carbon_media_write(memfile *dst, carbon_field_type_e type);

/**
 * Returns the mime type identifier for a file extension <code>ext</code>. If <code>ext</code> is not known,
 * the mime type application/octet-stream (.bin) is returned.
 */
u32 carbon_media_mime_type_by_ext(const char *ext);

/**
 * Returns a human readable string_buffer representing the mime type for the mime type identifier <code>id</code>.
 * In case <code>id</code> is invalid, the mime type application/octet-stream is returned.
 */
const char *carbon_media_mime_type_by_id(u32 id);

/**
 * Returns the file extension for the mime type identifier <code>id</code>.
 * In case <code>id</code> is invalid, the file extension "bin" is returned.
 */
const char *carbon_media_mime_ext_by_id(u32 id);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_OBJECT_IT_H
#define CARBON_OBJECT_IT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <memfile.h>
#include <jakson/carbon/field.h>
#include <jakson/carbon/array_it.h>

BEGIN_DECL

typedef struct carbon_object_it {
        memfile memfile;
        err err;

        offset_t object_contents_off;
        bool object_end_reached;

        vector ofType(offset_t) history;

        struct {
                struct {
                        offset_t offset;
                        const char *name;
                        u64 name_len;
                } key;
                struct {
                        offset_t offset;
                        field_access data;
                } value;
        } field;

        spinlock lock;
        /* in case of modifications (updates, inserts, deletes), the number of bytes that are added resp. removed */
        i64 mod_size;
} carbon_object_it;

bool carbon_object_it_create(carbon_object_it *it, memfile *memfile, err *err, offset_t payload_start);
bool carbon_object_it_copy(carbon_object_it *dst, carbon_object_it *src);
bool carbon_object_it_clone(carbon_object_it *dst, carbon_object_it *src);
bool carbon_object_it_drop(carbon_object_it *it);

bool carbon_object_it_rewind(carbon_object_it *it);
bool carbon_object_it_next(carbon_object_it *it);
bool carbon_object_it_has_next(carbon_object_it *it);
bool carbon_object_it_fast_forward(carbon_object_it *it);
bool carbon_object_it_prev(carbon_object_it *it);

offset_t carbon_object_it_memfile_pos(carbon_object_it *it);
bool carbon_object_it_tell(offset_t *key_off, offset_t *value_off, carbon_object_it *it);

const char *carbon_object_it_prop_name(u64 *key_len, carbon_object_it *it);
bool carbon_object_it_remove(carbon_object_it *it);
bool carbon_object_it_prop_type(carbon_field_type_e *type, carbon_object_it *it);

bool carbon_object_it_insert_begin(carbon_insert *inserter, carbon_object_it *it);
bool carbon_object_it_insert_end(carbon_insert *inserter);

bool carbon_object_it_lock(carbon_object_it *it);
bool carbon_object_it_unlock(carbon_object_it *it);

bool carbon_object_it_u8_value(u8 *value, carbon_object_it *it);
bool carbon_object_it_u16_value(u16 *value, carbon_object_it *it);
bool carbon_object_it_u32_value(u32 *value, carbon_object_it *it);
bool carbon_object_it_u64_value(u64 *value, carbon_object_it *it);
bool carbon_object_it_i8_value(i8 *value, carbon_object_it *it);
bool carbon_object_it_i16_value(i16 *value, carbon_object_it *it);
bool carbon_object_it_i32_value(i32 *value, carbon_object_it *it);
bool carbon_object_it_i64_value(i64 *value, carbon_object_it *it);
bool carbon_object_it_float_value(bool *is_null_in, float *value, carbon_object_it *it);
bool carbon_object_it_signed_value(bool *is_null_in, i64 *value, carbon_object_it *it);
bool carbon_object_it_unsigned_value(bool *is_null_in, u64 *value, carbon_object_it *it);
const char *carbon_object_it_string_value(u64 *strlen, carbon_object_it *it);
bool carbon_object_it_binary_value(carbon_binary *out, carbon_object_it *it);
carbon_array_it *carbon_object_it_array_value(carbon_object_it *it_in);
carbon_object_it *carbon_object_it_object_value(carbon_object_it *it_in);
carbon_column_it *carbon_object_it_column_value(carbon_object_it *it_in);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_PATH_H
#define CARBON_PATH_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/carbon/dot.h>

BEGIN_DECL

typedef struct carbon_path_evaluator {
        carbon *doc;
        carbon_array_it root_it;
        carbon_path_status_e status;
        err err;
        struct {
                carbon_container_e container_type;
                union {
                        struct {
                                carbon_array_it it;
                        } array;

                        struct {
                                carbon_object_it it;
                        } object;

                        struct {
                                carbon_column_it it;
                                u32 elem_pos;
                        } column;

                } containers;
        } result;
} carbon_path_evaluator;

bool carbon_path_evaluator_begin(carbon_path_evaluator *eval, carbon_dot_path *path, carbon *doc);
bool carbon_path_evaluator_begin_mutable(carbon_path_evaluator *eval, const carbon_dot_path *path, carbon_revise *context);
bool carbon_path_evaluator_end(carbon_path_evaluator *state);

bool carbon_path_evaluator_status(carbon_path_status_e *status, carbon_path_evaluator *state);
bool carbon_path_evaluator_has_result(carbon_path_evaluator *state);
bool carbon_path_exists(carbon *doc, const char *path);

bool carbon_path_is_array(carbon *doc, const char *path);
bool carbon_path_is_column(carbon *doc, const char *path);
bool carbon_path_is_object(carbon *doc, const char *path);
bool carbon_path_is_container(carbon *doc, const char *path);
bool carbon_path_is_null(carbon *doc, const char *path);
bool carbon_path_is_number(carbon *doc, const char *path);
bool carbon_path_is_boolean(carbon *doc, const char *path);
bool carbon_path_is_string(carbon *doc, const char *path);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_PATH_INDEX_H
#define CARBON_PATH_INDEX_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <memfile.h>
#include <memblock.h>
#include <jakson/error.h>
#include <jakson/carbon.h>
#include <jakson/carbon/find.h>
#include <jakson/carbon/dot.h>

BEGIN_DECL

// ---------------------------------------------------------------------------------------------------------------------
//  types
// ---------------------------------------------------------------------------------------------------------------------

typedef struct carbon_path_index {
        memblock *memblock;
        memfile memfile;
        err err;
} carbon_path_index;

typedef struct carbon_path_index_it {
        carbon *doc;
        memfile memfile;
        err err;

        carbon_container_e container_type;
        u64 pos;
} carbon_path_index_it;

typedef enum path_index_node {
        PATH_ROOT, PATH_INDEX_PROP_KEY, PATH_INDEX_ARRAY_INDEX, PATH_INDEX_COLUMN_INDEX
} path_index_node_e;

// ---------------------------------------------------------------------------------------------------------------------
//  construction and deconstruction
// ---------------------------------------------------------------------------------------------------------------------

bool carbon_path_index_create(carbon_path_index *index, carbon *doc);
bool carbon_path_index_drop(carbon_path_index *index);

// ---------------------------------------------------------------------------------------------------------------------
//  index data access and meta information
// ---------------------------------------------------------------------------------------------------------------------

const void *carbon_path_index_raw_data(u64 *size, carbon_path_index *index);
bool carbon_path_index_commit_hash(u64 *commit_hash, carbon_path_index *index);
bool carbon_path_index_key_type(carbon_key_e *key_type, carbon_path_index *index);
bool carbon_path_index_key_unsigned_value(u64 *key, carbon_path_index *index);
bool carbon_path_index_key_signed_value(i64 *key, carbon_path_index *index);
const char *carbon_path_index_key_string_value(u64 *str_len, carbon_path_index *index);
bool carbon_path_index_indexes_doc(carbon_path_index *index, carbon *doc);

DEFINE_ERROR_GETTER(carbon_path_index);

// ---------------------------------------------------------------------------------------------------------------------
//  index access and type information
// ---------------------------------------------------------------------------------------------------------------------

bool carbon_path_index_it_open(carbon_path_index_it *it, carbon_path_index *index, carbon *doc);
bool carbon_path_index_it_type(carbon_container_e *type, carbon_path_index_it *it);

// ---------------------------------------------------------------------------------------------------------------------
//  array and column container functions
// ---------------------------------------------------------------------------------------------------------------------

bool carbon_path_index_it_list_length(u64 *key_len, carbon_path_index_it *it);
bool carbon_path_index_it_list_goto(u64 pos, carbon_path_index_it *it);
bool carbon_path_index_it_list_pos(u64 *pos, carbon_path_index_it *it);
bool carbon_path_index_it_list_can_enter(carbon_path_index_it *it);
bool carbon_path_index_it_list_enter(carbon_path_index_it *it);

// ---------------------------------------------------------------------------------------------------------------------
//  object container functions
// ---------------------------------------------------------------------------------------------------------------------

bool carbon_path_index_it_obj_num_props(u64 *num_props, carbon_path_index_it *it);
bool carbon_path_index_it_obj_goto(const char *key_name, carbon_path_index_it *it);
const char *carbon_path_index_it_key_name(u64 *name_len, carbon_path_index_it *it);
bool carbon_path_index_it_obj_can_enter(carbon_path_index_it *it);
bool carbon_path_index_it_obj_enter(carbon_path_index_it *it);

// ---------------------------------------------------------------------------------------------------------------------
//  field access
// ---------------------------------------------------------------------------------------------------------------------

bool carbon_path_index_it_field_type(carbon_field_type_e *type, carbon_path_index_it *it);
bool carbon_path_index_it_field_u8_value(u8 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_u16_value(u16 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_u32_value(u32 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_u64_value(u64 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_i8_value(i8 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_i16_value(i16 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_i32_value(i32 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_i64_value(i64 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_float_value(bool *is_null_in, float *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_signed_value(bool *is_null_in, i64 *value, carbon_path_index_it *it);
bool carbon_path_index_it_field_unsigned_value(bool *is_null_in, u64 *value, carbon_path_index_it *it);
const char *carbon_path_index_it_field_string_value(u64 *strlen, carbon_path_index_it *it);
bool carbon_path_index_it_field_binary_value(carbon_binary *out, carbon_array_it *it);
bool carbon_path_index_it_field_array_value(carbon_array_it *it_out, carbon_path_index_it *it_in);
bool carbon_path_index_it_field_object_value(carbon_object_it *it_out, carbon_path_index_it *it_in);
bool carbon_path_index_it_field_column_value(carbon_column_it *it_out, carbon_path_index_it *it_in);

// ---------------------------------------------------------------------------------------------------------------------
//  diagnostics
// ---------------------------------------------------------------------------------------------------------------------

bool carbon_path_index_hexdump(FILE *file, carbon_path_index *index);
bool carbon_path_index_to_carbon(carbon *doc, carbon_path_index *index);
const char *carbon_path_index_to_str(string_buffer *str, carbon_path_index *index);
bool carbon_path_index_print(FILE *file, carbon_path_index *index);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_PRINTERS_H
#define CARBON_PRINTERS_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>
#include <string_buffer.h>
#include <unique_id.h>

BEGIN_DECL

typedef struct carbon_printer
{
        void *extra;

        void (*drop)(carbon_printer *self);
        void (*record_begin)(carbon_printer *self, string_buffer *builder);
        void (*record_end)(carbon_printer *self, string_buffer *builder);
        void (*meta_begin)(carbon_printer *self, string_buffer *builder);
        /* type is of carbon_key_e */
        void (*meta_data)(carbon_printer *self, string_buffer *builder, int key_type, const void *key, u64 key_length, u64 commit_hash);
        void (*meta_end)(carbon_printer *self, string_buffer *builder);
        void (*doc_begin)(carbon_printer *self, string_buffer *builder);
        void (*doc_end)(carbon_printer *self, string_buffer *builder);
        void (*empty_record)(carbon_printer *self, string_buffer *builder);
        void (*unit_array_begin)(carbon_printer *self, string_buffer *builder);
        void (*unit_array_end)(carbon_printer *self, string_buffer *builder);
        void (*array_begin)(carbon_printer *self, string_buffer *builder);
        void (*array_end)(carbon_printer *self, string_buffer *builder);
        void (*const_null)(carbon_printer *self, string_buffer *builder);
        void (*const_true)(carbon_printer *self, bool is_null, string_buffer *builder);
        void (*const_false)(carbon_printer *self, bool is_null, string_buffer *builder);
        /* if <code>value</code> is NULL, <code>value</code> is interpreted as null-value'd entry */
        void (*val_signed)(carbon_printer *self, string_buffer *builder, const i64 *value);
        /* if <code>value</code> is NULL, <code>value</code> is interpreted as null-value'd entry */
        void (*val_unsigned)(carbon_printer *self, string_buffer *builder, const u64 *value);
        /* if <code>value</code> is NULL, <code>value</code> is interpreted as null-value'd entry */
        void (*val_float)(carbon_printer *self, string_buffer *builder, const float *value);
        void (*val_string)(carbon_printer *self, string_buffer *builder, const char *value, u64 strlen);
        void (*val_binary)(carbon_printer *self, string_buffer *builder, const carbon_binary *binary);
        void (*comma)(carbon_printer *self, string_buffer *builder);
        void (*obj_begin)(carbon_printer *self, string_buffer *builder);
        void (*obj_end)(carbon_printer *self, string_buffer *builder);
        void (*prop_null)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len);
        void (*prop_true)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len);
        void (*prop_false)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len);
        void (*prop_signed)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len, const i64 *value);
        void (*prop_unsigned)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len, const u64 *value);
        void (*prop_float)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len, const float *value);
        void (*prop_string)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len, const char *value, u64 strlen);
        void (*prop_binary)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len, const carbon_binary *binary);
        void (*array_prop_name)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len);
        void (*column_prop_name)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len);
        void (*obj_prop_name)(carbon_printer *self, string_buffer *builder, const char *key_name, u64 key_len);
} carbon_printer;

/* 'impl' is of carbon_printer_impl_e */
bool carbon_printer_drop(carbon_printer *printer);
bool carbon_printer_by_type(carbon_printer *printer, int impl);

bool carbon_printer_begin(carbon_printer *printer, string_buffer *str);
bool carbon_printer_end(carbon_printer *printer, string_buffer *str);
bool carbon_printer_header_begin(carbon_printer *printer, string_buffer *str);
/* 'key_type' is of carbon_key_e */
bool carbon_printer_header_contents(carbon_printer *printer, string_buffer *str, int key_type, const void *key, u64 key_length, u64 rev);
bool carbon_printer_header_end(carbon_printer *printer, string_buffer *str);
bool carbon_printer_payload_begin(carbon_printer *printer, string_buffer *str);
bool carbon_printer_payload_end(carbon_printer *printer, string_buffer *str);
bool carbon_printer_empty_record(carbon_printer *printer, string_buffer *str);
bool carbon_printer_array_begin(carbon_printer *printer, string_buffer *str);
bool carbon_printer_array_end(carbon_printer *printer, string_buffer *str);
bool carbon_printer_unit_array_begin(carbon_printer *printer, string_buffer *str);
bool carbon_printer_unit_array_end(carbon_printer *printer, string_buffer *str);
bool carbon_printer_object_begin(carbon_printer *printer, string_buffer *str);
bool carbon_printer_object_end(carbon_printer *printer, string_buffer *str);
bool carbon_printer_null(carbon_printer *printer, string_buffer *str);
bool carbon_printer_true(carbon_printer *printer, bool is_null, string_buffer *str);
bool carbon_printer_false(carbon_printer *printer, bool is_null, string_buffer *str);
bool carbon_printer_comma(carbon_printer *printer, string_buffer *str);
bool carbon_printer_signed_nonull(carbon_printer *printer, string_buffer *str, const i64 *value);
bool carbon_printer_unsigned_nonull(carbon_printer *printer, string_buffer *str, const u64 *value);
bool carbon_printer_u8_or_null(carbon_printer *printer, string_buffer *str, u8 value);
bool carbon_printer_u16_or_null(carbon_printer *printer, string_buffer *str, u16 value);
bool carbon_printer_u32_or_null(carbon_printer *printer, string_buffer *str, u32 value);
bool carbon_printer_u64_or_null(carbon_printer *printer, string_buffer *str, u64 value);
bool carbon_printer_i8_or_null(carbon_printer *printer, string_buffer *str, i8 value);
bool carbon_printer_i16_or_null(carbon_printer *printer, string_buffer *str, i16 value);
bool carbon_printer_i32_or_null(carbon_printer *printer, string_buffer *str, i32 value);
bool carbon_printer_i64_or_null(carbon_printer *printer, string_buffer *str, i64 value);
bool carbon_printer_float(carbon_printer *printer, string_buffer *str, const float *value);
bool carbon_printer_string(carbon_printer *printer, string_buffer *str, const char *value, u64 strlen);
bool carbon_printer_binary(carbon_printer *printer, string_buffer *str, const carbon_binary *binary);
bool carbon_printer_prop_null(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len);
bool carbon_printer_prop_true(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len);
bool carbon_printer_prop_false(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len);
bool carbon_printer_prop_signed(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len, const i64 *value);
bool carbon_printer_prop_unsigned(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len, const u64 *value);
bool carbon_printer_prop_float(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len, const float *value);
bool carbon_printer_prop_string(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len, const char *value, u64 strlen);
bool carbon_printer_prop_binary(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len, const carbon_binary *binary);
bool carbon_printer_array_prop_name(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len);
bool carbon_printer_column_prop_name(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len);
bool carbon_printer_object_prop_name(carbon_printer *printer, string_buffer *str, const char *key_name, u64 key_len);
bool carbon_printer_print_object(carbon_object_it *it, carbon_printer *printer, string_buffer *builder);
bool carbon_printer_print_array(carbon_array_it *it, carbon_printer *printer, string_buffer *builder, bool is_record_container);
bool carbon_printer_print_column(carbon_column_it *it, carbon_printer *printer, string_buffer *builder);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_PROP_H
#define CARBON_PROP_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/carbon/field.h>

BEGIN_DECL

u64 carbon_prop_size(memfile *file);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_REVISE_H
#define CARBON_REVISE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <unique_id.h>
#include <jakson/carbon.h>

BEGIN_DECL

DEFINE_ERROR_GETTER(carbon_revise)

/**
 * Acquires a new revision context for the carbon document.
 *
 * In case of an already running revision, the function returns <code>false</code> without blocking.
 * Otherwise, <code>carbon_revise_begin</code> is called internally.
 *
 * @param context non-null pointer to revision context
 * @param doc document that should be revised
 * @return <code>false</code> in case of an already running revision. Otherwise returns value of
 *                            <code>carbon_revise_begin</code>
 */
bool carbon_revise_try_begin(carbon_revise *context, carbon *revised_doc, carbon *doc);
bool carbon_revise_begin(carbon_revise *context, carbon *revised_doc, carbon *original);
const carbon *carbon_revise_end(carbon_revise *context);

bool carbon_revise_key_generate(unique_id_t *out, carbon_revise *context);

bool carbon_revise_key_set_unsigned(carbon_revise *context, u64 key_value);
bool carbon_revise_key_set_signed(carbon_revise *context, i64 key_value);
bool carbon_revise_key_set_string(carbon_revise *context, const char *key_value);

bool carbon_revise_iterator_open(carbon_array_it *it, carbon_revise *context);
bool carbon_revise_iterator_close(carbon_array_it *it);

bool carbon_revise_find_begin(carbon_find *out, const char *dot_path, carbon_revise *context);
bool carbon_revise_find_end(carbon_find *find);

bool carbon_revise_remove(const char *dot_path, carbon_revise *context);
bool carbon_revise_remove_one(const char *dot_path, carbon *rev_doc, carbon *doc);

bool carbon_revise_pack(carbon_revise *context);
bool carbon_revise_shrink(carbon_revise *context);

bool carbon_revise_abort(carbon_revise *context);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_STRING_H
#define CARBON_STRING_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <memfile.h>

BEGIN_DECL

bool carbon_string_write(memfile *file, const char *string_buffer);
bool carbon_string_nchar_write(memfile *file, const char *string_buffer, u64 str_len);
bool carbon_string_nomarker_write(memfile *file, const char *string_buffer);
bool carbon_string_nomarker_nchar_write(memfile *file, const char *string_buffer, u64 str_len);
bool carbon_string_nomarker_remove(memfile *file);
bool carbon_string_remove(memfile *file);
bool carbon_string_update(memfile *file, const char *string_buffer);
bool carbon_string_update_wnchar(memfile *file, const char *string_buffer, size_t str_len);
bool carbon_string_skip(memfile *file);
bool carbon_string_nomarker_skip(memfile *file);
const char *carbon_string_read(u64 *len, memfile *file);
const char *carbon_string_nomarker_read(u64 *len, memfile *file);

END_DECL

#endif
/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CARBON_UPDATE_H
#define CARBON_UPDATE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>
#include <memblock.h>
#include <memfile.h>
#include <spinlock.h>
#include <jakson/carbon.h>
#include <jakson/carbon/dot.h>
#include <jakson/carbon/path.h>
#include <jakson/carbon/internal.h>

BEGIN_DECL

typedef struct carbon_update {
        carbon_revise *context;
        carbon_path_evaluator path_evaluater;
        const carbon_dot_path *path;
        err err;
        bool is_found;
} carbon_update;

DEFINE_ERROR_GETTER(carbon_update)

bool carbon_update_set_null(carbon_revise *context, const char *path);
bool carbon_update_set_true(carbon_revise *context, const char *path);
bool carbon_update_set_false(carbon_revise *context, const char *path);
bool carbon_update_set_u8(carbon_revise *context, const char *path, u8 value);
bool carbon_update_set_u16(carbon_revise *context, const char *path, u16 value);
bool carbon_update_set_u32(carbon_revise *context, const char *path, u32 value);
bool carbon_update_set_u64(carbon_revise *context, const char *path, u64 value);
bool carbon_update_set_i8(carbon_revise *context, const char *path, i8 value);
bool carbon_update_set_i16(carbon_revise *context, const char *path, i16 value);
bool carbon_update_set_i32(carbon_revise *context, const char *path, i32 value);
bool carbon_update_set_i64(carbon_revise *context, const char *path, i64 value);
bool carbon_update_set_float(carbon_revise *context, const char *path, float value);
bool carbon_update_set_unsigned(carbon_revise *context, const char *path, u64 value);
bool carbon_update_set_signed(carbon_revise *context, const char *path, i64 value);
bool carbon_update_set_string(carbon_revise *context, const char *path, const char *value);
bool carbon_update_set_binary(carbon_revise *context, const char *path, const void *value, size_t nbytes, const char *file_ext, const char *user_type);

carbon_insert *carbon_update_set_array_begin(carbon_revise *context, const char *path, carbon_insert_array_state *state_out, u64 array_capacity);
bool carbon_update_set_array_end(carbon_insert_array_state *state_in);

carbon_insert *carbon_update_set_column_begin(carbon_revise *context, const char *path, carbon_insert_column_state *state_out, carbon_field_type_e type, u64 column_capacity);
bool carbon_update_set_column_end(carbon_insert_column_state *state_in);

bool carbon_update_set_null_compiled(carbon_revise *context, const carbon_dot_path *path);
bool carbon_update_set_true_compiled(carbon_revise *context, const carbon_dot_path *path);
bool carbon_update_set_false_compiled(carbon_revise *context, const carbon_dot_path *path);

bool carbon_update_set_u8_compiled(carbon_revise *context, const carbon_dot_path *path, u8 value);
bool carbon_update_set_u16_compiled(carbon_revise *context, const carbon_dot_path *path, u16 value);
bool carbon_update_set_u32_compiled(carbon_revise *context, const carbon_dot_path *path, u32 value);
bool carbon_update_set_u64_compiled(carbon_revise *context, const carbon_dot_path *path, u64 value);
bool carbon_update_set_i8_compiled(carbon_revise *context, const carbon_dot_path *path, i8 value);
bool carbon_update_set_i16_compiled(carbon_revise *context, const carbon_dot_path *path, i16 value);
bool carbon_update_set_i32_compiled(carbon_revise *context, const carbon_dot_path *path, i32 value);
bool carbon_update_set_i64_compiled(carbon_revise *context, const carbon_dot_path *path, i64 value);
bool carbon_update_set_float_compiled(carbon_revise *context, const carbon_dot_path *path, float value);
bool carbon_update_set_unsigned_compiled(carbon_revise *context, const carbon_dot_path *path, u64 value);
bool carbon_update_set_signed_compiled(carbon_revise *context, const carbon_dot_path *path, i64 value);
bool carbon_update_set_string_compiled(carbon_revise *context, const carbon_dot_path *path, const char *value);
bool carbon_update_set_binary_compiled(carbon_revise *context, const carbon_dot_path *path, const void *value, size_t nbytes, const char *file_ext, const char *user_type);
carbon_insert * carbon_update_set_array_begin_compiled(carbon_revise *context, const carbon_dot_path *path, carbon_insert_array_state *state_out, u64 array_capacity);
bool carbon_update_set_array_end_compiled(carbon_insert_array_state *state_in);
carbon_insert *carbon_update_set_column_begin_compiled(carbon_revise *context, const carbon_dot_path *path, carbon_insert_column_state *state_out, carbon_field_type_e type, u64 column_capacity);
bool carbon_update_set_column_end_compiled(carbon_insert_column_state *state_in);

bool carbon_update_one_set_null(const char *dot_path, carbon *rev_doc, carbon *doc);
bool carbon_update_one_set_true(const char *dot_path, carbon *rev_doc, carbon *doc);
bool carbon_update_one_set_false(const char *dot_path, carbon *rev_doc, carbon *doc);
bool carbon_update_one_set_u8(const char *dot_path, carbon *rev_doc, carbon *doc, u8 value);
bool carbon_update_one_set_u16(const char *dot_path, carbon *rev_doc, carbon *doc, u16 value);
bool carbon_update_one_set_u32(const char *dot_path, carbon *rev_doc, carbon *doc, u32 value);
bool carbon_update_one_set_u64(const char *dot_path, carbon *rev_doc, carbon *doc, u64 value);
bool carbon_update_one_set_i8(const char *dot_path, carbon *rev_doc, carbon *doc, i8 value);
bool carbon_update_one_set_i16(const char *dot_path, carbon *rev_doc, carbon *doc, i16 value);
bool carbon_update_one_set_i32(const char *dot_path, carbon *rev_doc, carbon *doc, i32 value);
bool carbon_update_one_set_i64(const char *dot_path, carbon *rev_doc, carbon *doc, i64 value);
bool carbon_update_one_set_float(const char *dot_path, carbon *rev_doc, carbon *doc, float value);
bool carbon_update_one_set_unsigned(const char *dot_path, carbon *rev_doc, carbon *doc, u64 value);
bool carbon_update_one_set_signed(const char *dot_path, carbon *rev_doc, carbon *doc, i64 value);
bool carbon_update_one_set_string(const char *dot_path, carbon *rev_doc, carbon *doc, const char *value);
bool carbon_update_one_set_binary(const char *dot_path, carbon *rev_doc, carbon *doc, const void *value, size_t nbytes, const char *file_ext, const char *user_type);
carbon_insert *carbon_update_one_set_array_begin(carbon_insert_array_state *state_out, const char *dot_path, carbon *rev_doc, carbon *doc, u64 array_capacity);
bool carbon_update_one_set_array_end(carbon_insert_array_state *state_in);

carbon_insert *carbon_update_one_set_column_begin(carbon_insert_column_state *state_out, const char *dot_path, carbon *rev_doc, carbon *doc, carbon_field_type_e type, u64 column_capacity);
bool carbon_update_one_set_column_end(carbon_insert_column_state *state_in);

bool carbon_update_one_set_null_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc);
bool carbon_update_one_set_true_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc);
bool carbon_update_one_set_false_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc);
bool carbon_update_one_set_u8_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, u8 value);
bool carbon_update_one_set_u16_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, u16 value);
bool carbon_update_one_set_u32_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, u32 value);
bool carbon_update_one_set_u64_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, u64 value);
bool carbon_update_one_set_i8_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, i8 value);
bool carbon_update_one_set_i16_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, i16 value);
bool carbon_update_one_set_i32_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, i32 value);
bool carbon_update_one_set_i64_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, i64 value);
bool carbon_update_one_set_float_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, float value);
bool carbon_update_one_set_unsigned_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, u64 value);
bool carbon_update_one_set_signed_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, i64 value);
bool carbon_update_one_set_string_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, const char *value);
bool carbon_update_one_set_binary_compiled(const carbon_dot_path *path, carbon *rev_doc, carbon *doc, const void *value, size_t nbytes, const char *file_ext, const char *user_type);
carbon_insert *carbon_update_one_set_array_begin_compiled(carbon_insert_array_state *state_out, const carbon_dot_path *path, carbon *rev_doc, carbon *doc, u64 array_capacity);
bool carbon_update_one_set_array_end_compiled(carbon_insert_array_state *state_in);

carbon_insert *carbon_update_one_set_column_begin_compiled(carbon_insert_column_state *state_out, const carbon_dot_path *path, carbon *rev_doc, carbon *doc, carbon_field_type_e type, u64 column_capacity);
bool carbon_update_one_set_column_end_compiled(carbon_insert_column_state *state_in);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef COLUMNDOC_H
#define COLUMNDOC_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>
#include <bloom.h>
#include <string_dict.h>
#include <doc.h>

BEGIN_DECL

/**
 * Transformation of an JSON-like array of objects to a columnar representation of key values.
 *
 * The assumption is that an array of objects is LIKELY to have elements of the same (well yet unknown) schema. The
 * following structure captures a particular key (with its data type) found in one or more elements inside this array,
 * and stores the value assigned to this key along with with the object position in the array in which this mapping
 * occurs. Note that a keys name might have different data types inside objects embedded in arrays, and a key is not
 * guaranteed to occur in all objects embedded in the array.
 */
typedef struct column_doc_column {
        /** Key name */
        archive_field_sid_t key_name;
        /** Particular key type */
        archive_field_e type;
        /** Positions of objects in the parent array that has this particular key name with this particular value type */
        vector ofType(u32) array_positions;
        /** Values stored in objects assigned to this key-type mapping. The i-th element in `values` (which hold the
         * i-th value) is associated to the i-th element in `arrayPosition` which holds the position of the object inside
         * the array from which this pair was taken. */
        vector ofType(Vector ofType( < T >)) values;
} column_doc_column;

typedef struct column_doc_group {
        /** Key name */
        archive_field_sid_t key;
        /** Key columns as a decomposition of objects stored in that JSON-like array */
        vector ofType(column_doc_column) columns;
} column_doc_group;

typedef struct column_doc_obj {
        /** Parent document meta doc */
        column_doc *parent;
        /** Key in parent document meta doc that maps to this one, or "/" if this is the top-level meta doc */
        archive_field_sid_t parent_key;
        /** Index inside the array of this doc in its parents property, or 0 if this is not an array type or top-level */
        size_t index;

        /** Inverted index of keys mapping to primitive boolean types (sorted by key) */
        vector ofType(archive_field_sid_t) bool_prop_keys;
        /** Inverted index of keys mapping to primitive int8 number types (sorted by key) */
        vector ofType(archive_field_sid_t) int8_prop_keys;
        /** Inverted index of keys mapping to primitive int16 number types (sorted by key) */
        vector ofType(archive_field_sid_t) int16_prop_keys;
        /** Inverted index of keys mapping to primitive int32 number types (sorted by key) */
        vector ofType(archive_field_sid_t) int32_prop_keys;
        /** Inverted index of keys mapping to primitive int64 number types (sorted by key) */
        vector ofType(archive_field_sid_t) int64_prop_keys;
        /** Inverted index of keys mapping to primitive uint8 number types (sorted by key) */
        vector ofType(archive_field_sid_t) uint8_prop_keys;
        /** Inverted index of keys mapping to primitive uint16 number types (sorted by key) */
        vector ofType(archive_field_sid_t) uint16_prop_keys;
        /** Inverted index of keys mapping to primitive uint32 number types (sorted by key) */
        vector ofType(archive_field_sid_t) uin32_prop_keys;
        /** Inverted index of keys mapping to primitive uint64 number types (sorted by key) */
        vector ofType(archive_field_sid_t) uint64_prop_keys;
        /** Inverted index of keys mapping to primitive string_buffer types (sorted by key) */
        vector ofType(archive_field_sid_t) string_prop_keys;
        /** Inverted index of keys mapping to primitive real types (sorted by key) */
        vector ofType(archive_field_sid_t) float_prop_keys;
        /** Inverted index of keys mapping to primitive null values (sorted by key) */
        vector ofType(archive_field_sid_t) null_prop_keys;
        /** Inverted index of keys mapping to exactly one nested object value (sorted by key) */
        vector ofType(archive_field_sid_t) obj_prop_keys;

        /** Inverted index of keys mapping to array of boolean types (sorted by key)*/
        vector ofType(archive_field_sid_t) bool_array_prop_keys;
        /** Inverted index of keys mapping to array of int8 number types (sorted by key)*/
        vector ofType(archive_field_sid_t) int8_array_prop_keys;
        /** Inverted index of keys mapping to array of int16 number types (sorted by key) */
        vector ofType(archive_field_sid_t) int16_array_prop_keys;
        /** Inverted index of keys mapping to array of int32 number types (sorted by key) */
        vector ofType(archive_field_sid_t) int32_array_prop_keys;
        /** Inverted index of keys mapping to array of int64 number types (sorted by key) */
        vector ofType(archive_field_sid_t) int64_array_prop_keys;
        /** Inverted index of keys mapping to array of uint8 number types (sorted by key) */
        vector ofType(archive_field_sid_t) uint8_array_prop_keys;
        /** Inverted index of keys mapping to array of uint16 number types (sorted by key) */
        vector ofType(archive_field_sid_t) uint16_array_prop_keys;
        /** Inverted index of keys mapping to array of uint32 number types (sorted by key) */
        vector ofType(archive_field_sid_t) uint32_array_prop_keys;
        /** Inverted index of keys mapping to array of uint64 number types (sorted by key) */
        vector ofType(archive_field_sid_t) uint64_array_prop_keys;
        /** Inverted index of keys mapping array of string_buffer types (sorted by key) */
        vector ofType(archive_field_sid_t) string_array_prop_keys;
        /** Inverted index of keys mapping array of real types (sorted by key) */
        vector ofType(archive_field_sid_t) float_array_prop_keys;
        /** Inverted index of keys mapping array of null value (sorted by key)s */
        vector ofType(archive_field_sid_t) null_array_prop_keys;

        /** Primitive boolean values associated to keys stored above (sorted by key) */
        vector ofType(FIELD_BOOLEANean_t) bool_prop_vals;
        /** Primitive int8 number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_i8_t) int8_prop_vals;
        /** Primitive int16 number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_i16_t) int16_prop_vals;
        /** Primitive int32 number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_i32_t) int32_prop_vals;
        /** Primitive int64 number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_i64_t) int64_prop_vals;
        /** Primitive uint8 number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_u8_t) uint8_prop_vals;
        /** Primitive uint16 number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_u16_t) uint16_prop_vals;
        /** Primitive uint32 number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_u32_t) uint32_prop_vals;
        /** Primitive uint64 number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_u64_t) uint64_prop_vals;
        /** Primitive real number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_number_t) float_prop_vals;
        /** Primitive string_buffer number values associated to keys stored above (sorted by key) */
        vector ofType(archive_field_sid_t) string_prop_vals;

        /** Array of boolean values associated to keys stored above (sorted by key) */
        vector ofType(Vector) bool_array_prop_vals;
        /** Array of int8 number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) int8_array_prop_vals;
        /** Array of int16 number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) int16_array_prop_vals;
        /** Array of int32 number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) int32_array_prop_vals;
        /** Array of int64 number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) int64_array_prop_vals;
        /** Array of uint8 number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) uint8_array_prop_vals;
        /** Array of uint16 number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) uint16_array_prop_vals;
        /** Array of uint32 number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) uint32_array_prop_vals;
        /** Array of uint64 number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) ui64_array_prop_vals;
        /** Array of real number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) float_array_prop_vals;
        /** Array of string_buffer number values associated to keys stored above (sorted by key) */
        vector ofType(Vector) string_array_prop_vals;
        /** Array of null values associated to keys stored above (sorted by key). The number represents the
         * multiplicity of nulls for the associated key. */
        vector ofType(u16) null_array_prop_vals;
        /** Primitive objects associated to keys stored above (sorted by key) */
        vector ofType(column_doc_obj) obj_prop_vals;

        /** Index of primitive boolean values associated to keys stored above (sorted by value) */
        vector ofType(u32) bool_val_idxs;
        /** Index of primitive int8 number values associated to keys stored above (sorted by value) */
        vector ofType(u32) int8_val_idxs;
        /** Index of primitive int16 number values associated to keys stored above (sorted by value) */
        vector ofType(u32) int16_val_idxs;
        /** Index of primitive int32 number values associated to keys stored above (sorted by value) */
        vector ofType(u32) int32_val_idxs;
        /** Index of primitive int64 number values associated to keys stored above (sorted by value) */
        vector ofType(u32) int64_val_idxs;
        /** Index of primitive uint8 number values associated to keys stored above (sorted by value) */
        vector ofType(u32) uint8_val_idxs;
        /** Index of primitive uint16 number values associated to keys stored above (sorted by value) */
        vector ofType(u32) uint16_val_idxs;
        /** Index of primitive uint32 number values associated to keys stored above (sorted by value) */
        vector ofType(u32) uint32_val_idxs;
        /** Index of primitive uint64 number values associated to keys stored above (sorted by value) */
        vector ofType(u32) uint64_val_idxs;
        /** Index of primitive real number values associated to keys stored above (sorted by value) */
        vector ofType(u32) float_val_idxs;
        /** Index of primitive string_buffer number values associated to keys stored above (sorted by value) */
        vector ofType(u32) string_val_idxs;

        /** Index of array of boolean values associated to keys stored above (sorted by value) */
        vector ofType(Vector) bool_array_idxs;
        /** Index of array of int8 number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) int8_array_idxs;
        /** Index of array of int16 number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) int16_array_idxs;
        /** Index of array of int32 number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) int32_array_idxs;
        /** Index of array of int64 number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) int64_array_idxs;
        /** Index of array of uint8 number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) uint8_array_idxs;
        /** Index of array of uint16 number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) uint16_array_idxs;
        /** Index of array of uint32 number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) uint32_array_idxs;
        /** Index of array of uint64 number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) uint64_array_idxs;
        /** Index of array of real number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) float_array_idxs;
        /** Index of array of string_buffer number values associated to keys stored above (sorted by value) */
        vector ofType(Vector) string_array_idxs;

        /** Array of objects associated to keys stored above (sorted by key) */
        vector ofType(column_doc_group) obj_array_props;
} column_doc_obj;

typedef struct column_doc {
        const doc *doc;
        string_dict *dic;
        column_doc_obj columndoc;
        const doc_bulk *bulk;
        bool read_optimized;
        err err;
} column_doc;

DEFINE_GET_ERROR_FUNCTION(columndoc, column_doc, doc)

bool columndoc_create(column_doc *columndoc, err *err, const doc *doc,  const doc_bulk *bulk, const doc_entries *entries, string_dict *dic);
bool columndoc_drop(column_doc *doc);

bool columndoc_free(column_doc *doc);

bool columndoc_print(FILE *file, column_doc *doc);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef DOC_H
#define DOC_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>
#include <string_dict.h>
#include <json.h>

BEGIN_DECL

typedef struct doc_entries {
        doc_obj *context;
        const char *key;
        archive_field_e type;
        vector ofType(<T>) values;
} doc_entries;

typedef struct doc_bulk {
        string_dict *dic;
        vector ofType(char *) keys, values;
        vector ofType(doc) models;
} doc_bulk;

typedef struct doc {
        doc_bulk *context;
        vector ofType(doc_obj) obj_model;
        archive_field_e type;
} doc;

typedef struct doc_obj {
        vector ofType(doc_entries) entries;
        doc *doc;
} doc_obj;

bool doc_bulk_create(doc_bulk *bulk, string_dict *dic);
bool doc_bulk_drop(doc_bulk *bulk);

bool doc_bulk_shrink(doc_bulk *bulk);
bool doc_bulk_print(FILE *file, doc_bulk *bulk);

doc *doc_bulk_new_doc(doc_bulk *context, archive_field_e type);
doc_obj *doc_bulk_new_obj(doc *model);
bool doc_bulk_get_dic_contents(vector ofType (const char *) **strings, vector ofType(archive_field_sid_t) **string_ids, const doc_bulk *context);

bool doc_print(FILE *file, const doc *doc);
const vector ofType(doc_entries) *doc_get_entries(const doc_obj *model);
void doc_print_entries(FILE *file, const doc_entries *entries);
void doc_drop(doc_obj *model);

bool doc_obj_add_key(doc_entries **out, doc_obj *obj, const char *key, archive_field_e type);
bool doc_obj_push_primtive(doc_entries *entry, const void *value);
bool doc_obj_push_object(doc_obj **out, doc_entries *entry);

doc_entries *doc_bulk_new_entries(doc_bulk *dst);
doc_obj *doc_bulk_add_json(doc_entries *partition, json *json);
doc_obj *doc_entries_get_root(const doc_entries *partition);
column_doc *doc_entries_columndoc(const doc_bulk *bulk, const doc_entries *partition, bool read_optimized);
bool doc_entries_drop(doc_entries *partition);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRDIC_ASYNC_H
#define STRDIC_ASYNC_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <string_dict.h>

BEGIN_DECL

int encode_async_create(string_dict *dic, size_t capacity, size_t num_index_buckets, size_t approx_num_unique_strs, size_t num_threads, const allocator *alloc);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRDIC_SYNC_H
#define STRDIC_SYNC_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <string_dict.h>

BEGIN_DECL

int encode_sync_create(string_dict *dic, size_t capacity, size_t num_indx_buckets, size_t num_index_bucket_cap, size_t num_threads, const allocator *alloc);

END_DECL

#endif/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ENCODED_DOC_H
#define ENCODED_DOC_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <hash_table.h>
#include <unique_id.h>
#include <types.h>
#include <jakson/archive.h>

BEGIN_DECL

typedef union encoded_doc_value {
        archive_field_i8_t int8;
        archive_field_i16_t int16;
        archive_field_i32_t int32;
        archive_field_i64_t int64;
        archive_field_u8_t uint8;
        archive_field_u16_t uint16;
        archive_field_u32_t uint32;
        archive_field_u64_t uint64;
        archive_field_number_t number;
        archive_field_boolean_t boolean;
        archive_field_sid_t string_buffer;
        unique_id_t object;
        u32 null;
} encoded_doc_value_u;

typedef enum encoded_doc_string {
        STRING_ENCODED, STRING_DECODED,
} encoded_doc_string_e;

typedef enum encoded_doc_value_e {
        VALUE_BUILTIN, VALUE_DECODED_STRING,
} encoded_doc_value_e;

typedef struct encoded_doc_prop_header {
        encoded_doc *context;

        encoded_doc_string_e key_type;
        union {
                archive_field_sid_t key_id;
                char *key_str;
        } key;

        encoded_doc_value_e value_type;
        enum archive_field_type type;
} encoded_doc_prop_header;

typedef struct encoded_doc_prop {
        encoded_doc_prop_header header;
        union {
                encoded_doc_value_u builtin;
                char *string_buffer;
        } value;
} encoded_doc_prop;

typedef struct encoded_doc_prop_array {
        encoded_doc_prop_header header;
        vector ofType(encoded_doc_value_u) values;
} encoded_doc_prop_array;

typedef struct encoded_doc {
        encoded_doc_list *context;
        unique_id_t object_id;
        vector ofType(encoded_doc_prop) props;
        vector ofType(encoded_doc_prop_array) props_arrays;
        hashtable ofMapping(archive_field_sid_t,
                                   u32) prop_array_index; /* maps key to index in prop arrays */
        err err;
} encoded_doc;

typedef struct encoded_doc_list {
        archive *archive;
        vector ofType(
                encoded_doc) flat_object_collection;   /* list of objects; also nested ones */
        hashtable ofMapping(object_id_t, u32) index;   /* maps oid to index in collection */
        err err;
} encoded_doc_list;

bool encoded_doc_collection_create(encoded_doc_list *collection, err *err, archive *archive);
bool encoded_doc_collection_drop(encoded_doc_list *collection);
encoded_doc *encoded_doc_collection_get_or_append(encoded_doc_list *collection, unique_id_t id);
bool encoded_doc_collection_print(FILE *file, encoded_doc_list *collection);

bool encoded_doc_drop(encoded_doc *doc);

#define DEFINE_ENCODED_DOC_ADD_PROP_BASIC(name, built_in_type)                                                  \
bool encoded_doc_add_prop_##name(encoded_doc *doc, archive_field_sid_t key, built_in_type value);

#define DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(name, built_in_type)                                          \
bool encoded_doc_add_prop_##name##_decoded(encoded_doc *doc, const char *key, built_in_type value);

DEFINE_ENCODED_DOC_ADD_PROP_BASIC(int8, archive_field_i8_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(int16, archive_field_i16_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(int32, archive_field_i32_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(int64, archive_field_i64_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(uint8, archive_field_u8_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(uint16, archive_field_u16_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(uint32, archive_field_u32_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(uint64, archive_field_u64_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(number, archive_field_number_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(boolean, archive_field_boolean_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC(string_buffer, archive_field_sid_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(int8, archive_field_i8_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(int16, archive_field_i16_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(int32, archive_field_i32_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(int64, archive_field_i64_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(uint8, archive_field_u8_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(uint16, archive_field_u16_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(uint32, archive_field_u32_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(uint64, archive_field_u64_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(number, archive_field_number_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(boolean, archive_field_boolean_t)
DEFINE_ENCODED_DOC_ADD_PROP_BASIC_DECODED(string_buffer, archive_field_sid_t)

bool encoded_doc_add_prop_string_decoded_string_value_decoded(encoded_doc *doc, const char *key, const char *value);
bool encoded_doc_add_prop_null(encoded_doc *doc, archive_field_sid_t key);
bool encoded_doc_add_prop_null_decoded(encoded_doc *doc, const char *key);
bool encoded_doc_add_prop_object(encoded_doc *doc, archive_field_sid_t key, encoded_doc *value);
bool encoded_doc_add_prop_object_decoded(encoded_doc *doc, const char *key, encoded_doc *value);

#define DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(name)                                                            \
bool encoded_doc_add_prop_array_##name(encoded_doc *doc, archive_field_sid_t key);

#define DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(name)                                                    \
bool encoded_doc_add_prop_array_##name##_decoded(encoded_doc *doc, const char *key);

DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int8)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int16)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int32)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int64)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint8)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint16)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint32)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint64)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(number)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(boolean)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(string_buffer)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(null)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(object)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int8)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int16)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int32)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int64)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint8)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint16)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint32)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint64)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(number)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(boolean)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(string_buffer)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(null)
DEFINE_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(object)

#define DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(name, built_in_type)                                                    \
bool encoded_doc_array_push_##name(encoded_doc *doc, archive_field_sid_t key, const built_in_type *array, u32 array_length);

#define DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(name, built_in_type)                                            \
bool encoded_doc_array_push_##name##_decoded(encoded_doc *doc, const char *key, const built_in_type *array, u32 array_length);

DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(int8, archive_field_i8_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(int16, archive_field_i16_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(int32, archive_field_i32_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(int64, archive_field_i64_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(uint8, archive_field_u8_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(uint16, archive_field_u16_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(uint32, archive_field_u32_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(uint64, archive_field_u64_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(number, archive_field_number_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(boolean, archive_field_boolean_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(string_buffer, archive_field_sid_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE(null, archive_field_u32_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int8, archive_field_i8_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int16, archive_field_i16_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int32, archive_field_i32_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int64, archive_field_i64_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint8, archive_field_u8_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint16, archive_field_u16_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint32, archive_field_u32_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint64, archive_field_u64_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(number, archive_field_number_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(boolean, archive_field_boolean_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(string_buffer, archive_field_sid_t)
DEFINE_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(null, archive_field_u32_t)

bool encoded_doc_array_push_object(encoded_doc *doc, archive_field_sid_t key, unique_id_t id);
bool encoded_doc_array_push_object_decoded(encoded_doc *doc, const char *key, unique_id_t id);
bool encoded_doc_print(FILE *file, encoded_doc *doc);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ERROR_H
#define ERROR_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdint.h>

#include <stdinc.h>
#include <types.h>

BEGIN_DECL

#define ERR_NOERR 0                    /** No ERROR */
#define ERR_NULLPTR 1                  /** Null pointer detected */
#define ERR_NOTIMPL 2                  /** Function not implemented */
#define ERR_OUTOFBOUNDS 3              /** Index is out of bounds */
#define ERR_MALLOCERR 4                /** Memory allocation failed */
#define ERR_ILLEGALARG 5               /** Illegal arguments */
#define ERR_INTERNALERR 6              /** Internal ERROR */
#define ERR_ILLEGALIMPL 7              /** Illegal implementation */
#define ERR_NOTFOUND 8                 /** Not found */
#define ERR_NIL 9                      /** Element not in list */
#define ERR_ARRAYOFARRAYS 10           /** Array index out of bounds */
#define ERR_ARRAYOFMIXEDTYPES 11       /** Illegal JSON array: mixed types */
#define ERR_FOPEN_FAILED 12            /** Reading from file failed */
#define ERR_IO 13                      /** I/O ERROR */
#define ERR_FORMATVERERR 14            /** Unsupported archive format version */
#define ERR_CORRUPTED 15               /** Format is corrupted */
#define ERR_NOCARBONSTREAM 16          /** Stream is not a carbon archive */
#define ERR_NOBITMODE 17               /** Not in bit writing mode */
#define ERR_NOTIMPLEMENTED 18          /** Function is not yet implemented */
#define ERR_NOTYPE 19                  /** Unsupported type found */
#define ERR_NOCOMPRESSOR 20            /** Unsupported compressor strategy requested */
#define ERR_NOVALUESTR 21              /** No string_buffer representation for type available */
#define ERR_MARKERMAPPING 22           /** Marker type cannot be mapped to value type */
#define ERR_PARSETYPE 23               /** Parsing stopped; unknown data type requested */
#define ERR_NOJSONTOKEN 24             /** Unknown token during parsing JSON detected */
#define ERR_NOJSONNUMBERT 25           /** Unknown value type for number in JSON property */
#define ERR_NOARCHIVEFILE 26           /** Stream is not a valid archive file */
#define ERR_UNSUPFINDSTRAT 27          /** Unsupported strategy requested for key lookup */
#define ERR_ERRINTERNAL 28             /** Internal ERROR */
#define ERR_HUFFERR 29                 /** No huffman code table entry found for character */
#define ERR_MEMSTATE 30                /** Memory file was opened as read-only but requested a modification */
#define ERR_JSONTYPE 31                /** Unable to import json file: unsupported type */
#define ERR_WRITEPROT 32               /** Mode set to read-only but modification was requested */
#define ERR_READOUTOFBOUNDS 33         /** Read outside of memory range bounds */
#define ERR_SLOTBROKEN 34              /** Slot management broken */
#define ERR_THREADOOOBJIDS 35          /** Thread run out of object ids: start another one */
#define ERR_JSONPARSEERR 36            /** JSON parsing ERROR */
#define ERR_BULKCREATEFAILED 37        /** Document insertion bulk creation failed */
#define ERR_FOPENWRITE 38              /** File cannot be opened for writing */
#define ERR_WRITEARCHIVE 39            /** Archive cannot be serialized into file */
#define ERR_ARCHIVEOPEN 40             /** Archive cannot be deserialized form file */
#define ERR_FREAD_FAILED 41            /** Unable to read from file */
#define ERR_SCAN_FAILED 42             /** Unable to perform full scan in archive file */
#define ERR_DECOMPRESSFAILED 43        /** String decompression from archive failed */
#define ERR_ITERATORNOTCLOSED 44       /** Closing iterator failed */
#define ERR_HARDCOPYFAILED 45          /** Unable to construct a hard copy of the source object */
#define ERR_REALLOCERR 46              /** Memory reallocation failed */
#define ERR_PREDEVAL_FAILED 47         /** Predicate evaluation failed */
#define ERR_INITFAILED 48              /** Initialization failed */
#define ERR_DROPFAILED 49              /** Resource release failed: potentially a memory leak occurred */
#define ERR_OPPFAILED 50               /** Operation failed */
#define ERR_REHASH_NOROLLBACK 51       /** Rehashing hash table failed; rollback is not performed */
#define ERR_MEMFILEOPEN_FAILED 52      /** Unable to open memory file */
#define ERR_VITEROPEN_FAILED 53        /** Value iterator cannot be initialized */
#define ERR_MEMFILESKIP_FAILED 54      /** Memfile cannot skip desired amount of bytes */
#define ERR_MEMFILESEEK_FAILED 55      /** Unable to seek in memory file */
#define ERR_ITER_NOOBJ 56              /** Unable to get value: type is not non-array object */
#define ERR_ITER_NOBOOL 57             /** Unable to get value: type is not non-array boolean */
#define ERR_ITER_NOINT8 58             /** Unable to get value: type is not non-array int8 */
#define ERR_ITER_NOINT16 59            /** Unable to get value: type is not non-array int16 */
#define ERR_ITER_NOINT32 60            /** Unable to get value: type is not non-array int32 */
#define ERR_ITER_NOINT64 61            /** Unable to get value: type is not non-array int64 */
#define ERR_ITER_NOUINT8 62            /** Unable to get value: type is not non-array uint8 */
#define ERR_ITER_NOUINT16 63           /** Unable to get value: type is not non-array uint16 */
#define ERR_ITER_NOUINT32 64           /** Unable to get value: type is not non-array uint32 */
#define ERR_ITER_NOUINT64 65           /** Unable to get value: type is not non-array uint64 */
#define ERR_ITER_NONUMBER 66           /** Unable to get value: type is not non-array number */
#define ERR_ITER_NOSTRING 67           /** Unable to get value: type is not non-array string_buffer */
#define ERR_ITER_OBJECT_NEEDED 68      /** Illegal state: iteration over object issued, but collection found */
#define ERR_ITER_COLLECTION_NEEDED 69  /** Illegal state: iteration over collection issued, but object found */
#define ERR_TYPEMISMATCH 70            /** Type mismatch detected */
#define ERR_INDEXCORRUPTED_OFFSET 71   /** Index is corrupted: requested offset is outside file bounds */
#define ERR_TMP_FOPENWRITE 72          /** Temporary file cannot be opened for writing */
#define ERR_FWRITE_FAILED 73           /** Unable to write to file */
#define ERR_HASTABLE_DESERIALERR 74    /** Unable to deserialize hash table from file */
#define ERR_UNKNOWN_DIC_TYPE 75        /** Unknown string_buffer dictionary implementation requested */
#define ERR_STACK_OVERFLOW 76          /** Stack overflow */
#define ERR_STACK_UNDERFLOW 77         /** Stack underflow */
#define ERR_OUTDATED 78                /** Object was modified but is out of date */
#define ERR_NOTREADABLE 79             /** Object is currently being updated; no read allowed */
#define ERR_ILLEGALOP 80               /** Illegal operation */
#define ERR_BADTYPE 81                 /** Unsupported type */
#define ERR_UNSUPPCONTAINER 82         /** Unsupported container for data type */
#define ERR_INSERT_TOO_DANGEROUS 83    /** Adding integers with this function will perform an auto casting to
                                             * the smallest type required to store the integer value. Since you push
                                             * integers with this function into an column container that is bound
                                             * to a specific type, any insertion function call will fail once the
                                             * integer value requires a larger (or smaller) type than the fist value
                                             * added to the container. Use '*_insert_X' instead, where X is u8, u16,...
                                             * , u32 resp. i8, i16,..., i32. */
#define ERR_PARSE_DOT_EXPECTED 84       /** parsing ERROR: dot ('.') expected */
#define ERR_PARSE_ENTRY_EXPECTED 85     /** parsing ERROR: key name or array index expected */
#define ERR_PARSE_UNKNOWN_TOKEN 86      /** parsing ERROR: unknown token */
#define ERR_DOT_PATH_PARSERR 87         /** dot-notated path could not be parsed */
#define ERR_ILLEGALSTATE 88             /** Illegal state */
#define ERR_UNSUPPORTEDTYPE 89          /** Unsupported data type */
#define ERR_FAILED 90                   /** Operation failed */
#define ERR_CLEANUP 91                  /** Cleanup operation failed; potentially a memory leak occurred */
#define ERR_DOT_PATH_COMPILEERR 92      /** dot-notated path could not be compiled */
#define ERR_NONUMBER 93                 /** not a number */
#define ERR_BUFFERTOOTINY 94            /** buffer capacity exceeded */
#define ERR_TAILINGJUNK 95              /** tailing junk was detected in a stream */
#define ERR_NOTINDEXED 96               /** not indexed */

static const char *const global_err_str[] =
        {"No ERROR", "Null pointer detected", "Function not implemented", "Index is out of bounds",
         "Memory allocation failed", "Illegal arguments", "Internal ERROR", "Illegal implementation", "Not found",
         "Element not in list", "Array index out of bounds", "Illegal JSON array: mixed types",
         "Reading from file failed", "I/O ERROR", "Unsupported archive format version", "Format is corrupted",
         "Stream is not a types archive", "Not in bit writing mode", "Function is not yet implemented",
         "Unsupported type found", "Unsupported pack strategy requested", "No string_buffer representation for type available",
         "Marker type cannot be mapped to value type", "Parsing stopped; unknown data type requested",
         "Unknown token during parsing JSON detected", "Unknown value type for number in JSON property",
         "Stream is not a valid archive file", "Unsupported strategy requested for key lookup", "Internal ERROR",
         "No huffman code table entry found for character",
         "Memory file was opened as read-only but requested a modification",
         "Unable to import json file: unsupported type", "Mode set to read-only but modification was requested",
         "Read outside of memory range bounds", "Slot management broken",
         "Thread run out of object ids: start another one", "JSON parsing ERROR",
         "Document insertion bulk creation failed", "File cannot be opened for writing",
         "Archive cannot be serialized into file", "Archive cannot be deserialized form file",
         "Unable to read from file", "Unable to perform full scan in archive file",
         "String decompression from archive failed", "Closing iterator failed",
         "Unable to construct a hard copy of the source object", "Memory reallocation failed",
         "Predicate evaluation failed", "Initialization failed",
         "Resource release failed: potentially a memory leak occurred", "Operation failed",
         "Rehashing hash table failed; rollback is not performed", "Unable to open memory file",
         "Value iterator cannot be initialized", "Memfile cannot skip desired amount of bytes",
         "Unable to seek in memory file", "Unable to get value: type is not non-array object",
         "Unable to get value: type is not non-array boolean", "Unable to get value: type is not non-array int8",
         "Unable to get value: type is not non-array int16", "Unable to get value: type is not non-array int32",
         "Unable to get value: type is not non-array int64", "Unable to get value: type is not non-array uint8",
         "Unable to get value: type is not non-array uint16", "Unable to get value: type is not non-array uint32",
         "Unable to get value: type is not non-array uint64", "Unable to get value: type is not non-array number",
         "Unable to get value: type is not non-array string_buffer",
         "Illegal state: iteration over object issued, but collection found",
         "Illegal state: iteration over collection issued, but object found", "Type mismatch detected",
         "Index is corrupted: requested offset is outside file bounds", "Temporary file cannot be opened for writing",
         "Unable to write to file", "Unable to deserialize hash table from file",
         "Unknown string_buffer dictionary implementation requested", "Stack overflow", "Stack underflow",
         "Object was modified but is out of date", "Object is currently being updated; no read allowed",
         "Illegal operation", "Unsupported type", "Unsupported container for data type",
         "Adding integers with this function will perform an auto casting to the smallest type required to store "
         "the integer value. Since you push integers with this function into an column container that is bound "
         "to a specific type, any insertion function call will fail once the integer value requires a larger "
         "(or smaller) type than the fist value added to the container. Use '*_insert_X' instead, where X is "
         "u8, u16,..., u32 resp. i8, i16,..., i32. ", "parsing ERROR dot ('.') expected",
         "parsing ERROR key name or array index expected", "parsing ERROR: unknown token",
         "dot-notated path could not be parsed", "Illegal state", "Unsupported data type", "Operation failed",
         "Cleanup operation failed; potentially a memory leak occurred", "dot-notated path could not be compiled",
         "not a number", "buffer capacity exceeded", "tailing junk was detected in a stream", "not indexed"};

#define ERRSTR_ILLEGAL_CODE "illegal ERROR code"

static const int global_nerr_str = ARRAY_LENGTH(global_err_str);

typedef struct err {
        int code;
        const char *file;
        u32 line;
        char *details;
} err;

bool error_init(err *err);

bool error_cpy(err *dst, const err *src);

bool error_drop(err *err);

bool error_set(err *err, int code, const char *file, u32 line);

bool error_set_wdetails(err *err, int code, const char *file, u32 line, const char *details);

bool error_set_no_abort(err *err, int code, const char *file, u32 line);

bool error_set_wdetails_no_abort(err *err, int code, const char *file, u32 line, const char *details);

bool error_str(const char **errstr, const char **file, u32 *line, bool *details, const char **detailsstr,
               const err *err);

bool error_print_to_stderr(const err *err);

bool error_print_and_abort(const err *err);

#define ERROR_OCCURED(x)                   ((x)->err.code != ERR_NOERR)

#define SUCCESS_ELSE_RETURN(expr, err, code, retval)                                                                   \
{                                                                                                                      \
        bool result = expr;                                                                                            \
        ERROR_IF(!(result), err, code);                                                                                \
        if (!(result)) { return retval; }                                                                              \
}

#define SUCCESS_ELSE_NULL(expr, err)           SUCCESS_ELSE_RETURN(expr, err, ERR_FAILED, NULL)
#define SUCCESS_ELSE_FAIL(expr, err)           SUCCESS_ELSE_RETURN(expr, err, ERR_FAILED, false)


#define ERROR(err, code)                     ERROR_IF (true, err, code)
#define ERROR_NO_ABORT(err, code)            ERROR_IF (true, err, code)
#define ERROR_IF(expr, err, code)            { if (expr) { error_set(err, code, __FILE__, __LINE__); } }
#define ERROR_IF_AND_RETURN(expr, err, code, retval) \
                                                    { if (expr) { error_set(err, code, __FILE__, __LINE__);            \
                                                                  return retval; } }

#define ERROR_IF_WDETAILS(expr, err, code, msg)            { if (expr) { ERROR_WDETAILS(err, code, msg); } }
#define ERROR_WDETAILS(err, code, msg)                     error_set_wdetails(err, code, __FILE__, __LINE__, msg);

#define ERROR_PRINT(code)                    ERROR_PRINT_IF(true, code)
#define ERROR_PRINT_AND_DIE(code)            { ERROR_PRINT(code); abort(); }
#define ERROR_PRINT_AND_DIE_IF(expr, code)   { if(expr) { ERROR_PRINT_AND_DIE(code) } }
#define ERROR_PRINT_IF(expr, code)                                                                                     \
{                                                                                                                      \
    if (expr) {                                                                                                        \
        err err;                                                                                                \
        error_init(&err);                                                                                              \
        ERROR(&err, code);                                                                                             \
        error_print_to_stderr(&err);                                                                                   \
    }                                                                                                                  \
}

#define DEFINE_ERROR_GETTER(type_tag_name)  DEFINE_GET_ERROR_FUNCTION(type_tag_name, struct type_tag_name, e)

#define DEFINE_GET_ERROR_FUNCTION(type_name, type, arg)                                                            \
FUNC_UNUSED static bool                                                                                            \
##type_name##_get_error(err *err, const type *arg)                                                                \
{                                                                                                                      \
    DEBUG_ERROR_IF_NULL(err)                                                                                                 \
    DEBUG_ERROR_IF_NULL(arg)                                                                                                 \
    error_cpy(err, &arg->err);                                                                                         \
    return true;                                                                                                       \
}

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef FORWDECL_H
#define FORWDECL_H

typedef struct allocator allocator;

typedef struct archive archive;
typedef struct archive_callback archive_callback;
typedef struct sid_cache_stats sid_cache_stats;
typedef struct archive_header archive_header;
typedef struct record_header record_header;
typedef struct object_header object_header;
typedef struct prop_header prop_header;
typedef union string_tab_flags string_tab_flags_u;
typedef struct string_table_header string_table_header;
typedef struct object_array_header object_array_header;
typedef struct column_group_header column_group_header;
typedef struct column_header column_header;
typedef union object_flags object_flags_u;
typedef struct archive_prop_offs archive_prop_offs;
typedef struct fixed_prop fixed_prop;
typedef struct table_prop table_prop;
typedef struct var_prop var_prop;
typedef struct array_prop array_prop;
typedef struct null_prop null_prop;
typedef struct record_flags record_flags;
typedef struct string_table string_table;
typedef struct record_table record_table;
typedef struct archive_info archive_info;
typedef struct string_entry_header string_entry_header;
typedef struct archive_io_context archive_io_context;
typedef struct archive_object archive_object;
typedef struct collection_iter_state collection_iter_state;
typedef struct archive_value_vector archive_value_vector;
typedef struct prop_iter prop_iter;
typedef struct independent_iter_state independent_iter_state;
typedef struct column_object_iter column_object_iter;
typedef struct string_pred string_pred;
typedef struct archive_query archive_query;
typedef struct strid_info strid_info;
typedef struct strid_iter strid_iter;
typedef struct path_entry path_entry;
typedef struct archive_visitor_desc archive_visitor_desc;
typedef struct archive_visitor archive_visitor;
typedef struct column_doc_column column_doc_column;
typedef struct column_doc_group column_doc_group;
typedef struct column_doc_obj column_doc_obj;
typedef struct column_doc column_doc;
typedef struct doc_entries doc_entries;
typedef struct doc_bulk doc_bulk;
typedef struct doc doc;
typedef struct doc_obj doc_obj;
typedef union encoded_doc_value encoded_doc_value_u;
typedef struct encoded_doc_prop_header encoded_doc_prop_header;
typedef struct encoded_doc_prop encoded_doc_prop;
typedef struct encoded_doc_prop_array encoded_doc_prop_array;
typedef struct encoded_doc encoded_doc;
typedef struct encoded_doc_list encoded_doc_list;

typedef struct err err;

typedef struct async_func_proxy async_func_proxy;
typedef struct filter_arg filter_arg;
typedef struct map_args map_args;
typedef struct gather_scatter_args gather_scatter_args;

typedef struct bitmap bitmap;

typedef struct carbon carbon;
typedef struct carbon_insert carbon_insert;
typedef struct carbon_new carbon_new;
typedef struct field_access field_access;
typedef struct carbon_array_it carbon_array_it;
typedef struct carbon_column_it carbon_column_it;
typedef struct carbon_dot_node carbon_dot_node;
typedef struct carbon_dot_path carbon_dot_path;
typedef struct carbon_find carbon_find;
typedef struct carbon_insert_array_state carbon_insert_array_state;
typedef struct carbon_insert_object_state carbon_insert_object_state;
typedef struct carbon_insert_column_state carbon_insert_column_state;
typedef struct carbon_object_it carbon_object_it;
typedef struct carbon_path_evaluator carbon_path_evaluator;
typedef struct carbon_path_index carbon_path_index;
typedef struct carbon_path_index_it carbon_path_index_it;
typedef struct carbon_printer carbon_printer;
typedef struct carbon_revise carbon_revise;
typedef struct carbon_binary carbon_binary;
typedef struct carbon_update carbon_update;
typedef struct packer packer;

typedef struct hashset_bucket hashset_bucket;
typedef struct hashset hashset;
typedef struct hashtable_bucket hashtable_bucket;
typedef struct hashtable hashtable;
typedef struct huffman huffman;
typedef struct pack_huffman_entry pack_huffman_entry;
typedef struct pack_huffman_info pack_huffman_info;
typedef struct pack_huffman_str_info pack_huffman_str_info;

typedef struct json_token json_token;
typedef struct json_err json_err;
typedef struct json_tokenizer json_tokenizer;
typedef struct json_parser json_parser;
typedef struct json json;
typedef struct json_node_value json_node_value;
typedef struct json_object json_object;
typedef struct json_element json_element;
typedef struct json_string json_string;
typedef struct json_prop json_prop;
typedef struct json_members json_members;
typedef struct json_elements json_elements;
typedef struct json_array json_array;
typedef struct json_number json_number;

typedef struct memblock memblock;
typedef struct memfile memfile;

typedef struct command_opt command_opt;
typedef struct command_opt_group command_opt_group;
typedef struct command_opt_mgr command_opt_mgr;

typedef struct priority_queue_element_info priority_queue_element_info;
typedef struct priority_queue priority_queue;

typedef struct slice slice;
typedef struct hash_bounds hash_bounds;
typedef struct slice_descriptor slice_descriptor;
typedef struct slice_list slice_list;
typedef struct slice_handle slice_handle;

typedef struct spinlock spinlock;

typedef struct vector vector;

typedef struct str_hash str_hash;
typedef struct str_hash_counters str_hash_counters;

typedef struct string_buffer string_buffer;

typedef struct string_dict string_dict;

typedef struct thread_task thread_task;
typedef struct task_state task_state;
typedef struct task_handle task_handle;
typedef struct thread_pool thread_pool;
typedef struct thread_info thread_info;
typedef struct thread_pool_stats thread_pool_stats;
typedef struct thread_stats thread_stats;
typedef struct task_stats task_stats;

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef HASH_H
#define HASH_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>

BEGIN_DECL

typedef u8 hash8_t;
typedef u16 hash16_t;
typedef u32 hash32_t;
typedef u64 hash64_t;

#define HASH_ADDITIVE(key_size, key)                                                                               \
({                                                                                                                     \
    hash32_t hash = 0;                                                                                                 \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash += ((unsigned char* )key)[i];                                                                             \
    }                                                                                                                  \
    hash;                                                                                                              \
})

#define HASH_BERNSTEIN(key_size, key)        HASH_BERNSTEIN_WTYPE(key_size, key, hash32_t)
#define HASH8_BERNSTEIN(key_size, key)       HASH_BERNSTEIN_WTYPE(key_size, key, hash8_t)
#define HASH16_BERNSTEIN(key_size, key)      HASH_BERNSTEIN_WTYPE(key_size, key, hash16_t)
#define HASH64_BERNSTEIN(key_size, key)        HASH_BERNSTEIN_WTYPE(key_size, key, hash64_t)

#define HASH_BERNSTEIN_WTYPE(key_size, key, hash_type)                                                             \
({                                                                                                                     \
    JAK_ASSERT ((key != NULL) && (key_size > 0));                                                                          \
                                                                                                                       \
    hash_type hash = 0;                                                                                                \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash ^= 33 * hash + ((unsigned char* )key)[i];                                                                 \
    }                                                                                                                  \
    hash;                                                                                                              \
})

#define HASH64_BERNSTEIN_WSEED(key_size, key, seed)                                                                \
({                                                                                                                     \
    JAK_ASSERT ((key != NULL) && (key_size > 0));                                                                          \
                                                                                                                       \
    hash64_t hash = seed;                                                                                              \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash ^= 33 * hash + ((unsigned char* )key)[i];                                                                 \
    }                                                                                                                  \
    hash;                                                                                                              \
})

#define HASH_BERNSTEIN2(key_size, key)                                                                             \
({                                                                                                                     \
    JAK_ASSERT ((key != NULL) && (key_size > 0));                                                                          \
                                                                                                                       \
    hash32_t hash = 0;                                                                                                 \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash ^= 33 * hash ^ ((unsigned char* )key)[i];                                                                 \
    }                                                                                                                  \
    hash;                                                                                                              \
})

#define HASH_ELF(key_size, key)                                                                                    \
({                                                                                                                     \
    JAK_ASSERT ((key != NULL) && (key_size > 0));                                                                          \
                                                                                                                       \
    hash32_t hash = 0, g;                                                                                              \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash = (hash << 4) + ((unsigned char* )key)[i];                                                                \
        if ((g = hash & 0xf0000000L) != 0) {                                                                           \
            hash ^= g >> 24;                                                                                           \
        }                                                                                                              \
        hash &= ~g;                                                                                                    \
    }                                                                                                                  \
    hash;                                                                                                              \
})

#define HASH8_FNV(key_size, key)             HASH_FNV_WTYPE(key_size, key, hash8_t)
#define HASH16_FNV(key_size, key)            HASH_FNV_WTYPE(key_size, key, hash16_t)
#define HASH_FNV(key_size, key)              HASH_FNV_WTYPE(key_size, key, hash32_t)
#define HASH64_FNV(key_size, key)              HASH_FNV_WTYPE(key_size, key, hash64_t)

#define HASH_FNV_WTYPE(key_size, key, hash_type)                                                                   \
({                                                                                                                     \
    JAK_ASSERT ((key != NULL) && (key_size > 0));                                                                          \
                                                                                                                       \
    hash_type hash = (hash_type) 2166136261;                                                                           \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash = (hash * 16777619) ^ ((unsigned char* )key)[i];                                                          \
    }                                                                                                                  \
    hash;                                                                                                              \
})

#define JENKINS_MIX(a, b, c)                                                                                       \
{                                                                                                                      \
    a -= b; a -= c; a ^= (c >> 13);                                                                                    \
    b -= c; b -= a; b ^= (a << 8);                                                                                     \
    c -= a; c -= b; c ^= (b >> 13);                                                                                    \
    a -= b; a -= c; a ^= (c >> 12);                                                                                    \
    b -= c; b -= a; b ^= (a << 16);                                                                                    \
    c -= a; c -= b; c ^= (b >> 5);                                                                                     \
    a -= b; a -= c; a ^= (c >> 3);                                                                                     \
    b -= c; b -= a; b ^= (a << 10);                                                                                    \
    c -= a; c -= b; c ^= (b >> 15);                                                                                    \
}

/** implements: hash32_t hash_jenkins(size_t key_size, const void *key) */
#define HASH_JENKINS(keySizeIn, key)                                                                               \
({                                                                                                                     \
    size_t key_size = keySizeIn;                                                                                       \
    JAK_ASSERT ((key != NULL) && (key_size > 0));                                                                          \
                                                                                                                       \
    unsigned a, b;                                                                                                     \
    unsigned c = 0;                                                                                                    \
    unsigned char *k = (unsigned char *) key;                                                                          \
                                                                                                                       \
    a = b = 0x9e3779b9;                                                                                                \
                                                                                                                       \
    while (key_size >= 12) {                                                                                           \
        a += (k[0] + ((unsigned)k[1] << 8) + ((unsigned)k[2] << 16) + ((unsigned)k[3] << 24));                         \
        b += (k[4] + ((unsigned)k[5] << 8) + ((unsigned)k[6] << 16) + ((unsigned)k[7] << 24));                         \
        c += (k[8] + ((unsigned)k[9] << 8) + ((unsigned)k[10] << 16) + ((unsigned)k[11] << 24));                       \
        JENKINS_MIX(a, b, c);                                                                                      \
        k += 12;                                                                                                       \
        key_size -= 12;                                                                                                \
    }                                                                                                                  \
                                                                                                                       \
    c += key_size;                                                                                                     \
                                                                                                                       \
    switch (key_size) {                                                                                                \
        case 11: c += ((unsigned)k[10] << 24); break;                                                                  \
        case 10: c += ((unsigned)k[9] << 16); break;                                                                   \
        case 9: c += ((unsigned)k[8] << 8); break;                                                                     \
        case 8: b += ((unsigned)k[7] << 24); break;                                                                    \
        case 7: b += ((unsigned)k[6] << 16); break;                                                                    \
        case 6: b += ((unsigned)k[5] << 8); break;                                                                     \
        case 5: b += k[4]; break;                                                                                      \
        case 4: a += ((unsigned)k[3] << 24); break;                                                                    \
        case 3: a += ((unsigned)k[2] << 16); break;                                                                    \
        case 2: a += ((unsigned)k[1] << 8); break;                                                                     \
        case 1: a += k[0]; break;                                                                                      \
    }                                                                                                                  \
    JENKINS_MIX(a, b, c);                                                                                          \
    c;                                                                                                                 \
})

#define HASH_OAT(key_size, key)                                                                                    \
({                                                                                                                     \
    JAK_ASSERT ((key != NULL) && (key_size > 0));                                                                          \
                                                                                                                       \
    hash32_t hash = 0;                                                                                                 \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash += ((unsigned char* )key)[i];                                                                             \
        hash += (hash << 10);                                                                                          \
        hash ^= (hash >> 6);                                                                                           \
    }                                                                                                                  \
                                                                                                                       \
    hash += (hash << 3);                                                                                               \
    hash ^= (hash >> 11);                                                                                              \
    hash += (hash << 15);                                                                                              \
                                                                                                                       \
    hash;                                                                                                              \
})

#define HASH_ROT(key_size, key)                                                                                    \
({                                                                                                                     \
    hash32_t hash = 0;                                                                                                 \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash ^= (hash << 4) ^ (hash >> 28) ^ ((unsigned char* )key)[i];                                                \
    }                                                                                                                  \
    hash;                                                                                                              \
})

#define HASH_SAX(key_size, key)                                                                                    \
({                                                                                                                     \
    hash32_t hash = 0;                                                                                                 \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash ^= (hash << 5) + (hash >> 2) + ((unsigned char* )key)[i];                                                 \
    }                                                                                                                  \
    hash;                                                                                                              \
})

#define HASH_XOR(key_size, key)                                                                                    \
({                                                                                                                     \
    hash32_t hash = 0;                                                                                                 \
    for (size_t i = 0; i < key_size; i++) {                                                                            \
        hash ^= ((unsigned char* )key)[i];                                                                             \
    }                                                                                                                  \
    hash;                                                                                                              \
})

END_DECL

#endif/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef HASHTEST_H
#define HASHTEST_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>
#include <spinlock.h>

BEGIN_DECL

typedef struct hashset_bucket {
        bool in_use_flag;  /* flag indicating if bucket is in use */
        i32 displacement; /* difference between intended position during insert, and actual position in table */
        u64 key_idx;      /* position of key element in owning hashset structure */
} hashset_bucket;

/**
 * Hashset implementation specialized for key of fixed-length size, and where comparision
 * for equals is byte-compare. With this, calling a (type-dependent) compare function becomes obsolete.
 *
 * Example: u64.
 *
 * This hashset is optimized to reduce access time to elements. Internally, a robin-hood hashing technique is used.
 *
 * Note: this implementation does not support string_buffer or pointer types. The structure is thread-safe by a spinlock
 * lock implementation.
 */
typedef struct hashset {
        vector key_data;
        vector ofType(hashset_bucket) table;
        spinlock lock;
        u32 size;
        err err;
} hashset;

DEFINE_GET_ERROR_FUNCTION(hashset, hashset, set);

bool hashset_create(hashset *map, err *err, size_t key_size, size_t capacity);
hashset *hashset_cpy(hashset *src);
bool hashset_drop(hashset *map);

vector *hashset_keys(hashset *map);
bool hashset_clear(hashset *map);
bool hashset_avg_displace(float *displace, const hashset *map);
bool hashset_lock(hashset *map);
bool hashset_unlock(hashset *map);
bool hashset_insert_or_update(hashset *map, const void *keys, uint_fast32_t num_pairs);
bool hashset_remove_if_contained(hashset *map, const void *keys, size_t num_pairs);
bool hashset_contains_key(hashset *map, const void *key);
bool hashset_get_load_factor(float *factor, hashset *map);
bool hashset_rehash(hashset *map);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef HAHSTABLE_H
#define HAHSTABLE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>
#include <spinlock.h>

BEGIN_DECL

typedef struct hashtable_bucket {
        bool in_use_flag;  /* flag indicating if bucket is in use */
        i32 displacement; /* difference between intended position during insert, and actual position in table */
        u32 num_probs;    /* number of probe calls to this bucket */
        u64 data_idx;      /* position of key element in owning hashtable structure */
} hashtable_bucket;

/**
 * Hash table implementation specialized for key and value types of fixed-length size, and where comparision
 * for equals is byte-compare. With this, calling a (type-dependent) compare function becomes obsolete.
 *
 * Example: mapping of u64 to u32.
 *
 * This hash table is optimized to reduce access time to elements. Internally, a robin-hood hashing technique is used.
 *
 * Note: this implementation does not support string_buffer or pointer types. The structure is thread-safe by a spinlock
 * lock implementation.
 */
typedef struct hashtable {
        vector key_data;
        vector value_data;
        vector ofType(hashtable_bucket) table;
        spinlock lock;
        u32 size;
        err err;
} hashtable;

DEFINE_GET_ERROR_FUNCTION(hashtable, hashtable, table);

bool hashtable_create(hashtable *map, err *err, size_t key_size, size_t value_size, size_t capacity);
hashtable *hashtable_cpy(hashtable *src);
bool hashtable_drop(hashtable *map);

bool hashtable_clear(hashtable *map);
bool hashtable_avg_displace(float *displace, const hashtable *map);
bool hashtable_lock(hashtable *map);
bool hashtable_unlock(hashtable *map);
bool hashtable_insert_or_update(hashtable *map, const void *keys, const void *values, uint_fast32_t num_pairs);
bool hashtable_serialize(FILE *file, hashtable *table);
bool hashtable_deserialize(hashtable *table, err *err, FILE *file);
bool hashtable_remove_if_contained(hashtable *map, const void *keys, size_t num_pairs);
const void *hashtable_get_value(hashtable *map, const void *key);
bool hashtable_get_load_factor(float *factor, hashtable *map);
bool hashtable_rehash(hashtable *map);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef HUFFMAN_H
#define HUFFMAN_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>
#include <memfile.h>
#include <types.h>

BEGIN_DECL

typedef struct huffman {
        vector ofType(pack_huffman_entry) table;
        err err;
} huffman;

typedef struct pack_huffman_entry {
        unsigned char letter;
        u32 *blocks;
        u16 nblocks;
} pack_huffman_entry;

typedef struct pack_huffman_info {
        unsigned char letter;
        u8 nbytes_prefix;
        char *prefix_code;
} pack_huffman_info;

typedef struct pack_huffman_str_info {
        u32 nbytes_encoded;
        const char *encoded_bytes;
} pack_huffman_str_info;

bool coding_huffman_create(huffman *dic);
bool coding_huffman_cpy(huffman *dst, huffman *src);
bool coding_huffman_drop(huffman *dic);

bool coding_huffman_build(huffman *encoder, const string_vector_t *strings);
bool coding_huffman_get_error(err *err, const huffman *dic);
bool coding_huffman_encode(memfile *file, huffman *dic, const char *string_buffer);
bool coding_huffman_read_string(pack_huffman_str_info *info, memfile *src);
bool coding_huffman_serialize(memfile *file, const huffman *dic, char marker_symbol);
bool coding_huffman_read_entry(pack_huffman_info *info, memfile *file, char marker_symbol);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef JSON_H
#define JSON_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>

BEGIN_DECL

typedef enum json_token_type {
        OBJECT_OPEN,
        OBJECT_CLOSE,
        LITERAL_STRING,
        LITERAL_INT,
        LITERAL_FLOAT,
        LITERAL_TRUE,
        LITERAL_FALSE,
        LITERAL_NULL,
        COMMA,
        ASSIGN,
        ARRAY_OPEN,
        ARRAY_CLOSE,
        JSON_UNKNOWN
} json_token_e;

typedef struct json_token {
        json_token_e type;
        const char *string_buffer;
        unsigned line;
        unsigned column;
        unsigned length;
} json_token;

typedef struct json_err {
        const json_token *token;
        const char *token_type_str;
        const char *msg;
} json_err;

typedef struct json_tokenizer {
        const char *cursor;
        json_token token;
        err err;
} json_tokenizer;

typedef struct json_parser {
        json_tokenizer tokenizer;
        err err;
} json_parser;

typedef enum json_parent {
        JSON_PARENT_OBJECT, JSON_PARENT_MEMBER, JSON_PARENT_ELEMENTS
} json_parent_e;

typedef enum json_value_type_e {
        JSON_VALUE_OBJECT,
        JSON_VALUE_ARRAY,
        JSON_VALUE_STRING,
        JSON_VALUE_NUMBER,
        JSON_VALUE_TRUE,
        JSON_VALUE_FALSE,
        JSON_VALUE_NULL
} json_value_type_e;

typedef enum json_list_type_e {
        JSON_LIST_EMPTY,
        JSON_LIST_VARIABLE_OR_NESTED,
        JSON_LIST_FIXED_U8,
        JSON_LIST_FIXED_U16,
        JSON_LIST_FIXED_U32,
        JSON_LIST_FIXED_U64,
        JSON_LIST_FIXED_I8,
        JSON_LIST_FIXED_I16,
        JSON_LIST_FIXED_I32,
        JSON_LIST_FIXED_I64,
        JSON_LIST_FIXED_FLOAT,
        JSON_LIST_FIXED_NULL,
        JSON_LIST_FIXED_BOOLEAN
} json_list_type_e;

typedef struct json {
        json_element *element;
        err err;
} json;

typedef struct json_node_value {
        json_element *parent;
        json_value_type_e value_type;
        union {
                json_object *object;
                json_array *array;
                json_string *string_buffer;
                json_number *number;
                void *ptr;
        } value;
} json_node_value;

typedef struct json_object {
        json_node_value *parent;
        json_members *value;
} json_object;

typedef struct json_element {
        json_parent_e parent_type;
        union {
                json *json;
                json_prop *member;
                json_elements *elements;
                void *ptr;
        } parent;
        json_node_value value;
} json_element;

typedef struct json_string {
        json_prop *parent;
        char *value;
} json_string;

typedef struct json_prop {
        json_members *parent;
        json_string key;
        json_element value;
} json_prop;

typedef struct json_members {
        json_object *parent;
        vector ofType(json_prop) members;
} json_members;

typedef struct json_elements {
        json_array *parent;
        vector ofType(json_element) elements;
} json_elements;

typedef struct json_array {
        json_node_value *parent;
        json_elements elements;
} json_array;

typedef enum json_number_type {
        JSON_NUMBER_FLOAT, JSON_NUMBER_UNSIGNED, JSON_NUMBER_SIGNED
} json_number_type_e;

typedef struct json_number {
        json_node_value *parent;
        json_number_type_e value_type;
        union {
                float float_number;
                i64 signed_integer;
                u64 unsigned_integer;
        } value;
} json_number;

bool json_tokenizer_init(json_tokenizer *tokenizer, const char *input);
const json_token *json_tokenizer_next(json_tokenizer *tokenizer);
void json_token_dup(json_token *dst, const json_token *src);
void json_token_print(FILE *file, const json_token *token);
bool json_parser_create(json_parser *parser);
bool json_parse(json *json, json_err *error_desc, json_parser *parser, const char *input);
bool json_test(err *err, json *json);
bool json_drop(json *json);
bool json_print(FILE *file, json *json);
bool json_list_is_empty(const json_elements *elements);
bool json_list_length(u32 *len, const json_elements *elements);
json_list_type_e json_fitting_type(json_list_type_e current, json_list_type_e to_add);
bool json_array_get_type(json_list_type_e *type, const json_array *array);

DEFINE_GET_ERROR_FUNCTION(json, json, json);

END_DECL

#endif/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef JSON_COMPACT_PRINTER_H
#define JSON_COMPACT_PRINTER_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jakson/carbon/printers.h>

bool json_compact_printer_create(carbon_printer *printer);

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef JSON_EXTENDED_PRINTER_H
#define JSON_EXTENDED_PRINTER_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jakson/carbon/printers.h>

bool json_extended_printer_create(carbon_printer *printer);

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef MEMBLOCK_H
#define MEMBLOCK_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>

BEGIN_DECL

bool memblock_create(memblock **block, size_t size);
bool memblock_drop(memblock *block);

bool memblock_from_file(memblock **block, FILE *file, size_t nbytes);

bool memblock_get_error(err *out, memblock *block);

bool memblock_zero_out(memblock *block);
bool memblock_size(offset_t *size, const memblock *block);
offset_t memblock_last_used_byte(const memblock *block);
bool memblock_write_to_file(FILE *file, const memblock *block);
const char *memblock_raw_data(const memblock *block);
bool memblock_resize(memblock *block, size_t size);
bool memblock_write(memblock *block, offset_t position, const char *data, offset_t nbytes);
bool memblock_cpy(memblock **dst, memblock *src);
bool memblock_shrink(memblock *block);
bool memblock_move_right(memblock *block, offset_t where, size_t nbytes);
bool memblock_move_left(memblock *block, offset_t where, size_t nbytes);
bool memblock_move_ex(memblock *block, offset_t where, size_t nbytes, bool zero_out);
void *memblock_move_contents_and_drop(memblock *block);
bool memfile_update_last_byte(memblock *block, size_t where);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef MEMFILE_H
#define MEMFILE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <string_buffer.h>
#include <utils_hexdump.h>
#include <memblock.h>

BEGIN_DECL

typedef struct memfile {
        memblock *memblock;
        offset_t pos;
        offset_t saved_pos[10];
        i8 saved_pos_ptr;
        bool bit_mode;
        size_t current_read_bit, current_write_bit, bytes_completed;
        access_mode_e mode;
        err err;
} memfile;

#define MEMFILE_PEEK(file, type)                                                                                   \
({                                                                                                                     \
    JAK_ASSERT (memfile_remain_size(file) >= sizeof(type));                                                                \
    (type*) memfile_peek(file, sizeof(type));                                                                          \
})

#define MEMFILE_READ_TYPE(file, type)                                                                              \
({                                                                                                                     \
    JAK_ASSERT (memfile_remain_size(file) >= sizeof(type));                                                                \
    (type*) memfile_read(file, sizeof(type));                                                                          \
})

#define MEMFILE_READ_TYPE_LIST(file, type, how_many)                                                               \
    (const type *) MEMFILE_READ(file, how_many * sizeof(type))

#define MEMFILE_READ(file, nbytes)                                                                                 \
({                                                                                                                     \
    JAK_ASSERT (memfile_remain_size(file) >= nbytes);                                                                      \
    memfile_read(file, nbytes);                                                                                        \
})

#define memfile_tell(file)                                                                                             \
({                                                                                                                     \
    offset_t offset = 0;                                                                                               \
    memfile_get_offset(&offset, file);                                                                                 \
    offset;                                                                                                            \
})

bool memfile_open(memfile *file, memblock *block, access_mode_e mode);
bool memfile_clone(memfile *dst, memfile *src);

bool memfile_seek(memfile *file, offset_t pos);
bool memfile_seek_from_here(memfile *file, signed_offset_t where);
bool memfile_rewind(memfile *file);
bool memfile_grow(memfile *file_in, size_t grow_by_bytes);
bool memfile_get_offset(offset_t *pos, const memfile *file);
size_t memfile_size(memfile *file);
bool memfile_cut(memfile *file, size_t how_many_bytes);
size_t memfile_remain_size(memfile *file);
bool memfile_shrink(memfile *file);
const char *memfile_read(memfile *file, offset_t nbytes);
u8 memfile_read_byte(memfile *file);
u8 memfile_peek_byte(memfile *file);
u64 memfile_read_u64(memfile *file);
i64 memfile_read_i64(memfile *file);
bool memfile_skip(memfile *file, signed_offset_t nbytes);
#define MEMFILE_SKIP_BYTE(file) memfile_skip(file, sizeof(u8))
const char *memfile_peek(memfile *file, offset_t nbytes);
bool memfile_write_byte(memfile *file, u8 data);
bool memfile_write(memfile *file, const void *data, offset_t nbytes);
bool memfile_write_zero(memfile *file, size_t how_many);
bool memfile_begin_bit_mode(memfile *file);
bool memfile_write_bit(memfile *file, bool flag);
bool memfile_read_bit(memfile *file);
offset_t memfile_save_position(memfile *file);
bool memfile_restore_position(memfile *file);
signed_offset_t memfile_ensure_space(memfile *memfile, u64 nbytes);
u64 memfile_read_uintvar_stream(u8 *nbytes, memfile *memfile);
bool memfile_skip_uintvar_stream(memfile *memfile);
u64 memfile_peek_uintvar_stream(u8 *nbytes, memfile *memfile);
u64 memfile_write_uintvar_stream(u64 *nbytes_moved, memfile *memfile, u64 value);
signed_offset_t memfile_update_uintvar_stream(memfile *memfile, u64 value);
bool memfile_seek_to_start(memfile *file);
bool memfile_seek_to_end(memfile *file);

/**
 * Moves the contents of the underlying memory block <code>nbytes</code> towards the end of the file.
 * The offset in the memory block from where this move is done is the current position stored in this file.
 * In case of not enough space, the underlying memory block is resized.
 */
bool memfile_inplace_insert(memfile *file, size_t nbytes);
bool memfile_inplace_remove(memfile *file, size_t nbytes_from_here);
bool memfile_end_bit_mode(size_t *num_bytes_written, memfile *file);
void *memfile_current_pos(memfile *file, offset_t nbytes);
bool memfile_hexdump(string_buffer *sb, memfile *file);
bool memfile_hexdump_printf(FILE *file, memfile *memfile);
bool memfile_hexdump_print(memfile *memfile);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef OPT_H
#define OPT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>

typedef struct command_opt {
        char *opt_name;
        char *opt_desc;
        char *opt_manfile;
        int (*callback)(int argc, char **argv, FILE *file);
} command_opt;

typedef struct command_opt_group {
        vector ofType(command_opt) cmd_options;
        char *desc;
} command_opt_group;

typedef enum module_arg_policy {
        MOD_ARG_REQUIRED, MOD_ARG_NOT_REQUIRED, MOD_ARG_MAYBE_REQUIRED,
} module_arg_policy;

typedef struct command_opt_mgr {
        vector ofType(command_opt_group) groups;
        module_arg_policy policy;
        bool (*fallback)(int argc, char **argv, FILE *file, command_opt_mgr *manager);
        char *module_name;
        char *module_desc;
} command_opt_mgr;

bool opt_manager_create(command_opt_mgr *manager, char *module_name, char *module_desc, module_arg_policy policy, bool (*fallback)(int argc, char **argv, FILE *file, command_opt_mgr *manager));
bool opt_manager_drop(command_opt_mgr *manager);

bool opt_manager_process(command_opt_mgr *manager, int argc, char **argv, FILE *file);
bool opt_manager_create_group(command_opt_group **group, const char *desc, command_opt_mgr *manager);
bool opt_group_add_cmd(command_opt_group *group, const char *opt_name, char *opt_desc, char *opt_manfile, int (*callback)(int argc, char **argv, FILE *file));
bool opt_manager_show_help(FILE *file, command_opt_mgr *manager);

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef PACK_H
#define PACK_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <pack_none.h>
#include <pack_huffman.h>
#include <huffman.h>
#include <stdinc.h>
#include <types.h>

BEGIN_DECL

/**
 * Unique tag identifying a specific implementation for compressing/decompressing string_buffer in a CARBON archives
 * string_buffer table.
 */
typedef enum packer_e {
        PACK_NONE, PACK_HUFFMAN
} packer_e;

/**
 * Main interface for the compressor framework. A compressor is used to encode/decode strings stored in a
 * CARBON archive.
 */
typedef struct packer {
        /** Tag identifying the implementation of this compressor */
        packer_e tag;

        /** Implementation-specific storage */
        void *extra;

        /**
         * Constructor for implementation-dependent initialization of the compressor at hand.
         *
         * Depending on the implementation, the compressor might allocate dynamic memory for
         * <code>extra</code> for book-keeping purposes.
         *
         * @param self A pointer to itself
         * @return <b>true</b> in case of success, or <b>false</b> otherwise.
         *
         * @author Marcus Pinnecke
         * @since 0.1.00.05
         */
        bool (*create)(packer *self);

        /**
         * Destructor for implementation-dependent deinitialization of the compressor at hand.
         *
         * If the implementation acquired dynamic memory during a call to <code>create</code>,
         * a call to this function frees up this memory.
         *
         * @param self A pointer to itself
         * @return <b>true</b> in case of success, or <b>false</b> otherwise.
         *
         * @author Marcus Pinnecke
         * @since 0.1.00.05
         */
        bool (*drop)(packer *self);

        /**
         * Perform a hard-copy of this compressor to dst
         *
         * @param self  A pointer to itself
         * @param dst   A pointer to the copy target
         *
         * @return <b>true</b> in case of success, or <b>false</b> otherwise.
         *
         * @author Marcus Pinnecke
         * @since 0.1.00.05
         */
        bool (*cpy)(const packer *self, packer *dst);

        /**
         * Function to construct and serialize an implementation-specific dictionary, book-keeping data, or extra data
         * (e.g., a code table)
         *
         * Depending on the implementation, a set of book-keeping data must be managed for a compressor. For instance,
         * in case of a huffman encoded this book-keeping is the code table that maps letters to prefix codes. This
         * function is invoked before any string_buffer gets encoded, and implements a compressor-specific management and
         * serialization of that book-keeping data. After internal construction of this book-keeping data,
         * this data is serialized into the <code>dst</code> parameter.
         *
         * Reverse function of <code>read_extra</code>.
         *
         * @note single strings must not be encoded; this is is done when the framework invokes <code>encode_string</code>
         *
         * @param self A pointer to the compressor that is used; maybe accesses <code>extra</code>
         * @param dst A memory file in which the book-keeping data (<code>extra</code>) for this compressor is serialized
         * @param strings The set of all strings that should be encoded. Used for tweaking the compressor;
         *                 <b>not</b> for serialization into <code>dst</code>
         *
         * @note strings in <code>strings</code> are unique (but not sorted)
         *
         * @author Marcus Pinnecke
         * @since 0.1.00.05
         * */
        bool (*write_extra)(packer *self, memfile *dst,
                            const vector ofType (const char *) *strings);

        /**
         * Function to reconstruct implementation-specific dictionary, book-keeping or extra data by deserialization (
         * e.g., a code table)
         *
         * Reverse function of <code>write_extra</code>.
         *
         * @param self A pointer to the compressor that is used; maybe accesses <code>extra</code>
         * @param src A file where the cursor is moved to the first byte of the extra field previously serialized with 'write_extra'
         * @param nbytes Number of bytes written when 'write_extra' was called. Intended to read read to restore the extra field.
         * @return The implementer must return <code>true</code> on success, and <code>false</code> otherwise.
         */
        bool (*read_extra)(packer *self, FILE *src, size_t nbytes);

        /**
         * Encodes an input string_buffer and writes its encoded version into a memory file.
         *
         * @param self A pointer to the compressor that is used; maybe accesses <code>extra</code>
         * @param dst A memory file in which the encoded string_buffer should be stored
         * @param err An ERROR information
         * @param string_buffer The string_buffer that should be encoded
         *
         * @return <b>true</b> in case of success, or <b>false</b> otherwise.
         *
         * @author Marcus Pinnecke
         * @since 0.1.00.05
         */
        bool
        (*encode_string)(packer *self, memfile *dst, err *err, const char *string_buffer);

        bool (*decode_string)(packer *self, char *dst, size_t strlen, FILE *src);

        /**
         * Reads implementation-specific book-keeping, meta or extra data from the input memory file and
         * prints its contents in a human-readable version to <code>file</code>
         *
         * @param self A pointer to the compressor that is used; potentially accessing <code>extra</code>
         * @param file A file to which a human-readable version of <code>extra</code> is printed (if any)
         * @param src A memory file which cursor is positioned at the begin of the serialized extra field. After
         *            a call to this function, the memory file cursor must be positioned after the serialized extra
         *            field (i.e., the entire entry must be read (if any))
         *
         * @return <b>true</b> in case of success, or <b>false</b> otherwise.
         *
         * @author Marcus Pinnecke
         * @since 0.1.00.05
         */
        bool (*print_extra)(packer *self, FILE *file, memfile *src);

        /**
         * Reads an implementation-specific encoded string_buffer from a memory file <code>src</code>, and prints
         * the encoded string_buffer in a human-readable version to <code>file</code>
         *
         * @param self A pointer to the compressor that is used; potentially accessing <code>extra</code>
         * @param file A file to which a human-readable version of the encoded string_buffer is printed.
         * @param src A memory file which cursor is positioned at the begin of the encoded string_buffer. After a call
         *            to this function, the memory file cursor must be positioned after the encoded string_buffer (i.e.,
         *            the entire encoded string_buffer must be read)
         * @param decompressed_strlen The length of the decoded string_buffer in number of characters
         *
         * @return <b>true</b> in case of success, or <b>false</b> otherwise.
         *
         * @author Marcus Pinnecke
         * @since 0.1.00.05
         */
        bool
        (*print_encoded)(packer *self, FILE *file, memfile *src, u32 decompressed_strlen);
} packer;

static void pack_none_create(packer *strategy)
{
        strategy->tag = PACK_NONE;
        strategy->create = pack_none_init;
        strategy->cpy = pack_none_cpy;
        strategy->drop = pack_none_drop;
        strategy->write_extra = pack_none_write_extra;
        strategy->read_extra = pack_none_read_extra;
        strategy->encode_string = pack_none_encode_string;
        strategy->decode_string = pack_none_decode_string;
        strategy->print_extra = pack_none_print_extra;
        strategy->print_encoded = pack_none_print_encoded_string;
}

static void pack_huffman_create(packer *strategy)
{
        strategy->tag = PACK_HUFFMAN;
        strategy->create = pack_huffman_init;
        strategy->cpy = pack_coding_huffman_cpy;
        strategy->drop = pack_coding_huffman_drop;
        strategy->write_extra = pack_huffman_write_extra;
        strategy->read_extra = pack_huffman_read_extra;
        strategy->encode_string = pack_huffman_encode_string;
        strategy->decode_string = pack_huffman_decode_string;
        strategy->print_extra = pack_huffman_print_extra;
        strategy->print_encoded = pack_huffman_print_encoded;
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"

static struct {
        packer_e type;
        const char *name;
        void (*create)(packer *strategy);
        u8 flag_bit;
} global_pack_strategy_register[] =
        {{.type = PACK_NONE, .name = "none", .create = pack_none_create, .flag_bit = 1 << 0},
         {.type = PACK_HUFFMAN, .name = "huffman", .create = pack_huffman_create, .flag_bit = 1 << 1}};

#pragma GCC diagnostic pop

bool pack_cpy(err *err, packer *dst, const packer *src);
bool pack_drop(err *err, packer *self);

bool pack_by_type(err *err, packer *strategy, packer_e type);
u8 pack_flagbit_by_type(packer_e type);
bool pack_by_flags(packer *strategy, u8 flags);
bool pack_by_name(packer_e *type, const char *name);

bool pack_write_extra(err *err, packer *self, memfile *dst, const vector ofType (const char *) *strings);
bool pack_read_extra(err *err, packer *self, FILE *src, size_t nbytes);
bool pack_encode(err *err, packer *self, memfile *dst, const char *string_buffer);
bool pack_decode(err *err, packer *self, char *dst, size_t strlen, FILE *src);
bool pack_print_extra(err *err, packer *self, FILE *file, memfile *src);
bool pack_print_encoded(err *err, packer *self, FILE *file, memfile *src, u32 decompressed_strlen);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef COMPRESSOR_HUFFMAN_H
#define COMPRESSOR_HUFFMAN_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>
#include <memfile.h>

BEGIN_DECL

bool pack_huffman_init(packer *self);
bool pack_coding_huffman_cpy(const packer *self, packer *dst);
bool pack_coding_huffman_drop(packer *self);
bool pack_huffman_write_extra(packer *self, memfile *dst, const vector ofType (const char *) *strings);
bool pack_huffman_read_extra(packer *self, FILE *src, size_t nbytes);
bool pack_huffman_print_extra(packer *self, FILE *file, memfile *src);
bool pack_huffman_print_encoded(packer *self, FILE *file, memfile *src, u32 decompressed_strlen);
bool pack_huffman_encode_string(packer *self, memfile *dst, err *err, const char *string_buffer);
bool pack_huffman_decode_string(packer *self, char *dst, size_t strlen, FILE *src);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef COMPRESSOR_NONE_H
#define COMPRESSOR_NONE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <types.h>
#include <stdinc.h>
#include <vector.h>
#include <memfile.h>

BEGIN_DECL

bool pack_none_init(packer *self);
bool pack_none_cpy(const packer *self, packer *dst);
bool pack_none_drop(packer *self);
bool pack_none_write_extra(packer *self, memfile *dst, const vector ofType (const char *) *strings);
bool pack_none_read_extra(packer *self, FILE *src, size_t nbytes);
bool pack_none_print_extra(packer *self, FILE *file, memfile *src);
bool pack_none_print_encoded_string(packer *self, FILE *file, memfile *src, u32 decompressed_strlen);
bool pack_none_encode_string(packer *self, memfile *dst, err *err, const char *string_buffer);
bool pack_none_decode_string(packer *self, char *dst, size_t strlen, FILE *src);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRING_PRED_CONTAINS_H
#define STRING_PRED_CONTAINS_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <archive_pred.h>

BEGIN_DECL

BUILT_IN(static bool) __string_pred_contains_func(size_t *idxs_matching, size_t *num_matching, char **strings, size_t num_strings, void *capture)
{
        size_t result_size = 0;
        const char *needle = (const char *) capture;

        for (size_t i = 0; i < num_strings; i++) {
                if (strstr(strings[i], needle) != NULL) {
                        idxs_matching[result_size++] = i;
                }
        }

        *num_matching = result_size;

        return true;
}

BUILT_IN(static bool)

string_pred_contains_init(string_pred *pred)
{
        DEBUG_ERROR_IF_NULL(pred);
        pred->limit = QUERY_LIMIT_NONE;
        pred->func = __string_pred_contains_func;
        return true;
}

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRING_PRED_EQUALS_H
#define STRING_PRED_EQUALS_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <archive_pred.h>

BEGIN_DECL

BUILT_IN(static bool) __string_pred_equals_func(size_t *idxs_matching, size_t *num_matching, char **strings, size_t num_strings, void *capture)
{
        size_t result_size = 0;
        const char *needle = (const char *) capture;

        for (size_t i = 0; i < num_strings; i++) {
                if (strstr(strings[i], needle) != NULL) {
                        idxs_matching[result_size++] = i;
                }
        }

        *num_matching = result_size;
        return true;
}

BUILT_IN(static bool)

string_pred_equals_init(string_pred *pred)
{
        DEBUG_ERROR_IF_NULL(pred);
        pred->limit = QUERY_LIMIT_1;
        pred->func = __string_pred_equals_func;
        return true;
}

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef PRIORITY_QUEUE_H
#define PRIORITY_QUEUE_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>

BEGIN_DECL

typedef struct priority_queue_element_info {
        size_t priority;
        void *element;
} priority_queue_element_info;

typedef struct priority_queue {
        priority_queue_element_info *data;
        size_t num_elements;
        size_t capacity;
        pthread_mutex_t mutex;
} priority_queue;

void priority_queue_init(priority_queue *queue);
void priority_queue_free(priority_queue *queue);
void priority_queue_push(priority_queue *queue, void *data, size_t priority);
void *priority_queue_pop(priority_queue *queue);
int priority_queue_is_empty(priority_queue *queue);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SLICELIST_H
#define SLICELIST_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <vector.h>
#include <bitmap.h>
#include <spinlock.h>
#include <bloom.h>
#include <hash.h>
#include <types.h>

BEGIN_DECL

FORWARD_STRUCT_DECL(slice)

#ifndef SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_NAME
#define SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_NAME "1 of 100 in CPU L1"
#endif
#ifndef SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_SIZE_IN_BYTE
#define SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_SIZE_IN_BYTE (32768/100)
#endif

#ifndef SLICE_LIST_TARGET_MEMORY_NAME
#define SLICE_LIST_TARGET_MEMORY_NAME "10 of 100 in CPU L1"
#endif
#ifndef SLICE_LIST_TARGET_MEMORY_SIZE_IN_BYTE
#define SLICE_LIST_TARGET_MEMORY_SIZE_IN_BYTE (32768/10)
#endif

#define SLICE_DATA_SIZE (SLICE_LIST_TARGET_MEMORY_SIZE_IN_BYTE - sizeof(slice_lookup_strat_e) - sizeof(u32))

#define SLICE_KEY_COLUMN_MAX_ELEMS (SLICE_DATA_SIZE / 8 / 3) /** one array with elements of 64 bits each, 3 of them */

typedef enum slice_lookup_strat_e {
        SLICE_LOOKUP_SCAN, SLICE_LOOKUP_BESEARCH,
} slice_lookup_strat_e;

typedef struct slice {
        /** Enumeration to determine which strategy for 'find' is currently applied */
        slice_lookup_strat_e strat;

        /** Data stored inside this slice. By setting 'SLICE_LIST_CPU_L3_SIZE_IN_BYTE' statically to the target
         * CPU L3 size, it is intended that one entire 'slice_t' structure fits into the L3 cache of the CPU.
         * It is assumed that at least one element can be inserted into a 'slice_t' object (which means that
         * the type of elements to be inserted must be less or equal to SLICE_DATA_SIZE. In case an element is
         * removed from this list, data is physically moved to avoid a "sparse" list, i.e., it is alwalys
         * guaranteeed that 'data' contains continously elements without any gabs until 'num_elems' limit. This
         * avoids to lookup in a struct bitmap or other structure whether a particular element is removed or not; also
         * this does not steal an element from the domain of the used data type to encode 'not present' with a
         * particular values. However, a remove operation is expensive. */
        const char *key_column[SLICE_KEY_COLUMN_MAX_ELEMS];
        hash32_t key_hash_column[SLICE_KEY_COLUMN_MAX_ELEMS];
        archive_field_sid_t string_id_column[SLICE_KEY_COLUMN_MAX_ELEMS];

        /** The number of elements stored in 'key_colum', 'key_hash_column', and 'string_id_column' */
        u32 num_elems;

        u32 cache_idx;
} slice;

typedef struct hash_bounds {
        /** Min and max values inside this slice. Used to skip the lookup in the per-slice bitmap during search */
        hash32_t min_hash, max_hash;
} hash_bounds;

typedef struct slice_descriptor {
        /** The number of reads to this slice including misses and hits. Along with 'num_reads_hit' used to determine
         * the order of this element w.r.t. to other elements in the list */
        size_t num_reads_all;

        /** The number of reads to this slice that lead to a search hit. See 'num_reads_all' for the purpose. */
        size_t num_reads_hit;

} slice_descriptor;

typedef struct slice_list {
        allocator alloc;
        spinlock lock;

        vector ofType(slice) slices;
        vector ofType(slice_descriptor) descriptors;
        vector ofType(bloomfilter) filters;
        vector ofType(hash_bounds) bounds;

        u32 appender_idx;
        err err;
} slice_list_t;

typedef struct slice_handle {
        slice *container;
        const char *key;
        archive_field_sid_t value;
        bool is_contained;
} slice_handle;

bool slice_list_create(slice_list_t *list, const allocator *alloc, size_t slice_capacity);
bool slice_list_drop(slice_list_t *list);
bool slice_list_lookup(slice_handle *handle, slice_list_t *list, const char *needle);
bool slice_list_is_empty(const slice_list_t *list);
bool slice_list_insert(slice_list_t *list, char **strings, archive_field_sid_t *ids, size_t npairs);
bool slice_list_remove(slice_list_t *list, slice_handle *handle);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SPINLOCK_H
#define SPINLOCK_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdatomic.h>

#include <stdinc.h>
#include <vector.h>

BEGIN_DECL

typedef struct spinlock {
        atomic_flag lock;
        pthread_t owner;
} spinlock;

bool spinlock_init(spinlock *spinlock);
bool spinlock_acquire(spinlock *spinlock);
bool spinlock_release(spinlock *spinlock);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef COMMON_H
#define COMMON_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdbool.h>
#include <stddef.h>
#include <string_buffer.h>
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <assert.h>
#include <inttypes.h>
#include <errno.h>
#include <limits.h>
#include <math.h>

#include "forwdecl.h"

#ifndef __cplusplus

# include <stdatomic.h>

#else
# include <atomic>
# define _Atomic(X) std::atomic< X >
#endif

#ifdef __cplusplus
#define BEGIN_DECL  extern "C" {
#define END_DECL    }
#else
#define BEGIN_DECL
#define END_DECL
#endif

#define MALLOC(size)                \
({                                      \
        void *ptr = malloc(size);       \
        ZERO_MEMORY(ptr, size);     \
        ptr;                            \
})

#define QUERY_LIMIT_NONE -1
#define QUERY_LIMIT_1     1

#define ARRAY_LENGTH(x)                                                                                            \
    sizeof(x)/sizeof(x[0])

typedef uint64_t offset_t;
typedef int64_t signed_offset_t;

typedef unsigned char u_char;

typedef enum archive_field_type {
        FIELD_NULL = 0,
        FIELD_BOOLEAN = 1,
        FIELD_INT8 = 2,
        FIELD_INT16 = 3,
        FIELD_INT32 = 4,
        FIELD_INT64 = 5,
        FIELD_UINT8 = 6,
        FIELD_UINT16 = 7,
        FIELD_UINT32 = 8,
        FIELD_UINT64 = 9,
        FIELD_FLOAT = 10,
        FIELD_STRING = 11,
        FIELD_OBJECT = 12
} archive_field_e;

typedef enum access_mode_e {
        READ_WRITE,
        READ_ONLY
} access_mode_e;

#define FUNC_UNUSED __attribute__((unused))

FUNC_UNUSED static const char *basic_type_to_json_type_str(enum archive_field_type t)
{
        switch (t) {
                case FIELD_INT8:
                case FIELD_INT16:
                case FIELD_INT32:
                case FIELD_INT64:
                case FIELD_UINT8:
                case FIELD_UINT16:
                case FIELD_UINT32:
                case FIELD_UINT64:
                        return "integer";
                case FIELD_FLOAT:
                        return "float";
                case FIELD_STRING:
                        return "string_buffer";
                case FIELD_BOOLEAN:
                        return "boolean";
                case FIELD_NULL:
                        return "null";
                case FIELD_OBJECT:
                        return "object";
                default:
                        return "(unknown)";
        }
}

FUNC_UNUSED static const char *basic_type_to_system_type_str(enum archive_field_type t)
{
        switch (t) {
                case FIELD_INT8:
                        return "int8";
                case FIELD_INT16:
                        return "int16";
                case FIELD_INT32:
                        return "int32";
                case FIELD_INT64:
                        return "int64";
                case FIELD_UINT8:
                        return "uint8";
                case FIELD_UINT16:
                        return "uint16";
                case FIELD_UINT32:
                        return "uint32";
                case FIELD_UINT64:
                        return "uint64";
                case FIELD_FLOAT:
                        return "float32";
                case FIELD_STRING:
                        return "string64";
                case FIELD_BOOLEAN:
                        return "bool8";
                case FIELD_NULL:
                        return "void";
                case FIELD_OBJECT:
                        return "variable";
                default:
                        return "(unknown)";
        }
}

#define NOT_IMPLEMENTED                                                                                            \
{                                                                                                                      \
    err err;                                                                                                    \
    error_init(&err);                                                                                                  \
    ERROR(&err, ERR_NOTIMPLEMENTED)                                                                                \
    error_print_and_abort(&err);                                                                                       \
    return false;                                                                                                      \
};

#ifndef NDEBUG
#define CHECK_TAG(is, expected)                                                                                 \
{                                                                                                                      \
    if (is != expected) {                                                                                              \
        ERROR_PRINT(ERR_ERRINTERNAL)                                                                     \
        return false;                                                                                                  \
    }                                                                                                                  \
}
#else
#define CHECK_TAG(is, expected) { }
#endif

#if !defined(LOG_TRACE) || defined(NDEBUG)
#define TRACE(tag, msg, ...) { }
#else
#define TRACE(tag, msg, ...)                                                                                    \
{                                                                                                                      \
    char buffer[1024];                                                                                                 \
    sprintf(buffer, "--%d-- [TRACE   : %-10s] %s\n", getpid(), tag, msg);                                              \
    fprintf(stderr, buffer, __VA_ARGS__);                                                                              \
    fflush(stderr);                                                                                                    \
}
#endif

#if !defined(LOG_INFO) || defined(NDEBUG)
#define INFO(tag, msg, ...) { }
#else
#define INFO(tag, msg, ...)                                                                                     \
{                                                                                                                      \
    char buffer[1024];                                                                                                 \
    sprintf(buffer, "--%d-- [INFO    : %-10s] %s\n", getpid(), tag, msg);                                              \
    fprintf(stderr, buffer, __VA_ARGS__);                                                                              \
    fflush(stderr);                                                                                                    \
}
#endif

#if !defined(LOG_DEBUG) || defined(NDEBUG)
#define DEBUG(tag, msg, ...)                                                                                       \
{ }
#else
#define DEBUG(tag, msg, ...)                                                                                    \
{                                                                                                                      \
    char buffer[1024];                                                                                                 \
    sprintf(buffer, "--%d-- [DEBUG   : %-10s] %s\n", getpid(), tag, msg);                                              \
    fprintf(stderr, buffer, __VA_ARGS__);                                                                              \
    fflush(stderr);                                                                                                    \
}
#endif

#if !defined(LOG_WARN) || defined(NDEBUG)
#define WARN(tag, msg, ...) { }
#else
#define WARN(tag, msg, ...)                                                                                     \
    {                                                                                                                  \
        char buffer[1024];                                                                                             \
        sprintf(buffer, "--%d-- [WARNING: %-10s] %s\n", getpid(), tag, msg);                                           \
        fprintf(stderr, buffer, __VA_ARGS__);                                                                          \
        fflush(stderr);                                                                                                \
    }
#endif

#define JAK_ASSERT(x) assert(x);

#define CARBON_ARCHIVE_MAGIC                "MP/CARBON"
#define CARBON_ARCHIVE_VERSION               1

#define  MARKER_SYMBOL_OBJECT_BEGIN        '{'
#define  MARKER_SYMBOL_OBJECT_END          '}'
#define  MARKER_SYMBOL_PROP_NULL           'n'
#define  MARKER_SYMBOL_PROP_BOOLEAN        'b'
#define  MARKER_SYMBOL_PROP_INT8           'c'
#define  MARKER_SYMBOL_PROP_INT16          's'
#define  MARKER_SYMBOL_PROP_INT32          'i'
#define  MARKER_SYMBOL_PROP_INT64          'l'
#define  MARKER_SYMBOL_PROP_UINT8          'r'
#define  MARKER_SYMBOL_PROP_UINT16         'h'
#define  MARKER_SYMBOL_PROP_UINT32         'e'
#define  MARKER_SYMBOL_PROP_UINT64         'g'
#define  MARKER_SYMBOL_PROP_REAL           'f'
#define  MARKER_SYMBOL_PROP_TEXT           't'
#define  MARKER_SYMBOL_PROP_OBJECT         'o'
#define  MARKER_SYMBOL_PROP_NULL_ARRAY     'N'
#define  MARKER_SYMBOL_PROP_BOOLEAN_ARRAY  'B'
#define  MARKER_SYMBOL_PROP_INT8_ARRAY     'C'
#define  MARKER_SYMBOL_PROP_INT16_ARRAY    'S'
#define  MARKER_SYMBOL_PROP_INT32_ARRAY    'I'
#define  MARKER_SYMBOL_PROP_INT64_ARRAY    'L'
#define  MARKER_SYMBOL_PROP_UINT8_ARRAY    'R'
#define  MARKER_SYMBOL_PROP_UINT16_ARRAY   'H'
#define  MARKER_SYMBOL_PROP_UINT32_ARRAY   'E'
#define  MARKER_SYMBOL_PROP_UINT64_ARRAY   'G'
#define  MARKER_SYMBOL_PROP_REAL_ARRAY     'F'
#define  MARKER_SYMBOL_PROP_TEXT_ARRAY     'T'
#define  MARKER_SYMBOL_PROP_OBJECT_ARRAY   'O'
#define  MARKER_SYMBOL_EMBEDDED_STR_DIC    'D'
#define  MARKER_SYMBOL_EMBEDDED_STR        '-'
#define  MARKER_SYMBOL_COLUMN_GROUP        'X'
#define  MARKER_SYMBOL_COLUMN              'x'
#define  MARKER_SYMBOL_HUFFMAN_DIC_ENTRY   'd'
#define  MARKER_SYMBOL_RECORD_HEADER       'r'
#define  MARKER_SYMBOL_HASHTABLE_HEADER    '#'
#define  MARKER_SYMBOL_VECTOR_HEADER       '|'

#define DECLARE_AND_INIT(type, name)                                                                               \
        type name;                                                                                                     \
        ZERO_MEMORY(&name, sizeof(type));

#define ZERO_MEMORY(dst, len)                                                                                      \
    memset((void *) dst, 0, len);

#define cast(type, name, src)                                                                                      \
      type name = (type) src

#define UNUSED(x)   (void)(x);

#define BUILT_IN(x)   FUNC_UNUSED x

#define ofType(x) /** a convenience way to write types for generic containers; no effect than just a visual one */
#define ofMapping(x, y) /** a convenience way to write types for generic containers; no effect than just a visual one */

#define OPTIONAL_CALL(x, func, ...) if((x) && (x)->func) { (x)->func(__VA_ARGS__); }

#define MAX(a, b)                                                                                                  \
    ((b) > (a) ? (b) : (a))

#define MIN(a, b)                                                                                                  \
    ((a) < (b) ? (a) : (b))

#define DEBUG_ERROR_IF_NULL(x)                                                                                               \
{                                                                                                                      \
    if (!(x)) {                                                                                                        \
        err err;                                                                                                \
        error_init(&err);                                                                                              \
        ERROR(&err, ERR_NULLPTR);                                                                                  \
        error_print_to_stderr(&err);                                                                                   \
        return false;                                                                                                  \
    }                                                                                                                  \
}

#define CHECK_SUCCESS(x)                                                                                           \
{                                                                                                                      \
    if (UNLIKELY(!x)) {                                                                                                \
        return x;                                                                                                      \
    }                                                                                                                  \
}

#define SUCCESS_OR_JUMP(expr, label)                                                                               \
{                                                                                                                      \
    if (UNLIKELY(!expr)) {                                                                                             \
        goto label;                                                                                                    \
    }                                                                                                                  \
}

#define LIKELY(x)                                                                                                      \
    __builtin_expect((x), 1)
#define UNLIKELY(x)                                                                                                    \
    __builtin_expect((x), 0)

#define PREFETCH_READ(adr)                                                                                             \
    __builtin_prefetch(adr, 0, 3)

#define PREFETCH_WRITE(adr)                                                                                            \
    __builtin_prefetch(adr, 1, 3)

#define FORWARD_STRUCT_DECL(x) struct x;

#define BIT_NUM_OF(x)             (sizeof(x) * 8)
#define SET_BIT(n)                ( ((u32) 1) << (n) )
#define SET_BITS(x, mask)         ( x |=  (mask) )
#define UNSET_BITS(x, mask)       ( x &= ~(mask) )
#define ARE_BITS_SET(mask, bit)   (((bit) & mask ) == (bit))

#define ERROR_IF_NOT_IMPLEMENTED(err, x, func)                                                                         \
    OPTIONAL(x->func == NULL, ERROR(err, ERR_NOTIMPLEMENTED))

#define OPTIONAL(expr, stmt)                                                                                       \
    if (expr) { stmt; }

#define OPTIONAL_SET(x, y)                                                                                         \
     OPTIONAL(x, *x = y)

#define OPTIONAL_SET_OR_ELSE(x, y, stmt)                                                                           \
    if (x) {                                                                                                           \
        *x = y;                                                                                                        \
    } else { stmt; }

bool global_console_enable_output;

#define CONSOLE_OUTPUT_ON()                                                                                        \
    global_console_enable_output = true;

#define CONSOLE_OUTPUT_OFF()                                                                                       \
    global_console_enable_output = false;

#define CONSOLE_WRITE(file, msg, ...)                                                                              \
{                                                                                                                      \
    if (global_console_enable_output) {                                                                                   \
        pid_t pid = getpid();                                                                                          \
        char timeBuffer[2048];                                                                                         \
        char formatBuffer[2048];                                                                                       \
        time_t now = time (0);                                                                                         \
        fflush(file);                                                                                                  \
        strftime (timeBuffer, 2048, "%Y-%m-%d %H:%M:%S", localtime (&now));                                            \
        sprintf (formatBuffer, msg, __VA_ARGS__);                                                                      \
        fprintf(file, "[%d] %s   %-70s", pid, timeBuffer, formatBuffer);                                               \
        fflush(file);                                                                                                  \
    }                                                                                                                  \
}

#define CONSOLE_WRITE_ENDL(file)                                                                                   \
{                                                                                                                      \
    if (global_console_enable_output) {                                                                                   \
        fprintf(file, "\n");                                                                                           \
    }                                                                                                                  \
}

#define CONSOLE_WRITE_CONT(file, msg, ...)                                                                         \
{                                                                                                                      \
    if (global_console_enable_output) {                                                                                   \
        fprintf(file, msg, __VA_ARGS__);                                                                               \
    }                                                                                                                  \
}

#define CONSOLE_WRITELN(file, msg, ...)                                                                            \
{                                                                                                                      \
    if (global_console_enable_output) {                                                                                   \
        CONSOLE_WRITE(file, msg, __VA_ARGS__)                                                                      \
        CONSOLE_WRITE_ENDL(file)                                                                                   \
        fflush(file);                                                                                                  \
    }                                                                                                                  \
}

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//
//  S U M M A R Y
//
// ---------------------------------------------------------------------------------------------------------------------

/**
 * SUMMARY
 *
 * A specialized hash table that uses strings as keys, and 64bit values. The specialization is to avoid some
 * indirection cost to compare keys, e.g., by calling a function pointer to compare two objects like clib suggest it,
 * and to ensure that the value is embedded in continuous memory rather than a pointer to another distant memory block.
 *
 * Internally, the str_hash is organized by paritions where each partition is assigned exclusively to
 * one thread. Each such parition contains of as a vector of length 'num_buckets' which contains of elements of a bucket
 * type. A bucket type is an fixed-size array of entries, each containing a key and a value. In case of no collisions,
 * this array contains of exactly one element. In case of collisions, colliding keys are stored in this array of entries
 * in the same bucket. To speedup lookups, this entry vector may be additionally sorted and a (specialized) binary
 * search is invoked to find the bucket entry associated to a particular key (if any). Other lookup strategies includes
 * both single and multi-threaded forward scans. Which strategy to use in which case is decided by the
 * str_hash itself, however. To satisfy user-specific memory limitations, some per-bucket elements may
 * be swapped out to a didicated swap space.
 *
 * The underlying hashing function is the Jenkins hash function.
 */

#ifndef STRHASH_H
#define STRHASH_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <alloc.h>
#include <vector.h>
#include <hash.h>
#include <types.h>

BEGIN_DECL

/**
 * Enables or disabled packing of entries inside a bucket. By default, packing is disabled.
 * To turn on packing, set 'CONFIG_PACK_BUCKETS' symbol
 */
#ifdef CONFIG_PACK_BUCKETS
#define
#define BUCKET_PACKING __attribute__((__packed__))
#else
#define BUCKET_PACKING
#endif

/**
 * Number of elements stored in the per-bucket cache (Tier 2, see below)
 */
#ifndef CONFIG_BUCKET_CACHE_SIZE
#define CONFIG_BUCKET_CACHE_SIZE  16
#endif

/**
 * Maximum number of elements stored per bucket (Tier 3, see below)
 */
#ifndef CONFIG_BUCKET_CAPACITY
#define CONFIG_BUCKET_CAPACITY  1024
#endif

typedef enum str_hash_tag {
        MEMORY_RESIDENT
} str_hash_tag_e;

typedef struct str_hash_counters {
        size_t num_bucket_search_miss;
        size_t num_bucket_search_hit;
        size_t num_bucket_cache_search_miss;
        size_t num_bucket_cache_search_hit;
} str_hash_counters;

typedef struct str_hash {
        /**
         * Implementation-specific values
         */
        void *extra;

        /**
         * Implementation tag
         */
        str_hash_tag_e tag;

        /**
         * Statistics to lookup misses and hits
         *
         * <b>Note</b>: Implementation must maintain counters by itself
         */
        str_hash_counters counters;

        /**
        *  Memory allocator that is used to get memory for user data
        */
        allocator allocator;

        /**
         *  Frees resources bound to <code>self</code> via the allocator specified by the constructor
         */
        int (*drop)(str_hash *self);

        /**
         * Put <code>num_pair</code> objects into this str_hash maybe updating old objects with the same key.
         */
        int (*put_bulk_safe)(str_hash *self, char *const *keys, const archive_field_sid_t *values, size_t npairs);

        /**
         * Put <code>num_pair</code> objects into this str_hash maybe without checking for updates.
         */
        int (*put_bulk_fast)(str_hash *self, char *const *keys, const archive_field_sid_t *values, size_t npairs);

        /**
         * Same as 'put_safe_bulk' but specialized for a single element
         */
        int (*put_exact_safe)(str_hash *self, const char *key, archive_field_sid_t value);

        /**
         * Same as 'put_fast_bulk' but specialized for a single element
         */
        int (*put_exact_fast)(str_hash *self, const char *key, archive_field_sid_t value);

        /**
         * Get the values associated with <code>keys</code> in this str_hash (if any).
         */
        int (*get_bulk_safe)(str_hash *self, archive_field_sid_t **out, bool **found_mask, size_t *nnot_found, char *const *keys, size_t nkeys);

        /**
         * The same as 'get_safe_bulk' but optimized for a single element
         */
        int (*get_exact_safe)(str_hash *self, archive_field_sid_t *out, bool *found_mask, const char *key);

        /**
         * Get the values associated with <code>keys</code> in this str_hash. All keys <u>must</u> exist.
         */
        int (*get_fast)(str_hash *self, archive_field_sid_t **out, char *const *keys, size_t nkeys);

        /**
         * Updates keys associated with <code>values</code> in this str_hash. All values <u>must</u> exist, and the
         * mapping between keys and values must be bidirectional.
         */
        int (*update_key_fast)(str_hash *self, const archive_field_sid_t *values, char *const *keys, size_t nkeys);

        /**
         * Removes the objects with the gives keys from this str_hash
         */
        int (*remove)(str_hash *self, char *const *keys, size_t nkeys);

        /**
         * Frees up allocated memory for <code>ptr</code> via the allocator in <code>str_hash</code> that was specified
         * by the call to <code>string_id_map_create</code>
         */
        int (*free)(str_hash *self, void *ptr);

        /**
         *  Error information
         */
        err err;
} str_hash;

DEFINE_GET_ERROR_FUNCTION(str_hash, str_hash, table);

/**
 * Frees resources bound to <code>str_hash</code> via the allocator specified by the call to <code>string_id_map_create</code>.
 *
 * @param str_hash a non-null pointer to the str_hash
 * @return <code>true</code> in case of success, otherwise a value indiciating the ERROR.
 */
inline static int str_hash_drop(str_hash *str_hash)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        JAK_ASSERT(str_hash->drop);
        return str_hash->drop(str_hash);
}

/**
 * Resets statistics counters
 *
 * @param str_hash a non-null pointer to the str_hash
 * @return <code>true</code> in case of success, otherwise a value indicating the ERROR.
 */
inline static bool str_hash_reset_counters(str_hash *str_hash)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        memset(&str_hash->counters, 0, sizeof(str_hash_counters));
        return true;
}

/**
 * Returns statistics counters
 * @param out non-null pointer to destination counter
 * @param str_hash non-null pointer to the str_hash
 * @return <code>true</code> in case of success, otherwise a value indicating the ERROR.
 */
inline static int str_hash_get_counters(str_hash_counters *out, const str_hash *str_hash)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(out);
        *out = str_hash->counters;
        return true;
}

/**
 * Put <code>num_pair</code> objects into this str_hash maybe updating old objects with the same key. If it is
 * guaranteed that the key is not yet inserted into this table, use <code>string_hashtable_put_blind</code>
 * instead.
 *
 * @param str_hash a non-null pointer to the str_hash
 * @param keys a non-null constant pointer to a list of at least <code>num_pairs</code> length of constant strings
 * @param values a non-null constant pointer to a list of at least <code>num_pairs</code> length of 64bit values
 * @param num_pairs the number of pairs that are read via <code>keys</code> and <code>values</code>
 * @return <code>true</code> in case of success, otherwise a value indicating the ERROR.
 */
inline static int str_hash_put_safe(str_hash *str_hash, char *const *keys, const archive_field_sid_t *values, size_t npairs)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(keys);
        DEBUG_ERROR_IF_NULL(values);
        JAK_ASSERT(str_hash->put_bulk_safe);
        return str_hash->put_bulk_safe(str_hash, keys, values, npairs);
}

/**
 * Put <code>num_pair</code> objects into this str_hash, ingoring whether the key exists or not. This function is
 * useful for insert operations of pairs where it is guaranteed that the keys are not yet inserted into this hashtable.
 * In case this guarantee is broken, the behavior is undefined. Depending on the implementation, this specialized
 * <code>put</code> function may have a better performance.
 *
 * If a check for existence is required, use <code>string_hashtable_put_test</code>
 * instead.
 *
 * @param str_hash a non-null pointer to the str_hash
 * @param keys a non-null constant pointer to a list of at least <code>num_pairs</code> length of constant strings
 * @param values a non-null constant pointer to a list of at least <code>num_pairs</code> length of 64bit values
 * @param num_pairs the number of pairs that are read via <code>keys</code> and <code>values</code>
 * @return <code>true</code> in case of success, otherwise a value indiciating the ERROR.
 */
inline static int str_hash_put_bulk_fast(str_hash *str_hash, char *const *keys, const archive_field_sid_t *values, size_t npairs)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(keys);
        DEBUG_ERROR_IF_NULL(values);
        JAK_ASSERT(str_hash->put_bulk_fast);
        return str_hash->put_bulk_fast(str_hash, keys, values, npairs);
}

/**
 * Same as 'string_lookup_put_bulk' but specialized for a single pair
 */
inline static int str_hash_put_exact(str_hash *str_hash, const char *key, archive_field_sid_t value)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(key);
        JAK_ASSERT(str_hash->put_exact_safe);
        return str_hash->put_exact_safe(str_hash, key, value);
}

/**
 * Same as 'string_lookup_put_fast_bulk' but specialized for a single pair
 */
inline static int str_hash_put_exact_fast(str_hash *str_hash, const char *key, archive_field_sid_t value)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(key);
        JAK_ASSERT(str_hash->put_exact_fast);
        return str_hash->put_exact_fast(str_hash, key, value);
}

/**
 * Get the values associated with <code>keys</code> in this str_hash (if any). In case one <code>key</code> does not
 * exists, the function will return this information via the parameters <code>found_mask</code> and
 * <code>num_not_found</code>. However, in case it is guaranteed that all keys exist, consider to use
 * <code>string_id_map_get_blind</code> instead. *
 *
 * @param out A non-null pointer to an unallocated memory address. The str_hash will allocate enough memory to store the
 *            result. There are <code>num_keys</code> elements returned, but not all of them are guaranteed to
 *            contain a particular value. That an entry does not contain a particular value happens if the
 *            associated key is not stored in this str_hash. Whether or not one particular entry is a valid value,
 *            can be determined by the caller via the <code>found_mask</code>.
 *            <b>Important</b> <code>out</code> must be freed manually by calling <code>string_id_map_free</code>.
 * @param found_mask A non-null pointer to an unallocated memory address. The str_hash will allocate enough memory to store
 *            the result. There are <code>num_keys</code> boolean values returned. This mask is used to determine
 *            if the i-th key has a mapping in this str_hash. If this is the case, the i-th entry in <code>found_mask</code>
 *            is <b>true</b> and the i-th entry in <code>out</code> holds the value. Otherwise, in case the i-th
 *            value in <code>found_mask</code> is <b>false</b>, there is no value stored to the i-th key in
 *            <code>keys</code>, and reading <code>out</code> for the i-th position is undefined.
 * @param num_not_found A non-null pointer to a value that will store the number of keys in <code>keys</code> for
 *                      which no value is stored in this str_hash.
 * @param num_out A non-null pointer to an unsigned integer that will contain the number of values return by the
 *                call to this function.
 * @param str_hash a non-null pointer to the str_hash
 * @param keys a non-null pointer to a list of at least <code>num_keys</code> strings
 * @param num_keys the number of keys
 * @return <code>true</code> in case of success, otherwise a value indicating the ERROR.
 */
inline static int str_hash_get_bulk_safe(archive_field_sid_t **out, bool **found_mask, size_t *num_not_found, str_hash *str_hash, char *const *keys, size_t nkeys)
{
        DEBUG_ERROR_IF_NULL(out);
        DEBUG_ERROR_IF_NULL(found_mask);
        DEBUG_ERROR_IF_NULL(num_not_found);
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(keys);
        JAK_ASSERT(str_hash->get_bulk_safe);
        int result = str_hash->get_bulk_safe(str_hash, out, found_mask, num_not_found, keys, nkeys);
        JAK_ASSERT (out != NULL);
        JAK_ASSERT (found_mask != NULL);
        return result;
}

inline static int str_hash_get_bulk_safe_exact(archive_field_sid_t *out, bool *found, str_hash *str_hash, const char *key)
{
        DEBUG_ERROR_IF_NULL(out);
        DEBUG_ERROR_IF_NULL(found);
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(key);
        JAK_ASSERT(str_hash->get_exact_safe);
        int result = str_hash->get_exact_safe(str_hash, out, found, key);
        JAK_ASSERT (out != NULL);
        JAK_ASSERT (found != NULL);
        return result;
}

/**
 * Get the values associated with <code>keys</code> in this str_hash. In case one <code>key</code> does not
 * exists, the behavior is undefined.
 *
 * However, if it cannot be guaranteed that all keys are known, use
 * <code>string_id_map_get_test</code> instead.
 *
 * @param out A non-null pointer to an unallocated memory address. The str_hash will allocate <code>num_keys</code>
 *            times <code>sizeof(archive_field_sid_t)</code> bytes memory to store the result. There are <code>num_keys</code>
 *            elements returned, and all of them are guaranteed to contain a particular value.
 * @param str_hash a non-null pointer to the str_hash
 * @param keys a non-null pointer to a list of at least <code>num_keys</code> strings
 * @param num_keys the number of keys
 * @return <code>true</code> in case of success, otherwise a value indicating the ERROR.
 */
inline static int str_hash_get_bulk_fast(archive_field_sid_t **out, str_hash *str_hash, char *const *keys, size_t nkeys)
{
        DEBUG_ERROR_IF_NULL(out);
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(keys);
        JAK_ASSERT(str_hash->get_fast);
        return str_hash->get_fast(str_hash, out, keys, nkeys);
}

/**
 * Update keys for a given list of values. It must be guaranteed that the mapping between a key and its value is
 * bidirectional, and that all values exists.
 *
 * If you want to update a value given its key, use <code>string_hashtable_put_test</code> or
 * <code>string_hashtable_put_blind</code> instead.
 *
 * @param out A non-null pointer to an unallocated memory address. The str_hash will allocate <code>num_keys</code>
 *            times <code>sizeof(archive_field_sid_t)</code> bytes memory to store the result. There are <code>num_keys</code>
 *            elements returned, and all of them are guaranteed to contain a particular value.
 * @param str_hash a non-null pointer to the str_hash
 * @param keys a non-null pointer to a list of at least <code>num_keys</code> strings
 * @param num_keys the number of keys
 * @return <code>true</code> in case of success, otherwise a value indicating the ERROR.
 */
inline static int str_hash_update_fast(str_hash *str_hash, const archive_field_sid_t *values, char *const *keys, size_t nkeys)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(keys);
        JAK_ASSERT(str_hash->update_key_fast);
        return str_hash->update_key_fast(str_hash, values, keys, nkeys);
}

/**
 * Removes the objects with the gives keys from this str_hash
 *
 * @param str_hash a non-null pointer to the str_hash
 * @param keys a non-null pointer to a list of at least <code>num_keys</code> strings
 * @param num_keys the number of keys
 * @return
 */
inline static int str_hash_remove(str_hash *str_hash, char *const *keys, size_t nkeys)
{
        DEBUG_ERROR_IF_NULL(str_hash);
        DEBUG_ERROR_IF_NULL(keys);
        JAK_ASSERT(str_hash->remove);
        return str_hash->remove(str_hash, keys, nkeys);
}

/**
 * Frees up allocated memory for <code>values</code> via the allocator in <code>str_hash</code> that was specified
 * by the call to <code>string_id_map_create</code>
 *
 * @param values A non-null pointer (potentially resulting from a call to <code>string_id_map_get</code>)
 * @return <code>true</code> in case of success, otherwise a value indiciating the ERROR.
 */
inline static int str_hash_free(void *ptr, str_hash *str_hash)
{
        DEBUG_ERROR_IF_NULL(ptr);
        DEBUG_ERROR_IF_NULL(str_hash);
        JAK_ASSERT(str_hash->free);
        return str_hash->free(str_hash, ptr);
}

/**
 * Resets the counter <code>counters</code> by setting all members to zero.
 *
 * @param counters non-null pointer to counter object
 * @return true if everything went normal, otherwise an value indicating the ERROR
 */
inline static int str_hash_counters_init(str_hash_counters *counters)
{
        DEBUG_ERROR_IF_NULL(counters);
        memset(counters, 0, sizeof(str_hash_counters));
        return true;
}

/**
 * Adds members of both input parameters and stores the result in <code>dstLhs</code>.
 *
 * @param dstLhs non-null pointer to counter (will contain the result)
 * @param rhs non-null pointer to counter
 * @return true if everything went normal, otherwise an value indicating the ERROR
 */
inline static int str_hash_counters_add(str_hash_counters *dst_lhs, const str_hash_counters *rhs)
{
        DEBUG_ERROR_IF_NULL(dst_lhs);
        DEBUG_ERROR_IF_NULL(rhs);
        dst_lhs->num_bucket_search_miss += rhs->num_bucket_search_miss;
        dst_lhs->num_bucket_search_hit += rhs->num_bucket_search_hit;
        dst_lhs->num_bucket_cache_search_hit += rhs->num_bucket_cache_search_hit;
        dst_lhs->num_bucket_cache_search_miss += rhs->num_bucket_cache_search_miss;
        return true;
}

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRHASH_MEM_H
#define STRHASH_MEM_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <alloc.h>
#include <str_hash.h>

BEGIN_DECL

bool str_hash_create_inmemory(str_hash *str_hash, const allocator *alloc, size_t num_buckets, size_t cap_buckets);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRING_H
#define STRING_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <jakson/error.h>

BEGIN_DECL

typedef struct string_buffer {
        char *data;
        size_t cap;
        size_t end;
        err err;
} string_buffer;

DEFINE_GET_ERROR_FUNCTION(string_buffer, string_buffer, builder);

bool string_buffer_create(string_buffer *builder);
bool string_buffer_create_ex(string_buffer *builder, size_t capacity);
bool string_buffer_drop(string_buffer *builder);

bool string_buffer_add(string_buffer *builder, const char *str);
bool string_buffer_add_nchar(string_buffer *builder, const char *str, u64 strlen);
bool string_buffer_add_char(string_buffer *builder, char c);
bool string_buffer_add_u8(string_buffer *builder, u8 value);
bool string_buffer_add_u16(string_buffer *builder, u16 value);
bool string_buffer_add_u32(string_buffer *builder, u32 value);
bool string_buffer_add_u64(string_buffer *builder, u64 value);
bool string_buffer_add_i8(string_buffer *builder, i8 value);
bool string_buffer_add_i16(string_buffer *builder, i16 value);
bool string_buffer_add_i32(string_buffer *builder, i32 value);
bool string_buffer_add_i64(string_buffer *builder, i64 value);
bool string_buffer_add_u64_as_hex(string_buffer *builder, u64 value);
bool string_buffer_add_u64_as_hex_0x_prefix_compact(string_buffer *builder, u64 value);
bool string_buffer_add_float(string_buffer *builder, float value);
bool string_buffer_clear(string_buffer *builder);
bool string_buffer_ensure_capacity(string_buffer *builder, u64 cap);
size_t string_len(string_buffer *builder);

const char *string_cstr(string_buffer *builder);

bool string_buffer_print(string_buffer *builder);
bool string_buffer_fprint(FILE *file, string_buffer *builder);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRDIC_H
#define STRDIC_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <alloc.h>
#include <types.h>
#include <hash.h>
#include <vector.h>

BEGIN_DECL

FORWARD_STRUCT_DECL(StringDictionary)
FORWARD_STRUCT_DECL(Vector)

typedef enum str_dict_tag_e {
        SYNC, ASYNC
} str_dict_tag_e;

/**
 * Thread-safe string_buffer pool implementation
 */
typedef struct string_dict {
        /**
         * Implementation-specific fields
         */
        void *extra;

        /**
         * Tag determining the current implementation
         */
        str_dict_tag_e tag;

        /**
         * Memory allocator that is used to get memory for user data
         */
        allocator alloc;

        /**
         * Frees up implementation-specific resources.
         *
         * Note: Implementation must ensure thread-safeness
         */
        bool (*drop)(string_dict *self);

        /**
         * Inserts a particular number of strings into this dictionary and returns associated string_buffer identifiers.
         *
         * Note: Implementation must ensure thread-safeness
        */
        bool (*insert)(string_dict *self, archive_field_sid_t **out, char *const *strings, size_t nstrings, size_t nthreads);

        /**
         * Removes a particular number of strings from this dictionary by their ids. The caller must ensure that
         * all string_buffer identifiers in <code>strings</code> are valid.
         *
         * Note: Implementation must ensure thread-safeness
         */
        bool (*remove)(string_dict *self, archive_field_sid_t *strings, size_t nstrings);

        /**
         * Get the string_buffer ids associated with <code>keys</code> in this async_map_exec (if any).
         *
         * Note: Implementation must ensure thread-safeness
         */
        bool (*locate_safe)(string_dict *self, archive_field_sid_t **out, bool **found_mask, size_t *num_not_found, char *const *keys, size_t num_keys);

        /**
         * Get the string_buffer ids associated with <code>keys</code> in this dic. All keys <u>must</u> exist.
         *
         * Note: Implementation must ensure thread-safeness
        */
        bool (*locate_fast)(string_dict *self, archive_field_sid_t **out, char *const *keys, size_t num_keys);

        /**
         * Extracts strings given their string_buffer identifier. All <code>ids</code> must be known.
         *
         * Note: Implementation must ensure thread-safeness
         */
        char **(*extract)(string_dict *self, const archive_field_sid_t *ids, size_t num_ids);

        /**
         * Frees up memory allocated inside a function call via the allocator given in the constructor
         *
         * Note: Implementation must ensure thread-safeness
         */
        bool (*free)(string_dict *self, void *ptr);

        /**
         * Reset internal statistic counters
         */
        bool (*resetCounters)(string_dict *self);

        /**
         * Get internal statistic counters
         */
        bool (*counters)(string_dict *self, str_hash_counters *counters);

        /**
         * Returns number of distinct strings stored in the dictionary
         */
        bool (*num_distinct)(string_dict *self, size_t *num);

        /**
         * Returns all contained (unique) strings and their mapped (unique) ids
         */
        bool (*get_contents)(string_dict *self, vector ofType (char *) *strings, vector ofType(archive_field_sid_t) *string_ids);
} string_dict;

/**
 *
 * @param dic
 * @return
 */
static BUILT_IN(bool) string_dict_drop(string_dict *dic)
{
        DEBUG_ERROR_IF_NULL(dic);
        JAK_ASSERT(dic->drop);
        return dic->drop(dic);
}

static BUILT_IN(bool)
string_dict_insert(string_dict *dic, archive_field_sid_t **out, char *const *strings, size_t nstrings, size_t nthreads)
{
        DEBUG_ERROR_IF_NULL(dic);
        DEBUG_ERROR_IF_NULL(strings);
        JAK_ASSERT(dic->insert);
        return dic->insert(dic, out, strings, nstrings, nthreads);
}

static BUILT_IN(bool)  string_dict_reset_counters(string_dict *dic)
{
        DEBUG_ERROR_IF_NULL(dic);
        JAK_ASSERT(dic->resetCounters);
        return dic->resetCounters(dic);
}

static BUILT_IN(bool)  string_dict_get_counters(str_hash_counters *counters, string_dict *dic)
{
        DEBUG_ERROR_IF_NULL(dic);
        JAK_ASSERT(dic->counters);
        return dic->counters(dic, counters);
}

static BUILT_IN(bool)  string_dict_remove(string_dict *dic, archive_field_sid_t *strings, size_t num_strings)
{
        DEBUG_ERROR_IF_NULL(dic);
        DEBUG_ERROR_IF_NULL(strings);
        JAK_ASSERT(dic->remove);
        return dic->remove(dic, strings, num_strings);
}

static BUILT_IN(bool) string_dict_locate_safe(archive_field_sid_t **out, bool **found_mask, size_t *num_not_found, string_dict *dic, char *const *keys, size_t num_keys)
{
        DEBUG_ERROR_IF_NULL(out);
        DEBUG_ERROR_IF_NULL(found_mask);
        DEBUG_ERROR_IF_NULL(num_not_found);
        DEBUG_ERROR_IF_NULL(dic);
        DEBUG_ERROR_IF_NULL(keys);
        JAK_ASSERT(dic->locate_safe);
        return dic->locate_safe(dic, out, found_mask, num_not_found, keys, num_keys);
}

static BUILT_IN(bool) string_dict_locate_fast(archive_field_sid_t **out, string_dict *dic, char *const *keys, size_t nkeys)
{
        DEBUG_ERROR_IF_NULL(out);
        DEBUG_ERROR_IF_NULL(dic);
        DEBUG_ERROR_IF_NULL(keys);
        JAK_ASSERT(dic->locate_fast);
        return dic->locate_fast(dic, out, keys, nkeys);
}

static BUILT_IN(char **)string_dict_extract(string_dict *dic, const archive_field_sid_t *ids, size_t nids)
{
        return dic->extract(dic, ids, nids);
}

static BUILT_IN(bool) string_dict_free(string_dict *dic, void *ptr)
{
        DEBUG_ERROR_IF_NULL(dic);
        if (ptr) {
                JAK_ASSERT(dic->free);
                return dic->free(dic, ptr);
        } else {
                return true;
        }
}

static BUILT_IN(bool) string_dict_num_distinct(size_t *num, string_dict *dic)
{
        DEBUG_ERROR_IF_NULL(num);
        DEBUG_ERROR_IF_NULL(dic);
        JAK_ASSERT(dic->num_distinct);
        return dic->num_distinct(dic, num);
}

static BUILT_IN(bool) string_dict_get_contents(vector ofType (char *) *strings, vector ofType(archive_field_sid_t) *string_ids, string_dict *dic)
{
        DEBUG_ERROR_IF_NULL(strings)
        DEBUG_ERROR_IF_NULL(string_ids)
        DEBUG_ERROR_IF_NULL(dic);
        JAK_ASSERT(dic->get_contents);
        return dic->get_contents(dic, strings, string_ids);
}

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef STRING_UTILS_H
#define STRING_UTILS_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>

BEGIN_DECL

bool strings_contains_blank_char(const char *str);
bool strings_is_enquoted(const char *str);
bool strings_is_enquoted_wlen(const char *str, size_t len);
const char *strings_skip_blanks(const char *str);
char *strings_remove_tailing_blanks(char *str_in);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef THREAD_POOL_H
#define THREAD_POOL_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <priority_queue.h>
#include <thread_pool_status.h>
#include <thread_pool_stats.h>

BEGIN_DECL

#ifndef NOOP
#define NOOP (void)0
#endif

#include <stdlib.h>
#include <pthread.h>

// Required due to bug in gcc, see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60932
// stdatomic.h must no be included in GTest
#ifndef CPP_TEST

#include <stdatomic.h>

#endif

#define THREAD_POOL_MAX_TASKS 4097

typedef void (*task_routine)(void *routine);

typedef struct thread_task {
        void *args;
        pthread_attr_t *attr;
        task_routine routine;
        size_t group_id;
        size_t priority;
        task_stats statistics;
} thread_task;

typedef struct task_state {
        atomic_int task_count; // remaining tasks in this group
        unsigned generation;
} task_state;

typedef struct task_handle {
        size_t index;
        unsigned generation;
} task_handle;

typedef struct thread_pool {
        char *name;
        pthread_t *pool;
        priority_queue waiting_tasks;
        task_state *task_group_states;
        size_t task_state_capacity; // number of tasks that can be tracked
        size_t size;
        size_t capacity;
        thread_info **thread_infos;
        thread_task **thread_tasks;
        thread_pool_stats *statistics;
        int enable_monitoring;
} thread_pool;

typedef struct thread_info {
        char name[12];
        thread_pool *pool;
        size_t id;
        atomic_int status;
        thread_stats *statistics;
} thread_info;

thread_pool *thread_pool_create(size_t num_threads, int enable_monitoring);
thread_pool *thread_pool_create_named(size_t num_threads, const char *name, int enable_monitoring);

// Releases all resources hold by the threadpool. 
// Currently working threads may finish but tasks left in the queue will be discarded.
void thread_pool_free(thread_pool *pool);
void thread_pool_set_name(thread_pool *pool, const char *name);

// Sets the number of active threads to num_threads.
// Currently working threads are terminated after there task is completed.
bool thread_pool_resize(thread_pool *pool, size_t num_threads);

// Add multiple tasks to be executed. Their progress is tracked by a single handle.
// hndl can be a nullptr.
bool thread_pool_enqueue_tasks(thread_task *task, thread_pool *pool, size_t num_tasks, task_handle *hndl);

bool thread_pool_enqueue_task(thread_task *task, thread_pool *pool, task_handle *hndl);

// Add multiple tasks to be executed. Waits until all passed tasks are finished. 
// The main thread also participates in task execution
bool thread_pool_enqueue_tasks_wait(thread_task *task, thread_pool *pool, size_t num_tasks);

// Waits until the tasks referenced by hndl are completed.
bool thread_pool_wait_for_task(thread_pool *pool, task_handle *hndl);

// Waits until all tasks currently in the queue are executed.
// The main thread also participates in task execution.
bool thread_pool_wait_for_all(thread_pool *pool);

void *__thread_main(void *args);
thread_task *__get_next_task(thread_pool *pool);
bool __create_thread(thread_info *thread_info, pthread_t *pp);
void __sig_seg(int sig);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef THREAD_POOL_MONITORING_H
#define THREAD_POOL_MONITORING_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>

BEGIN_DECL

#include "thread_pool.h"

// Returns the average fraction of time the active threads have been working.
double thread_pool_get_time_working(thread_pool *pool);

// Fill all stats of the passed thread pool instance
thread_pool_stats thread_pool_get_stats(thread_pool *pool);

// Fill all stats of the thread matching the given id in the thread pool
thread_stats thread_pool_get_thread_stats(thread_pool *pool, size_t id);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef THREAD_POOL_STATISTICS_H
#define THREAD_POOL_STATISTICS_H

#include <stdinc.h>

BEGIN_DECL

#include <time.h>
#include <stdio.h>

typedef struct thread_pool_stats {
        struct timespec creation_time;
        unsigned int task_enqueued_count;
        unsigned int task_complete_count;
        long long complete_time;
        long long wait_time;
        long long avg_complete_time;
        long long avg_wait_time;
} thread_pool_stats;

typedef struct thread_stats {
        struct timespec creation_time;
        long long idle_time;
        long long busy_time;
        size_t task_count;
} thread_stats;

typedef struct task_stats {
        struct timespec enqueue_time;
        struct timespec execution_time;
        struct timespec complete_time;
} task_stats;

static inline long long __get_time_diff(struct timespec *begin, struct timespec *end)
{
        return (end->tv_sec - begin->tv_sec) * 1000000000L + (end->tv_nsec - begin->tv_nsec); /// 1000000000.0;
}

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef THREAD_POOL_STATUS_H
#define THREAD_POOL_STATUS_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>

BEGIN_DECL

typedef enum thread_status_e {
        THREAD_STATUS_IDLE = 0,
        THREAD_STATUS_WORKING = 1,
        THREAD_STATUS_ABORTED = 2,
        THREAD_STATUS_FINISHED = 3,
        THREAD_STATUS_KILLED = 4,
        THREAD_STATUS_CREATED = 5,
        THREAD_STATUS_WILL_TERMINATE = 6,
        THREAD_STATUS_COMPLETED = 7,
        THREAD_STATUS_EMPTY = 99
} thread_status_e;

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef TIME_H
#define TIME_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>

BEGIN_DECL

typedef u64 timestamp;

timestamp wallclock();

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef TYPES_H
#define TYPES_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>

BEGIN_DECL

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;
typedef float float;

#define U8_NULL         UINT8_MAX
#define U16_NULL        UINT16_MAX
#define U32_NULL        UINT32_MAX
#define U64_NULL        UINT64_MAX
#define I8_NULL         INT8_MIN
#define I16_NULL        INT16_MIN
#define I32_NULL        INT32_MIN
#define I64_NULL        INT64_MIN
#define FLOAT_NULL      NAN

#define CARBON_U8_MIN    UINT8_MIN
#define CARBON_U16_MIN   UINT16_MIN
#define CARBON_U32_MIN   UINT32_MIN
#define CARBON_U64_MIN   UINT64_MIN
#define CARBON_I8_MIN    (INT8_MIN + 1)
#define CARBON_I16_MIN   (INT16_MIN + 1)
#define CARBON_I32_MIN   (INT32_MIN + 1)
#define CARBON_I64_MIN   (INT64_MIN + 1)
#define CARBON_U8_MAX    (U8_NULL - 1)
#define CARBON_U16_MAX   (U16_NULL - 1)
#define CARBON_U32_MAX   (U32_NULL - 1)
#define CARBON_U64_MAX   (U64_NULL - 1)
#define CARBON_I8_MAX    INT8_MAX
#define CARBON_I16_MAX   INT16_MAX
#define CARBON_I32_MAX   INT32_MAX
#define CARBON_I64_MAX   INT64_MAX

#define CARBON_BOOLEAN_COLUMN_FALSE     0
#define CARBON_BOOLEAN_COLUMN_TRUE      1
#define CARBON_BOOLEAN_COLUMN_NULL      2

#define IS_NULL_BOOLEAN(x)      (x == CARBON_BOOLEAN_COLUMN_NULL)
#define IS_NULL_U8(x)           (x == U8_NULL)
#define IS_NULL_U16(x)          (x == U16_NULL)
#define IS_NULL_U32(x)          (x == U32_NULL)
#define IS_NULL_U64(x)          (x == U64_NULL)
#define IS_NULL_I8(x)           (x == I8_NULL)
#define IS_NULL_I16(x)          (x == I16_NULL)
#define IS_NULL_I32(x)          (x == I32_NULL)
#define IS_NULL_I64(x)          (x == I64_NULL)
#define IS_NULL_FLOAT(x)        (isnan(x))

typedef u64 archive_field_sid_t;  /* string_buffer identifier, resolvable by a string_buffer dictionary */
typedef char field_null_t;
typedef i8 archive_field_boolean_t;
typedef i8 archive_field_i8_t;
typedef i16 archive_field_i16_t;
typedef i32 archive_field_i32_t;
typedef i64 archive_field_i64_t;
typedef u8 archive_field_u8_t;
typedef u16 archive_field_u16_t;
typedef u32 archive_field_u32_t;
typedef u64 archive_field_u64_t;
typedef float archive_field_number_t;
typedef const char *field_string_t;

#define NULL_ENCODED_STRING            0
#define NULL_BOOLEAN                   INT8_MAX
#define NULL_INT8                      INT8_MAX
#define NULL_INT16                     INT16_MAX
#define NULL_INT32                     INT32_MAX
#define NULL_INT64                     INT64_MAX
#define NULL_UINT8                     UINT8_MAX
#define NULL_UINT16                    UINT16_MAX
#define NULL_UINT32                    UINT32_MAX
#define NULL_UINT64                    UINT64_MAX
#define NULL_FLOAT                     NAN
#define NULL_OBJECT_MODEL(objectModel) (objectModel->entries.num_elems == 0)

#define IS_NULL_STRING(str)   (str == NULL_ENCODED_STRING)
#define IS_NULL_BOOL(val)     (val == NULL_BOOLEAN)
#define IS_NULL_INT8(val)     (val == NULL_INT8)
#define IS_NULL_INT16(val)    (val == NULL_INT16)
#define IS_NULL_INT32(val)    (val == NULL_INT32)
#define IS_NULL_INT64(val)    (val == NULL_INT64)
#define IS_NULL_UINT8(val)    (val == NULL_UINT8)
#define IS_NULL_UINT16(val)   (val == NULL_UINT16)
#define IS_NULL_UINT32(val)   (val == NULL_UINT32)
#define IS_NULL_UINT64(val)   (val == NULL_UINT64)
#define IS_NULL_NUMBER(val)   (val == NULL_FLOAT)

#define LIMITS_INT8_MAX                (NULL_INT8 - 1)
#define LIMITS_INT16_MAX               (NULL_INT16 - 1)
#define LIMITS_INT32_MAX               (NULL_INT32 - 1)
#define LIMITS_INT64_MAX               (NULL_INT64 - 1)
#define LIMITS_UINT8_MAX               (NULL_UINT8 - 1)
#define LIMITS_UINT16_MAX              (NULL_UINT16 - 1)
#define LIMITS_UINT32_MAX              (NULL_UINT32 - 1)
#define LIMITS_UINT64_MAX              (NULL_UINT64 - 1)

#define LIMITS_INT8_MIN                INT8_MIN
#define LIMITS_INT16_MIN               INT16_MIN
#define LIMITS_INT32_MIN               INT32_MIN
#define LIMITS_INT64_MIN               INT64_MIN
#define LIMITS_UINT8_MIN               0
#define LIMITS_UINT16_MIN              0
#define LIMITS_UINT32_MIN              0
#define LIMITS_UINT64_MIN              0

#define NULL_TEXT "null"

#define BOOLEAN_FALSE 0
#define BOOLEAN_TRUE  1

#define GET_TYPE_SIZE(value_type)                                                                                      \
({                                                                                                                     \
    size_t value_size;                                                                                                 \
    switch (value_type) {                                                                                              \
        case FIELD_NULL:                                                                                           \
            value_size = sizeof(u16);                                                                              \
            break;                                                                                                     \
        case FIELD_BOOLEAN:                                                                                        \
            value_size = sizeof(archive_field_boolean_t);                                                          \
            break;                                                                                                     \
        case FIELD_INT8:                                                                                           \
            value_size = sizeof(archive_field_i8_t);                                                               \
            break;                                                                                                     \
        case FIELD_INT16:                                                                                          \
            value_size = sizeof(archive_field_i16_t);                                                              \
            break;                                                                                                     \
        case FIELD_INT32:                                                                                          \
            value_size = sizeof(archive_field_i32_t);                                                              \
            break;                                                                                                     \
        case FIELD_INT64:                                                                                          \
            value_size = sizeof(archive_field_i64_t);                                                              \
            break;                                                                                                     \
        case FIELD_UINT8:                                                                                          \
            value_size = sizeof(archive_field_u8_t);                                                               \
            break;                                                                                                     \
        case FIELD_UINT16:                                                                                         \
            value_size = sizeof(archive_field_u16_t);                                                              \
            break;                                                                                                     \
        case FIELD_UINT32:                                                                                         \
            value_size = sizeof(archive_field_u32_t);                                                              \
            break;                                                                                                     \
        case FIELD_UINT64:                                                                                         \
            value_size = sizeof(archive_field_u64_t);                                                              \
            break;                                                                                                     \
        case FIELD_FLOAT:                                                                                          \
            value_size = sizeof(archive_field_number_t);                                                           \
            break;                                                                                                     \
        case FIELD_STRING:                                                                                         \
            value_size = sizeof(archive_field_sid_t);                                                              \
            break;                                                                                                     \
        case FIELD_OBJECT:                                                                                         \
            value_size = sizeof(column_doc_obj);                                                                   \
            break;                                                                                                     \
        default:                                                                                                       \
        ERROR_PRINT_AND_DIE(ERR_NOTYPE);                                                                       \
    }                                                                                                                  \
    value_size;                                                                                                        \
})

END_DECL

#endif/**
 * A variable-length unsigned integer type that encodes the number of used bytes by a preceding marker byte
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef UINTVAR_MARKER_H
#define UINTVAR_MARKER_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include "stdinc.h"
#include "stdbool.h"
#include "types.h"

/**
 * This type is for variable-length unsigned integer types.
 *
 * The encoding uses a dedicated byte (called marker) to identify the number of subsequent bytes that holding the
 * actual value: if the first byte read is...
 *      - ... 'c', then the next byte contains an unsigned integer value of 8bit.
 *      - ... 'd', then the next 2 bytes contain an unsigned integer value of 16bit.
 *      - ... 'i', then the next 4 bytes contain an unsigned integer value of 32bit.
 *      - ... 'l', then the next 8 bytes contain an unsigned integer value of 64bit.
 *
 * This implementation supports variable-length encoding to the maximum of unsigned integers of
 * 64bit (fixed-sized) requiring constant 1 byte more than the standard C type.
 *
 * Note that size requirements for this kind of variable-length encoding is (relatively) huge;
 * the encoding requires as least 12.5% additional storage (to encode 64bit integers) and at most
 * 100.0% (!) additional storage (to encode 8bit integers). The benefit of marker-based variable-length encoding is that
 * read-/write performance is superior to byte-stream based variable-length encoding (see <code>uintvar_stream</code>),
 * and that size requirements payoff for values larger than 65536. Faster read/write performance compared to byte-stream
 * based variable-length encoding comes by the fact that after determination of actual number of bytes to reads
 * (i.e., the marker), there is no interpretation overhead to read the actual value while in byte-stream based encoding
 * each subsequent byte must be inspect (on whether it is the last byte in the stream) before reading its contained
 * value (after some byte shift operations).
 *
 * Rule of thumb:
 *      - if fixed-length types are a good choice, and...
 *          - ... if speed matters, use fast-types of the C library (e.g., <code>uint_fast32_t</code>)
 *          - ... if space matters, use fix-types of the C library (e.g., <code>uint32_t</code>)
 *      - if variable-length types are a good choice, and...
 *          - ... if space shall be minimized in exchange of read/write performance, use <code>uintvar_stream_t</code>
 *          - ... if read/write performance shall be maximized in exchange of space, use <code>uintvar_marker_t</code>
 */

BEGIN_DECL

#define UINT_VAR_MARKER_8 'c'
#define UINT_VAR_MARKER_16 'd'
#define UINT_VAR_MARKER_32 'i'
#define UINT_VAR_MARKER_64 'l'

typedef void *uintvar_marker_t;

typedef enum uintvar_marker {
        UINTVAR_8,
        UINTVAR_16,
        UINTVAR_32,
        UINTVAR_64
} uintvar_marker_e;

bool uintvar_marker_write(uintvar_marker_t dst, u64 value);
u64 uintvar_marker_read(u8 *nbytes_read, uintvar_marker_t src);
uintvar_marker_e uintvar_marker_type_for(u64 value);
bool uintvar_marker_type(const void *data);
size_t uintvar_marker_sizeof(uintvar_marker_t value);
size_t uintvar_marker_required_size(u64 value);

END_DECL

#endif
/**
 * A variable-length unsigned integer type that encodes the number of used bytes by a flag bit in the byte stream
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef UINTVAR_STREAM_H
#define UINTVAR_STREAM_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>
#include <memfile.h>

BEGIN_DECL

/**
 * This type is for variable-length unsigned integer types.
 *
 * The encoding uses the most significant bit (MSB) for each byte in sequence of bytes (called blocks) to determine the
 * number of bytes required to express the unsigned integer value. The MSB is 1 if there is at least one further byte to
 * be read, and 0 if the end of the sequence is reached. The remaining 7 bits per block contain the actual bits for
 * integer value encoding.
 *
 * This implementation supports variable-length encoding of the maximum value up to unsigned integer of 64bit (fixed-
 * length) in at most 10 blocks.
 *
 * Example: Given the unsigned integer 16389, its fixed-length representation is
 *                  01000000 00000101
 *          Using the varuint type, the representation is
 *                  (1)0000001 (1)0000000 (0)0000101
 *
 *
 *      # required |      min value      |      max value
 *        blocks   |       (incl.)       |       (incl.)
 *      -----------+---------------------+----------------------
 *               1 |                   0 |                  127
 *               2 |                 128 |                16383
 *               3 |               16384 |              2097151
 *               4 |             2097152 |            268435455
 *               5 |           268435456 |          34359738367
 *               6 |         34359738368 |        4398046511103
 *               7 |       4398046511104 |      562949953421311
 *               8 |     562949953421312 |    72057594037927935
 *               9 |   72057594037927936 |  9223372036854775807
 *              10 | 9223372036854775808 | 18446744073709551615
 *
  * Rule of thumb:
 *      - if fixed-length types are a good choice, and...
 *          - ... if speed matters, use fast-types of the C library (e.g., <code>uint_fast32_t</code>)
 *          - ... if space matters, use fix-types of the C library (e.g., <code>uint32_t</code>)
 *      - if variable-length types are a good choice, and...
 *          - ... if space shall be minimized in exchange of read/write performance, use <code>uintvar_stream_t</code>
 *          - ... if read/write performance shall be maximized in exchange of space, use <code>uintvar_marker_t</code>
 */

typedef void *uintvar_stream_t;

#define UINTVAR_STREAM_MAX_BLOCKS()    (4)

u8 uintvar_stream_write(uintvar_stream_t dst, u64 value);

#define UINTVAR_STREAM_SIZEOF(value)                                                                               \
({                                                                                                                     \
        size_t num_blocks_strlen = UINTVAR_STREAM_REQUIRED_BLOCKS(value);                                          \
        num_blocks_strlen = num_blocks_strlen < sizeof(uintvar_stream_t) ? sizeof(uintvar_stream_t):num_blocks_strlen; \
        num_blocks_strlen;                                                                                             \
})

#define UINTVAR_STREAM_REQUIRED_BLOCKS(value)                                                                      \
({                                                                                                                     \
        u8 num_blocks_required;                                                                                    \
        if (value < 128u) {                                                                                            \
                num_blocks_required = 1;                                                                               \
        } else if (value < 16384u) {                                                                                   \
                num_blocks_required = 2;                                                                               \
        } else if (value < 2097152u) {                                                                                 \
                num_blocks_required = 3;                                                                               \
        } else if (value < 268435456u) {                                                                               \
                num_blocks_required = 4;                                                                               \
        } else if (value < 34359738368u) {                                                                             \
                num_blocks_required = 5;                                                                               \
        } else if (value < 4398046511104u) {                                                                           \
                num_blocks_required = 6;                                                                               \
        } else if (value < 562949953421312u) {                                                                         \
                num_blocks_required = 7;                                                                               \
        } else if (value < 72057594037927936u) {                                                                       \
                num_blocks_required = 8;                                                                               \
        } else if (value < 9223372036854775808u) {                                                                     \
                num_blocks_required = 9;                                                                               \
        } else {                                                                                                       \
                num_blocks_required = 10;                                                                              \
        }                                                                                                              \
        num_blocks_required;                                                                                           \
})

u64 uintvar_stream_read(u8 *nbytes, uintvar_stream_t src);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef UNIQUE_ID_H
#define UNIQUE_ID_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>

BEGIN_DECL

typedef u64 unique_id_t;

bool unique_id_create(unique_id_t *out);

bool unique_id_get_global_wallclocktime(uint_fast8_t *out, unique_id_t id);
bool unique_id_get_global_build_path_bit(uint_fast8_t *out, unique_id_t id);
bool unique_id_get_global_build_time_bit(uint_fast8_t *out, unique_id_t id);
bool unique_id_get_process_id(uint_fast8_t *out, unique_id_t id);
bool unique_id_get_process_magic(uint_fast8_t *out, unique_id_t id);
bool unique_id_get_process_counter(uint_fast16_t *out, unique_id_t id);
bool unique_id_get_thread_id(uint_fast8_t *out, unique_id_t id);
bool unique_id_get_thread_magic(uint_fast8_t *out, unique_id_t id);
bool unique_id_get_thread_counter(uint_fast32_t *out, unique_id_t id);
bool unique_id_get_call_random(uint_fast8_t *out, unique_id_t id);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef CONVERT_H
#define CONVERT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <types.h>

BEGIN_DECL

i64 convert_atoi64(const char *string_buffer);
u64 convert_atoiu64(const char *string_buffer);

END_DECL

#endif/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef HEXDUMP_H
#define HEXDUMP_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <string_buffer.h>

BEGIN_DECL

bool hexdump(string_buffer *dst, const void *base, u64 nbytes);
bool hexdump_print(FILE *file, const void *base, u64 nbytes);

END_DECL

#endif
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef AKR_NUMBERS_H
#define AKR_NUMBERS_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <types.h>

typedef enum number_min_type_e {
        NUMBER_U8,
        NUMBER_U16,
        NUMBER_U32,
        NUMBER_U64,
        NUMBER_I8,
        NUMBER_I16,
        NUMBER_I32,
        NUMBER_I64,
        NUMBER_UNKNOWN
} number_min_type_e;

number_min_type_e number_min_type_unsigned(u64 value);
number_min_type_e number_min_type_signed(i64 value);

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SORT_H
#define SORT_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <stdinc.h>
#include <alloc.h>

#include "stdlib.h"

BEGIN_DECL

typedef bool (*less_eq_func_t)(const void *lhs, const void *rhs);

typedef bool (*less_eq_wargs_func_t)(const void *lhs, const void *rhs, void *args);

typedef bool (*eq_func_t)(const void *lhs, const void *rhs);

typedef bool (*less_func_t)(const void *lhs, const void *rhs);

#define QSORT_INDICES_SWAP(x, y)                                                                                   \
{                                                                                                                      \
    size_t *a = x;                                                                                                     \
    size_t *b = y;                                                                                                     \
    size_t tmp = *a;                                                                                                   \
    *a = *b;                                                                                                           \
    *b = tmp;                                                                                                          \
}

#define QSORT_INDICIES_PARTITION(indices, base, width, comp, l, h)                                                 \
({                                                                                                                     \
    const void   *x       = base + indices[h] * width;                                                                 \
    i64        i       = (l - 1);                                                                                  \
                                                                                                                       \
    for (i64 j = l; j <= h - 1; j++)                                                                               \
    {                                                                                                                  \
        if (comp(base + indices[j] * width, x))                                                                        \
        {                                                                                                              \
            i++;                                                                                                       \
            QSORT_INDICES_SWAP (indices + i, indices + j);                                                         \
        }                                                                                                              \
    }                                                                                                                  \
    QSORT_INDICES_SWAP (indices + (i + 1), indices + h);                                                           \
    (i + 1);                                                                                                           \
})

#define QSORT_INDICIES_PARTITION_WARGS(indices, base, width, comp, l, h, args)                                     \
({                                                                                                                     \
    const void   *x       = base + indices[h] * width;                                                                 \
    i64        i       = (l - 1);                                                                                  \
                                                                                                                       \
    for (i64 j = l; j <= h - 1; j++)                                                                               \
    {                                                                                                                  \
        if (comp(base + indices[j] * width, x, args))                                                                  \
        {                                                                                                              \
            i++;                                                                                                       \
            QSORT_INDICES_SWAP (indices + i, indices + j);                                                         \
        }                                                                                                              \
    }                                                                                                                  \
    QSORT_INDICES_SWAP (indices + (i + 1), indices + h);                                                           \
    (i + 1);                                                                                                           \
})

bool sort_qsort_indicies(size_t *indices, const void *base, size_t width, less_eq_func_t comp, size_t nelemns, allocator *alloc);
int sort_qsort_indicies_wargs(size_t *indices, const void *base, size_t width, less_eq_wargs_func_t comp, size_t nelemens, allocator *alloc, void *args);
size_t sort_bsearch_indicies(const size_t *indicies, const void *base, size_t width, size_t nelemens, const void *neelde, eq_func_t compEq, less_func_t compLess);

size_t sort_get_min(const size_t *elements, size_t nelemens);
size_t sort_get_max(const size_t *elements, size_t nelemens);
double sort_get_sum(const size_t *elements, size_t nelemens);
double sort_get_avg(const size_t *elements, size_t nelemens);

END_DECL

#endif
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef VECTOR_H
#define VECTOR_H

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <sys/mman.h>

#include <stdinc.h>
#include <alloc.h>
#include <memfile.h>

BEGIN_DECL

#define DECLARE_PRINTER_FUNC(type)                                                                                     \
    void vector_##type##_printer_func(memfile *dst, void ofType(T) *values, size_t num_elems);

DECLARE_PRINTER_FUNC(u_char)

DECLARE_PRINTER_FUNC(i8)

DECLARE_PRINTER_FUNC(i16)

DECLARE_PRINTER_FUNC(i32)

DECLARE_PRINTER_FUNC(i64)

DECLARE_PRINTER_FUNC(u8)

DECLARE_PRINTER_FUNC(u16)

DECLARE_PRINTER_FUNC(u32)

DECLARE_PRINTER_FUNC(u64)

DECLARE_PRINTER_FUNC(size_t)

#define VECTOR_PRINT_UCHAR  vector_u_char_printer_func
#define VECTOR_PRINT_UINT8  vector_u8_printer_func
#define VECTOR_PRINT_UINT16 vector_u16_printer_func
#define VECTOR_PRINT_UINT32 vector_u32_printer_func
#define VECTOR_PRINT_UINT64 vector_u64_printer_func
#define VECTOR_PRINT_INT8   vector_i8_printer_func
#define VECTOR_PRINT_INT16  vector_i16_printer_func
#define VECTOR_PRINT_INT32  vector_i32_printer_func
#define VECTOR_PRINT_INT64  vector_i64_printer_func
#define VECTOR_PRINT_SIZE_T vector_size_t_printer_func

/**
 * An implementation of the concrete data type Vector, a resizeable dynamic array.
 */
typedef struct vector {
        /**
        *  Memory allocator that is used to get memory for user data
        */
        allocator *allocator;

        /**
         *  Fixed number of bytes for a single element that should be stored in the vector
         */
        size_t elem_size;

        /**
         *  The number of elements currently stored in the vector
         */
        u32 num_elems;

        /**
         *  The number of elements for which currently memory is reserved
         */
        u32 cap_elems;

        /**
        * The grow factor considered for resize operations
        */
        float grow_factor;

        /**
         * A pointer to a memory address managed by 'allocator' that contains the user data
         */
        void *base;

        /**
         *  Error information
         */
        err err;
} vector;

/**
 * Utility implementation of generic vector to specialize for type of 'char *'
 */
typedef vector ofType(const char *) string_vector_t;

/**
 * Constructs a new vector for elements of size 'elem_size', reserving memory for 'cap_elems' elements using
 * the allocator 'alloc'.
 *
 * @param out non-null vector that should be constructed
 * @param alloc an allocator
 * @param elem_size fixed-length element size
 * @param cap_elems number of elements for which memory should be reserved
 * @return STATUS_OK if success, and STATUS_NULLPTR in case of NULL pointer parameters
 */
bool vector_create(vector *out, const allocator *alloc, size_t elem_size, size_t cap_elems);

bool vector_serialize(FILE *file, vector *vec);

bool vector_deserialize(vector *vec, err *err, FILE *file);

/**
 * Provides hints on the OS kernel how to deal with memory inside this vector.
 *
 * @param vec non-null vector
 * @param madviseAdvice value to give underlying <code>madvise</code> syscall and advice, see man page
 * of <code>madvise</code>
 * @return STATUS_OK if success, otherwise a value indicating the ERROR
 */
bool vector_memadvice(vector *vec, int madviseAdvice);

/**
 * Sets the factor for determining the reallocation size in case of a resizing operation.
 *
 * Note that <code>factor</code> must be larger than one.
 *
 * @param vec non-null vector for which the grow factor should be changed
 * @param factor a positive real number larger than 1
 * @return STATUS_OK if success, otherwise a value indicating the ERROR
 */
bool vector_set_grow_factor(vector *vec, float factor);

/**
 * Frees up memory requested via the allocator.
 *
 * Depending on the allocator implementation, dropping the reserved memory might not take immediately effect.
 * The pointer 'vec' itself gets not freed.
 *
 * @param vec vector to be freed
 * @return STATUS_OK if success, and STATUS_NULL_PTR in case of NULL pointer to 'vec'
 */
bool vector_drop(vector *vec);

/**
 * Returns information on whether elements are stored in this vector or not.
 * @param vec non-null pointer to the vector
 * @return Returns <code>STATUS_TRUE</code> if <code>vec</code> is empty. Otherwise <code>STATUS_FALSE</code> unless
 *         an ERROR occurs. In case an ERROR is occured, the return value is neither <code>STATUS_TRUE</code> nor
 *         <code>STATUS_FALSE</code> but an value indicating that ERROR.
 */
bool vector_is_empty(const vector *vec);

/**
 * Appends 'num_elems' elements stored in 'data' into the vector by copying num_elems * vec->elem_size into the
 * vectors memory block.
 *
 * In case the capacity is not sufficient, the vector gets automatically resized.
 *
 * @param vec the vector in which the data should be pushed
 * @param data non-null pointer to data that should be appended. Must be at least size of 'num_elems' * vec->elem_size.
 * @param num_elems number of elements stored in data
 * @return STATUS_OK if success, and STATUS_NULLPTR in case of NULL pointer parameters
 */
bool vector_push(vector *vec, const void *data, size_t num_elems);

const void *vector_peek(vector *vec);

#define VECTOR_PEEK(vec, type) (type *)(vector_peek(vec))

/**
 * Appends 'how_many' elements of the same source stored in 'data' into the vector by copying how_many * vec->elem_size
 * into the vectors memory block.
 *
 * In case the capacity is not sufficient, the vector gets automatically resized.
 *
 * @param vec the vector in which the data should be pushed
 * @param data non-null pointer to data that should be appended. Must be at least size of one vec->elem_size.
 * @param num_elems number of elements stored in data
 * @return STATUS_OK if success, and STATUS_NULLPTR in case of NULL pointer parameters
 */
bool vector_repeated_push(vector *vec, const void *data, size_t how_often);

/**
 * Returns a pointer to the last element in this vector, or <code>NULL</code> is the vector is already empty.
 * The number of elements contained in that vector is decreased, too.
 *
 * @param vec non-null pointer to the vector
 * @return Pointer to last element, or <code>NULL</code> if vector is empty
 */
const void *vector_pop(vector *vec);

bool vector_clear(vector *vec);

/**
 * Shinks the vector's internal data block to fits its real size, i.e., remove reserved memory
 *
 * @param vec
 * @return
 */
bool vector_shrink(vector *vec);

/**
 * Increases the capacity of that vector according the internal grow factor
 * @param numNewSlots a pointer to a value that will store the number of newly created slots in that vector if
 *                      <code>num_new_slots</code> is non-null. If this parameter is <code>NULL</code>, it is ignored.
 * @param vec non-null pointer to the vector that should be grown
 * @return STATUS_OK in case of success, and another value indicating an ERROR otherwise.
 */
bool vector_grow(size_t *numNewSlots, vector *vec);

bool vector_grow_to(vector *vec, size_t capacity);

/**
 * Returns the number of elements currently stored in the vector
 *
 * @param vec the vector for which the operation is started
 * @return 0 in case of NULL pointer to 'vec', or the number of elements otherwise.
 */
size_t vector_length(const vector *vec);

#define VECTOR_GET(vec, pos, type) (type *) vector_at(vec, pos)

#define VECTOR_NEW_AND_GET(vec, type)                                                                              \
({                                                                                                                     \
    type obj;                                                                                                          \
    size_t vectorLength = vector_length(vec);                                                                      \
    vector_push(vec, &obj, 1);                                                                                     \
    VECTOR_GET(vec, vectorLength, type);                                                                           \
})

const void *vector_at(const vector *vec, size_t pos);

/**
 * Returns the number of elements for which memory is currently reserved in the vector
 *
 * @param vec the vector for which the operation is started
 * @return 0 in case of NULL pointer to 'vec', or the number of elements otherwise.
 */
size_t vector_capacity(const vector *vec);

/**
 * Set the internal size of <code>vec</code> to its capacity.
 */
bool vector_enlarge_size_to_capacity(vector *vec);

bool vector_zero_memory(vector *vec);

bool vector_zero_memory_in_range(vector *vec, size_t from, size_t to);

bool vector_set(vector *vec, size_t pos, const void *data);

bool vector_cpy(vector *dst, const vector *src);

bool vector_cpy_to(vector *dst, vector *src);

/**
 * Gives raw data access to data stored in the vector; do not manipulate this data since otherwise the vector
 * might get corrupted.
 *
 * @param vec the vector for which the operation is started
 * @return pointer to user-data managed by this vector
 */
const void *vector_data(const vector *vec);

char *vector_string(const vector ofType(T) *vec,
                    void (*printerFunc)(memfile *dst, void ofType(T) *values, size_t num_elems));

#define VECTOR_ALL(vec, type) (type *) vector_data(vec)

END_DECL

#endif
