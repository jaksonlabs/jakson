/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <errno.h>

#include <jak_alloc.h>

static void *_jak_alloc_invoke_malloc(jak_allocator *self, size_t size);

static void *_jak_alloc_invoke_realloc(jak_allocator *self, void *ptr, size_t size);

static void _jak_alloc_invoke_free(jak_allocator *self, void *ptr);

static void _jak_alloc_invoke_clone(jak_allocator *dst, const jak_allocator *self);

bool jak_alloc_create_std(jak_allocator *alloc)
{
        if (alloc) {
                alloc->extra = NULL;
                alloc->malloc = _jak_alloc_invoke_malloc;
                alloc->realloc = _jak_alloc_invoke_realloc;
                alloc->free = _jak_alloc_invoke_free;
                alloc->clone = _jak_alloc_invoke_clone;
                jak_error_init(&alloc->err);
                return true;
        } else {
                return false;
        }
}

bool jak_alloc_this_or_std(jak_allocator *dst, const jak_allocator *self)
{
        if (!self) {
                return jak_alloc_create_std(dst);
        } else {
                return jak_alloc_clone(dst, self);
        }
}

void *jak_alloc_malloc(jak_allocator *alloc, size_t size)
{
        JAK_ASSERT(alloc);
        return alloc->malloc(alloc, size);
}

void *jak_alloc_realloc(jak_allocator *alloc, void *ptr, size_t size)
{
        return alloc->realloc(alloc, ptr, size);
}

bool jak_alloc_free(jak_allocator *alloc, void *ptr)
{
        JAK_ERROR_IF_NULL(alloc);
        JAK_ERROR_IF_NULL(ptr);
        alloc->free(alloc, ptr);
        return true;
}

bool jak_alloc_clone(jak_allocator *dst, const jak_allocator *src)
{
        JAK_ERROR_IF_NULL(dst && src)
        src->clone(dst, src);
        return true;
}

static void *_jak_alloc_invoke_malloc(jak_allocator *self, size_t size)
{
        JAK_UNUSED(self);
        void *result;

        errno = 0;
        if ((result = malloc(size)) == NULL) {
                JAK_ERROR_PRINT_AND_DIE(JAK_ERR_MALLOCERR)
        } else {
                return result;
        }
}

static void *_jak_alloc_invoke_realloc(jak_allocator *self, void *ptr, size_t size)
{
        JAK_UNUSED(self);
        void *result;

        if ((result = realloc(ptr, size)) == NULL) {
                JAK_ERROR_PRINT(JAK_ERR_MALLOCERR)
                return ptr;
        } else {
                return result;
        }
}

static void _jak_alloc_invoke_free(jak_allocator *self, void *ptr)
{
        JAK_UNUSED(self);
        return free(ptr);
}

static void _jak_alloc_invoke_clone(jak_allocator *dst, const jak_allocator *self)
{
        *dst = *self;
}
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <inttypes.h>

#include <jak_vector.h>
#include <jak_alloc_trace.h>
#include <jak_utils_sort.h>
#include <jak_spinlock.h>
#include <jak_time.h>

#define TRACE_ALLOC_TAG "trace_alloc"

#define TO_GIB(x)       (x/1024.0f/1024.0f/1024.0f)

struct trace_stats {
        size_t num_malloc_calls;
        size_t num_realloc_calls;
        size_t num_free_calls;
        size_t total_size;
        jak_vector ofType(size_t) *malloc_sizes;
        jak_spinlock *spinlock;
        FILE *statistics_file;
        jak_timestamp startup_timestamp;
};

#define DEFINE_PAGE_WITH_SIZE(x)                                                                                       \
typedef struct page_##x##b_t                                                                                           \
{                                                                                                                      \
    size_t                        user_size;                                                                           \
    size_t                        capacity;                                                                            \
    char                          data[x];                                                                             \
} page_##x##b_t;                                                                                                       \
                                                                                                                       \
JAK_FUNC_UNUSED static inline void *page_##x##b_new(size_t user_size) {                                             \
    JAK_ASSERT (user_size <= x);                                                                                           \
    struct page_##x##b_t *page = malloc(sizeof(struct page_##x##b_t));                                                 \
    page->user_size = user_size;                                                                                       \
    page->capacity = x;                                                                                                \
    return (((void *)page) + 2 * sizeof(size_t));                                                                      \
}

DEFINE_PAGE_WITH_SIZE(1)

DEFINE_PAGE_WITH_SIZE(2)

DEFINE_PAGE_WITH_SIZE(4)

DEFINE_PAGE_WITH_SIZE(8)

DEFINE_PAGE_WITH_SIZE(16)

DEFINE_PAGE_WITH_SIZE(32)

DEFINE_PAGE_WITH_SIZE(64)

DEFINE_PAGE_WITH_SIZE(128)

DEFINE_PAGE_WITH_SIZE(256)

DEFINE_PAGE_WITH_SIZE(512)

DEFINE_PAGE_WITH_SIZE(1024)

DEFINE_PAGE_WITH_SIZE(2048)

DEFINE_PAGE_WITH_SIZE(4096)

DEFINE_PAGE_WITH_SIZE(8192)

DEFINE_PAGE_WITH_SIZE(16384)

DEFINE_PAGE_WITH_SIZE(32768)

DEFINE_PAGE_WITH_SIZE(65536)

DEFINE_PAGE_WITH_SIZE(131072)

DEFINE_PAGE_WITH_SIZE(262144)

DEFINE_PAGE_WITH_SIZE(524288)

DEFINE_PAGE_WITH_SIZE(1048576)

DEFINE_PAGE_WITH_SIZE(2097152)

DEFINE_PAGE_WITH_SIZE(4194304)

DEFINE_PAGE_WITH_SIZE(8388608)

DEFINE_PAGE_WITH_SIZE(16777216)

DEFINE_PAGE_WITH_SIZE(33554432)

DEFINE_PAGE_WITH_SIZE(67108864)

DEFINE_PAGE_WITH_SIZE(134217728)

DEFINE_PAGE_WITH_SIZE(268435456)

DEFINE_PAGE_WITH_SIZE(536870912)

DEFINE_PAGE_WITH_SIZE(1073741824)

DEFINE_PAGE_WITH_SIZE(2147483648)

DEFINE_PAGE_WITH_SIZE(4294967296)

DEFINE_PAGE_WITH_SIZE(8589934592)

DEFINE_PAGE_WITH_SIZE(17179869184)

DEFINE_PAGE_WITH_SIZE(34359738368)

DEFINE_PAGE_WITH_SIZE(68719476736)

DEFINE_PAGE_WITH_SIZE(137438953472)

DEFINE_PAGE_WITH_SIZE(274877906944)

DEFINE_PAGE_WITH_SIZE(549755813888)

#define REGISTER_PAGE(x)    \
    {x, page_##x##b_new}

struct page_template_entry {
        size_t size;

        void *(*new_ptr_func)(size_t user_size);
} page_template_register[] = {

        REGISTER_PAGE(1), REGISTER_PAGE(2), REGISTER_PAGE(4), REGISTER_PAGE(8), REGISTER_PAGE(16), REGISTER_PAGE(32),
        REGISTER_PAGE(64), REGISTER_PAGE(128), REGISTER_PAGE(256), REGISTER_PAGE(512), REGISTER_PAGE(1024),
        REGISTER_PAGE(2048), REGISTER_PAGE(4096), REGISTER_PAGE(8192), REGISTER_PAGE(16384), REGISTER_PAGE(32768),
        REGISTER_PAGE(65536), REGISTER_PAGE(131072), REGISTER_PAGE(262144), REGISTER_PAGE(524288),
        REGISTER_PAGE(1048576), REGISTER_PAGE(2097152), REGISTER_PAGE(4194304), REGISTER_PAGE(8388608),
        REGISTER_PAGE(16777216), REGISTER_PAGE(33554432), REGISTER_PAGE(67108864), REGISTER_PAGE(134217728),
        REGISTER_PAGE(268435456), REGISTER_PAGE(536870912), REGISTER_PAGE(1073741824), REGISTER_PAGE(2147483648),
        REGISTER_PAGE(4294967296), REGISTER_PAGE(8589934592), REGISTER_PAGE(17179869184), REGISTER_PAGE(34359738368),
        REGISTER_PAGE(68719476736), REGISTER_PAGE(137438953472), REGISTER_PAGE(274877906944),
        REGISTER_PAGE(549755813888)};

static inline void *alloc_register(size_t size)
{
        size_t num_options = JAK_ARRAY_LENGTH(page_template_register);
        for (size_t i = 0; i < num_options; i++) {
                struct page_template_entry *entry = page_template_register + i;
                if (size <= entry->size) {
                        return entry->new_ptr_func(size);
                }
        }
        JAK_ERROR_PRINT_AND_DIE(JAK_ERR_MALLOCERR)
        return NULL;
}

struct trace_stats global_trace_stats =
        {.num_malloc_calls   = 0, .num_realloc_calls  = 0, .num_free_calls     = 0, .total_size         = 0, .malloc_sizes       = NULL, .spinlock           = NULL};

static void *_jak_alloc_trace_invoke_malloc(jak_allocator *self, size_t size);

static void *_jak_alloc_trace_invoke_realloc(jak_allocator *self, void *ptr, size_t size);

static void _jak_alloc_trace_invoke_free(jak_allocator *self, void *ptr);

static void _jak_alloc_trace_invoke_clone(jak_allocator *dst, const jak_allocator *self);

#define LAZY_INIT()                                                                                                    \
if (!global_trace_stats.malloc_sizes) {                                                                                \
    global_trace_stats.malloc_sizes = malloc(sizeof(jak_vector));                                                    \
    jak_vector_create(global_trace_stats.malloc_sizes, &default_alloc, sizeof(size_t), 1000000);                       \
    global_trace_stats.spinlock = jak_alloc_malloc(&default_alloc, sizeof(jak_spinlock));                            \
    jak_spinlock_init(global_trace_stats.spinlock);                                                                 \
    global_trace_stats.statistics_file = fopen("trace-alloc-stats.csv", "a");                                          \
    fprintf(global_trace_stats.statistics_file,                                                                        \
            "system_time;num_alloc_calls;num_realloc_calls;num_free_calls;memory_in_use\n");                           \
    global_trace_stats.startup_timestamp = jak_wallclock();                                                \
}

#define WRITE_STATS_FILE()                                                                                             \
{                                                                                                                      \
    fprintf(global_trace_stats.statistics_file, "%" PRIu64 ";%zu;%zu;%zu;%zu\n",                                       \
            jak_wallclock() - global_trace_stats.startup_timestamp,                                        \
            global_trace_stats.num_malloc_calls,                                                                       \
            global_trace_stats.num_realloc_calls,                                                                      \
            global_trace_stats.num_free_calls,                                                                         \
            global_trace_stats.total_size);                                                                            \
    fflush(global_trace_stats.statistics_file);                                                                        \
}

int jak_trace_alloc_create(jak_allocator *alloc)
{
        JAK_ERROR_IF_NULL(alloc);
        jak_allocator default_alloc;
        jak_alloc_create_std(&default_alloc);

        alloc->extra = NULL;
        LAZY_INIT();

        alloc->malloc = _jak_alloc_trace_invoke_malloc;
        alloc->realloc = _jak_alloc_trace_invoke_realloc;
        alloc->free = _jak_alloc_trace_invoke_free;
        alloc->clone = _jak_alloc_trace_invoke_clone;

        return true;
}

static void *_jak_alloc_trace_invoke_malloc(jak_allocator *self, size_t size)
{
        JAK_UNUSED(self);

        jak_spinlock_acquire(global_trace_stats.spinlock);

        jak_allocator default_alloc;
        jak_alloc_create_std(&default_alloc);

        LAZY_INIT();

        global_trace_stats.num_malloc_calls++;

        //DEBUG(TRACE_ALLOC_TAG, "malloc %zu B, call to malloc: %zu so far (allocator %p)", size,
        //      global_trace_stats.num_malloc_calls, self);
        jak_vector_push(global_trace_stats.malloc_sizes, &size, 1);

        size_t min_alloc_size = jak_sort_get_min(JAK_VECTOR_ALL(global_trace_stats.malloc_sizes, size_t),
                                             jak_vector_length(global_trace_stats.malloc_sizes));
        size_t max_alloc_size = jak_sort_get_max(JAK_VECTOR_ALL(global_trace_stats.malloc_sizes, size_t),
                                             jak_vector_length(global_trace_stats.malloc_sizes));
        double avg_alloc_size = jak_sort_get_avg(JAK_VECTOR_ALL(global_trace_stats.malloc_sizes, size_t),
                                             jak_vector_length(global_trace_stats.malloc_sizes));
        global_trace_stats.total_size += size;

        JAK_UNUSED(min_alloc_size);
        JAK_UNUSED(max_alloc_size);
        JAK_UNUSED(avg_alloc_size);

        //DEBUG(TRACE_ALLOC_TAG, "min/max/avg alloc size: %zu/%zu/%f B (allocator %p)", min_alloc_size, max_alloc_size,
        //      avg_alloc_size, self);
        //DEBUG(TRACE_ALLOC_TAG, "allocated size in at total: %zu B (%f GiB)", global_trace_stats.total_size,
        //      TO_GIB(global_trace_stats.total_size));

        void *result = alloc_register(size);

        WRITE_STATS_FILE();

        jak_spinlock_release(global_trace_stats.spinlock);

        return result;
}

static void *_jak_alloc_trace_invoke_realloc(jak_allocator *self, void *ptr, size_t size)
{
        JAK_UNUSED(self);

        jak_spinlock_acquire(global_trace_stats.spinlock);

        jak_allocator default_alloc;
        jak_alloc_create_std(&default_alloc);

        LAZY_INIT();

        size_t page_capacity = *(size_t *) (ptr - sizeof(size_t));
        size_t page_usersize = *(size_t *) (ptr - 2 * sizeof(size_t));

        global_trace_stats.total_size -= page_usersize;
        global_trace_stats.total_size += size;

        global_trace_stats.num_realloc_calls++;

        //DEBUG(TRACE_ALLOC_TAG, "num realloc calls %zu (allocator %p)", global_trace_stats.num_realloc_calls, self);

        //DEBUG(TRACE_ALLOC_TAG, "allocated size in at total: %zu B (%f GiB)", global_trace_stats.total_size,
        //      TO_GIB(global_trace_stats.total_size));

        WRITE_STATS_FILE();

        if (size <= page_capacity) {
                *(size_t *) (ptr - 2 * sizeof(size_t)) = size;
                jak_spinlock_release(global_trace_stats.spinlock);
                return ptr;
        } else {
                void *page_ptr = ptr - 2 * sizeof(size_t);
                free(page_ptr);
                void *result = alloc_register(size);
                jak_spinlock_release(global_trace_stats.spinlock);
                return result;
        }
}

static void _jak_alloc_trace_invoke_free(jak_allocator *self, void *ptr)
{
        JAK_UNUSED(self);

        jak_spinlock_acquire(global_trace_stats.spinlock);

        jak_allocator default_alloc;
        jak_alloc_create_std(&default_alloc);

        void *page_ptr = ptr - 2 * sizeof(size_t);

        global_trace_stats.total_size -= *(size_t *) (page_ptr);

        global_trace_stats.num_free_calls++;

        //DEBUG(TRACE_ALLOC_TAG, "freed %zu B, num free calls %zu (allocator %p)", *(size_t *) (page_ptr),
        //      global_trace_stats.num_free_calls, self);

        //DEBUG(TRACE_ALLOC_TAG, "allocated size in at total: %zu B (%f GiB)", global_trace_stats.total_size,
        //      TO_GIB(global_trace_stats.total_size));

        WRITE_STATS_FILE();

        free(page_ptr);

        jak_spinlock_release(global_trace_stats.spinlock);
}

static void _jak_alloc_trace_invoke_clone(jak_allocator *dst, const jak_allocator *self)
{
        *dst = *self;
}
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <inttypes.h>

#include <jak_unique_id.h>
#include <jak_encode_async.h>
#include <jak_pack.h>
#include <jak_archive_strid_it.h>
#include <jak_archive_int.h>
#include <jak_archive_query.h>
#include <jak_archive_cache.h>
#include <jak_archive.h>
#include <jak_encode_sync.h>
#include <jak_stdinc.h>
#include <jak_memblock.h>
#include <jak_memfile.h>
#include <jak_huffman.h>
#include <jak_archive.h>

#define WRITE_PRIMITIVE_VALUES(memfile, values_vec, type)                                                              \
{                                                                                                                      \
    type *values = JAK_VECTOR_ALL(values_vec, type);                                                                \
    jak_memfile_write(memfile, values, values_vec->num_elems * sizeof(type));                                       \
}

#define WRITE_ARRAY_VALUES(memfile, values_vec, type)                                                                  \
{                                                                                                                      \
    for (jak_u32 i = 0; i < values_vec->num_elems; i++) {                                                             \
        jak_vector ofType(type) *nested_values = JAK_VECTOR_GET(values_vec, i, jak_vector);                     \
        WRITE_PRIMITIVE_VALUES(memfile, nested_values, type);                                                          \
    }                                                                                                                  \
}

#define PRINT_SIMPLE_PROPS(file, memfile, offset, nesting_level, value_type, type_string, format_string)               \
{                                                                                                                      \
    jak_prop_header *prop_header = JAK_MEMFILE_READ_TYPE(memfile, jak_prop_header);             \
    jak_archive_field_sid_t *keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile, prop_header->num_entries *          \
                                   sizeof(jak_archive_field_sid_t));                                                        \
    value_type *values = (value_type *) JAK_MEMFILE_READ(memfile, prop_header->num_entries * sizeof(value_type));   \
    fprintf(file, "0x%04x ", (unsigned) offset);                                                                       \
    INTENT_LINE(nesting_level)                                                                                         \
    fprintf(file, "[marker: %c (" type_string ")] [num_entries: %d] [", entryMarker, prop_header->num_entries);        \
    for (jak_u32 i = 0; i < prop_header->num_entries; i++) {                                                          \
        fprintf(file, "key: %"PRIu64"%s", keys[i], i + 1 < prop_header->num_entries ? ", " : "");                      \
    }                                                                                                                  \
    fprintf(file, "] [");                                                                                              \
    for (jak_u32 i = 0; i < prop_header->num_entries; i++) {                                                          \
      fprintf(file, "value: "format_string"%s", values[i], i + 1 < prop_header->num_entries ? ", " : "");              \
    }                                                                                                                  \
    fprintf(file, "]\n");                                                                                              \
}

#define PRINT_ARRAY_PROPS(memfile, offset, nesting_level, entryMarker, type, type_string, format_string)               \
{                                                                                                                      \
    jak_prop_header *prop_header = JAK_MEMFILE_READ_TYPE(memfile, jak_prop_header);             \
                                                                                                                       \
    jak_archive_field_sid_t *keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile, prop_header->num_entries *          \
                                        sizeof(jak_archive_field_sid_t));                                                   \
    jak_u32 *array_lengths;                                                                                           \
                                                                                                                       \
    fprintf(file, "0x%04x ", (unsigned) offset);                                                                       \
    INTENT_LINE(nesting_level)                                                                                         \
    fprintf(file, "[marker: %c ("type_string")] [num_entries: %d] [", entryMarker, prop_header->num_entries);          \
                                                                                                                       \
    for (jak_u32 i = 0; i < prop_header->num_entries; i++) {                                                          \
        fprintf(file, "key: %"PRIu64"%s", keys[i], i + 1 < prop_header->num_entries ? ", " : "");                      \
    }                                                                                                                  \
    fprintf(file, "] [");                                                                                              \
                                                                                                                       \
    array_lengths = (jak_u32 *) JAK_MEMFILE_READ(memfile, prop_header->num_entries * sizeof(jak_u32));            \
                                                                                                                       \
    for (jak_u32 i = 0; i < prop_header->num_entries; i++) {                                                          \
        fprintf(file, "num_entries: %d%s", array_lengths[i], i + 1 < prop_header->num_entries ? ", " : "");            \
    }                                                                                                                  \
                                                                                                                       \
    fprintf(file, "] [");                                                                                              \
                                                                                                                       \
    for (jak_u32 array_idx = 0; array_idx < prop_header->num_entries; array_idx++) {                                  \
        type *values = (type *) JAK_MEMFILE_READ(memfile, array_lengths[array_idx] * sizeof(type));                 \
        fprintf(file, "[");                                                                                            \
        for (jak_u32 i = 0; i < array_lengths[array_idx]; i++) {                                                      \
            fprintf(file, "value: "format_string"%s", values[i], i + 1 < array_lengths[array_idx] ? ", " : "");        \
        }                                                                                                              \
        fprintf(file, "]%s", array_idx + 1 < prop_header->num_entries ? ", " : "");                                    \
    }                                                                                                                  \
                                                                                                                       \
    fprintf(file, "]\n");                                                                                              \
}

#define INTENT_LINE(nesting_level)                                                                                     \
{                                                                                                                      \
    for (unsigned nest_level = 0; nest_level < nesting_level; nest_level++) {                                          \
        fprintf(file, "   ");                                                                                          \
    }                                                                                                                  \
}

#define PRINT_VALUE_ARRAY(type, memfile, header, format_string)                                                        \
{                                                                                                                      \
    jak_u32 num_elements = *JAK_MEMFILE_READ_TYPE(memfile, jak_u32);                                              \
    const type *values = (const type *) JAK_MEMFILE_READ(memfile, num_elements * sizeof(type));                     \
    fprintf(file, "0x%04x ", (unsigned) offset);                                                                       \
    INTENT_LINE(nesting_level);                                                                                        \
    fprintf(file, "   [num_elements: %d] [values: [", num_elements);                                                   \
    for (size_t i = 0; i < num_elements; i++) {                                                                        \
        fprintf(file, "value: "format_string"%s", values[i], i + 1 < num_elements ? ", " : "");                        \
    }                                                                                                                  \
    fprintf(file, "]\n");                                                                                              \
}

static jak_offset_t skip_record_header(jak_memfile *memfile);

static void
update_record_header(jak_memfile *memfile, jak_offset_t root_object_header_offset, jak_column_doc *model,
                     jak_u64 record_size);

static bool __serialize(jak_offset_t *offset, jak_error *err, jak_memfile *memfile,
                        jak_column_doc_obj *columndoc,
                        jak_offset_t root_object_header_offset);

static jak_object_flags_u *get_flags(jak_object_flags_u *flags, jak_column_doc_obj *columndoc);

static void update_file_header(jak_memfile *memfile, jak_offset_t root_object_header_offset);

static void skip_file_header(jak_memfile *memfile);

static bool serialize_jak_string_dic(jak_memfile *memfile, jak_error *err, const jak_doc_bulk *context,
                                 jak_packer_e compressor);

static bool print_archive_from_memfile(FILE *file, jak_error *err, jak_memfile *memfile);

bool jak_archive_from_json(jak_archive *out, const char *file, jak_error *err, const char *json_string,
                           jak_packer_e compressor, jak_str_dict_tag_e dictionary,
                           size_t num_async_dic_threads,
                           bool read_optimized,
                           bool bake_jak_string_id_index, jak_archive_callback *callback)
{
        JAK_ERROR_IF_NULL(out);
        JAK_ERROR_IF_NULL(file);
        JAK_ERROR_IF_NULL(err);
        JAK_ERROR_IF_NULL(json_string);

        JAK_OPTIONAL_CALL(callback, begin_create_from_json);

        jak_memblock *stream;
        FILE *out_file;

        if (!jak_archive_stream_from_json(&stream,
                                          err,
                                          json_string,
                                          compressor,
                                          dictionary,
                                          num_async_dic_threads,
                                          read_optimized,
                                          bake_jak_string_id_index,
                                          callback)) {
                return false;
        }

        JAK_OPTIONAL_CALL(callback, begin_write_archive_file_to_disk);

        if ((out_file = fopen(file, "w")) == NULL) {
                JAK_ERROR(err, JAK_ERR_FOPENWRITE);
                jak_memblock_drop(stream);
                return false;
        }

        if (!jak_archive_write(out_file, stream)) {
                JAK_ERROR(err, JAK_ERR_WRITEARCHIVE);
                fclose(out_file);
                jak_memblock_drop(stream);
                return false;
        }

        fclose(out_file);

        JAK_OPTIONAL_CALL(callback, end_write_archive_file_to_disk);

        JAK_OPTIONAL_CALL(callback, begin_load_archive);

        if (!jak_archive_open(out, file)) {
                JAK_ERROR(err, JAK_ERR_ARCHIVEOPEN);
                return false;
        }

        JAK_OPTIONAL_CALL(callback, end_load_archive);

        jak_memblock_drop(stream);

        JAK_OPTIONAL_CALL(callback, end_create_from_json);

        return true;
}

bool jak_archive_stream_from_json(jak_memblock **stream, jak_error *err, const char *json_string,
                                  jak_packer_e compressor, jak_str_dict_tag_e dictionary,
                                  size_t num_async_dic_threads,
                                  bool read_optimized,
                                  bool bake_id_index, jak_archive_callback *callback)
{
        JAK_ERROR_IF_NULL(stream);
        JAK_ERROR_IF_NULL(err);
        JAK_ERROR_IF_NULL(json_string);

        jak_string_dict dic;
        jak_json_parser parser;
        jak_json_err error_desc;
        jak_doc_bulk bulk;
        jak_doc_entries *partition;
        jak_column_doc *columndoc;
        jak_json jak_json;

        JAK_OPTIONAL_CALL(callback, begin_jak_archive_stream_from_json)

        JAK_OPTIONAL_CALL(callback, begin_setup_jak_string_dict_ionary);
        if (dictionary == JAK_SYNC) {
                jak_encode_sync_create(&dic, 1000, 1000, 1000, 0, NULL);
        } else if (dictionary == JAK_ASYNC) {
                jak_encode_async_create(&dic, 1000, 1000, 1000, num_async_dic_threads, NULL);
        } else {
                JAK_ERROR(err, JAK_ERR_UNKNOWN_DIC_TYPE);
        }

        JAK_OPTIONAL_CALL(callback, end_setup_jak_string_dict_ionary);

        JAK_OPTIONAL_CALL(callback, begin_parse_json);
        jak_json_parser_create(&parser);
        if (!(jak_json_parse(&jak_json, &error_desc, &parser, json_string))) {
                char buffer[2048];
                if (error_desc.token) {
                        sprintf(buffer,
                                "%s. Token %s was found in line %u column %u",
                                error_desc.msg,
                                error_desc.token_type_str,
                                error_desc.token->line,
                                error_desc.token->column);
                        JAK_ERROR_WDETAILS(err, JAK_ERR_JSONPARSEERR, &buffer[0]);
                } else {
                        sprintf(buffer, "%s", error_desc.msg);
                        JAK_ERROR_WDETAILS(err, JAK_ERR_JSONPARSEERR, &buffer[0]);
                }
                return false;
        }
        JAK_OPTIONAL_CALL(callback, end_parse_json);

        JAK_OPTIONAL_CALL(callback, begin_test_json);
        if (!jak_json_test(err, &jak_json)) {
                return false;
        }
        JAK_OPTIONAL_CALL(callback, end_test_json);

        JAK_OPTIONAL_CALL(callback, begin_import_json);
        if (!jak_doc_bulk_create(&bulk, &dic)) {
                JAK_ERROR(err, JAK_ERR_BULKCREATEFAILED);
                return false;
        }

        partition = jak_doc_bulk_new_entries(&bulk);
        jak_doc_bulk_add_json(partition, &jak_json);

        jak_json_drop(&jak_json);

        jak_doc_bulk_shrink(&bulk);

        columndoc = jak_doc_entries_columndoc(&bulk, partition, read_optimized);

        if (!jak_archive_from_model(stream, err, columndoc, compressor, bake_id_index, callback)) {
                return false;
        }

        JAK_OPTIONAL_CALL(callback, end_import_json);

        JAK_OPTIONAL_CALL(callback, begin_cleanup);
        jak_string_dict_drop(&dic);
        jak_doc_bulk_drop(&bulk);
        jak_doc_entries_drop(partition);
        jak_columndoc_free(columndoc);
        free(columndoc);
        JAK_OPTIONAL_CALL(callback, end_cleanup);

        JAK_OPTIONAL_CALL(callback, end_jak_archive_stream_from_json)

        return true;
}

static bool run_jak_string_id_baking(jak_error *err, jak_memblock **stream)
{
        jak_archive archive;
        char tmp_file_name[512];
        jak_uid_t rand_part;
        jak_unique_id_create(&rand_part);
        sprintf(tmp_file_name, "/tmp/jakson-tool-temp-%"
                               PRIu64
                               ".jakson-tool", rand_part);
        FILE *tmp_file;

        if ((tmp_file = fopen(tmp_file_name, "w")) == NULL) {
                JAK_ERROR(err, JAK_ERR_TMP_FOPENWRITE);
                return false;
        }

        if (!jak_archive_write(tmp_file, *stream)) {
                JAK_ERROR(err, JAK_ERR_WRITEARCHIVE);
                fclose(tmp_file);
                remove(tmp_file_name);
                return false;
        }

        fflush(tmp_file);
        fclose(tmp_file);

        if (!jak_archive_open(&archive, tmp_file_name)) {
                JAK_ERROR(err, JAK_ERR_ARCHIVEOPEN);
                return false;
        }

        bool has_index;
        jak_archive_has_query_index_jak_string_id_to_offset(&has_index, &archive);
        if (has_index) {
                JAK_ERROR(err, JAK_ERR_INTERNALERR);
                remove(tmp_file_name);
                return false;
        }

        struct jak_sid_to_offset *index;
        jak_archive_query query;
        jak_query_create(&query, &archive);
        jak_query_create_index_jak_string_id_to_offset(&index, &query);
        jak_query_drop(&query);
        jak_archive_close(&archive);

        if ((tmp_file = fopen(tmp_file_name, "rb+")) == NULL) {
                JAK_ERROR(err, JAK_ERR_TMP_FOPENWRITE);
                return false;
        }

        fseek(tmp_file, 0, SEEK_END);
        jak_offset_t index_pos = ftell(tmp_file);
        jak_query_index_id_to_offset_serialize(tmp_file, err, index);
        jak_offset_t file_length = ftell(tmp_file);
        fseek(tmp_file, 0, SEEK_SET);

        jak_archive_header header;
        size_t nread = fread(&header, sizeof(jak_archive_header), 1, tmp_file);
        JAK_ERROR_IF(nread != 1, err, JAK_ERR_FREAD_FAILED);
        header.jak_string_id_to_offset_index_offset = index_pos;
        fseek(tmp_file, 0, SEEK_SET);
        int nwrite = fwrite(&header, sizeof(jak_archive_header), 1, tmp_file);
        JAK_ERROR_IF(nwrite != 1, err, JAK_ERR_FWRITE_FAILED);
        fseek(tmp_file, 0, SEEK_SET);

        jak_query_drop_index_jak_string_id_to_offset(index);

        jak_memblock_drop(*stream);
        jak_memblock_from_file(stream, tmp_file, file_length);

        remove(tmp_file_name);

        return true;
}

bool jak_archive_from_model(jak_memblock **stream, jak_error *err, jak_column_doc *model,
                            jak_packer_e compressor,
                            bool bake_jak_string_id_index, jak_archive_callback *callback)
{
        JAK_ERROR_IF_NULL(model)
        JAK_ERROR_IF_NULL(stream)
        JAK_ERROR_IF_NULL(err)

        JAK_OPTIONAL_CALL(callback, begin_create_from_model)

        jak_memblock_create(stream, 1024 * 1024 * 1024);
        jak_memfile memfile;
        jak_memfile_open(&memfile, *stream, JAK_READ_WRITE);

        JAK_OPTIONAL_CALL(callback, begin_write_jak_string_table);
        skip_file_header(&memfile);
        if (!serialize_jak_string_dic(&memfile, err, model->bulk, compressor)) {
                return false;
        }
        JAK_OPTIONAL_CALL(callback, end_write_jak_string_table);

        JAK_OPTIONAL_CALL(callback, begin_write_record_table);
        jak_offset_t record_header_offset = skip_record_header(&memfile);
        update_file_header(&memfile, record_header_offset);
        jak_offset_t root_object_header_offset = jak_memfile_tell(&memfile);
        if (!__serialize(NULL, err, &memfile, &model->columndoc, root_object_header_offset)) {
                return false;
        }
        jak_u64 record_size = jak_memfile_tell(&memfile) - (record_header_offset + sizeof(jak_record_header));
        update_record_header(&memfile, record_header_offset, model, record_size);
        JAK_OPTIONAL_CALL(callback, end_write_record_table);

        jak_memfile_shrink(&memfile);

        if (bake_jak_string_id_index) {
                /* create string id to offset index, and append it to the CARBON file */
                JAK_OPTIONAL_CALL(callback, begin_jak_string_id_index_baking);
                if (!run_jak_string_id_baking(err, stream)) {
                        return false;
                }
                JAK_OPTIONAL_CALL(callback, end_jak_string_id_index_baking);
        } else {
                JAK_OPTIONAL_CALL(callback, skip_jak_string_id_index_baking);
        }

        JAK_OPTIONAL_CALL(callback, end_create_from_model)

        return true;
}

jak_archive_io_context *jak_archive_io_context_create(jak_archive *archive)
{
        JAK_ERROR_IF_NULL(archive);
        jak_archive_io_context *context;
        if (jak_io_context_create(&context, &archive->err, archive->disk_file_path)) {
                return context;
        } else {
                JAK_ERROR(&archive->err, JAK_ERR_IO)
                return NULL;
        }
}

bool jak_archive_write(FILE *file, const jak_memblock *stream)
{
        return jak_memblock_write_to_file(file, stream);
}

bool jak_archive_load(jak_memblock **stream, FILE *file)
{
        long start = ftell(file);
        fseek(file, 0, SEEK_END);
        long end = ftell(file);
        fseek(file, start, SEEK_SET);
        long fileSize = (end - start);

        return jak_memblock_from_file(stream, file, fileSize);
}

bool jak_archive_print(FILE *file, jak_error *err, jak_memblock *stream)
{
        jak_memfile memfile;
        jak_memfile_open(&memfile, stream, JAK_READ_ONLY);
        if (jak_memfile_size(&memfile)
            < sizeof(jak_archive_header) + sizeof(jak_string_table_header) +
              sizeof(jak_object_header)) {
                JAK_ERROR(err, JAK_ERR_NOCARBONSTREAM);
                return false;
        } else {
                return print_archive_from_memfile(file, err, &memfile);
        }
}

bool _jak_archive_print_object(FILE *file, jak_error *err, jak_memfile *memfile, unsigned nesting_level);

static jak_u32 flags_to_int32(jak_object_flags_u *flags)
{
        return *((jak_i32 *) flags);
}

static const char *array_value_type_to_string(jak_error *err, jak_archive_field_e type)
{
        switch (type) {
                case JAK_FIELD_NULL:
                        return "Null Array";
                case JAK_FIELD_BOOLEAN:
                        return "Boolean Array";
                case JAK_FIELD_INT8:
                        return "Int8 Array";
                case JAK_FIELD_INT16:
                        return "Int16 Array";
                case JAK_FIELD_INT32:
                        return "Int32 Array";
                case JAK_FIELD_INT64:
                        return "Int64 Array";
                case JAK_FIELD_UINT8:
                        return "UInt8 Array";
                case JAK_FIELD_UINT16:
                        return "UInt16 Array";
                case JAK_FIELD_UINT32:
                        return "UInt32 Array";
                case JAK_FIELD_UINT64:
                        return "UInt64 Array";
                case JAK_FIELD_FLOAT:
                        return "UIntFloat Array";
                case JAK_FIELD_STRING:
                        return "Text Array";
                case JAK_FIELD_OBJECT:
                        return "Object Array";
                default: {
                        JAK_ERROR(err, JAK_ERR_NOVALUESTR)
                        return NULL;
                }
        }
}

static void
write_primitive_key_column(jak_memfile *memfile, jak_vector ofType(jak_archive_field_sid_t) *keys)
{
        jak_archive_field_sid_t *jak_string_ids = JAK_VECTOR_ALL(keys, jak_archive_field_sid_t);
        jak_memfile_write(memfile, jak_string_ids, keys->num_elems * sizeof(jak_archive_field_sid_t));
}

static jak_offset_t skip_var_value_offset_column(jak_memfile *memfile, size_t num_keys)
{
        jak_offset_t result = jak_memfile_tell(memfile);
        jak_memfile_skip(memfile, num_keys * sizeof(jak_offset_t));
        return result;
}

static void write_var_value_offset_column(jak_memfile *file, jak_offset_t where, jak_offset_t after,
                                          const jak_offset_t *values,
                                          size_t n)
{
        jak_memfile_seek(file, where);
        jak_memfile_write(file, values, n * sizeof(jak_offset_t));
        jak_memfile_seek(file, after);
}

static bool
write_primitive_fixed_value_column(jak_memfile *memfile, jak_error *err, jak_archive_field_e type,
                                   jak_vector ofType(T) *values_vec)
{
        JAK_ASSERT (type != JAK_FIELD_OBJECT); /** use 'write_primitive_var_value_column' instead */

        switch (type) {
                case JAK_FIELD_NULL:
                        break;
                case JAK_FIELD_BOOLEAN: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_boolean_t);
                        break;
                case JAK_FIELD_INT8: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_i8_t);
                        break;
                case JAK_FIELD_INT16: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_i16_t);
                        break;
                case JAK_FIELD_INT32: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_i32_t);
                        break;
                case JAK_FIELD_INT64: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_i64_t);
                        break;
                case JAK_FIELD_UINT8: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_u8_t);
                        break;
                case JAK_FIELD_UINT16: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_u16_t);
                        break;
                case JAK_FIELD_UINT32: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_u32_t);
                        break;
                case JAK_FIELD_UINT64: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_u64_t);
                        break;
                case JAK_FIELD_FLOAT: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_number_t);
                        break;
                case JAK_FIELD_STRING: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_archive_field_sid_t);
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOTYPE);
                        return false;
        }
        return true;
}

static jak_offset_t *__write_primitive_column(jak_memfile *memfile, jak_error *err,
                                              jak_vector ofType(jak_column_doc_obj) *values_vec,
                                              jak_offset_t root_offset)
{
        jak_offset_t *result = JAK_MALLOC(values_vec->num_elems * sizeof(jak_offset_t));
        jak_column_doc_obj *mapped = JAK_VECTOR_ALL(values_vec, jak_column_doc_obj);
        for (jak_u32 i = 0; i < values_vec->num_elems; i++) {
                jak_column_doc_obj *obj = mapped + i;
                result[i] = jak_memfile_tell(memfile) - root_offset;
                if (!__serialize(NULL, err, memfile, obj, root_offset)) {
                        return NULL;
                }
        }
        return result;
}

static bool __write_array_len_column(jak_error *err, jak_memfile *memfile, jak_archive_field_e type,
                                     jak_vector ofType(...) *values)
{
        switch (type) {
                case JAK_FIELD_NULL:
                        break;
                case JAK_FIELD_BOOLEAN:
                case JAK_FIELD_INT8:
                case JAK_FIELD_INT16:
                case JAK_FIELD_INT32:
                case JAK_FIELD_INT64:
                case JAK_FIELD_UINT8:
                case JAK_FIELD_UINT16:
                case JAK_FIELD_UINT32:
                case JAK_FIELD_UINT64:
                case JAK_FIELD_FLOAT:
                case JAK_FIELD_STRING:
                        for (jak_u32 i = 0; i < values->num_elems; i++) {
                                jak_vector *arrays = JAK_VECTOR_GET(values, i, jak_vector);
                                jak_memfile_write(memfile, &arrays->num_elems, sizeof(jak_u32));
                        }
                        break;
                case JAK_FIELD_OBJECT: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_ILLEGALIMPL)
                        return false;
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOTYPE);
                        return false;
        }
        return true;
}

static bool write_array_value_column(jak_memfile *memfile, jak_error *err, jak_archive_field_e type,
                                     jak_vector ofType(...) *values_vec)
{

        switch (type) {
                case JAK_FIELD_NULL: WRITE_PRIMITIVE_VALUES(memfile, values_vec, jak_u32);
                        break;
                case JAK_FIELD_BOOLEAN: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_boolean_t);
                        break;
                case JAK_FIELD_INT8: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_i8_t);
                        break;
                case JAK_FIELD_INT16: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_i16_t);
                        break;
                case JAK_FIELD_INT32: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_i32_t);
                        break;
                case JAK_FIELD_INT64: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_i64_t);
                        break;
                case JAK_FIELD_UINT8: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_u64_t);
                        break;
                case JAK_FIELD_UINT16: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_u16_t);
                        break;
                case JAK_FIELD_UINT32: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_u32_t);
                        break;
                case JAK_FIELD_UINT64: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_u64_t);
                        break;
                case JAK_FIELD_FLOAT: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_number_t);
                        break;
                case JAK_FIELD_STRING: WRITE_ARRAY_VALUES(memfile, values_vec, jak_archive_field_sid_t);
                        break;
                case JAK_FIELD_OBJECT: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_NOTIMPL)
                        return false;
                default: JAK_ERROR(err, JAK_ERR_NOTYPE)
                        return false;
        }
        return true;
}

static bool write_array_prop(jak_offset_t *offset, jak_error *err, jak_memfile *memfile,
                             jak_vector ofType(jak_archive_field_sid_t) *keys, jak_archive_field_e type,
                             jak_vector ofType(...) *values,
                             jak_offset_t root_object_header_offset)
{
        JAK_ASSERT(keys->num_elems == values->num_elems);

        if (keys->num_elems > 0) {
                jak_prop_header header =
                        {.marker = jak_global_marker_symbols[jak_global_value_array_marker_mapping[type].marker].symbol, .num_entries = keys
                                ->num_elems};
                jak_offset_t prop_ofOffset = jak_memfile_tell(memfile);
                jak_memfile_write(memfile, &header, sizeof(jak_prop_header));

                write_primitive_key_column(memfile, keys);
                if (!__write_array_len_column(err, memfile, type, values)) {
                        return false;
                }
                if (!write_array_value_column(memfile, err, type, values)) {
                        return false;
                }
                *offset = (prop_ofOffset - root_object_header_offset);
        } else {
                *offset = 0;
        }
        return true;
}

static bool write_array_props(jak_memfile *memfile, jak_error *err, jak_column_doc_obj *columndoc,
                              jak_archive_prop_offs *offsets, jak_offset_t root_object_header_offset)
{
        if (!write_array_prop(&offsets->null_arrays,
                              err,
                              memfile,
                              &columndoc->null_array_prop_keys,
                              JAK_FIELD_NULL,
                              &columndoc->null_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->bool_arrays,
                              err,
                              memfile,
                              &columndoc->bool_array_prop_keys,
                              JAK_FIELD_BOOLEAN,
                              &columndoc->bool_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->int8_arrays,
                              err,
                              memfile,
                              &columndoc->int8_array_prop_keys,
                              JAK_FIELD_INT8,
                              &columndoc->int8_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->int16_arrays,
                              err,
                              memfile,
                              &columndoc->int16_array_prop_keys,
                              JAK_FIELD_INT16,
                              &columndoc->int16_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->int32_arrays,
                              err,
                              memfile,
                              &columndoc->int32_array_prop_keys,
                              JAK_FIELD_INT32,
                              &columndoc->int32_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->int64_arrays,
                              err,
                              memfile,
                              &columndoc->int64_array_prop_keys,
                              JAK_FIELD_INT64,
                              &columndoc->int64_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->uint8_arrays,
                              err,
                              memfile,
                              &columndoc->uint8_array_prop_keys,
                              JAK_FIELD_UINT8,
                              &columndoc->uint8_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->uint16_arrays,
                              err,
                              memfile,
                              &columndoc->uint16_array_prop_keys,
                              JAK_FIELD_UINT16,
                              &columndoc->uint16_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->uint32_arrays,
                              err,
                              memfile,
                              &columndoc->uint32_array_prop_keys,
                              JAK_FIELD_UINT32,
                              &columndoc->uint32_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->uint64_arrays,
                              err,
                              memfile,
                              &columndoc->uint64_array_prop_keys,
                              JAK_FIELD_UINT64,
                              &columndoc->ui64_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->float_arrays,
                              err,
                              memfile,
                              &columndoc->float_array_prop_keys,
                              JAK_FIELD_FLOAT,
                              &columndoc->float_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        if (!write_array_prop(&offsets->jak_string_arrays,
                              err,
                              memfile,
                              &columndoc->jak_string_array_prop_keys,
                              JAK_FIELD_STRING,
                              &columndoc->jak_string_array_prop_vals,
                              root_object_header_offset)) {
                return false;
        }
        return true;
}

/** Fixed-length property lists; value position can be determined by size of value and position of key in key column.
 * In contrast, variable-length property list require an additional offset column (see 'write_var_props') */
static bool write_fixed_props(jak_offset_t *offset, jak_error *err, jak_memfile *memfile,
                              jak_vector ofType(jak_archive_field_sid_t) *keys, jak_archive_field_e type,
                              jak_vector ofType(T) *values)
{
        JAK_ASSERT(!values || keys->num_elems == values->num_elems);
        JAK_ASSERT(type != JAK_FIELD_OBJECT); /** use 'write_var_props' instead */

        if (keys->num_elems > 0) {
                jak_prop_header header =
                        {.marker = jak_global_marker_symbols[valueMarkerMapping[type].marker].symbol, .num_entries = keys
                                ->num_elems};

                jak_offset_t prop_ofOffset = jak_memfile_tell(memfile);
                jak_memfile_write(memfile, &header, sizeof(jak_prop_header));

                write_primitive_key_column(memfile, keys);
                if (!write_primitive_fixed_value_column(memfile, err, type, values)) {
                        return false;
                }
                *offset = prop_ofOffset;
        } else {
                *offset = 0;
        }
        return true;
}

/** Variable-length property lists; value position cannot be determined by position of key in key column, since single
 * value has unknown size. Hence, a dedicated offset column is added to these properties allowing to seek directly
 * to a particular property. Due to the move of strings (i.e., variable-length values) to a dedicated string table,
 * the only variable-length value for properties are "JSON objects".
 * In contrast, fixed-length property list doesn't require an additional offset column (see 'write_fixed_props') */
static bool write_var_props(jak_offset_t *offset, jak_error *err, jak_memfile *memfile,
                            jak_vector ofType(jak_archive_field_sid_t) *keys,
                            jak_vector ofType(jak_column_doc_obj) *objects,
                            jak_offset_t root_object_header_offset)
{
        JAK_ASSERT(!objects || keys->num_elems == objects->num_elems);

        if (keys->num_elems > 0) {
                jak_prop_header header = {.marker = JAK_MARKER_SYMBOL_PROP_OBJECT, .num_entries = keys->num_elems};

                jak_offset_t prop_ofOffset = jak_memfile_tell(memfile);
                jak_memfile_write(memfile, &header, sizeof(jak_prop_header));

                write_primitive_key_column(memfile, keys);
                jak_offset_t value_offset = skip_var_value_offset_column(memfile, keys->num_elems);
                jak_offset_t *value_offsets = __write_primitive_column(memfile, err, objects,
                                                                       root_object_header_offset);
                if (!value_offsets) {
                        return false;
                }

                jak_offset_t last = jak_memfile_tell(memfile);
                write_var_value_offset_column(memfile, value_offset, last, value_offsets, keys->num_elems);
                free(value_offsets);
                *offset = prop_ofOffset;
        } else {
                *offset = 0;
        }
        return true;
}

static bool
write_primitive_props(jak_memfile *memfile, jak_error *err, jak_column_doc_obj *columndoc,
                      jak_archive_prop_offs *offsets, jak_offset_t root_object_header_offset)
{
        if (!write_fixed_props(&offsets->nulls, err, memfile, &columndoc->null_prop_keys, JAK_FIELD_NULL, NULL)) {
                return false;
        }
        if (!write_fixed_props(&offsets->bools,
                               err,
                               memfile,
                               &columndoc->bool_prop_keys,
                               JAK_FIELD_BOOLEAN,
                               &columndoc->bool_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->int8s,
                               err,
                               memfile,
                               &columndoc->int8_prop_keys,
                               JAK_FIELD_INT8,
                               &columndoc->int8_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->int16s,
                               err,
                               memfile,
                               &columndoc->int16_prop_keys,
                               JAK_FIELD_INT16,
                               &columndoc->int16_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->int32s,
                               err,
                               memfile,
                               &columndoc->int32_prop_keys,
                               JAK_FIELD_INT32,
                               &columndoc->int32_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->int64s,
                               err,
                               memfile,
                               &columndoc->int64_prop_keys,
                               JAK_FIELD_INT64,
                               &columndoc->int64_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->uint8s,
                               err,
                               memfile,
                               &columndoc->uint8_prop_keys,
                               JAK_FIELD_UINT8,
                               &columndoc->uint8_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->uint16s,
                               err,
                               memfile,
                               &columndoc->uint16_prop_keys,
                               JAK_FIELD_UINT16,
                               &columndoc->uint16_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->uint32s,
                               err,
                               memfile,
                               &columndoc->uin32_prop_keys,
                               JAK_FIELD_UINT32,
                               &columndoc->uint32_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->uint64s,
                               err,
                               memfile,
                               &columndoc->uint64_prop_keys,
                               JAK_FIELD_UINT64,
                               &columndoc->uint64_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->floats,
                               err,
                               memfile,
                               &columndoc->float_prop_keys,
                               JAK_FIELD_FLOAT,
                               &columndoc->float_prop_vals)) {
                return false;
        }
        if (!write_fixed_props(&offsets->strings,
                               err,
                               memfile,
                               &columndoc->jak_string_prop_keys,
                               JAK_FIELD_STRING,
                               &columndoc->jak_string_prop_vals)) {
                return false;
        }
        if (!write_var_props(&offsets->objects,
                             err,
                             memfile,
                             &columndoc->obj_prop_keys,
                             &columndoc->obj_prop_vals,
                             root_object_header_offset)) {
                return false;
        }

        offsets->nulls -= root_object_header_offset;
        offsets->bools -= root_object_header_offset;
        offsets->int8s -= root_object_header_offset;
        offsets->int16s -= root_object_header_offset;
        offsets->int32s -= root_object_header_offset;
        offsets->int64s -= root_object_header_offset;
        offsets->uint8s -= root_object_header_offset;
        offsets->uint16s -= root_object_header_offset;
        offsets->uint32s -= root_object_header_offset;
        offsets->uint64s -= root_object_header_offset;
        offsets->floats -= root_object_header_offset;
        offsets->strings -= root_object_header_offset;
        offsets->objects -= root_object_header_offset;
        return true;
}

static bool write_column_entry(jak_memfile *memfile, jak_error *err, jak_archive_field_e type,
                               jak_vector ofType(<T>) *column, jak_offset_t root_object_header_offset)
{
        jak_memfile_write(memfile, &column->num_elems, sizeof(jak_u32));
        switch (type) {
                case JAK_FIELD_NULL:
                        jak_memfile_write(memfile, column->base, column->num_elems * sizeof(jak_u32));
                        break;
                case JAK_FIELD_BOOLEAN:
                case JAK_FIELD_INT8:
                case JAK_FIELD_INT16:
                case JAK_FIELD_INT32:
                case JAK_FIELD_INT64:
                case JAK_FIELD_UINT8:
                case JAK_FIELD_UINT16:
                case JAK_FIELD_UINT32:
                case JAK_FIELD_UINT64:
                case JAK_FIELD_FLOAT:
                case JAK_FIELD_STRING:
                        jak_memfile_write(memfile, column->base, column->num_elems * GET_TYPE_SIZE(type));
                        break;
                case JAK_FIELD_OBJECT: {
                        jak_offset_t preObjectNext = 0;
                        for (size_t i = 0; i < column->num_elems; i++) {
                                jak_column_doc_obj *object = JAK_VECTOR_GET(column, i, jak_column_doc_obj);
                                if (JAK_LIKELY(preObjectNext != 0)) {
                                        jak_offset_t continuePos = jak_memfile_tell(memfile);
                                        jak_offset_t relativeContinuePos = continuePos - root_object_header_offset;
                                        jak_memfile_seek(memfile, preObjectNext);
                                        jak_memfile_write(memfile, &relativeContinuePos, sizeof(jak_offset_t));
                                        jak_memfile_seek(memfile, continuePos);
                                }
                                if (!__serialize(&preObjectNext, err, memfile, object, root_object_header_offset)) {
                                        return false;
                                }
                        }
                }
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOTYPE)
                        return false;
        }
        return true;
}

static bool write_column(jak_memfile *memfile, jak_error *err, jak_column_doc_column *column,
                         jak_offset_t root_object_header_offset)
{
        JAK_ASSERT(column->array_positions.num_elems == column->values.num_elems);

        jak_column_header header = {.marker = jak_global_marker_symbols[JAK_MARKER_TYPE_COLUMN].symbol, .column_name = column
                ->key_name, .value_type = jak_global_marker_symbols[jak_global_value_array_marker_mapping[column->type].marker]
                .symbol, .num_entries = column->values.num_elems};

        jak_memfile_write(memfile, &header, sizeof(jak_column_header));

        /** skip offset column to value entry points */
        jak_offset_t value_entry_offsets = jak_memfile_tell(memfile);
        jak_memfile_skip(memfile, column->values.num_elems * sizeof(jak_offset_t));

        jak_memfile_write(memfile, column->array_positions.base, column->array_positions.num_elems * sizeof(jak_u32));

        for (size_t i = 0; i < column->values.num_elems; i++) {
                jak_vector ofType(<T>) *column_data = JAK_VECTOR_GET(&column->values, i, jak_vector);
                jak_offset_t column_entry_offset = jak_memfile_tell(memfile);
                jak_offset_t relative_entry_offset = column_entry_offset - root_object_header_offset;
                jak_memfile_seek(memfile, value_entry_offsets + i * sizeof(jak_offset_t));
                jak_memfile_write(memfile, &relative_entry_offset, sizeof(jak_offset_t));
                jak_memfile_seek(memfile, column_entry_offset);
                if (!write_column_entry(memfile, err, column->type, column_data, root_object_header_offset)) {
                        return false;
                }
        }
        return true;
}

static bool write_object_array_props(jak_memfile *memfile, jak_error *err,
                                     jak_vector ofType(jak_column_doc_group) *object_key_columns,
                                     jak_archive_prop_offs *offsets,
                                     jak_offset_t root_object_header_offset)
{
        if (object_key_columns->num_elems > 0) {
                jak_object_array_header header = {.marker = jak_global_marker_symbols[JAK_MARKER_TYPE_PROP_OBJECT_ARRAY]
                        .symbol, .num_entries = object_key_columns->num_elems};

                offsets->object_arrays = jak_memfile_tell(memfile) - root_object_header_offset;
                jak_memfile_write(memfile, &header, sizeof(jak_object_array_header));

                for (size_t i = 0; i < object_key_columns->num_elems; i++) {
                        jak_column_doc_group *column_group = JAK_VECTOR_GET(object_key_columns, i,
                                                                            jak_column_doc_group);
                        jak_memfile_write(memfile, &column_group->key, sizeof(jak_archive_field_sid_t));
                }

                // skip offset column to column groups
                jak_offset_t column_offsets = jak_memfile_tell(memfile);
                jak_memfile_skip(memfile, object_key_columns->num_elems * sizeof(jak_offset_t));

                for (size_t i = 0; i < object_key_columns->num_elems; i++) {
                        jak_column_doc_group *column_group = JAK_VECTOR_GET(object_key_columns, i,
                                                                            jak_column_doc_group);
                        jak_offset_t this_column_offset_relative = jak_memfile_tell(memfile) - root_object_header_offset;

                        /* write an object-id for each position number */
                        size_t max_pos = 0;
                        for (size_t k = 0; k < column_group->columns.num_elems; k++) {
                                jak_column_doc_column
                                        *column = JAK_VECTOR_GET(&column_group->columns, k, jak_column_doc_column);
                                const jak_u32 *array_pos = JAK_VECTOR_ALL(&column->array_positions, jak_u32);
                                for (size_t m = 0; m < column->array_positions.num_elems; m++) {
                                        max_pos = JAK_MAX(max_pos, array_pos[m]);
                                }
                        }
                        jak_column_group_header jak_column_group_header =
                                {.marker = jak_global_marker_symbols[JAK_MARKER_TYPE_COLUMN_GROUP].symbol, .num_columns = column_group
                                        ->columns.num_elems, .num_objects = max_pos + 1};
                        jak_memfile_write(memfile, &jak_column_group_header, sizeof(jak_column_group_header));

                        for (size_t i = 0; i < jak_column_group_header.num_objects; i++) {
                                jak_uid_t oid;
                                if (!jak_unique_id_create(&oid)) {
                                        JAK_ERROR(err, JAK_ERR_THREADOOOBJIDS);
                                        return false;
                                }
                                jak_memfile_write(memfile, &oid, sizeof(jak_uid_t));
                        }

                        jak_offset_t continue_write = jak_memfile_tell(memfile);
                        jak_memfile_seek(memfile, column_offsets + i * sizeof(jak_offset_t));
                        jak_memfile_write(memfile, &this_column_offset_relative, sizeof(jak_offset_t));
                        jak_memfile_seek(memfile, continue_write);

                        jak_offset_t offset_column_to_columns = continue_write;
                        jak_memfile_skip(memfile, column_group->columns.num_elems * sizeof(jak_offset_t));

                        for (size_t k = 0; k < column_group->columns.num_elems; k++) {
                                jak_column_doc_column
                                        *column = JAK_VECTOR_GET(&column_group->columns, k, jak_column_doc_column);
                                jak_offset_t continue_write = jak_memfile_tell(memfile);
                                jak_offset_t column_off = continue_write - root_object_header_offset;
                                jak_memfile_seek(memfile, offset_column_to_columns + k * sizeof(jak_offset_t));
                                jak_memfile_write(memfile, &column_off, sizeof(jak_offset_t));
                                jak_memfile_seek(memfile, continue_write);
                                if (!write_column(memfile, err, column, root_object_header_offset)) {
                                        return false;
                                }
                        }

                }
        } else {
                offsets->object_arrays = 0;
        }

        return true;
}

static jak_offset_t skip_record_header(jak_memfile *memfile)
{
        jak_offset_t offset = jak_memfile_tell(memfile);
        jak_memfile_skip(memfile, sizeof(jak_record_header));
        return offset;
}

static void
update_record_header(jak_memfile *memfile, jak_offset_t root_object_header_offset, jak_column_doc *model,
                     jak_u64 record_size)
{
        jak_record_flags flags = {.bits.is_sorted = model->read_optimized};
        jak_record_header
                header = {.marker = JAK_MARKER_SYMBOL_RECORD_HEADER, .flags = flags.value, .record_size = record_size};
        jak_offset_t offset;
        jak_memfile_get_offset(&offset, memfile);
        jak_memfile_seek(memfile, root_object_header_offset);
        jak_memfile_write(memfile, &header, sizeof(jak_record_header));
        jak_memfile_seek(memfile, offset);
}

static void propOffsetsWrite(jak_memfile *memfile, const jak_object_flags_u *flags,
                             jak_archive_prop_offs *prop_offsets)
{
        if (flags->bits.has_null_props) {
                jak_memfile_write(memfile, &prop_offsets->nulls, sizeof(jak_offset_t));
        }
        if (flags->bits.has_bool_props) {
                jak_memfile_write(memfile, &prop_offsets->bools, sizeof(jak_offset_t));
        }
        if (flags->bits.has_int8_props) {
                jak_memfile_write(memfile, &prop_offsets->int8s, sizeof(jak_offset_t));
        }
        if (flags->bits.has_int16_props) {
                jak_memfile_write(memfile, &prop_offsets->int16s, sizeof(jak_offset_t));
        }
        if (flags->bits.has_int32_props) {
                jak_memfile_write(memfile, &prop_offsets->int32s, sizeof(jak_offset_t));
        }
        if (flags->bits.has_int64_props) {
                jak_memfile_write(memfile, &prop_offsets->int64s, sizeof(jak_offset_t));
        }
        if (flags->bits.has_uint8_props) {
                jak_memfile_write(memfile, &prop_offsets->uint8s, sizeof(jak_offset_t));
        }
        if (flags->bits.has_uint16_props) {
                jak_memfile_write(memfile, &prop_offsets->uint16s, sizeof(jak_offset_t));
        }
        if (flags->bits.has_uint32_props) {
                jak_memfile_write(memfile, &prop_offsets->uint32s, sizeof(jak_offset_t));
        }
        if (flags->bits.has_uint64_props) {
                jak_memfile_write(memfile, &prop_offsets->uint64s, sizeof(jak_offset_t));
        }
        if (flags->bits.has_float_props) {
                jak_memfile_write(memfile, &prop_offsets->floats, sizeof(jak_offset_t));
        }
        if (flags->bits.has_jak_string_props) {
                jak_memfile_write(memfile, &prop_offsets->strings, sizeof(jak_offset_t));
        }
        if (flags->bits.has_object_props) {
                jak_memfile_write(memfile, &prop_offsets->objects, sizeof(jak_offset_t));
        }
        if (flags->bits.has_null_array_props) {
                jak_memfile_write(memfile, &prop_offsets->null_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_bool_array_props) {
                jak_memfile_write(memfile, &prop_offsets->bool_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_int8_array_props) {
                jak_memfile_write(memfile, &prop_offsets->int8_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_int16_array_props) {
                jak_memfile_write(memfile, &prop_offsets->int16_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_int32_array_props) {
                jak_memfile_write(memfile, &prop_offsets->int32_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_int64_array_props) {
                jak_memfile_write(memfile, &prop_offsets->int64_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_uint8_array_props) {
                jak_memfile_write(memfile, &prop_offsets->uint8_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_uint16_array_props) {
                jak_memfile_write(memfile, &prop_offsets->uint16_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_uint32_array_props) {
                jak_memfile_write(memfile, &prop_offsets->uint32_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_uint64_array_props) {
                jak_memfile_write(memfile, &prop_offsets->uint64_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_float_array_props) {
                jak_memfile_write(memfile, &prop_offsets->float_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_jak_string_array_props) {
                jak_memfile_write(memfile, &prop_offsets->jak_string_arrays, sizeof(jak_offset_t));
        }
        if (flags->bits.has_object_array_props) {
                jak_memfile_write(memfile, &prop_offsets->object_arrays, sizeof(jak_offset_t));
        }
}

static void prop_offsets_skip_write(jak_memfile *memfile, const jak_object_flags_u *flags)
{
        unsigned num_skip_offset_bytes = 0;
        if (flags->bits.has_null_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_bool_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int8_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int16_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int32_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int64_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint8_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint16_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint32_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint64_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_float_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_jak_string_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_object_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_null_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_bool_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int8_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int16_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int32_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_int64_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint8_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint16_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint32_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_uint64_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_float_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_jak_string_array_props) {
                num_skip_offset_bytes++;
        }
        if (flags->bits.has_object_array_props) {
                num_skip_offset_bytes++;
        }

        jak_memfile_skip(memfile, num_skip_offset_bytes * sizeof(jak_offset_t));
}

static bool __serialize(jak_offset_t *offset, jak_error *err, jak_memfile *memfile,
                        jak_column_doc_obj *columndoc,
                        jak_offset_t root_object_header_offset)
{
        jak_object_flags_u flags;
        jak_archive_prop_offs prop_offsets;
        get_flags(&flags, columndoc);

        jak_offset_t header_offset = jak_memfile_tell(memfile);
        jak_memfile_skip(memfile, sizeof(jak_object_header));

        prop_offsets_skip_write(memfile, &flags);
        jak_offset_t next_offset = jak_memfile_tell(memfile);
        jak_offset_t default_next_nil = 0;
        jak_memfile_write(memfile, &default_next_nil, sizeof(jak_offset_t));

        if (!write_primitive_props(memfile, err, columndoc, &prop_offsets, root_object_header_offset)) {
                return false;
        }
        if (!write_array_props(memfile, err, columndoc, &prop_offsets, root_object_header_offset)) {
                return false;
        }
        if (!write_object_array_props(memfile,
                                      err,
                                      &columndoc->obj_array_props,
                                      &prop_offsets,
                                      root_object_header_offset)) {
                return false;
        }

        jak_memfile_write(memfile, &jak_global_marker_symbols[JAK_MARKER_TYPE_OBJECT_END].symbol, 1);

        jak_offset_t object_end_offset = jak_memfile_tell(memfile);
        jak_memfile_seek(memfile, header_offset);

        jak_uid_t oid;
        if (!jak_unique_id_create(&oid)) {
                JAK_ERROR(err, JAK_ERR_THREADOOOBJIDS);
                return false;
        }

        jak_object_header header =
                {.marker = jak_global_marker_symbols[JAK_MARKER_TYPE_OBJECT_BEGIN].symbol, .oid = oid, .flags = flags_to_int32(
                        &flags),

                };

        jak_memfile_write(memfile, &header, sizeof(jak_object_header));

        propOffsetsWrite(memfile, &flags, &prop_offsets);

        jak_memfile_seek(memfile, object_end_offset);
        JAK_OPTIONAL_SET(offset, next_offset);
        return true;
}

static char *embedded_dic_flags_to_string(const jak_string_tab_flags_u *flags)
{
        size_t max = 2048;
        char *string = JAK_MALLOC(max + 1);
        size_t length = 0;

        if (flags->value == 0) {
                strcpy(string, " uncompressed");
                length = strlen(string);
                JAK_ASSERT(length <= max);
        } else {

                for (size_t i = 0; i < JAK_ARRAY_LENGTH(jak_global_pack_strategy_register); i++) {
                        if (flags->value & jak_global_pack_strategy_register[i].flag_bit) {
                                strcpy(string + length, jak_global_pack_strategy_register[i].name);
                                length = strlen(string);
                                strcpy(string + length, " ");
                                length = strlen(string);
                        }
                }
        }
        string[length] = '\0';
        return string;
}

static char *record_header_flags_to_string(const jak_record_flags *flags)
{
        size_t max = 2048;
        char *string = JAK_MALLOC(max + 1);
        size_t length = 0;

        if (flags->value == 0) {
                strcpy(string, " none");
                length = strlen(string);
                JAK_ASSERT(length <= max);
        } else {
                if (flags->bits.is_sorted) {
                        strcpy(string + length, " sorted");
                        length = strlen(string);
                        JAK_ASSERT(length <= max);
                }
        }
        string[length] = '\0';
        return string;
}

static bool serialize_jak_string_dic(jak_memfile *memfile, jak_error *err, const jak_doc_bulk *context,
                                 jak_packer_e compressor)
{
        jak_string_tab_flags_u flags;
        jak_packer strategy;
        jak_string_table_header header;

        jak_vector ofType (const char *) *strings;
        jak_vector ofType(jak_archive_field_sid_t) *jak_string_ids;

        jak_doc_bulk_get_dic_contents(&strings, &jak_string_ids, context);

        JAK_ASSERT(strings->num_elems == jak_string_ids->num_elems);

        flags.value = 0;
        if (!jak_pack_by_type(err, &strategy, compressor)) {
                return false;
        }
        jak_u8 flag_bit = jak_pack_flagbit_by_type(compressor);
        JAK_SET_BITS(flags.value, flag_bit);

        jak_offset_t header_pos = jak_memfile_tell(memfile);
        jak_memfile_skip(memfile, sizeof(jak_string_table_header));

        jak_offset_t extra_begin_off = jak_memfile_tell(memfile);
        jak_pack_write_extra(err, &strategy, memfile, strings);
        jak_offset_t extra_end_off = jak_memfile_tell(memfile);

        header = (jak_string_table_header) {.marker = jak_global_marker_symbols[JAK_MARKER_TYPE_EMBEDDED_STR_DIC]
                .symbol, .flags = flags.value, .num_entries = strings
                ->num_elems, .first_entry = jak_memfile_tell(memfile), .compressor_extra_size = (extra_end_off
                                                                                             - extra_begin_off)};

        for (size_t i = 0; i < strings->num_elems; i++) {
                jak_archive_field_sid_t id = *JAK_VECTOR_GET(jak_string_ids, i, jak_archive_field_sid_t);
                const char *string = *JAK_VECTOR_GET(strings, i, char *);

                jak_string_entry_header header = {.marker = jak_global_marker_symbols[JAK_MARKER_TYPE_EMBEDDED_UNCOMP_STR]
                        .symbol, .next_entry_off = 0, .jak_string_id = id, .jak_string_len = strlen(string)};

                jak_offset_t header_pos_off = jak_memfile_tell(memfile);
                jak_memfile_skip(memfile, sizeof(jak_string_entry_header));

                if (!jak_pack_encode(err, &strategy, memfile, string)) {
                        JAK_ERROR_PRINT(err.code);
                        return false;
                }
                jak_offset_t continue_off = jak_memfile_tell(memfile);
                jak_memfile_seek(memfile, header_pos_off);
                header.next_entry_off = i + 1 < strings->num_elems ? continue_off : 0;
                jak_memfile_write(memfile, &header, sizeof(jak_string_entry_header));
                jak_memfile_seek(memfile, continue_off);
        }

        jak_offset_t continue_pos = jak_memfile_tell(memfile);
        jak_memfile_seek(memfile, header_pos);
        jak_memfile_write(memfile, &header, sizeof(jak_string_table_header));
        jak_memfile_seek(memfile, continue_pos);

        jak_vector_drop(strings);
        jak_vector_drop(jak_string_ids);
        free(strings);
        free(jak_string_ids);

        return jak_pack_drop(err, &strategy);
}

static void skip_file_header(jak_memfile *memfile)
{
        jak_memfile_skip(memfile, sizeof(jak_archive_header));
}

static void update_file_header(jak_memfile *memfile, jak_offset_t record_header_offset)
{
        jak_offset_t current_pos;
        jak_memfile_get_offset(&current_pos, memfile);
        jak_memfile_seek(memfile, 0);
        memcpy(&this_file_header.magic, JAK_CARBON_ARCHIVE_MAGIC, strlen(JAK_CARBON_ARCHIVE_MAGIC));
        this_file_header.root_object_header_offset = record_header_offset;
        this_file_header.jak_string_id_to_offset_index_offset = 0;
        jak_memfile_write(memfile, &this_file_header, sizeof(jak_archive_header));
        jak_memfile_seek(memfile, current_pos);
}

static bool
print_column_form_memfile(FILE *file, jak_error *err, jak_memfile *memfile, unsigned nesting_level)
{
        jak_offset_t offset;
        jak_memfile_get_offset(&offset, memfile);
        jak_column_header *header = JAK_MEMFILE_READ_TYPE(memfile, jak_column_header);
        if (header->marker != JAK_MARKER_SYMBOL_COLUMN) {
                char buffer[256];
                sprintf(buffer, "expected marker [%c] but found [%c]", JAK_MARKER_SYMBOL_COLUMN, header->marker);
                JAK_ERROR_WDETAILS(err, JAK_ERR_CORRUPTED, buffer);
                return false;
        }
        fprintf(file, "0x%04x ", (unsigned) offset);
        INTENT_LINE(nesting_level);
        const char *type_name = array_value_type_to_string(err, jak_int_marker_to_field_type(header->value_type));
        if (!type_name) {
                return false;
        }

        fprintf(file,
                "[marker: %c (Column)] [column_name: '%"PRIu64"'] [value_type: %c (%s)] [nentries: %d] [",
                header->marker,
                header->column_name,
                header->value_type,
                type_name,
                header->num_entries);

        for (size_t i = 0; i < header->num_entries; i++) {
                jak_offset_t entry_off = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
                fprintf(file, "offset: 0x%04x%s", (unsigned) entry_off, i + 1 < header->num_entries ? ", " : "");
        }

        jak_u32 *positions = (jak_u32 *) JAK_MEMFILE_READ(memfile, header->num_entries * sizeof(jak_u32));
        fprintf(file, "] [positions: [");
        for (size_t i = 0; i < header->num_entries; i++) {
                fprintf(file, "%d%s", positions[i], i + 1 < header->num_entries ? ", " : "");
        }

        fprintf(file, "]]\n");

        jak_archive_field_e data_type = jak_int_marker_to_field_type(header->value_type);

        //fprintf(file, "[");
        for (size_t i = 0; i < header->num_entries; i++) {
                switch (data_type) {
                        case JAK_FIELD_NULL: {
                                PRINT_VALUE_ARRAY(jak_u32, memfile, header, "%d");
                        }
                                break;
                        case JAK_FIELD_BOOLEAN: {
                                PRINT_VALUE_ARRAY(jak_archive_field_boolean_t, memfile, header, "%d");
                        }
                                break;
                        case JAK_FIELD_INT8: {
                                PRINT_VALUE_ARRAY(jak_archive_field_i8_t, memfile, header, "%d");
                        }
                                break;
                        case JAK_FIELD_INT16: {
                                PRINT_VALUE_ARRAY(jak_archive_field_i16_t, memfile, header, "%d");
                        }
                                break;
                        case JAK_FIELD_INT32: {
                                PRINT_VALUE_ARRAY(jak_archive_field_i32_t, memfile, header, "%d");
                        }
                                break;
                        case JAK_FIELD_INT64: {
                                PRINT_VALUE_ARRAY(jak_archive_field_i64_t, memfile, header, "%"
                                        PRIi64);
                        }
                                break;
                        case JAK_FIELD_UINT8: {
                                PRINT_VALUE_ARRAY(jak_archive_field_u8_t, memfile, header, "%d");
                        }
                                break;
                        case JAK_FIELD_UINT16: {
                                PRINT_VALUE_ARRAY(jak_archive_field_u16_t, memfile, header, "%d");
                        }
                                break;
                        case JAK_FIELD_UINT32: {
                                PRINT_VALUE_ARRAY(jak_archive_field_u32_t, memfile, header, "%d");
                        }
                                break;
                        case JAK_FIELD_UINT64: {
                                PRINT_VALUE_ARRAY(jak_archive_field_u64_t, memfile, header, "%"
                                        PRIu64);
                        }
                                break;
                        case JAK_FIELD_FLOAT: {
                                PRINT_VALUE_ARRAY(jak_archive_field_number_t, memfile, header, "%f");
                        }
                                break;
                        case JAK_FIELD_STRING: {
                                PRINT_VALUE_ARRAY(jak_archive_field_sid_t, memfile, header, "%"
                                        PRIu64
                                        "");
                        }
                                break;
                        case JAK_FIELD_OBJECT: {
                                jak_u32 num_elements = *JAK_MEMFILE_READ_TYPE(memfile, jak_u32);
                                INTENT_LINE(nesting_level);
                                fprintf(file, "   [num_elements: %d] [values: [\n", num_elements);
                                for (size_t i = 0; i < num_elements; i++) {
                                        if (!_jak_archive_print_object(file, err, memfile, nesting_level + 2)) {
                                                return false;
                                        }
                                }
                                INTENT_LINE(nesting_level);
                                fprintf(file, "   ]\n");
                        }
                                break;
                        default: JAK_ERROR(err, JAK_ERR_NOTYPE)
                                return false;
                }
        }
        return true;
}

static bool _jak_archive_print_object_array_from_memfile(FILE *file, jak_error *err, jak_memfile *memfile,
                                            unsigned nesting_level)
{
        unsigned offset = (unsigned) jak_memfile_tell(memfile);
        jak_object_array_header *header = JAK_MEMFILE_READ_TYPE(memfile, jak_object_array_header);
        if (header->marker != JAK_MARKER_SYMBOL_PROP_OBJECT_ARRAY) {
                char buffer[256];
                sprintf(buffer, "expected marker [%c] but found [%c]", JAK_MARKER_SYMBOL_PROP_OBJECT_ARRAY,
                        header->marker);
                JAK_ERROR_WDETAILS(err, JAK_ERR_CORRUPTED, buffer);
                return false;
        }

        fprintf(file, "0x%04x ", offset);
        INTENT_LINE(nesting_level);
        fprintf(file, "[marker: %c (Object Array)] [nentries: %d] [", header->marker, header->num_entries);

        for (size_t i = 0; i < header->num_entries; i++) {
                jak_archive_field_sid_t jak_string_id = *JAK_MEMFILE_READ_TYPE(memfile, jak_archive_field_sid_t);
                fprintf(file, "key: %"PRIu64"%s", jak_string_id, i + 1 < header->num_entries ? ", " : "");
        }
        fprintf(file, "] [");
        for (size_t i = 0; i < header->num_entries; i++) {
                jak_offset_t columnGroupOffset = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
                fprintf(file,
                        "offset: 0x%04x%s",
                        (unsigned) columnGroupOffset,
                        i + 1 < header->num_entries ? ", " : "");
        }

        fprintf(file, "]\n");
        nesting_level++;

        for (size_t i = 0; i < header->num_entries; i++) {
                offset = jak_memfile_tell(memfile);
                jak_column_group_header
                        *column_group_header = JAK_MEMFILE_READ_TYPE(memfile, jak_column_group_header);
                if (column_group_header->marker != JAK_MARKER_SYMBOL_COLUMN_GROUP) {
                        char buffer[256];
                        sprintf(buffer,
                                "expected marker [%c] but found [%c]",
                                JAK_MARKER_SYMBOL_COLUMN_GROUP,
                                column_group_header->marker);
                        JAK_ERROR_WDETAILS(err, JAK_ERR_CORRUPTED, buffer);
                        return false;
                }
                fprintf(file, "0x%04x ", offset);
                INTENT_LINE(nesting_level);
                fprintf(file,
                        "[marker: %c (Column Group)] [num_columns: %d] [num_objects: %d] [object_ids: ",
                        column_group_header->marker,
                        column_group_header->num_columns,
                        column_group_header->num_objects);
                const jak_uid_t
                        *oids = JAK_MEMFILE_READ_TYPE_LIST(memfile, jak_uid_t,
                                                           column_group_header->num_objects);
                for (size_t k = 0; k < column_group_header->num_objects; k++) {
                        fprintf(file, "%"PRIu64"%s", oids[k], k + 1 < column_group_header->num_objects ? ", " : "");
                }
                fprintf(file, "] [offsets: ");
                for (size_t k = 0; k < column_group_header->num_columns; k++) {
                        jak_offset_t column_off = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
                        fprintf(file,
                                "0x%04x%s",
                                (unsigned) column_off,
                                k + 1 < column_group_header->num_columns ? ", " : "");
                }

                fprintf(file, "]\n");

                for (size_t k = 0; k < column_group_header->num_columns; k++) {
                        if (!print_column_form_memfile(file, err, memfile, nesting_level + 1)) {
                                return false;
                        }
                }

                fprintf(file, "0x%04x ", offset);
                INTENT_LINE(nesting_level);
                fprintf(file, "]\n");
        }
        return true;
}

static void print_prop_offsets(FILE *file, const jak_object_flags_u *flags,
                               const jak_archive_prop_offs *prop_offsets)
{
        if (flags->bits.has_null_props) {
                fprintf(file, " nulls: 0x%04x", (unsigned) prop_offsets->nulls);
        }
        if (flags->bits.has_bool_props) {
                fprintf(file, " bools: 0x%04x", (unsigned) prop_offsets->bools);
        }
        if (flags->bits.has_int8_props) {
                fprintf(file, " int8s: 0x%04x", (unsigned) prop_offsets->int8s);
        }
        if (flags->bits.has_int16_props) {
                fprintf(file, " int16s: 0x%04x", (unsigned) prop_offsets->int16s);
        }
        if (flags->bits.has_int32_props) {
                fprintf(file, " int32s: 0x%04x", (unsigned) prop_offsets->int32s);
        }
        if (flags->bits.has_int64_props) {
                fprintf(file, " int64s: 0x%04x", (unsigned) prop_offsets->int64s);
        }
        if (flags->bits.has_uint8_props) {
                fprintf(file, " uint8s: 0x%04x", (unsigned) prop_offsets->uint8s);
        }
        if (flags->bits.has_uint16_props) {
                fprintf(file, " uint16s: 0x%04x", (unsigned) prop_offsets->uint16s);
        }
        if (flags->bits.has_uint32_props) {
                fprintf(file, " uint32s: 0x%04x", (unsigned) prop_offsets->uint32s);
        }
        if (flags->bits.has_uint64_props) {
                fprintf(file, " uint64s: 0x%04x", (unsigned) prop_offsets->uint64s);
        }
        if (flags->bits.has_float_props) {
                fprintf(file, " floats: 0x%04x", (unsigned) prop_offsets->floats);
        }
        if (flags->bits.has_jak_string_props) {
                fprintf(file, " texts: 0x%04x", (unsigned) prop_offsets->strings);
        }
        if (flags->bits.has_object_props) {
                fprintf(file, " objects: 0x%04x", (unsigned) prop_offsets->objects);
        }
        if (flags->bits.has_null_array_props) {
                fprintf(file, " nullArrays: 0x%04x", (unsigned) prop_offsets->null_arrays);
        }
        if (flags->bits.has_bool_array_props) {
                fprintf(file, " boolArrays: 0x%04x", (unsigned) prop_offsets->bool_arrays);
        }
        if (flags->bits.has_int8_array_props) {
                fprintf(file, " int8Arrays: 0x%04x", (unsigned) prop_offsets->int8_arrays);
        }
        if (flags->bits.has_int16_array_props) {
                fprintf(file, " int16Arrays: 0x%04x", (unsigned) prop_offsets->int16_arrays);
        }
        if (flags->bits.has_int32_array_props) {
                fprintf(file, " int32Arrays: 0x%04x", (unsigned) prop_offsets->int32_arrays);
        }
        if (flags->bits.has_int64_array_props) {
                fprintf(file, " int16Arrays: 0x%04x", (unsigned) prop_offsets->int64_arrays);
        }
        if (flags->bits.has_uint8_array_props) {
                fprintf(file, " uint8Arrays: 0x%04x", (unsigned) prop_offsets->uint8_arrays);
        }
        if (flags->bits.has_uint16_array_props) {
                fprintf(file, " uint16Arrays: 0x%04x", (unsigned) prop_offsets->uint16_arrays);
        }
        if (flags->bits.has_uint32_array_props) {
                fprintf(file, " uint32Arrays: 0x%04x", (unsigned) prop_offsets->uint32_arrays);
        }
        if (flags->bits.has_uint64_array_props) {
                fprintf(file, " uint64Arrays: 0x%04x", (unsigned) prop_offsets->uint64_arrays);
        }
        if (flags->bits.has_float_array_props) {
                fprintf(file, " floatArrays: 0x%04x", (unsigned) prop_offsets->float_arrays);
        }
        if (flags->bits.has_jak_string_array_props) {
                fprintf(file, " textArrays: 0x%04x", (unsigned) prop_offsets->jak_string_arrays);
        }
        if (flags->bits.has_object_array_props) {
                fprintf(file, " objectArrays: 0x%04x", (unsigned) prop_offsets->object_arrays);
        }
}

bool _jak_archive_print_object(FILE *file, jak_error *err, jak_memfile *memfile, unsigned nesting_level)
{
        unsigned offset = (unsigned) jak_memfile_tell(memfile);
        jak_object_header *header = JAK_MEMFILE_READ_TYPE(memfile, jak_object_header);

        jak_archive_prop_offs prop_offsets;
        jak_object_flags_u flags = {.value = header->flags};

        jak_int_read_prop_offsets(&prop_offsets, memfile, &flags);
        jak_offset_t nextObjectOrNil = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);

        if (header->marker != JAK_MARKER_SYMBOL_OBJECT_BEGIN) {
                char buffer[256];
                sprintf(buffer, "Parsing JAK_ERROR: expected object marker [{] but found [%c]\"", header->marker);
                JAK_ERROR_WDETAILS(err, JAK_ERR_CORRUPTED, buffer);
                return false;
        }

        fprintf(file, "0x%04x ", offset);
        INTENT_LINE(nesting_level);
        nesting_level++;
        fprintf(file,
                "[marker: %c (BeginObject)] [object-id: %"PRIu64"] [flags: %u] [propertyOffsets: [",
                header->marker,
                header->oid,
                header->flags);
        print_prop_offsets(file, &flags, &prop_offsets);
        fprintf(file, " ] [next: 0x%04x] \n", (unsigned) nextObjectOrNil);

        bool continue_read = true;
        while (continue_read) {
                offset = jak_memfile_tell(memfile);
                char entryMarker = *JAK_MEMFILE_PEEK(memfile, char);

                switch (entryMarker) {
                        case JAK_MARKER_SYMBOL_PROP_NULL: {
                                jak_prop_header *prop_header = JAK_MEMFILE_READ_TYPE(memfile,
                                                                                                jak_prop_header);
                                jak_archive_field_sid_t *keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile,
                                                                                                             prop_header->num_entries *
                                                                                                             sizeof(jak_archive_field_sid_t));
                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file, "[marker: %c (null)] [nentries: %d] [", entryMarker,
                                        prop_header->num_entries);

                                for (jak_u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file, "%"PRIu64"%s", keys[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "]\n");
                        }
                                break;
                        case JAK_MARKER_SYMBOL_PROP_BOOLEAN: {
                                jak_prop_header *prop_header = JAK_MEMFILE_READ_TYPE(memfile,
                                                                                                jak_prop_header);
                                jak_archive_field_sid_t *keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile,
                                                                                                             prop_header->num_entries *
                                                                                                             sizeof(jak_archive_field_sid_t));
                                jak_archive_field_boolean_t *values = (jak_archive_field_boolean_t *) JAK_MEMFILE_READ(
                                        memfile,
                                        prop_header->num_entries *
                                        sizeof(jak_archive_field_boolean_t));
                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file, "[marker: %c (boolean)] [nentries: %d] [", entryMarker,
                                        prop_header->num_entries);
                                for (jak_u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file, "%"PRIu64"%s", keys[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [");
                                for (jak_u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file,
                                                "%s%s",
                                                values[i] ? "true" : "false",
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "]\n");
                        }
                                break;
                        case JAK_MARKER_SYMBOL_PROP_INT8: PRINT_SIMPLE_PROPS(file,
                                                                             memfile,
                                                                             jak_memfile_tell(memfile),
                                                                             nesting_level,
                                                                             jak_archive_field_i8_t,
                                                                             "Int8",
                                                                             "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_INT16: PRINT_SIMPLE_PROPS(file,
                                                                              memfile,
                                                                              jak_memfile_tell(memfile),
                                                                              nesting_level,
                                                                              jak_archive_field_i16_t,
                                                                              "Int16",
                                                                              "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_INT32: PRINT_SIMPLE_PROPS(file,
                                                                              memfile,
                                                                              jak_memfile_tell(memfile),
                                                                              nesting_level,
                                                                              jak_archive_field_i32_t,
                                                                              "Int32",
                                                                              "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_INT64: PRINT_SIMPLE_PROPS(file,
                                                                              memfile,
                                                                              jak_memfile_tell(memfile),
                                                                              nesting_level,
                                                                              jak_archive_field_i64_t,
                                                                              "Int64",
                                                                              "%"
                                                                                      PRIi64);
                                break;
                        case JAK_MARKER_SYMBOL_PROP_UINT8: PRINT_SIMPLE_PROPS(file,
                                                                              memfile,
                                                                              jak_memfile_tell(memfile),
                                                                              nesting_level,
                                                                              jak_archive_field_u8_t,
                                                                              "UInt8",
                                                                              "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_UINT16: PRINT_SIMPLE_PROPS(file,
                                                                               memfile,
                                                                               jak_memfile_tell(memfile),
                                                                               nesting_level,
                                                                               jak_archive_field_u16_t,
                                                                               "UInt16",
                                                                               "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_UINT32: PRINT_SIMPLE_PROPS(file,
                                                                               memfile,
                                                                               jak_memfile_tell(memfile),
                                                                               nesting_level,
                                                                               jak_archive_field_u32_t,
                                                                               "UInt32",
                                                                               "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_UINT64: PRINT_SIMPLE_PROPS(file,
                                                                               memfile,
                                                                               jak_memfile_tell(memfile),
                                                                               nesting_level,
                                                                               jak_archive_field_u64_t,
                                                                               "UInt64",
                                                                               "%"
                                                                                       PRIu64);
                                break;
                        case JAK_MARKER_SYMBOL_PROP_REAL: PRINT_SIMPLE_PROPS(file,
                                                                             memfile,
                                                                             jak_memfile_tell(memfile),
                                                                             nesting_level,
                                                                             jak_archive_field_number_t,
                                                                             "Float",
                                                                             "%f");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_TEXT: PRINT_SIMPLE_PROPS(file,
                                                                             memfile,
                                                                             jak_memfile_tell(memfile),
                                                                             nesting_level,
                                                                             jak_archive_field_sid_t,
                                                                             "Text",
                                                                             "%"
                                                                                     PRIu64
                                                                                     "");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_OBJECT: {
                                jak_var_prop prop;
                                jak_int_embedded_var_props_read(&prop, memfile);
                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file, "[marker: %c (Object)] [nentries: %d] [", entryMarker,
                                        prop.header->num_entries);
                                for (jak_u32 i = 0; i < prop.header->num_entries; i++) {
                                        fprintf(file,
                                                "key: %"PRIu64"%s",
                                                prop.keys[i],
                                                i + 1 < prop.header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [");
                                for (jak_u32 i = 0; i < prop.header->num_entries; i++) {
                                        fprintf(file,
                                                "offsets: 0x%04x%s",
                                                (unsigned) prop.offsets[i],
                                                i + 1 < prop.header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [\n");

                                char nextEntryMarker;
                                do {
                                        if (!_jak_archive_print_object(file, err, memfile, nesting_level + 1)) {
                                                return false;
                                        }
                                        nextEntryMarker = *JAK_MEMFILE_PEEK(memfile, char);
                                } while (nextEntryMarker == JAK_MARKER_SYMBOL_OBJECT_BEGIN);

                        }
                                break;
                        case JAK_MARKER_SYMBOL_PROP_NULL_ARRAY: {
                                jak_prop_header *prop_header = JAK_MEMFILE_READ_TYPE(memfile,
                                                                                                jak_prop_header);

                                jak_archive_field_sid_t *keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile,
                                                                                                             prop_header->num_entries *
                                                                                                             sizeof(jak_archive_field_sid_t));
                                jak_u32 *nullArrayLengths;

                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file,
                                        "[marker: %c (Null Array)] [nentries: %d] [",
                                        entryMarker,
                                        prop_header->num_entries);

                                for (jak_u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file, "%"PRIu64"%s", keys[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [");

                                nullArrayLengths = (jak_u32 *) JAK_MEMFILE_READ(memfile,
                                                                                prop_header->num_entries *
                                                                                sizeof(jak_u32));

                                for (jak_u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file,
                                                "nentries: %d%s",
                                                nullArrayLengths[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }

                                fprintf(file, "]\n");
                        }
                                break;
                        case JAK_MARKER_SYMBOL_PROP_BOOLEAN_ARRAY: {
                                jak_prop_header *prop_header = JAK_MEMFILE_READ_TYPE(memfile,
                                                                                                jak_prop_header);

                                jak_archive_field_sid_t *keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile,
                                                                                                             prop_header->num_entries *
                                                                                                             sizeof(jak_archive_field_sid_t));
                                jak_u32 *array_lengths;

                                fprintf(file, "0x%04x ", offset);
                                INTENT_LINE(nesting_level)
                                fprintf(file,
                                        "[marker: %c (Boolean Array)] [nentries: %d] [",
                                        entryMarker,
                                        prop_header->num_entries);

                                for (jak_u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file, "%"PRIu64"%s", keys[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }
                                fprintf(file, "] [");

                                array_lengths = (jak_u32 *) JAK_MEMFILE_READ(memfile,
                                                                             prop_header->num_entries *
                                                                             sizeof(jak_u32));

                                for (jak_u32 i = 0; i < prop_header->num_entries; i++) {
                                        fprintf(file,
                                                "arrayLength: %d%s",
                                                array_lengths[i],
                                                i + 1 < prop_header->num_entries ? ", " : "");
                                }

                                fprintf(file, "] [");

                                for (jak_u32 array_idx = 0; array_idx < prop_header->num_entries; array_idx++) {
                                        jak_archive_field_boolean_t *values = (jak_archive_field_boolean_t *) JAK_MEMFILE_READ(
                                                memfile,
                                                array_lengths[array_idx] *
                                                sizeof(jak_archive_field_boolean_t));
                                        fprintf(file, "[");
                                        for (jak_u32 i = 0; i < array_lengths[array_idx]; i++) {
                                                fprintf(file,
                                                        "value: %s%s",
                                                        values[i] ? "true" : "false",
                                                        i + 1 < array_lengths[array_idx] ? ", " : "");
                                        }
                                        fprintf(file, "]%s", array_idx + 1 < prop_header->num_entries ? ", " : "");
                                }

                                fprintf(file, "]\n");
                        }
                                break;
                                break;
                        case JAK_MARKER_SYMBOL_PROP_INT8_ARRAY: {
                                PRINT_ARRAY_PROPS(memfile,
                                                  jak_memfile_tell(memfile),
                                                  nesting_level,
                                                  entryMarker,
                                                  jak_archive_field_i8_t,
                                                  "Int8 Array",
                                                  "%d");
                        }
                                break;
                        case JAK_MARKER_SYMBOL_PROP_INT16_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                   jak_memfile_tell(memfile),
                                                                                   nesting_level,
                                                                                   entryMarker,
                                                                                   jak_archive_field_i16_t,
                                                                                   "Int16 Array",
                                                                                   "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_INT32_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                   jak_memfile_tell(memfile),
                                                                                   nesting_level,
                                                                                   entryMarker,
                                                                                   jak_archive_field_i32_t,
                                                                                   "Int32 Array",
                                                                                   "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_INT64_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                   jak_memfile_tell(memfile),
                                                                                   nesting_level,
                                                                                   entryMarker,
                                                                                   jak_archive_field_i64_t,
                                                                                   "Int64 Array",
                                                                                   "%"
                                                                                           PRIi64);
                                break;
                        case JAK_MARKER_SYMBOL_PROP_UINT8_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                   jak_memfile_tell(memfile),
                                                                                   nesting_level,
                                                                                   entryMarker,
                                                                                   jak_archive_field_u8_t,
                                                                                   "UInt8 Array",
                                                                                   "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_UINT16_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                    jak_memfile_tell(memfile),
                                                                                    nesting_level,
                                                                                    entryMarker,
                                                                                    jak_archive_field_u16_t,
                                                                                    "UInt16 Array",
                                                                                    "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_UINT32_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                    jak_memfile_tell(memfile),
                                                                                    nesting_level,
                                                                                    entryMarker,
                                                                                    jak_archive_field_u32_t,
                                                                                    "UInt32 Array",
                                                                                    "%d");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_UINT64_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                    jak_memfile_tell(memfile),
                                                                                    nesting_level,
                                                                                    entryMarker,
                                                                                    jak_archive_field_u64_t,
                                                                                    "UInt64 Array",
                                                                                    "%"
                                                                                            PRIu64);
                                break;
                        case JAK_MARKER_SYMBOL_PROP_REAL_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                  jak_memfile_tell(memfile),
                                                                                  nesting_level,
                                                                                  entryMarker,
                                                                                  jak_archive_field_number_t,
                                                                                  "Float Array",
                                                                                  "%f");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_TEXT_ARRAY: PRINT_ARRAY_PROPS(memfile,
                                                                                  jak_memfile_tell(memfile),
                                                                                  nesting_level,
                                                                                  entryMarker,
                                                                                  jak_archive_field_sid_t,
                                                                                  "Text Array",
                                                                                  "%"
                                                                                          PRIu64
                                                                                          "");
                                break;
                        case JAK_MARKER_SYMBOL_PROP_OBJECT_ARRAY:
                                if (!_jak_archive_print_object_array_from_memfile(file, err, memfile, nesting_level)) {
                                        return false;
                                }
                                break;
                        case JAK_MARKER_SYMBOL_OBJECT_END:
                                continue_read = false;
                                break;
                        default: {
                                char buffer[256];
                                sprintf(buffer,
                                        "Parsing JAK_ERROR: unexpected marker [%c] was detected in file %p",
                                        entryMarker,
                                        memfile);
                                JAK_ERROR_WDETAILS(err, JAK_ERR_CORRUPTED, buffer);
                                return false;
                        }
                }
        }

        offset = jak_memfile_tell(memfile);
        char end_marker = *JAK_MEMFILE_READ_TYPE(memfile, char);
        JAK_ASSERT (end_marker == JAK_MARKER_SYMBOL_OBJECT_END);
        nesting_level--;
        fprintf(file, "0x%04x ", offset);
        INTENT_LINE(nesting_level);
        fprintf(file, "[marker: %c (EndObject)]\n", end_marker);
        return true;
}

static bool is_valid_file(const jak_archive_header *header)
{
        if (JAK_ARRAY_LENGTH(header->magic) != strlen(JAK_CARBON_ARCHIVE_MAGIC)) {
                return false;
        } else {
                for (size_t i = 0; i < JAK_ARRAY_LENGTH(header->magic); i++) {
                        if (header->magic[i] != JAK_CARBON_ARCHIVE_MAGIC[i]) {
                                return false;
                        }
                }
                if (header->version != JAK_CARBON_ARCHIVE_VERSION) {
                        return false;
                }
                if (header->root_object_header_offset == 0) {
                        return false;
                }
                return true;
        }
}

static void print_record_header_from_memfile(FILE *file, jak_memfile *memfile)
{
        unsigned offset = jak_memfile_tell(memfile);
        jak_record_header *header = JAK_MEMFILE_READ_TYPE(memfile, jak_record_header);
        jak_record_flags flags;
        memset(&flags, 0, sizeof(jak_record_flags));
        flags.value = header->flags;
        char *flags_string = record_header_flags_to_string(&flags);
        fprintf(file, "0x%04x ", offset);
        fprintf(file,
                "[marker: %c] [flags: %s] [record_size: 0x%04x]\n",
                header->marker,
                flags_string,
                (unsigned) header->record_size);
        free(flags_string);
}

static bool print_header_from_memfile(FILE *file, jak_error *err, jak_memfile *memfile)
{
        unsigned offset = jak_memfile_tell(memfile);
        JAK_ASSERT(jak_memfile_size(memfile) > sizeof(jak_archive_header));
        jak_archive_header *header = JAK_MEMFILE_READ_TYPE(memfile, jak_archive_header);
        if (!is_valid_file(header)) {
                JAK_ERROR(err, JAK_ERR_NOARCHIVEFILE)
                return false;
        }

        fprintf(file, "0x%04x ", offset);
        fprintf(file,
                "[magic: " JAK_CARBON_ARCHIVE_MAGIC "] [version: %d] [recordOffset: 0x%04x] [string-id-offset-index: 0x%04x]\n",
                header->version,
                (unsigned) header->root_object_header_offset,
                (unsigned) header->jak_string_id_to_offset_index_offset);
        return true;
}

static bool print_embedded_dic_from_memfile(FILE *file, jak_error *err, jak_memfile *memfile)
{
        jak_packer strategy;
        jak_string_tab_flags_u flags;

        unsigned offset = jak_memfile_tell(memfile);
        jak_string_table_header *header = JAK_MEMFILE_READ_TYPE(memfile, jak_string_table_header);
        if (header->marker != jak_global_marker_symbols[JAK_MARKER_TYPE_EMBEDDED_STR_DIC].symbol) {
                char buffer[256];
                sprintf(buffer,
                        "expected [%c] marker, but found [%c]",
                        jak_global_marker_symbols[JAK_MARKER_TYPE_EMBEDDED_STR_DIC].symbol,
                        header->marker);
                JAK_ERROR_WDETAILS(err, JAK_ERR_CORRUPTED, buffer);
                return false;
        }
        flags.value = header->flags;

        char *flagsStr = embedded_dic_flags_to_string(&flags);
        fprintf(file, "0x%04x ", offset);
        fprintf(file,
                "[marker: %c] [nentries: %d] [flags: %s] [first-entry-off: 0x%04x] [extra-size: %" PRIu64 "]\n",
                header->marker,
                header->num_entries,
                flagsStr,
                (unsigned) header->first_entry,
                header->compressor_extra_size);
        free(flagsStr);

        if (jak_pack_by_flags(&strategy, flags.value) != true) {
                JAK_ERROR(err, JAK_ERR_NOCOMPRESSOR);
                return false;
        }

        jak_pack_print_extra(err, &strategy, file, memfile);

        while ((*JAK_MEMFILE_PEEK(memfile, char)) == jak_global_marker_symbols[JAK_MARKER_TYPE_EMBEDDED_UNCOMP_STR].symbol) {
                unsigned offset = jak_memfile_tell(memfile);
                jak_string_entry_header header = *JAK_MEMFILE_READ_TYPE(memfile, jak_string_entry_header);
                fprintf(file,
                        "0x%04x    [marker: %c] [next-entry-off: 0x%04zx] [string-id: %"PRIu64"] [string-length: %"PRIu32"]",
                        offset,
                        header.marker,
                        (size_t) header.next_entry_off,
                        header.jak_string_id,
                        header.jak_string_len);
                jak_pack_print_encoded(err, &strategy, file, memfile, header.jak_string_len);
                fprintf(file, "\n");
        }

        return jak_pack_drop(err, &strategy);
}

static bool print_archive_from_memfile(FILE *file, jak_error *err, jak_memfile *memfile)
{
        if (!print_header_from_memfile(file, err, memfile)) {
                return false;
        }
        if (!print_embedded_dic_from_memfile(file, err, memfile)) {
                return false;
        }
        print_record_header_from_memfile(file, memfile);
        if (!_jak_archive_print_object(file, err, memfile, 0)) {
                return false;
        }
        return true;
}

static jak_object_flags_u *get_flags(jak_object_flags_u *flags, jak_column_doc_obj *columndoc)
{
        JAK_ZERO_MEMORY(flags, sizeof(jak_object_flags_u));
        flags->bits.has_null_props = (columndoc->null_prop_keys.num_elems > 0);
        flags->bits.has_bool_props = (columndoc->bool_prop_keys.num_elems > 0);
        flags->bits.has_int8_props = (columndoc->int8_prop_keys.num_elems > 0);
        flags->bits.has_int16_props = (columndoc->int16_prop_keys.num_elems > 0);
        flags->bits.has_int32_props = (columndoc->int32_prop_keys.num_elems > 0);
        flags->bits.has_int64_props = (columndoc->int64_prop_keys.num_elems > 0);
        flags->bits.has_uint8_props = (columndoc->uint8_prop_keys.num_elems > 0);
        flags->bits.has_uint16_props = (columndoc->uint16_prop_keys.num_elems > 0);
        flags->bits.has_uint32_props = (columndoc->uin32_prop_keys.num_elems > 0);
        flags->bits.has_uint64_props = (columndoc->uint64_prop_keys.num_elems > 0);
        flags->bits.has_float_props = (columndoc->float_prop_keys.num_elems > 0);
        flags->bits.has_jak_string_props = (columndoc->jak_string_prop_keys.num_elems > 0);
        flags->bits.has_object_props = (columndoc->obj_prop_keys.num_elems > 0);
        flags->bits.has_null_array_props = (columndoc->null_array_prop_keys.num_elems > 0);
        flags->bits.has_bool_array_props = (columndoc->bool_array_prop_keys.num_elems > 0);
        flags->bits.has_int8_array_props = (columndoc->int8_array_prop_keys.num_elems > 0);
        flags->bits.has_int16_array_props = (columndoc->int16_array_prop_keys.num_elems > 0);
        flags->bits.has_int32_array_props = (columndoc->int32_array_prop_keys.num_elems > 0);
        flags->bits.has_int64_array_props = (columndoc->int64_array_prop_keys.num_elems > 0);
        flags->bits.has_uint8_array_props = (columndoc->uint8_array_prop_keys.num_elems > 0);
        flags->bits.has_uint16_array_props = (columndoc->uint16_array_prop_keys.num_elems > 0);
        flags->bits.has_uint32_array_props = (columndoc->uint32_array_prop_keys.num_elems > 0);
        flags->bits.has_uint64_array_props = (columndoc->uint64_array_prop_keys.num_elems > 0);
        flags->bits.has_float_array_props = (columndoc->float_array_prop_keys.num_elems > 0);
        flags->bits.has_jak_string_array_props = (columndoc->jak_string_array_prop_keys.num_elems > 0);
        flags->bits.has_object_array_props = (columndoc->obj_array_props.num_elems > 0);
        //JAK_ASSERT(flags->value != 0);
        return flags;
}

static bool init_decompressor(jak_packer *strategy, jak_u8 flags);

static bool read_stringtable(jak_string_table *table, jak_error *err, FILE *disk_file);

static bool read_record(jak_record_header *header_read, jak_archive *archive, FILE *disk_file,
                        jak_offset_t record_header_offset);

static bool read_jak_string_id_to_offset_index(jak_error *err, jak_archive *archive, const char *file_path,
                                           jak_offset_t jak_string_id_to_offset_index_offset);

bool jak_archive_open(jak_archive *out, const char *file_path)
{
        int status;
        FILE *disk_file;

        jak_error_init(&out->err);
        out->disk_file_path = strdup(file_path);
        disk_file = fopen(out->disk_file_path, "r");
        if (!disk_file) {
                jak_string sb;
                char cwd[PATH_MAX];
                jak_string_create(&sb);

                jak_string_add(&sb, "File '");
                jak_string_add(&sb, file_path);
                jak_string_add(&sb, "' not found in current working directory ('");
                jak_string_add(&sb, getcwd(cwd, sizeof(cwd)));
                jak_string_add(&sb, "')");
                JAK_ERROR_WDETAILS(&out->err, JAK_ERR_FOPEN_FAILED, jak_string_cstr(&sb));
                jak_string_drop(&sb);
                return false;
        } else {
                jak_archive_header header;
                size_t nread = fread(&header, sizeof(jak_archive_header), 1, disk_file);
                if (nread != 1) {
                        fclose(disk_file);
                        JAK_ERROR_PRINT(JAK_ERR_IO);
                        return false;
                } else {
                        if (!is_valid_file(&header)) {
                                JAK_ERROR_PRINT(JAK_ERR_FORMATVERERR);
                                return false;
                        } else {
                                out->query_index_jak_string_id_to_offset = NULL;
                                out->jak_string_id_cache = NULL;

                                jak_record_header jak_record_header;

                                if ((status = read_stringtable(&out->jak_string_table, &out->err, disk_file)) != true) {
                                        return status;
                                }
                                if ((status = read_record(&jak_record_header,
                                                          out,
                                                          disk_file,
                                                          header.root_object_header_offset)) != true) {
                                        return status;
                                }

                                if (header.jak_string_id_to_offset_index_offset != 0) {
                                        jak_error err;
                                        if ((status = read_jak_string_id_to_offset_index(&err,
                                                                                     out,
                                                                                     file_path,
                                                                                     header.jak_string_id_to_offset_index_offset)) !=
                                            true) {
                                                JAK_ERROR_PRINT(err.code);
                                                return status;
                                        }
                                }

                                fseek(disk_file, sizeof(jak_archive_header), SEEK_SET);

                                jak_offset_t data_start = ftell(disk_file);
                                fseek(disk_file, 0, SEEK_END);
                                jak_offset_t file_size = ftell(disk_file);

                                fclose(disk_file);

                                size_t jak_string_table_size = header.root_object_header_offset - data_start;
                                size_t record_table_size = jak_record_header.record_size;
                                size_t jak_string_id_index = file_size - header.jak_string_id_to_offset_index_offset;

                                out->info.jak_string_table_size = jak_string_table_size;
                                out->info.record_table_size = record_table_size;
                                out->info.num_embeddded_strings = out->jak_string_table.num_embeddded_strings;
                                out->info.jak_string_id_index_size = jak_string_id_index;
                                out->default_query = JAK_MALLOC(sizeof(jak_archive_query));
                                jak_query_create(out->default_query, out);

                        }
                }
        }

        return true;
}

bool jak_archive_get_info(jak_archive_info *info, const jak_archive *archive)
{
        JAK_ERROR_IF_NULL(info);
        JAK_ERROR_IF_NULL(archive);
        *info = archive->info;
        return true;
}

bool jak_archive_close(jak_archive *archive)
{
        JAK_ERROR_IF_NULL(archive);
        jak_archive_drop_indexes(archive);
        jak_archive_drop_query_jak_string_id_cache(archive);
        free(archive->disk_file_path);
        jak_memblock_drop(archive->record_table.record_db);
        jak_query_drop(archive->default_query);
        free(archive->default_query);
        return true;
}

bool jak_archive_drop_indexes(jak_archive *archive)
{
        if (archive->query_index_jak_string_id_to_offset) {
                jak_query_drop_index_jak_string_id_to_offset(archive->query_index_jak_string_id_to_offset);
                archive->query_index_jak_string_id_to_offset = NULL;
        }
        return true;
}

bool jak_archive_query_run(jak_archive_query *query, jak_archive *archive)
{
        if (jak_query_create(query, archive)) {
                bool has_index = false;
                jak_archive_has_query_index_jak_string_id_to_offset(&has_index, archive);
                if (!has_index) {
                        jak_query_create_index_jak_string_id_to_offset(&archive->query_index_jak_string_id_to_offset, query);
                }
                bool has_cache = false;
                jak_archive_hash_query_jak_string_id_cache(&has_cache, archive);
                if (!has_cache) {
                        jak_string_id_cache_create_lru(&archive->jak_string_id_cache, archive);
                }
                return true;
        } else {
                return false;
        }
}

bool jak_archive_has_query_index_jak_string_id_to_offset(bool *state, jak_archive *archive)
{
        JAK_ERROR_IF_NULL(state)
        JAK_ERROR_IF_NULL(archive)
        *state = (archive->query_index_jak_string_id_to_offset != NULL);
        return true;
}

bool jak_archive_hash_query_jak_string_id_cache(bool *has_cache, jak_archive *archive)
{
        JAK_ERROR_IF_NULL(has_cache)
        JAK_ERROR_IF_NULL(archive)
        *has_cache = archive->jak_string_id_cache != NULL;
        return true;
}

bool jak_archive_drop_query_jak_string_id_cache(jak_archive *archive)
{
        JAK_ERROR_IF_NULL(archive)
        if (archive->jak_string_id_cache) {
                jak_string_id_cache_drop(archive->jak_string_id_cache);
                archive->jak_string_id_cache = NULL;
        }
        return true;
}

struct jak_string_cache *jak_archive_get_query_jak_string_id_cache(jak_archive *archive)
{
        return archive->jak_string_id_cache;
}

jak_archive_query *jak_archive_query_default(jak_archive *archive)
{
        return archive ? archive->default_query : NULL;
}

static bool init_decompressor(jak_packer *strategy, jak_u8 flags)
{
        if (jak_pack_by_flags(strategy, flags) != true) {
                return false;
        }
        return true;
}

static bool read_stringtable(jak_string_table *table, jak_error *err, FILE *disk_file)
{
        JAK_ASSERT(disk_file);

        jak_string_table_header header;
        jak_string_tab_flags_u flags;

        size_t num_read = fread(&header, sizeof(jak_string_table_header), 1, disk_file);
        if (num_read != 1) {
                JAK_ERROR(err, JAK_ERR_IO);
                return false;
        }
        if (header.marker != jak_global_marker_symbols[JAK_MARKER_TYPE_EMBEDDED_STR_DIC].symbol) {
                JAK_ERROR(err, JAK_ERR_CORRUPTED);
                return false;
        }

        flags.value = header.flags;
        table->first_entry_off = header.first_entry;
        table->num_embeddded_strings = header.num_entries;

        if ((init_decompressor(&table->compressor, flags.value)) != true) {
                return false;
        }
        if ((jak_pack_read_extra(err, &table->compressor, disk_file, header.compressor_extra_size)) != true) {
                return false;
        }
        return true;
}

static bool read_record(jak_record_header *header_read, jak_archive *archive, FILE *disk_file,
                        jak_offset_t record_header_offset)
{
        jak_error err;
        fseek(disk_file, record_header_offset, SEEK_SET);
        jak_record_header header;
        if (fread(&header, sizeof(jak_record_header), 1, disk_file) != 1) {
                JAK_ERROR(&archive->err, JAK_ERR_CORRUPTED);
                return false;
        } else {
                archive->record_table.flags.value = header.flags;
                bool status = jak_memblock_from_file(&archive->record_table.record_db, disk_file, header.record_size);
                if (!status) {
                        jak_memblock_get_error(&err, archive->record_table.record_db);
                        jak_error_cpy(&archive->err, &err);
                        return false;
                }

                jak_memfile memfile;
                if (jak_memfile_open(&memfile, archive->record_table.record_db, JAK_READ_ONLY) != true) {
                        JAK_ERROR(&archive->err, JAK_ERR_CORRUPTED);
                        status = false;
                }
                if (*JAK_MEMFILE_PEEK(&memfile, char) != JAK_MARKER_SYMBOL_OBJECT_BEGIN) {
                        JAK_ERROR(&archive->err, JAK_ERR_CORRUPTED);
                        status = false;
                }

                *header_read = header;
                return true;
        }
}

static bool read_jak_string_id_to_offset_index(jak_error *err, jak_archive *archive, const char *file_path,
                                           jak_offset_t jak_string_id_to_offset_index_offset)
{
        return jak_query_index_id_to_offset_deserialize(&archive->query_index_jak_string_id_to_offset,
                                                        err,
                                                        file_path,
                                                        jak_string_id_to_offset_index_offset);
}







/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_stdinc.h>
#include <jak_hash.h>
#include <jak_error.h>
#include <jak_archive_cache.h>

struct cache_entry {
        struct cache_entry *prev, *next;
        jak_archive_field_sid_t id;
        char *string;
};

struct lru_list {
        struct cache_entry *most_recent;
        struct cache_entry *lest_recent;
        struct cache_entry entries[1024];
};

struct jak_string_cache {
        jak_vector ofType(struct lru_list) list_entries;
        jak_sid_cache_stats statistics;
        jak_archive_query query;
        jak_error err;
        size_t capacity;
};

static void init_list(struct lru_list *list)
{
        size_t num_entries = sizeof(list->entries) / sizeof(list->entries[0]);
        list->most_recent = list->entries + 0;
        list->lest_recent = list->entries + num_entries - 1;
        for (size_t i = 0; i < num_entries; i++) {
                struct cache_entry *entry = list->entries + i;
                entry->prev = i == 0 ? NULL : &list->entries[i - 1];
                entry->next = i + 1 < num_entries ? &list->entries[i + 1] : NULL;
        }
}

bool jak_string_id_cache_create_lru(struct jak_string_cache **cache, jak_archive *archive)
{
        jak_archive_info archive_info;
        jak_archive_get_info(&archive_info, archive);
        jak_u32 capacity = archive_info.num_embeddded_strings * 0.25f;
        return jak_string_id_cache_create_lru_ex(cache, archive, capacity);
}

bool jak_string_id_cache_create_lru_ex(struct jak_string_cache **cache, jak_archive *archive, size_t capacity)
{
        JAK_ERROR_IF_NULL(cache)
        JAK_ERROR_IF_NULL(archive)

        struct jak_string_cache *result = JAK_MALLOC(sizeof(struct jak_string_cache));

        jak_query_create(&result->query, archive);
        result->capacity = capacity;

        size_t num_buckets = JAK_MAX(1, capacity);
        jak_vector_create(&result->list_entries, NULL, sizeof(struct lru_list), num_buckets);
        for (size_t i = 0; i < num_buckets; i++) {
                struct lru_list *list = JAK_VECTOR_NEW_AND_GET(&result->list_entries, struct lru_list);
                JAK_ZERO_MEMORY(list, sizeof(struct lru_list));
                init_list(list);
        }

        jak_error_init(&result->err);
        jak_string_id_cache_reset_statistics(result);
        *cache = result;

        return true;
}

bool jak_string_id_cache_get_error(jak_error *err, const struct jak_string_cache *cache)
{
        JAK_ERROR_IF_NULL(err)
        JAK_ERROR_IF_NULL(cache)
        *err = cache->err;
        return true;
}

bool jak_string_id_cache_get_size(size_t *size, const struct jak_string_cache *cache)
{
        JAK_ERROR_IF_NULL(size)
        JAK_ERROR_IF_NULL(cache)
        *size = cache->capacity;
        return true;
}

static void make_most_recent(struct lru_list *list, struct cache_entry *entry)
{
        if (list->most_recent == entry) {
                return;
        } else {
                if (entry->prev) {
                        entry->prev->next = entry->next;
                }
                if (entry->next) {
                        entry->next->prev = entry->prev;
                } else {
                        list->lest_recent = entry->prev;
                }
                list->most_recent->prev = entry;
                entry->next = list->most_recent;
                list->most_recent = entry;
        }
}

char *jak_string_id_cache_get(struct jak_string_cache *cache, jak_archive_field_sid_t id)
{
        JAK_ERROR_IF_NULL(cache)
        hash32_t id_hash = JAK_HASH_BERNSTEIN(sizeof(jak_archive_field_sid_t), &id);
        size_t bucket_pos = id_hash % cache->list_entries.num_elems;
        struct lru_list *list = JAK_VECTOR_GET(&cache->list_entries, bucket_pos, struct lru_list);
        struct cache_entry *cursor = list->most_recent;
        while (cursor != NULL) {
                if (id == cursor->id) {
                        make_most_recent(list, cursor);
                        cache->statistics.num_hits++;
                        return strdup(cursor->string);
                }
                cursor = cursor->next;
        }
        char *result = jak_query_fetch_jak_string_by_id_nocache(&cache->query, id);
        JAK_ASSERT(result);
        if (list->lest_recent->string != NULL) {
                cache->statistics.num_evicted++;
        }
        list->lest_recent->string = result;
        list->lest_recent->id = id;
        make_most_recent(list, list->lest_recent);
        cache->statistics.num_misses++;
        return strdup(result);
}

bool jak_string_id_cache_get_statistics(jak_sid_cache_stats *statistics, struct jak_string_cache *cache)
{
        JAK_ERROR_IF_NULL(statistics);
        JAK_ERROR_IF_NULL(cache);
        *statistics = cache->statistics;
        return true;
}

bool jak_string_id_cache_reset_statistics(struct jak_string_cache *cache)
{
        JAK_ERROR_IF_NULL(cache);
        JAK_ZERO_MEMORY(&cache->statistics, sizeof(jak_sid_cache_stats));
        return true;
}

bool jak_string_id_cache_drop(struct jak_string_cache *cache)
{
        JAK_ERROR_IF_NULL(cache);
        for (size_t i = 0; i < cache->list_entries.num_elems; i++) {
                struct lru_list *entry = JAK_VECTOR_GET(&cache->list_entries, i, struct lru_list);
                for (size_t k = 0; k < sizeof(entry->entries) / sizeof(entry->entries[0]); k++) {
                        struct cache_entry *it = &entry->entries[k];
                        if (it->string) {
                                free(it->string);
                        }
                }
        }
        jak_vector_drop(&cache->list_entries);
        return true;
}


/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_stdinc.h>
#include <jak_archive_visitor.h>
#include <jak_archive_converter.h>

struct converter_capture {
        jak_encoded_doc_list *collection;
};

#define IMPORT_BASIC_PAIR(name)                                                                                        \
{                                                                                                                      \
    JAK_UNUSED(jak_archive);                                                                                            \
    JAK_UNUSED(path_stack);                                                                                         \
    JAK_ASSERT(capture);                                                                                                   \
                                                                                                                       \
    struct converter_capture *extra = (struct converter_capture *) capture;                                                                          \
    jak_encoded_doc *doc = jak_encoded_doc_collection_get_or_append(extra->collection, oid);                          \
    for (jak_u32 i = 0; i < num_pairs; i++) {                                                                         \
        jak_encoded_doc_add_prop_##name(doc, keys[i], values[i]);                                                   \
    }                                                                                                                  \
}

#define DECLARE_VISIT_BASIC_TYPE_PAIR(name, built_in_type)                                                             \
static void                                                                                                            \
visit_##name##_pairs (jak_archive *jak_archive, path_stack_t path_stack, jak_uid_t oid,                      \
                  const jak_archive_field_sid_t *keys, const built_in_type *values, jak_u32 num_pairs, void *capture)      \
{                                                                                                                      \
    IMPORT_BASIC_PAIR(name)                                                                                            \
}

#define DECLARE_VISIT_ARRAY_TYPE(name, built_in_type)                                                                  \
static jak_visit_policy_e                                                                                         \
visit_enter_##name##_array_pairs(jak_archive *jak_archive, path_stack_t path, jak_uid_t id,                  \
                                 const jak_archive_field_sid_t *keys, jak_u32 num_pairs, void *capture)                    \
{                                                                                                                      \
    JAK_UNUSED(jak_archive);                                                                                            \
    JAK_UNUSED(path);                                                                                               \
    JAK_UNUSED(id);                                                                                                 \
    JAK_UNUSED(keys);                                                                                               \
    JAK_UNUSED(num_pairs);                                                                                          \
    JAK_UNUSED(capture);                                                                                            \
                                                                                                                       \
    JAK_ASSERT(capture);                                                                                                   \
                                                                                                                       \
    struct converter_capture *extra = (struct converter_capture *) capture;                                                                          \
    jak_encoded_doc *doc = jak_encoded_doc_collection_get_or_append(extra->collection, id);                           \
    for (jak_u32 i = 0; i < num_pairs; i++)                                                                           \
    {                                                                                                                  \
        jak_encoded_doc_add_prop_array_##name(doc, keys[i]);                                                        \
    }                                                                                                                  \
                                                                                                                       \
    return JAK_VISIT_INCLUDE;                                                                              \
}                                                                                                                      \
                                                                                                                       \
static void                                                                                                            \
visit_##name##_array_pair(jak_archive *jak_archive, path_stack_t path, jak_uid_t id,                         \
                          const jak_archive_field_sid_t key, jak_u32 entry_idx, jak_u32 max_entries,                      \
                          const built_in_type *array, jak_u32 array_length, void *capture)                            \
{                                                                                                                      \
    JAK_UNUSED(jak_archive);                                                                                            \
    JAK_UNUSED(path);                                                                                               \
    JAK_UNUSED(id);                                                                                                 \
    JAK_UNUSED(key);                                                                                                \
    JAK_UNUSED(entry_idx);                                                                                          \
    JAK_UNUSED(max_entries);                                                                                        \
    JAK_UNUSED(capture);                                                                                            \
                                                                                                                       \
    JAK_ASSERT(capture);                                                                                                   \
                                                                                                                       \
    struct converter_capture *extra = (struct converter_capture *) capture;                                                                          \
    jak_encoded_doc *doc = jak_encoded_doc_collection_get_or_append(extra->collection, id);                           \
    jak_encoded_doc_array_push_##name(doc, key, array, array_length);                                               \
}                                                                                                                      \


static void visit_root_object(jak_archive *archive, jak_uid_t id, void *capture)
{
        JAK_UNUSED(archive);
        JAK_ASSERT(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        jak_encoded_doc_collection_get_or_append(extra->collection, id);
}

DECLARE_VISIT_BASIC_TYPE_PAIR(int8, jak_archive_field_i8_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(int16, jak_archive_field_i16_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(int32, jak_archive_field_i32_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(int64, jak_archive_field_i64_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(uint8, jak_archive_field_u8_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(uint16, jak_archive_field_u16_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(uint32, jak_archive_field_u32_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(uint64, jak_archive_field_u64_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(number, jak_archive_field_number_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(boolean, jak_archive_field_boolean_t)

DECLARE_VISIT_BASIC_TYPE_PAIR(string, jak_archive_field_sid_t)

static void visit_null_pairs(jak_archive *archive, path_stack_t path, jak_uid_t oid,
                             const jak_archive_field_sid_t *keys,
                             jak_u32 num_pairs, void *capture)
{
        JAK_UNUSED(archive);
        JAK_UNUSED(path);
        JAK_ASSERT(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        jak_encoded_doc *doc = jak_encoded_doc_collection_get_or_append(extra->collection, oid);
        for (jak_u32 i = 0; i < num_pairs; i++) {
                jak_encoded_doc_add_prop_null(doc, keys[i]);
        }
}

static jak_visit_policy_e
before_object_visit(jak_archive *archive, path_stack_t path_stack, jak_uid_t parent_id,
                    jak_uid_t value_id, jak_u32 object_idx, jak_u32 num_objects, jak_archive_field_sid_t key,
                    void *capture)
{
        JAK_UNUSED(archive);
        JAK_UNUSED(path_stack);
        JAK_UNUSED(object_idx);
        JAK_UNUSED(num_objects);
        JAK_UNUSED(key);
        JAK_UNUSED(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        jak_encoded_doc *parent_doc = jak_encoded_doc_collection_get_or_append(extra->collection, parent_id);
        jak_encoded_doc *child_doc = jak_encoded_doc_collection_get_or_append(extra->collection, value_id);
        jak_encoded_doc_add_prop_object(parent_doc, key, child_doc);

        return JAK_VISIT_INCLUDE;
}

DECLARE_VISIT_ARRAY_TYPE(int8, jak_archive_field_i8_t)

DECLARE_VISIT_ARRAY_TYPE(int16, jak_archive_field_i16_t)

DECLARE_VISIT_ARRAY_TYPE(int32, jak_archive_field_i32_t)

DECLARE_VISIT_ARRAY_TYPE(int64, jak_archive_field_i64_t)

DECLARE_VISIT_ARRAY_TYPE(uint8, jak_archive_field_u8_t)

DECLARE_VISIT_ARRAY_TYPE(uint16, jak_archive_field_u16_t)

DECLARE_VISIT_ARRAY_TYPE(uint32, jak_archive_field_u32_t)

DECLARE_VISIT_ARRAY_TYPE(uint64, jak_archive_field_u64_t)

DECLARE_VISIT_ARRAY_TYPE(number, jak_archive_field_number_t)

DECLARE_VISIT_ARRAY_TYPE(boolean, jak_archive_field_boolean_t)

DECLARE_VISIT_ARRAY_TYPE(string, jak_archive_field_sid_t)

static jak_visit_policy_e
visit_enter_null_array_pairs(jak_archive *archive, path_stack_t path, jak_uid_t id,
                             const jak_archive_field_sid_t *keys, jak_u32 num_pairs, void *capture)
{
        JAK_UNUSED(archive);
        JAK_UNUSED(path);
        JAK_UNUSED(id);
        JAK_UNUSED(keys);
        JAK_UNUSED(num_pairs);
        JAK_UNUSED(capture);

        JAK_ASSERT(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        jak_encoded_doc *doc = jak_encoded_doc_collection_get_or_append(extra->collection, id);
        for (jak_u32 i = 0; i < num_pairs; i++) {
                jak_encoded_doc_add_prop_array_null(doc, keys[i]);
        }

        return JAK_VISIT_INCLUDE;
}

static void visit_null_array_pair(jak_archive *archive, path_stack_t path, jak_uid_t id,
                                  const jak_archive_field_sid_t key,
                                  jak_u32 entry_idx, jak_u32 max_entries, jak_u32 num_nulls, void *capture)
{
        JAK_UNUSED(archive);
        JAK_UNUSED(path);
        JAK_UNUSED(id);
        JAK_UNUSED(key);
        JAK_UNUSED(entry_idx);
        JAK_UNUSED(max_entries);
        JAK_UNUSED(num_nulls);
        JAK_UNUSED(capture);

        JAK_ASSERT(capture);

        struct converter_capture *extra = (struct converter_capture *) capture;
        jak_encoded_doc *doc = jak_encoded_doc_collection_get_or_append(extra->collection, id);
        jak_encoded_doc_array_push_null(doc, key, &num_nulls, 1);
}

static void
before_visit_object_array_objects(bool *skip_group_object_ids, jak_archive *archive, path_stack_t path,
                                  jak_uid_t parent_id, jak_archive_field_sid_t key,
                                  const jak_uid_t *group_object_ids, jak_u32 num_group_object_ids,
                                  void *capture)
{
        JAK_UNUSED(archive);
        JAK_UNUSED(path);
        JAK_UNUSED(parent_id);
        JAK_UNUSED(capture);
        JAK_UNUSED(group_object_ids);
        JAK_UNUSED(skip_group_object_ids);
        JAK_UNUSED(num_group_object_ids);

        struct converter_capture *extra = (struct converter_capture *) capture;
        jak_encoded_doc *doc = jak_encoded_doc_collection_get_or_append(extra->collection, parent_id);
        jak_encoded_doc_add_prop_array_object(doc, key);
        for (jak_u32 i = 0; i < num_group_object_ids; i++) {
                jak_encoded_doc_array_push_object(doc, key, group_object_ids[i]);
        }
}

#define DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(name, built_in_type)                                             \
static void                                                                                                            \
visit_object_array_object_property_##name(jak_archive *jak_archive, path_stack_t path,                                \
                                           jak_uid_t parent_id,                                               \
                                           jak_archive_field_sid_t key,                                                     \
                                           jak_uid_t nested_object_id,                                        \
                                           jak_archive_field_sid_t nested_key,                                              \
                                           const built_in_type *nested_values,                                         \
                                           jak_u32 num_nested_values, void *capture)                                  \
{                                                                                                                      \
    JAK_UNUSED(jak_archive);                                                                                            \
    JAK_UNUSED(path);                                                                                               \
    JAK_UNUSED(parent_id);                                                                                          \
    JAK_UNUSED(key);                                                                                                \
    JAK_UNUSED(nested_key);                                                                                         \
    JAK_UNUSED(nested_values);                                                                                      \
                                                                                                                       \
    struct converter_capture *extra = (struct converter_capture *) capture;                                                                          \
        jak_encoded_doc *doc = jak_encoded_doc_collection_get_or_append(extra->collection, nested_object_id);             \
        jak_encoded_doc_add_prop_array_##name(doc, nested_key);                                                                                                   \
        jak_encoded_doc_array_push_##name(doc, nested_key, nested_values, num_nested_values);                           \
}

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(int8, jak_archive_field_i8_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(int16, jak_archive_field_i16_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(int32, jak_archive_field_i32_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(int64, jak_archive_field_i64_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(uint8, jak_archive_field_u8_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(uint16, jak_archive_field_u16_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(uint32, jak_archive_field_u32_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(uint64, jak_archive_field_u64_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(number, jak_archive_field_number_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(string, jak_archive_field_sid_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(boolean, jak_archive_field_boolean_t);

DEFINE_VISIT_OBJECT_ARRAY_OBJECT_PROP_HANDLER(null, jak_archive_field_u32_t);

bool jak_archive_converter(jak_encoded_doc_list *collection, jak_archive *archive)
{

        JAK_ERROR_IF_NULL(collection);
        JAK_ERROR_IF_NULL(archive);

        jak_encoded_doc_collection_create(collection, &archive->err, archive);

        jak_archive_visitor visitor = {0};
        jak_archive_visitor_desc desc = {.visit_mask = JAK_ARCHIVE_ITER_MASK_ANY};
        struct converter_capture capture = {.collection = collection};

        visitor.visit_root_object = visit_root_object;
        visitor.before_object_visit = before_object_visit;
        visitor.visit_int8_pairs = visit_int8_pairs;
        visitor.visit_int16_pairs = visit_int16_pairs;
        visitor.visit_int32_pairs = visit_int32_pairs;
        visitor.visit_int64_pairs = visit_int64_pairs;
        visitor.visit_uint8_pairs = visit_uint8_pairs;
        visitor.visit_uint16_pairs = visit_uint16_pairs;
        visitor.visit_uint32_pairs = visit_uint32_pairs;
        visitor.visit_uint64_pairs = visit_uint64_pairs;
        visitor.visit_number_pairs = visit_number_pairs;
        visitor.visit_string_pairs = visit_string_pairs;
        visitor.visit_boolean_pairs = visit_boolean_pairs;
        visitor.visit_null_pairs = visit_null_pairs;

        visitor.visit_enter_int8_array_pairs = visit_enter_int8_array_pairs;
        visitor.visit_int8_array_pair = visit_int8_array_pair;
        visitor.visit_enter_int16_array_pairs = visit_enter_int16_array_pairs;
        visitor.visit_int16_array_pair = visit_int16_array_pair;
        visitor.visit_enter_int32_array_pairs = visit_enter_int32_array_pairs;
        visitor.visit_int32_array_pair = visit_int32_array_pair;
        visitor.visit_enter_int64_array_pairs = visit_enter_int64_array_pairs;
        visitor.visit_int64_array_pair = visit_int64_array_pair;
        visitor.visit_enter_uint8_array_pairs = visit_enter_uint8_array_pairs;
        visitor.visit_uint8_array_pair = visit_uint8_array_pair;
        visitor.visit_enter_uint16_array_pairs = visit_enter_uint16_array_pairs;
        visitor.visit_uint16_array_pair = visit_uint16_array_pair;
        visitor.visit_enter_uint32_array_pairs = visit_enter_uint32_array_pairs;
        visitor.visit_uint32_array_pair = visit_uint32_array_pair;
        visitor.visit_enter_uint64_array_pairs = visit_enter_uint64_array_pairs;
        visitor.visit_uint64_array_pair = visit_uint64_array_pair;
        visitor.visit_enter_boolean_array_pairs = visit_enter_boolean_array_pairs;
        visitor.visit_boolean_array_pair = visit_boolean_array_pair;
        visitor.visit_enter_number_array_pairs = visit_enter_number_array_pairs;
        visitor.visit_number_array_pair = visit_number_array_pair;
        visitor.visit_enter_null_array_pairs = visit_enter_null_array_pairs;
        visitor.visit_null_array_pair = visit_null_array_pair;
        visitor.visit_enter_string_array_pairs = visit_enter_string_array_pairs;
        visitor.visit_string_array_pair = visit_string_array_pair;

        visitor.before_visit_object_array_objects = before_visit_object_array_objects;

        visitor.visit_object_array_object_property_int8s = visit_object_array_object_property_int8;
        visitor.visit_object_array_object_property_int16s = visit_object_array_object_property_int16;
        visitor.visit_object_array_object_property_int32s = visit_object_array_object_property_int32;
        visitor.visit_object_array_object_property_int64s = visit_object_array_object_property_int64;
        visitor.visit_object_array_object_property_uint8s = visit_object_array_object_property_uint8;
        visitor.visit_object_array_object_property_uint16s = visit_object_array_object_property_uint16;
        visitor.visit_object_array_object_property_uint32s = visit_object_array_object_property_uint32;
        visitor.visit_object_array_object_property_uint64s = visit_object_array_object_property_uint64;
        visitor.visit_object_array_object_property_numbers = visit_object_array_object_property_number;
        visitor.visit_object_array_object_property_strings = visit_object_array_object_property_string;
        visitor.visit_object_array_object_property_booleans = visit_object_array_object_property_boolean;
        visitor.visit_object_array_object_property_nulls = visit_object_array_object_property_null;

        jak_archive_visit_archive(archive, &desc, &visitor, &capture);

        return true;
}


/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_archive_int.h>

void jak_int_read_prop_offsets(jak_archive_prop_offs *prop_offsets, jak_memfile *memfile,
                               const jak_object_flags_u *flags)
{
        JAK_ZERO_MEMORY(prop_offsets, sizeof(jak_archive_prop_offs));
        if (flags->bits.has_null_props) {
                prop_offsets->nulls = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_bool_props) {
                prop_offsets->bools = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_int8_props) {
                prop_offsets->int8s = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_int16_props) {
                prop_offsets->int16s = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_int32_props) {
                prop_offsets->int32s = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_int64_props) {
                prop_offsets->int64s = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_uint8_props) {
                prop_offsets->uint8s = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_uint16_props) {
                prop_offsets->uint16s = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_uint32_props) {
                prop_offsets->uint32s = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_uint64_props) {
                prop_offsets->uint64s = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_float_props) {
                prop_offsets->floats = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_jak_string_props) {
                prop_offsets->strings = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_object_props) {
                prop_offsets->objects = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_null_array_props) {
                prop_offsets->null_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_bool_array_props) {
                prop_offsets->bool_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_int8_array_props) {
                prop_offsets->int8_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_int16_array_props) {
                prop_offsets->int16_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_int32_array_props) {
                prop_offsets->int32_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_int64_array_props) {
                prop_offsets->int64_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_uint8_array_props) {
                prop_offsets->uint8_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_uint16_array_props) {
                prop_offsets->uint16_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_uint32_array_props) {
                prop_offsets->uint32_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_uint64_array_props) {
                prop_offsets->uint64_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_float_array_props) {
                prop_offsets->float_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_jak_string_array_props) {
                prop_offsets->jak_string_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
        if (flags->bits.has_object_array_props) {
                prop_offsets->object_arrays = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        }
}

void jak_int_embedded_fixed_props_read(jak_fixed_prop *prop, jak_memfile *memfile)
{
        prop->header = JAK_MEMFILE_READ_TYPE(memfile, jak_prop_header);
        prop->keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(jak_archive_field_sid_t));
        prop->values = jak_memfile_peek(memfile, 1);
}

void jak_int_embedded_var_props_read(jak_var_prop *prop, jak_memfile *memfile)
{
        prop->header = JAK_MEMFILE_READ_TYPE(memfile, jak_prop_header);
        prop->keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(jak_archive_field_sid_t));
        prop->offsets = (jak_offset_t *) JAK_MEMFILE_READ(memfile, prop->header->num_entries * sizeof(jak_offset_t));
        prop->values = jak_memfile_peek(memfile, 1);
}

void jak_int_embedded_null_props_read(jak_null_prop *prop, jak_memfile *memfile)
{
        prop->header = JAK_MEMFILE_READ_TYPE(memfile, jak_prop_header);
        prop->keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(jak_archive_field_sid_t));
}

void jak_int_embedded_array_props_read(jak_array_prop *prop, jak_memfile *memfile)
{
        prop->header = JAK_MEMFILE_READ_TYPE(memfile, jak_prop_header);
        prop->keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(jak_archive_field_sid_t));
        prop->lengths = (jak_u32 *) JAK_MEMFILE_READ(memfile, prop->header->num_entries * sizeof(jak_u32));
        prop->values_begin = jak_memfile_tell(memfile);
}

void jak_int_embedded_table_props_read(jak_table_prop *prop, jak_memfile *memfile)
{
        prop->header->marker = *JAK_MEMFILE_READ_TYPE(memfile, char);
        prop->header->num_entries = *JAK_MEMFILE_READ_TYPE(memfile, jak_u8);
        prop->keys = (jak_archive_field_sid_t *) JAK_MEMFILE_READ(memfile, prop->header->num_entries *
                                                                           sizeof(jak_archive_field_sid_t));
        prop->group_offs = (jak_offset_t *) JAK_MEMFILE_READ(memfile, prop->header->num_entries * sizeof(jak_offset_t));
}

jak_archive_field_e jak_int_get_value_type_of_char(char c)
{
        size_t len = sizeof(jak_global_value_array_marker_mapping) / sizeof(jak_global_value_array_marker_mapping[0]);
        for (size_t i = 0; i < len; i++) {
                if (jak_global_marker_symbols[jak_global_value_array_marker_mapping[i].marker].symbol == c) {
                        return jak_global_value_array_marker_mapping[i].value_type;
                }
        }
        return JAK_FIELD_NULL;
}

jak_archive_field_e // TODO: check whether 'jak_archive_field_e' can be replaced by 'enum jak_archive_field_type'
jak_int_marker_to_field_type(char symbol)
{
        switch (symbol) {
                case JAK_MARKER_SYMBOL_PROP_NULL:
                case JAK_MARKER_SYMBOL_PROP_NULL_ARRAY:
                        return JAK_FIELD_NULL;
                case JAK_MARKER_SYMBOL_PROP_BOOLEAN:
                case JAK_MARKER_SYMBOL_PROP_BOOLEAN_ARRAY:
                        return JAK_FIELD_BOOLEAN;
                case JAK_MARKER_SYMBOL_PROP_INT8:
                case JAK_MARKER_SYMBOL_PROP_INT8_ARRAY:
                        return JAK_FIELD_INT8;
                case JAK_MARKER_SYMBOL_PROP_INT16:
                case JAK_MARKER_SYMBOL_PROP_INT16_ARRAY:
                        return JAK_FIELD_INT16;
                case JAK_MARKER_SYMBOL_PROP_INT32:
                case JAK_MARKER_SYMBOL_PROP_INT32_ARRAY:
                        return JAK_FIELD_INT32;
                case JAK_MARKER_SYMBOL_PROP_INT64:
                case JAK_MARKER_SYMBOL_PROP_INT64_ARRAY:
                        return JAK_FIELD_INT64;
                case JAK_MARKER_SYMBOL_PROP_UINT8:
                case JAK_MARKER_SYMBOL_PROP_UINT8_ARRAY:
                        return JAK_FIELD_UINT8;
                case JAK_MARKER_SYMBOL_PROP_UINT16:
                case JAK_MARKER_SYMBOL_PROP_UINT16_ARRAY:
                        return JAK_FIELD_UINT16;
                case JAK_MARKER_SYMBOL_PROP_UINT32:
                case JAK_MARKER_SYMBOL_PROP_UINT32_ARRAY:
                        return JAK_FIELD_UINT32;
                case JAK_MARKER_SYMBOL_PROP_UINT64:
                case JAK_MARKER_SYMBOL_PROP_UINT64_ARRAY:
                        return JAK_FIELD_UINT64;
                case JAK_MARKER_SYMBOL_PROP_REAL:
                case JAK_MARKER_SYMBOL_PROP_REAL_ARRAY:
                        return JAK_FIELD_FLOAT;
                case JAK_MARKER_SYMBOL_PROP_TEXT:
                case JAK_MARKER_SYMBOL_PROP_TEXT_ARRAY:
                        return JAK_FIELD_STRING;
                case JAK_MARKER_SYMBOL_PROP_OBJECT:
                case JAK_MARKER_SYMBOL_PROP_OBJECT_ARRAY:
                        return JAK_FIELD_OBJECT;
                default: {
                        JAK_ERROR_PRINT_AND_DIE(JAK_ERR_MARKERMAPPING);
                }
        }
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_archive.h>
#include <jak_spinlock.h>
#include <jak_archive_io.h>

typedef struct jak_archive_io_context {
        jak_error err;
        FILE *file;
        jak_spinlock lock;
        jak_offset_t last_pos;
} jak_archive_io_context;

bool jak_io_context_create(jak_archive_io_context **context, jak_error *err, const char *file_path)
{
        JAK_ERROR_IF_NULL(context);
        JAK_ERROR_IF_NULL(err);
        JAK_ERROR_IF_NULL(file_path);

        jak_archive_io_context *result = JAK_MALLOC(sizeof(jak_archive_io_context));

        if (!result) {
                JAK_ERROR(err, JAK_ERR_MALLOCERR);
                return false;
        }

        jak_spinlock_init(&result->lock);
        jak_error_init(&result->err);

        result->file = fopen(file_path, "r");

        if (!result->file) {
                JAK_ERROR(err, JAK_ERR_FOPEN_FAILED);
                result->file = NULL;
                return false;
        } else {
                *context = result;
                return true;
        }
}

jak_error *jak_io_context_get_error(jak_archive_io_context *context)
{
        return context ? &context->err : NULL;
}

FILE *jak_io_context_lock_and_access(jak_archive_io_context *context)
{
        if (context) {
                jak_spinlock_acquire(&context->lock);
                context->last_pos = ftell(context->file);
                return context->file;
        } else {
                JAK_ERROR(&context->err, JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool jak_io_context_unlock(jak_archive_io_context *context)
{
        if (context) {
                fseek(context->file, context->last_pos, SEEK_SET);
                jak_spinlock_release(&context->lock);
                return true;
        } else {
                JAK_ERROR(&context->err, JAK_ERR_NULLPTR);
                return false;
        }
}

bool jak_io_context_drop(jak_archive_io_context *context)
{
        JAK_ERROR_IF_NULL(context);
        JAK_OPTIONAL(context->file != NULL, fclose(context->file);
                context->file = NULL)
        free(context);
        return true;
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_archive_it.h>
#include <jak_archive_int.h>

static bool init_object_from_memfile(jak_archive_object *obj, jak_memfile *memfile)
{
        JAK_ASSERT(obj);
        jak_offset_t object_off;
        jak_object_header *header;
        jak_object_flags_u flags;

        object_off = jak_memfile_tell(memfile);
        header = JAK_MEMFILE_READ_TYPE(memfile, jak_object_header);
        if (JAK_UNLIKELY(header->marker != JAK_MARKER_SYMBOL_OBJECT_BEGIN)) {
                return false;
        }

        flags.value = header->flags;
        jak_int_read_prop_offsets(&obj->prop_offsets, memfile, &flags);

        obj->object_id = header->oid;
        obj->offset = object_off;
        obj->next_obj_off = *JAK_MEMFILE_READ_TYPE(memfile, jak_offset_t);
        jak_memfile_open(&obj->memfile, memfile->memblock, JAK_READ_ONLY);

        return true;
}

#define STATE_AND_PROPERTY_EXISTS(state, property) \
    (iter->prop_cursor != state || iter->object.property != 0)

inline static jak_offset_t offset_by_state(jak_prop_iter *iter)
{
        switch (iter->prop_cursor) {
                case JAK_PROP_ITER_NULLS:
                        return iter->object.prop_offsets.nulls;
                case JAK_PROP_ITER_BOOLS:
                        return iter->object.prop_offsets.bools;
                case JAK_PROP_ITER_INT8S:
                        return iter->object.prop_offsets.int8s;
                case JAK_PROP_ITER_INT16S:
                        return iter->object.prop_offsets.int16s;
                case JAK_PROP_ITER_INT32S:
                        return iter->object.prop_offsets.int32s;
                case JAK_PROP_ITER_INT64S:
                        return iter->object.prop_offsets.int64s;
                case JAK_PROP_ITER_UINT8S:
                        return iter->object.prop_offsets.uint8s;
                case JAK_PROP_ITER_UINT16S:
                        return iter->object.prop_offsets.uint16s;
                case JAK_PROP_ITER_UINT32S:
                        return iter->object.prop_offsets.uint32s;
                case JAK_PROP_ITER_UINT64S:
                        return iter->object.prop_offsets.uint64s;
                case JAK_PROP_ITER_FLOATS:
                        return iter->object.prop_offsets.floats;
                case JAK_PROP_ITER_STRINGS:
                        return iter->object.prop_offsets.strings;
                case JAK_PROP_ITER_OBJECTS:
                        return iter->object.prop_offsets.objects;
                case JAK_PROP_ITER_NULL_ARRAYS:
                        return iter->object.prop_offsets.null_arrays;
                case JAK_PROP_ITER_BOOL_ARRAYS:
                        return iter->object.prop_offsets.bool_arrays;
                case JAK_PROP_ITER_INT8_ARRAYS:
                        return iter->object.prop_offsets.int8_arrays;
                case JAK_PROP_ITER_INT16_ARRAYS:
                        return iter->object.prop_offsets.int16_arrays;
                case JAK_PROP_ITER_INT32_ARRAYS:
                        return iter->object.prop_offsets.int32_arrays;
                case JAK_PROP_ITER_INT64_ARRAYS:
                        return iter->object.prop_offsets.int64_arrays;
                case JAK_PROP_ITER_UINT8_ARRAYS:
                        return iter->object.prop_offsets.uint8_arrays;
                case JAK_PROP_ITER_UINT16_ARRAYS:
                        return iter->object.prop_offsets.uint16_arrays;
                case JAK_PROP_ITER_UINT32_ARRAYS:
                        return iter->object.prop_offsets.uint32_arrays;
                case JAK_PROP_ITER_UINT64_ARRAYS:
                        return iter->object.prop_offsets.uint64_arrays;
                case JAK_PROP_ITER_FLOAT_ARRAYS:
                        return iter->object.prop_offsets.float_arrays;
                case JAK_PROP_ITER_STRING_ARRAYS:
                        return iter->object.prop_offsets.jak_string_arrays;
                case JAK_PROP_ITER_OBJECT_ARRAYS:
                        return iter->object.prop_offsets.object_arrays;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR)
        }
}

static bool prop_iter_read_colum_entry(jak_collection_iter_state *state, jak_memfile *memfile)
{
        JAK_ASSERT(state->current_column_group.current_column.current_entry.idx
                   < state->current_column_group.current_column.num_elem);

        jak_u32 current_idx = state->current_column_group.current_column.current_entry.idx;
        jak_offset_t entry_off = state->current_column_group.current_column.elem_offsets[current_idx];
        jak_memfile_seek(memfile, entry_off);

        state->current_column_group.current_column.current_entry.array_length = *JAK_MEMFILE_READ_TYPE(memfile,
                                                                                                       jak_u32);
        state->current_column_group.current_column.current_entry.array_base = JAK_MEMFILE_PEEK(memfile, void);

        return (++state->current_column_group.current_column.current_entry.idx)
               < state->current_column_group.current_column.num_elem;
}

static bool prop_iter_read_column(jak_collection_iter_state *state, jak_memfile *memfile)
{
        JAK_ASSERT(state->current_column_group.current_column.idx < state->current_column_group.num_columns);

        jak_u32 current_idx = state->current_column_group.current_column.idx;
        jak_offset_t column_off = state->current_column_group.column_offs[current_idx];
        jak_memfile_seek(memfile, column_off);
        const jak_column_header *header = JAK_MEMFILE_READ_TYPE(memfile, jak_column_header);

        JAK_ASSERT(header->marker == JAK_MARKER_SYMBOL_COLUMN);
        state->current_column_group.current_column.name = header->column_name;
        state->current_column_group.current_column.type = jak_int_marker_to_field_type(header->value_type);

        state->current_column_group.current_column.num_elem = header->num_entries;
        state->current_column_group.current_column.elem_offsets =
                JAK_MEMFILE_READ_TYPE_LIST(memfile, jak_offset_t, header->num_entries);
        state->current_column_group.current_column.elem_positions =
                JAK_MEMFILE_READ_TYPE_LIST(memfile, jak_u32, header->num_entries);
        state->current_column_group.current_column.current_entry.idx = 0;

        return (++state->current_column_group.current_column.idx) < state->current_column_group.num_columns;
}

static bool collection_iter_read_next_column_group(jak_collection_iter_state *state, jak_memfile *memfile)
{
        JAK_ASSERT(state->current_column_group_idx < state->num_column_groups);
        jak_memfile_seek(memfile, state->column_group_offsets[state->current_column_group_idx]);
        const jak_column_group_header *header = JAK_MEMFILE_READ_TYPE(memfile, jak_column_group_header);
        JAK_ASSERT(header->marker == JAK_MARKER_SYMBOL_COLUMN_GROUP);
        state->current_column_group.num_columns = header->num_columns;
        state->current_column_group.num_objects = header->num_objects;
        state->current_column_group.object_ids = JAK_MEMFILE_READ_TYPE_LIST(memfile, jak_uid_t,
                                                                            header->num_objects);
        state->current_column_group.column_offs = JAK_MEMFILE_READ_TYPE_LIST(memfile, jak_offset_t,
                                                                             header->num_columns);
        state->current_column_group.current_column.idx = 0;

        return (++state->current_column_group_idx) < state->num_column_groups;
}

static void prop_iter_cursor_init(jak_prop_iter *iter)
{
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_NULLS, prop_offsets.nulls));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_BOOLS, prop_offsets.bools));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_INT8S, prop_offsets.int8s));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_INT16S, prop_offsets.int16s));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_INT32S, prop_offsets.int32s));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_INT64S, prop_offsets.int64s));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_UINT8S, prop_offsets.uint8s));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_UINT16S, prop_offsets.uint16s));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_UINT32S, prop_offsets.uint32s));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_UINT64S, prop_offsets.uint64s));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_FLOATS, prop_offsets.floats));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_STRINGS, prop_offsets.strings));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_OBJECTS, prop_offsets.objects));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_NULL_ARRAYS, prop_offsets.null_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_BOOL_ARRAYS, prop_offsets.bool_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_INT8_ARRAYS, prop_offsets.int8_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_INT16_ARRAYS, prop_offsets.int16_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_INT32_ARRAYS, prop_offsets.int32_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_INT64_ARRAYS, prop_offsets.int64_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_UINT8_ARRAYS, prop_offsets.uint8_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_UINT16_ARRAYS, prop_offsets.uint16_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_UINT32_ARRAYS, prop_offsets.uint32_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_UINT64_ARRAYS, prop_offsets.uint64_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_FLOAT_ARRAYS, prop_offsets.float_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_STRING_ARRAYS, prop_offsets.jak_string_arrays));
        JAK_ASSERT(STATE_AND_PROPERTY_EXISTS(JAK_PROP_ITER_OBJECT_ARRAYS, prop_offsets.object_arrays));

        if (iter->mode == JAK_PROP_ITER_MODE_COLLECTION) {
                iter->mode_collection.collection_start_off = offset_by_state(iter);
                jak_memfile_seek(&iter->record_table_memfile, iter->mode_collection.collection_start_off);
                const jak_object_array_header
                        *header = JAK_MEMFILE_READ_TYPE(&iter->record_table_memfile, jak_object_array_header);
                iter->mode_collection.num_column_groups = header->num_entries;
                iter->mode_collection.current_column_group_idx = 0;
                iter->mode_collection.column_group_keys = JAK_MEMFILE_READ_TYPE_LIST(&iter->record_table_memfile,
                                                                                     jak_archive_field_sid_t,
                                                                                     iter->mode_collection.num_column_groups);
                iter->mode_collection.column_group_offsets = JAK_MEMFILE_READ_TYPE_LIST(&iter->record_table_memfile,
                                                                                        jak_offset_t,
                                                                                        iter->mode_collection.num_column_groups);

        } else {
                iter->mode_object.current_prop_group_off = offset_by_state(iter);
                jak_memfile_seek(&iter->record_table_memfile, iter->mode_object.current_prop_group_off);
                jak_int_embedded_fixed_props_read(&iter->mode_object.prop_group_header, &iter->record_table_memfile);
                iter->mode_object.prop_data_off = jak_memfile_tell(&iter->record_table_memfile);
        }

}

#define SET_STATE_FOR_FALL_THROUGH(iter, prop_offset_type, mask_group, mask_type, next_state)                          \
{                                                                                                                      \
    if ((iter->object.prop_offsets.prop_offset_type != 0) &&                                                           \
        (JAK_ARE_BITS_SET(iter->mask, mask_group | mask_type)))                                                  \
    {                                                                                                                  \
        iter->prop_cursor = next_state;                                                                                \
        break;                                                                                                         \
    }                                                                                                                  \
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"

static jak_prop_iter_state_e prop_iter_state_next(jak_prop_iter *iter)
{
        switch (iter->prop_cursor) {
                case JAK_PROP_ITER_INIT: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                    nulls,
                                                                    JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                    JAK_ARCHIVE_ITER_MASK_NULL,
                                                                    JAK_PROP_ITER_NULLS)
                case JAK_PROP_ITER_NULLS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                     bools,
                                                                     JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                     JAK_ARCHIVE_ITER_MASK_BOOLEAN,
                                                                     JAK_PROP_ITER_BOOLS)
                case JAK_PROP_ITER_BOOLS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                     int8s,
                                                                     JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                     JAK_ARCHIVE_ITER_MASK_INT8,
                                                                     JAK_PROP_ITER_INT8S)
                case JAK_PROP_ITER_INT8S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                     int16s,
                                                                     JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                     JAK_ARCHIVE_ITER_MASK_INT16,
                                                                     JAK_PROP_ITER_INT16S)
                case JAK_PROP_ITER_INT16S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      int32s,
                                                                      JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      JAK_ARCHIVE_ITER_MASK_INT32,
                                                                      JAK_PROP_ITER_INT32S)
                case JAK_PROP_ITER_INT32S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      int64s,
                                                                      JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      JAK_ARCHIVE_ITER_MASK_INT64,
                                                                      JAK_PROP_ITER_INT64S)
                case JAK_PROP_ITER_INT64S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      uint8s,
                                                                      JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      JAK_ARCHIVE_ITER_MASK_UINT8,
                                                                      JAK_PROP_ITER_UINT8S)
                case JAK_PROP_ITER_UINT8S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      uint16s,
                                                                      JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      JAK_ARCHIVE_ITER_MASK_UINT16,
                                                                      JAK_PROP_ITER_UINT16S)
                case JAK_PROP_ITER_UINT16S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       uint32s,
                                                                       JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                       JAK_ARCHIVE_ITER_MASK_UINT32,
                                                                       JAK_PROP_ITER_UINT32S)
                case JAK_PROP_ITER_UINT32S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       uint64s,
                                                                       JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                       JAK_ARCHIVE_ITER_MASK_UINT64,
                                                                       JAK_PROP_ITER_UINT64S)
                case JAK_PROP_ITER_UINT64S: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       floats,
                                                                       JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                       JAK_ARCHIVE_ITER_MASK_NUMBER,
                                                                       JAK_PROP_ITER_FLOATS)
                case JAK_PROP_ITER_FLOATS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                      strings,
                                                                      JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                      JAK_ARCHIVE_ITER_MASK_STRING,
                                                                      JAK_PROP_ITER_STRINGS)
                case JAK_PROP_ITER_STRINGS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       objects,
                                                                       JAK_ARCHIVE_ITER_MASK_PRIMITIVES,
                                                                       JAK_ARCHIVE_ITER_MASK_OBJECT,
                                                                       JAK_PROP_ITER_OBJECTS)
                case JAK_PROP_ITER_OBJECTS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                       null_arrays,
                                                                       JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                       JAK_ARCHIVE_ITER_MASK_NULL,
                                                                       JAK_PROP_ITER_NULL_ARRAYS)
                case JAK_PROP_ITER_NULL_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                           bool_arrays,
                                                                           JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                           JAK_ARCHIVE_ITER_MASK_BOOLEAN,
                                                                           JAK_PROP_ITER_BOOL_ARRAYS)
                case JAK_PROP_ITER_BOOL_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                           int8_arrays,
                                                                           JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                           JAK_ARCHIVE_ITER_MASK_INT8,
                                                                           JAK_PROP_ITER_INT8_ARRAYS)
                case JAK_PROP_ITER_INT8_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                           int16_arrays,
                                                                           JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                           JAK_ARCHIVE_ITER_MASK_INT16,
                                                                           JAK_PROP_ITER_INT16_ARRAYS)
                case JAK_PROP_ITER_INT16_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            int32_arrays,
                                                                            JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                            JAK_ARCHIVE_ITER_MASK_INT32,
                                                                            JAK_PROP_ITER_INT32_ARRAYS)
                case JAK_PROP_ITER_INT32_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            int64_arrays,
                                                                            JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                            JAK_ARCHIVE_ITER_MASK_INT64,
                                                                            JAK_PROP_ITER_INT64_ARRAYS)
                case JAK_PROP_ITER_INT64_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            uint8_arrays,
                                                                            JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                            JAK_ARCHIVE_ITER_MASK_UINT8,
                                                                            JAK_PROP_ITER_UINT8_ARRAYS)
                case JAK_PROP_ITER_UINT8_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            uint16_arrays,
                                                                            JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                            JAK_ARCHIVE_ITER_MASK_UINT16,
                                                                            JAK_PROP_ITER_UINT16_ARRAYS)
                case JAK_PROP_ITER_UINT16_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                             uint32_arrays,
                                                                             JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                             JAK_ARCHIVE_ITER_MASK_UINT32,
                                                                             JAK_PROP_ITER_UINT32_ARRAYS)
                case JAK_PROP_ITER_UINT32_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                             uint64_arrays,
                                                                             JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                             JAK_ARCHIVE_ITER_MASK_UINT64,
                                                                             JAK_PROP_ITER_UINT64_ARRAYS)
                case JAK_PROP_ITER_UINT64_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                             float_arrays,
                                                                             JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                             JAK_ARCHIVE_ITER_MASK_NUMBER,
                                                                             JAK_PROP_ITER_FLOAT_ARRAYS)
                case JAK_PROP_ITER_FLOAT_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                            jak_string_arrays,
                                                                            JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                            JAK_ARCHIVE_ITER_MASK_STRING,
                                                                            JAK_PROP_ITER_STRING_ARRAYS)
                case JAK_PROP_ITER_STRING_ARRAYS: SET_STATE_FOR_FALL_THROUGH(iter,
                                                                             object_arrays,
                                                                             JAK_ARCHIVE_ITER_MASK_ARRAYS,
                                                                             JAK_ARCHIVE_ITER_MASK_OBJECT,
                                                                             JAK_PROP_ITER_OBJECT_ARRAYS)
                case JAK_PROP_ITER_OBJECT_ARRAYS:
                        iter->prop_cursor = JAK_PROP_ITER_DONE;
                        break;

                case JAK_PROP_ITER_DONE:
                        break;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR);
        }

        iter->mode = iter->prop_cursor == JAK_PROP_ITER_OBJECT_ARRAYS ? JAK_PROP_ITER_MODE_COLLECTION
                                                                      : JAK_PROP_ITER_MODE_OBJECT;

        if (iter->prop_cursor != JAK_PROP_ITER_DONE) {
                prop_iter_cursor_init(iter);
        }
        return iter->prop_cursor;
}

#pragma GCC diagnostic pop

static void prop_iter_state_init(jak_prop_iter *iter)
{
        iter->prop_cursor = JAK_PROP_ITER_INIT;
        iter->mode = JAK_PROP_ITER_MODE_OBJECT;
}

static bool archive_prop_iter_from_memblock(jak_prop_iter *iter, jak_error *err, jak_u16 mask,
                                            jak_memblock *memblock, jak_offset_t object_offset)
{
        JAK_ERROR_IF_NULL(iter)
        JAK_ERROR_IF_NULL(err)
        JAK_ERROR_IF_NULL(memblock)

        iter->mask = mask;
        if (!jak_memfile_open(&iter->record_table_memfile, memblock, JAK_READ_ONLY)) {
                JAK_ERROR(err, JAK_ERR_MEMFILEOPEN_FAILED)
                return false;
        }
        if (!jak_memfile_seek(&iter->record_table_memfile, object_offset)) {
                JAK_ERROR(err, JAK_ERR_MEMFILESEEK_FAILED)
                return false;
        }
        if (!init_object_from_memfile(&iter->object, &iter->record_table_memfile)) {
                JAK_ERROR(err, JAK_ERR_INTERNALERR);
                return false;
        }

        jak_error_init(&iter->err);
        prop_iter_state_init(iter);
        prop_iter_state_next(iter);

        return true;
}

bool jak_archive_prop_iter_from_archive(jak_prop_iter *iter, jak_error *err, jak_u16 mask,
                                        jak_archive *archive)
{
        return archive_prop_iter_from_memblock(iter, err, mask, archive->record_table.record_db, 0);
}

bool jak_archive_prop_iter_from_object(jak_prop_iter *iter, jak_u16 mask, jak_error *err,
                                       const jak_archive_object *obj)
{
        return archive_prop_iter_from_memblock(iter, err, mask, obj->memfile.memblock, obj->offset);
}

static enum jak_archive_field_type get_basic_type(jak_prop_iter_state_e state)
{
        switch (state) {
                case JAK_PROP_ITER_NULLS:
                case JAK_PROP_ITER_NULL_ARRAYS:
                        return JAK_FIELD_NULL;
                case JAK_PROP_ITER_BOOLS:
                case JAK_PROP_ITER_BOOL_ARRAYS:
                        return JAK_FIELD_BOOLEAN;
                case JAK_PROP_ITER_INT8S:
                case JAK_PROP_ITER_INT8_ARRAYS:
                        return JAK_FIELD_INT8;
                case JAK_PROP_ITER_INT16S:
                case JAK_PROP_ITER_INT16_ARRAYS:
                        return JAK_FIELD_INT16;
                case JAK_PROP_ITER_INT32S:
                case JAK_PROP_ITER_INT32_ARRAYS:
                        return JAK_FIELD_INT32;
                case JAK_PROP_ITER_INT64S:
                case JAK_PROP_ITER_INT64_ARRAYS:
                        return JAK_FIELD_INT64;
                case JAK_PROP_ITER_UINT8S:
                case JAK_PROP_ITER_UINT8_ARRAYS:
                        return JAK_FIELD_UINT8;
                case JAK_PROP_ITER_UINT16S:
                case JAK_PROP_ITER_UINT16_ARRAYS:
                        return JAK_FIELD_UINT16;
                case JAK_PROP_ITER_UINT32S:
                case JAK_PROP_ITER_UINT32_ARRAYS:
                        return JAK_FIELD_UINT32;
                case JAK_PROP_ITER_UINT64S:
                case JAK_PROP_ITER_UINT64_ARRAYS:
                        return JAK_FIELD_UINT64;
                case JAK_PROP_ITER_FLOATS:
                case JAK_PROP_ITER_FLOAT_ARRAYS:
                        return JAK_FIELD_FLOAT;
                case JAK_PROP_ITER_STRINGS:
                case JAK_PROP_ITER_STRING_ARRAYS:
                        return JAK_FIELD_STRING;
                case JAK_PROP_ITER_OBJECTS:
                case JAK_PROP_ITER_OBJECT_ARRAYS:
                        return JAK_FIELD_OBJECT;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR);
        }
}

static bool is_array_type(jak_prop_iter_state_e state)
{
        switch (state) {
                case JAK_PROP_ITER_NULLS:
                case JAK_PROP_ITER_BOOLS:
                case JAK_PROP_ITER_INT8S:
                case JAK_PROP_ITER_INT16S:
                case JAK_PROP_ITER_INT32S:
                case JAK_PROP_ITER_INT64S:
                case JAK_PROP_ITER_UINT8S:
                case JAK_PROP_ITER_UINT16S:
                case JAK_PROP_ITER_UINT32S:
                case JAK_PROP_ITER_UINT64S:
                case JAK_PROP_ITER_FLOATS:
                case JAK_PROP_ITER_STRINGS:
                case JAK_PROP_ITER_OBJECTS:
                        return false;
                case JAK_PROP_ITER_NULL_ARRAYS:
                case JAK_PROP_ITER_BOOL_ARRAYS:
                case JAK_PROP_ITER_INT8_ARRAYS:
                case JAK_PROP_ITER_INT16_ARRAYS:
                case JAK_PROP_ITER_INT32_ARRAYS:
                case JAK_PROP_ITER_INT64_ARRAYS:
                case JAK_PROP_ITER_UINT8_ARRAYS:
                case JAK_PROP_ITER_UINT16_ARRAYS:
                case JAK_PROP_ITER_UINT32_ARRAYS:
                case JAK_PROP_ITER_UINT64_ARRAYS:
                case JAK_PROP_ITER_FLOAT_ARRAYS:
                case JAK_PROP_ITER_STRING_ARRAYS:
                case JAK_PROP_ITER_OBJECT_ARRAYS:
                        return true;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR);
        }
}

bool jak_archive_prop_iter_next(jak_prop_iter_mode_e *type, jak_archive_value_vector *value_vector,
                                jak_independent_iter_state *collection_iter, jak_prop_iter *prop_iter)
{
        JAK_ERROR_IF_NULL(type);
        JAK_ERROR_IF_NULL(prop_iter);

        if (prop_iter->prop_cursor != JAK_PROP_ITER_DONE) {
                switch (prop_iter->mode) {
                        case JAK_PROP_ITER_MODE_OBJECT: {
                                value_vector->keys = prop_iter->mode_object.prop_group_header.keys;

                                prop_iter->mode_object.type = get_basic_type(prop_iter->prop_cursor);
                                prop_iter->mode_object.is_array = is_array_type(prop_iter->prop_cursor);

                                value_vector->value_max_idx = prop_iter->mode_object.prop_group_header.header->num_entries;
                                value_vector->prop_type = prop_iter->mode_object.type;
                                value_vector->is_array = prop_iter->mode_object.is_array;

                                if (value_vector
                                    && !jak_archive_value_jak_vector_from_prop_iter(value_vector, &prop_iter->err,
                                                                                prop_iter)) {
                                        JAK_ERROR(&prop_iter->err, JAK_ERR_VITEROPEN_FAILED);
                                        return false;
                                }
                        }
                                break;
                        case JAK_PROP_ITER_MODE_COLLECTION: {
                                collection_iter->state = prop_iter->mode_collection;
                                jak_memfile_open(&collection_iter->record_table_memfile,
                                             prop_iter->record_table_memfile.memblock,
                                             JAK_READ_ONLY);
                                jak_error_init(&collection_iter->err);
                        }
                                break;
                        default: JAK_ERROR(&prop_iter->err, JAK_ERR_INTERNALERR);
                                return false;
                }
                *type = prop_iter->mode;
                prop_iter_state_next(prop_iter);
                return true;
        } else {
                return false;
        }
}

const jak_archive_field_sid_t *
jak_archive_collection_iter_get_keys(jak_u32 *num_keys, jak_independent_iter_state *iter)
{
        if (num_keys && iter) {
                *num_keys = iter->state.num_column_groups;
                return iter->state.column_group_keys;
        } else {
                JAK_ERROR(&iter->err, JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool jak_archive_collection_next_column_group(jak_independent_iter_state *group_iter,
                                              jak_independent_iter_state *iter)
{
        JAK_ERROR_IF_NULL(group_iter)
        JAK_ERROR_IF_NULL(iter)

        if (iter->state.current_column_group_idx < iter->state.num_column_groups) {
                collection_iter_read_next_column_group(&iter->state, &iter->record_table_memfile);
                jak_memfile_open(&group_iter->record_table_memfile, iter->record_table_memfile.memblock, JAK_READ_ONLY);
                group_iter->state = iter->state;
                jak_error_init(&group_iter->err);
                return true;
        } else {
                return false;
        }
}

const jak_uid_t *
jak_archive_column_group_get_object_ids(jak_u32 *num_objects, jak_independent_iter_state *iter)
{
        if (num_objects && iter) {
                *num_objects = iter->state.current_column_group.num_objects;
                return iter->state.current_column_group.object_ids;
        } else {
                JAK_ERROR(&iter->err, JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool jak_archive_column_group_next_column(jak_independent_iter_state *column_iter,
                                          jak_independent_iter_state *iter)
{
        JAK_ERROR_IF_NULL(column_iter)
        JAK_ERROR_IF_NULL(iter)

        if (iter->state.current_column_group.current_column.idx < iter->state.current_column_group.num_columns) {
                prop_iter_read_column(&iter->state, &iter->record_table_memfile);
                jak_memfile_open(&column_iter->record_table_memfile, iter->record_table_memfile.memblock, JAK_READ_ONLY);
                column_iter->state = iter->state;
                jak_error_init(&column_iter->err);
                return true;
        } else {
                return false;
        }
}

bool jak_archive_column_get_name(jak_archive_field_sid_t *name, enum jak_archive_field_type *type,
                                 jak_independent_iter_state *column_iter)
{
        JAK_ERROR_IF_NULL(column_iter)
        JAK_OPTIONAL_SET(name, column_iter->state.current_column_group.current_column.name)
        JAK_OPTIONAL_SET(type, column_iter->state.current_column_group.current_column.type)
        return true;
}

const jak_u32 *
jak_archive_column_get_entry_positions(jak_u32 *num_entry, jak_independent_iter_state *column_iter)
{
        if (num_entry && column_iter) {
                *num_entry = column_iter->state.current_column_group.current_column.num_elem;
                return column_iter->state.current_column_group.current_column.elem_positions;
        } else {
                JAK_ERROR(&column_iter->err, JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool
jak_archive_column_next_entry(jak_independent_iter_state *entry_iter, jak_independent_iter_state *iter)
{
        JAK_ERROR_IF_NULL(entry_iter)
        JAK_ERROR_IF_NULL(iter)

        if (iter->state.current_column_group.current_column.current_entry.idx
            < iter->state.current_column_group.current_column.num_elem) {
                prop_iter_read_colum_entry(&iter->state, &iter->record_table_memfile);
                jak_memfile_open(&entry_iter->record_table_memfile, iter->record_table_memfile.memblock, JAK_READ_ONLY);
                entry_iter->state = iter->state;
                jak_error_init(&entry_iter->err);
                return true;
        } else {
                return false;
        }
}

bool jak_archive_column_entry_get_type(enum jak_archive_field_type *type, jak_independent_iter_state *entry)
{
        JAK_ERROR_IF_NULL(type)
        JAK_ERROR_IF_NULL(entry)
        *type = entry->state.current_column_group.current_column.type;
        return true;
}

#define DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(built_in_type, name, basic_type)                            \
const built_in_type *                                                                                   \
jak_archive_column_entry_get_##name(jak_u32 *array_length, jak_independent_iter_state *entry)              \
{                                                                                                                      \
    if (array_length && entry) {                                                                                       \
        if (entry->state.current_column_group.current_column.type == basic_type)                                       \
        {                                                                                                              \
            *array_length =  entry->state.current_column_group.current_column.current_entry.array_length;              \
            return (const built_in_type *) entry->state.current_column_group.current_column.current_entry.array_base;  \
        } else {                                                                                                       \
            JAK_ERROR(&entry->err, JAK_ERR_TYPEMISMATCH);                                                        \
            return NULL;                                                                                               \
        }                                                                                                              \
    } else {                                                                                                           \
        JAK_ERROR(&entry->err, JAK_ERR_NULLPTR);                                                                 \
        return NULL;                                                                                                   \
    }                                                                                                                  \
}

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_i8_t, int8s, JAK_FIELD_INT8);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_i16_t, int16s, JAK_FIELD_INT16);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_i32_t, int32s, JAK_FIELD_INT32);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_i64_t, int64s, JAK_FIELD_INT64);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_u8_t, uint8s, JAK_FIELD_UINT8);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_u16_t, uint16s, JAK_FIELD_UINT16);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_u32_t, uint32s, JAK_FIELD_UINT32);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_u64_t, uint64s, JAK_FIELD_UINT64);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_sid_t, strings, JAK_FIELD_STRING);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_number_t, numbers, JAK_FIELD_FLOAT);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_boolean_t, booleans, JAK_FIELD_BOOLEAN);

DECLARE_JAK_ARCHIVE_COLUMN_ENTRY_GET_BASIC_TYPE(jak_archive_field_u32_t, nulls, JAK_FIELD_NULL);

bool jak_archive_column_entry_get_objects(jak_column_object_iter *iter, jak_independent_iter_state *entry)
{
        JAK_ERROR_IF_NULL(iter)
        JAK_ERROR_IF_NULL(entry)

        iter->entry_state = entry->state;
        jak_memfile_open(&iter->memfile, entry->record_table_memfile.memblock, JAK_READ_ONLY);
        jak_memfile_seek(&iter->memfile,
                     entry->state.current_column_group.current_column.elem_offsets[
                             entry->state.current_column_group.current_column.current_entry.idx - 1] + sizeof(jak_u32));
        iter->next_obj_off = jak_memfile_tell(&iter->memfile);
        jak_error_init(&iter->err);

        return true;
}

const jak_archive_object *jak_archive_column_entry_object_iter_next_object(jak_column_object_iter *iter)
{
        if (iter) {
                if (iter->next_obj_off != 0) {
                        jak_memfile_seek(&iter->memfile, iter->next_obj_off);
                        if (init_object_from_memfile(&iter->obj, &iter->memfile)) {
                                iter->next_obj_off = iter->obj.next_obj_off;
                                return &iter->obj;
                        } else {
                                JAK_ERROR(&iter->err, JAK_ERR_INTERNALERR);
                                return NULL;
                        }
                } else {
                        return NULL;
                }
        } else {
                JAK_ERROR(&iter->err, JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool jak_archive_object_get_object_id(jak_uid_t *id, const jak_archive_object *object)
{
        JAK_ERROR_IF_NULL(id)
        JAK_ERROR_IF_NULL(object)
        *id = object->object_id;
        return true;
}

bool jak_archive_object_get_prop_iter(jak_prop_iter *iter, const jak_archive_object *object)
{
        // XXXX jak_archive_prop_iter_from_object()
        JAK_UNUSED(iter);
        JAK_UNUSED(object);
        return false;
}

bool jak_archive_value_jak_vector_get_object_id(jak_uid_t *id, const jak_archive_value_vector *iter)
{
        JAK_ERROR_IF_NULL(id)
        JAK_ERROR_IF_NULL(iter)
        *id = iter->object_id;
        return true;
}

const jak_archive_field_sid_t *
jak_archive_value_jak_vector_get_keys(jak_u32 *num_keys, jak_archive_value_vector *iter)
{
        if (num_keys && iter) {
                *num_keys = iter->value_max_idx;
                return iter->keys;
        } else {
                JAK_ERROR(&iter->err, JAK_ERR_NULLPTR)
                return NULL;
        }
}

static void value_jak_vector_init_object_basic(jak_archive_value_vector *value)
{
        value->data.object.offsets =
                JAK_MEMFILE_READ_TYPE_LIST(&value->record_table_memfile, jak_offset_t, value->value_max_idx);
}

static void value_jak_vector_init_fixed_length_types_basic(jak_archive_value_vector *value)
{
        JAK_ASSERT(!value->is_array);

        switch (value->prop_type) {
                case JAK_FIELD_INT8:
                        value->data.basic.values.int8s = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                          jak_archive_field_i8_t);
                        break;
                case JAK_FIELD_INT16:
                        value->data.basic.values.int16s = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                           jak_archive_field_i16_t);
                        break;
                case JAK_FIELD_INT32:
                        value->data.basic.values.int32s = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                           jak_archive_field_i32_t);
                        break;
                case JAK_FIELD_INT64:
                        value->data.basic.values.int64s = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                           jak_archive_field_i64_t);
                        break;
                case JAK_FIELD_UINT8:
                        value->data.basic.values.uint8s = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                           jak_archive_field_u8_t);
                        break;
                case JAK_FIELD_UINT16:
                        value->data.basic.values.uint16s = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                            jak_archive_field_u16_t);
                        break;
                case JAK_FIELD_UINT32:
                        value->data.basic.values.uint32s = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                            jak_archive_field_u32_t);
                        break;
                case JAK_FIELD_UINT64:
                        value->data.basic.values.uint64s = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                            jak_archive_field_u64_t);
                        break;
                case JAK_FIELD_FLOAT:
                        value->data.basic.values.numbers = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                            jak_archive_field_number_t);
                        break;
                case JAK_FIELD_STRING:
                        value->data.basic.values.strings = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                            jak_archive_field_sid_t);
                        break;
                case JAK_FIELD_BOOLEAN:
                        value->data.basic.values.booleans = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                             jak_archive_field_boolean_t);
                        break;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR);
        }
}

static void value_jak_vector_init_fixed_length_types_null_arrays(jak_archive_value_vector *value)
{
        JAK_ASSERT(value->is_array);
        JAK_ASSERT(value->prop_type == JAK_FIELD_NULL);
        value->data.arrays.meta.num_nulls_contained =
                JAK_MEMFILE_READ_TYPE_LIST(&value->record_table_memfile, jak_u32, value->value_max_idx);
}

static void value_jak_vector_init_fixed_length_types_non_null_arrays(jak_archive_value_vector *value)
{
        JAK_ASSERT (value->is_array);

        value->data.arrays.meta.array_lengths =
                JAK_MEMFILE_READ_TYPE_LIST(&value->record_table_memfile, jak_u32, value->value_max_idx);

        switch (value->prop_type) {
                case JAK_FIELD_INT8:
                        value->data.arrays.values.int8s_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                jak_archive_field_i8_t);
                        break;
                case JAK_FIELD_INT16:
                        value->data.arrays.values.int16s_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                 jak_archive_field_i16_t);
                        break;
                case JAK_FIELD_INT32:
                        value->data.arrays.values.int32s_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                 jak_archive_field_i32_t);
                        break;
                case JAK_FIELD_INT64:
                        value->data.arrays.values.int64s_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                 jak_archive_field_i64_t);
                        break;
                case JAK_FIELD_UINT8:
                        value->data.arrays.values.uint8s_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                 jak_archive_field_u8_t);
                        break;
                case JAK_FIELD_UINT16:
                        value->data.arrays.values.uint16s_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                  jak_archive_field_u16_t);
                        break;
                case JAK_FIELD_UINT32:
                        value->data.arrays.values.uint32s_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                  jak_archive_field_u32_t);
                        break;
                case JAK_FIELD_UINT64:
                        value->data.arrays.values.uint64s_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                  jak_archive_field_u64_t);
                        break;
                case JAK_FIELD_FLOAT:
                        value->data.arrays.values.numbers_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                  jak_archive_field_number_t);
                        break;
                case JAK_FIELD_STRING:
                        value->data.arrays.values.strings_base = JAK_MEMFILE_PEEK(&value->record_table_memfile,
                                                                                  jak_archive_field_sid_t);
                        break;
                case JAK_FIELD_BOOLEAN:
                        value->data.arrays.values.booleans_base =
                                JAK_MEMFILE_PEEK(&value->record_table_memfile, jak_archive_field_boolean_t);
                        break;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR);
        }
}

static void value_jak_vector_init_fixed_length_types(jak_archive_value_vector *value)
{
        if (value->is_array) {
                value_jak_vector_init_fixed_length_types_non_null_arrays(value);
        } else {
                value_jak_vector_init_fixed_length_types_basic(value);
        }
}

static void value_jak_vector_init_object(jak_archive_value_vector *value)
{
        if (value->is_array) {
                //value_jak_vector_init_object_array(value);
        } else {
                value_jak_vector_init_object_basic(value);
        }
}

bool jak_archive_value_jak_vector_from_prop_iter(jak_archive_value_vector *value, jak_error *err,
                                             jak_prop_iter *prop_iter)
{
        JAK_ERROR_IF_NULL(value);
        JAK_ERROR_IF_NULL(prop_iter);

        JAK_ERROR_IF_AND_RETURN (prop_iter->mode != JAK_PROP_ITER_MODE_OBJECT,
                             &prop_iter->err,
                             JAK_ERR_ITER_OBJECT_NEEDED,
                             false)

        jak_error_init(&value->err);

        value->prop_iter = prop_iter;
        value->data_off = prop_iter->mode_object.prop_data_off;
        value->object_id = prop_iter->object.object_id;

        if (!jak_memfile_open(&value->record_table_memfile, prop_iter->record_table_memfile.memblock, JAK_READ_ONLY)) {
                JAK_ERROR(err, JAK_ERR_MEMFILEOPEN_FAILED);
                return false;
        }
        if (!jak_memfile_skip(&value->record_table_memfile, value->data_off)) {
                JAK_ERROR(err, JAK_ERR_MEMFILESKIP_FAILED);
                return false;
        }

        value->prop_type = prop_iter->mode_object.type;
        value->is_array = prop_iter->mode_object.is_array;
        value->value_max_idx = prop_iter->mode_object.prop_group_header.header->num_entries;

        switch (value->prop_type) {
                case JAK_FIELD_OBJECT:
                        value_jak_vector_init_object(value);
                        break;
                case JAK_FIELD_NULL:
                        if (value->is_array) {
                                value_jak_vector_init_fixed_length_types_null_arrays(value);
                        }
                        break;
                case JAK_FIELD_INT8:
                case JAK_FIELD_INT16:
                case JAK_FIELD_INT32:
                case JAK_FIELD_INT64:
                case JAK_FIELD_UINT8:
                case JAK_FIELD_UINT16:
                case JAK_FIELD_UINT32:
                case JAK_FIELD_UINT64:
                case JAK_FIELD_FLOAT:
                case JAK_FIELD_STRING:
                case JAK_FIELD_BOOLEAN:
                        value_jak_vector_init_fixed_length_types(value);
                        break;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR);
        }

        return true;
}

bool jak_archive_value_jak_vector_get_basic_type(enum jak_archive_field_type *type,
                                                 const jak_archive_value_vector *value)
{
        JAK_ERROR_IF_NULL(type)
        JAK_ERROR_IF_NULL(value)
        *type = value->prop_type;
        return true;
}

bool jak_archive_value_jak_vector_is_array_type(bool *is_array, const jak_archive_value_vector *value)
{
        JAK_ERROR_IF_NULL(is_array)
        JAK_ERROR_IF_NULL(value)
        *is_array = value->is_array;
        return true;
}

bool jak_archive_value_jak_vector_get_length(jak_u32 *length, const jak_archive_value_vector *value)
{
        JAK_ERROR_IF_NULL(length)
        JAK_ERROR_IF_NULL(value)
        *length = value->value_max_idx;
        return true;
}

bool jak_archive_value_jak_vector_is_of_objects(bool *is_object, jak_archive_value_vector *value)
{
        JAK_ERROR_IF_NULL(is_object)
        JAK_ERROR_IF_NULL(value)

        *is_object = value->prop_type == JAK_FIELD_OBJECT && !value->is_array;

        return true;
}

bool jak_archive_value_jak_vector_get_object_at(jak_archive_object *object, jak_u32 idx,
                                                jak_archive_value_vector *value)
{
        JAK_ERROR_IF_NULL(object)
        JAK_ERROR_IF_NULL(value)

        if (idx >= value->value_max_idx) {
                JAK_ERROR(&value->err, JAK_ERR_OUTOFBOUNDS);
                return false;
        }

        bool is_object;

        jak_archive_value_jak_vector_is_of_objects(&is_object, value);

        if (is_object) {
                jak_memfile_seek(&value->record_table_memfile, value->data.object.offsets[idx]);
                init_object_from_memfile(&value->data.object.object, &value->record_table_memfile);
                *object = value->data.object.object;
                return true;
        } else {
                JAK_ERROR(&value->err, JAK_ERR_ITER_NOOBJ);
                return false;
        }
}

#define DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(name, basic_type)                                            \
bool                                                                                                    \
jak_archive_value_jak_vector_is_##name(bool *type_match, jak_archive_value_vector *value)                          \
{                                                                                                                      \
    JAK_ERROR_IF_NULL(type_match)                                                                               \
    JAK_ERROR_IF_NULL(value)                                                                                    \
                                                                                                                       \
    *type_match = value->prop_type == basic_type;                                                                      \
                                                                                                                       \
    return true;                                                                                                       \
}

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(int8, JAK_FIELD_INT8)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(int16, JAK_FIELD_INT16)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(int32, JAK_FIELD_INT32)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(int64, JAK_FIELD_INT64)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(uint8, JAK_FIELD_UINT8)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(uint16, JAK_FIELD_UINT16)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(uint32, JAK_FIELD_UINT32)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(uint64, JAK_FIELD_UINT64)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(string, JAK_FIELD_STRING)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(number, JAK_FIELD_FLOAT)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(boolean, JAK_FIELD_BOOLEAN)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_IS_BASIC_TYPE(null, JAK_FIELD_NULL)

#define DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(names, name, built_in_type, err_code)                       \
const built_in_type *                                                                                   \
jak_archive_value_jak_vector_get_##names(jak_u32 *num_values, jak_archive_value_vector *value)                    \
{                                                                                                                      \
    JAK_ERROR_IF_NULL(value)                                                                                    \
                                                                                                                       \
    bool is_array;                                                                                                     \
    bool type_match;                                                                                                   \
                                                                                                                       \
    if (jak_archive_value_jak_vector_is_array_type(&is_array, value) &&                                                 \
        jak_archive_value_jak_vector_is_##name(&type_match, value) && !is_array)                                        \
    {                                                                                                                  \
        JAK_OPTIONAL_SET(num_values, value->value_max_idx)                                                          \
        return value->data.basic.values.names;                                                                         \
    } else                                                                                                             \
    {                                                                                                                  \
        JAK_ERROR(&value->err, err_code);                                                                           \
        return NULL;                                                                                                   \
    }                                                                                                                  \
}

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(int8s, int8, jak_archive_field_i8_t, JAK_ERR_ITER_NOINT8)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(int16s, int16, jak_archive_field_i16_t, JAK_ERR_ITER_NOINT16)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(int32s, int32, jak_archive_field_i32_t, JAK_ERR_ITER_NOINT32)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(int64s, int64, jak_archive_field_i64_t, JAK_ERR_ITER_NOINT64)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(uint8s, uint8, jak_archive_field_u8_t, JAK_ERR_ITER_NOUINT8)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(uint16s, uint16, jak_archive_field_u16_t, JAK_ERR_ITER_NOUINT16)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(uint32s, uint32, jak_archive_field_u32_t, JAK_ERR_ITER_NOUINT32)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(uint64s, uint64, jak_archive_field_u64_t, JAK_ERR_ITER_NOUINT64)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(strings, string, jak_archive_field_sid_t, JAK_ERR_ITER_NOSTRING)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(numbers, number, jak_archive_field_number_t, JAK_ERR_ITER_NONUMBER)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_BASIC_TYPE(booleans, boolean, jak_archive_field_boolean_t, JAK_ERR_ITER_NOBOOL)

const jak_archive_field_u32_t *
jak_archive_value_jak_vector_get_null_arrays(jak_u32 *num_values, jak_archive_value_vector *value)
{
        JAK_ERROR_IF_NULL(value)

        bool is_array;
        bool type_match;

        if (jak_archive_value_jak_vector_is_array_type(&is_array, value) &&
            jak_archive_value_jak_vector_is_null(&type_match, value)
            && is_array) {
                JAK_OPTIONAL_SET(num_values, value->value_max_idx);
                return value->data.arrays.meta.num_nulls_contained;
        } else {
                return NULL;
        }
}

#define DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(name, built_in_type, base)                               \
const built_in_type *                                                                                   \
jak_archive_value_jak_vector_get_##name##_arrays_at(jak_u32 *array_length, jak_u32 idx,                               \
                                               jak_archive_value_vector *value)                                   \
{                                                                                                                      \
    JAK_ERROR_IF_NULL(value)                                                                                    \
                                                                                                                       \
    bool is_array;                                                                                                     \
    bool type_match;                                                                                                   \
                                                                                                                       \
    if (idx < value->value_max_idx && jak_archive_value_jak_vector_is_array_type(&is_array, value) &&                   \
        jak_archive_value_jak_vector_is_##name(&type_match, value) && is_array)                                         \
    {                                                                                                                  \
        jak_u32 skip_length = 0;                                                                                      \
        for (jak_u32 i = 0; i < idx; i++) {                                                                           \
            skip_length += value->data.arrays.meta.array_lengths[i];                                                   \
        }                                                                                                              \
        *array_length = value->data.arrays.meta.array_lengths[idx];                                                    \
        return value->data.arrays.values.base + skip_length;                                                           \
    } else                                                                                                             \
    {                                                                                                                  \
        return NULL;                                                                                                   \
    }                                                                                                                  \
}

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(int8, jak_archive_field_i8_t, int8s_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(int16, jak_archive_field_i16_t, int16s_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(int32, jak_archive_field_i32_t, int32s_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(int64, jak_archive_field_i64_t, int64s_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(uint8, jak_archive_field_u8_t, uint8s_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(uint16, jak_archive_field_u16_t, uint16s_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(uint32, jak_archive_field_u32_t, uint32s_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(uint64, jak_archive_field_u64_t, uint64s_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(string, jak_archive_field_sid_t, strings_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(number, jak_archive_field_number_t, numbers_base)

DECLARE_JAK_ARCHIVE_VALUE_VECTOR_GET_ARRAY_TYPE_AT(boolean, jak_archive_field_boolean_t, booleans_base)

void jak_archive_int_reset_carbon_object_mem_file(jak_archive_object *object)
{
        JAK_UNUSED(object);
        //  jak_memfile_seek(&object->file, object->self);
        abort();
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_archive_int.h>
#include <jak_archive_pred.h>
#include <jak_archive_cache.h>
#include <jak_archive_query.h>

struct jak_sid_to_offset_arg {
        jak_offset_t offset;
        jak_u32 strlen;
};

struct jak_sid_to_offset {
        jak_hashtable ofMapping(jak_archive_field_sid_t, struct jak_sid_to_offset_arg) mapping;
        FILE *disk_file;
        size_t disk_file_size;

};

#define OBJECT_GET_KEYS_TO_FIX_TYPE_GENERIC(num_pairs, obj, bit_flag_name, offset_name)                                \
{                                                                                                                      \
    if (!obj) {                                                                                                        \
        JAK_ERROR_PRINT_AND_DIE(JAK_ERR_NULLPTR)                                                                 \
    }                                                                                                                  \
                                                                                                                       \
    if (obj->flags.bits.bit_flag_name) {                                                                               \
        JAK_ASSERT(obj->props.offset_name != 0);                                                                           \
        jak_memfile_seek(&obj->file, obj->props.offset_name);                                                       \
        jak_fixed_prop prop;                                                                                      \
        jak_int_embedded_fixed_props_read(&prop, &obj->file);                                                       \
        jak_archive_int_reset_carbon_object_mem_file(obj);                                                                   \
        JAK_OPTIONAL_SET(num_pairs, prop.header->num_entries);                                                      \
        return prop.keys;                                                                                              \
    } else {                                                                                                           \
        JAK_OPTIONAL_SET(num_pairs, 0);                                                                             \
        return NULL;                                                                                                   \
    }                                                                                                                  \
}

bool jak_query_create(jak_archive_query *query, jak_archive *archive)
{
        JAK_ERROR_IF_NULL(query)
        JAK_ERROR_IF_NULL(archive)
        query->archive = archive;
        query->context = jak_archive_io_context_create(archive);
        jak_error_init(&query->err);
        return query->context != NULL;
}

bool jak_query_drop(jak_archive_query *query)
{
        JAK_ERROR_IF_NULL(query)
        return jak_io_context_drop(query->context);
}

bool jak_query_scan_strids(jak_strid_iter *it, jak_archive_query *query)
{
        JAK_ERROR_IF_NULL(it)
        JAK_ERROR_IF_NULL(query)
        return jak_strid_iter_open(it, &query->err, query->archive);
}

static bool
index_jak_string_id_to_offset_open_file(struct jak_sid_to_offset *index, jak_error *err, const char *file)
{
        index->disk_file = fopen(file, "r");
        if (!index->disk_file) {
                JAK_ERROR(err, JAK_ERR_FOPEN_FAILED)
                return false;
        } else {
                fseek(index->disk_file, 0, SEEK_END);
                index->disk_file_size = ftell(index->disk_file);
                fseek(index->disk_file, 0, SEEK_SET);
                return true;
        }
}

bool jak_query_create_index_jak_string_id_to_offset(struct jak_sid_to_offset **index, jak_archive_query *query)
{
        JAK_ERROR_IF_NULL(index)
        JAK_ERROR_IF_NULL(query)

        jak_strid_iter strid_iter;
        jak_strid_info *info;
        size_t jak_vector_len;
        bool status;
        bool success;
        jak_u32 capacity;
        jak_archive_info archive_info;
        jak_archive_get_info(&archive_info, query->archive);
        capacity = archive_info.num_embeddded_strings;

        struct jak_sid_to_offset *result = JAK_MALLOC(sizeof(struct jak_sid_to_offset));
        jak_hashtable_create(&result->mapping,
                         &query->err,
                         sizeof(jak_archive_field_sid_t),
                         sizeof(struct jak_sid_to_offset_arg),
                         capacity);

        if (!index_jak_string_id_to_offset_open_file(result, &query->err, query->archive->disk_file_path)) {
                return false;
        }

        status = jak_query_scan_strids(&strid_iter, query);

        if (status) {
                while (jak_strid_iter_next(&success, &info, &query->err, &jak_vector_len, &strid_iter)) {
                        for (size_t i = 0; i < jak_vector_len; i++) {
                                struct jak_sid_to_offset_arg arg = {.offset = info[i].offset, .strlen = info[i].strlen};
                                jak_hashtable_insert_or_update(&result->mapping, &info[i].id, &arg, 1);
                        }
                }
                *index = result;
                jak_strid_iter_close(&strid_iter);
                return true;
        } else {
                JAK_ERROR(&query->err, JAK_ERR_SCAN_FAILED);
                return false;
        }

}

void jak_query_drop_index_jak_string_id_to_offset(struct jak_sid_to_offset *index)
{
        if (index) {
                jak_hashtable_drop(&index->mapping);
                fclose(index->disk_file);
                free(index);
        }
}

bool jak_query_index_id_to_offset_serialize(FILE *file, jak_error *err, struct jak_sid_to_offset *index)
{
        JAK_UNUSED(file);
        JAK_UNUSED(err);
        JAK_UNUSED(index);
        return jak_hashtable_serialize(file, &index->mapping);
}

bool jak_query_index_id_to_offset_deserialize(struct jak_sid_to_offset **index, jak_error *err,
                                              const char *file_path, jak_offset_t offset)
{
        JAK_ERROR_IF_NULL(index)
        JAK_ERROR_IF_NULL(err)
        JAK_ERROR_IF_NULL(file_path)
        JAK_ERROR_IF_NULL(offset)

        struct jak_sid_to_offset *result = JAK_MALLOC(sizeof(struct jak_sid_to_offset));
        if (!result) {
                JAK_ERROR(err, JAK_ERR_MALLOCERR);
                return false;
        }

        if (!index_jak_string_id_to_offset_open_file(result, err, file_path)) {
                return false;
        }

        FILE *index_reader_file = fopen(file_path, "r");
        if (!index_reader_file) {
                JAK_ERROR(err, JAK_ERR_FOPEN_FAILED)
                return false;
        } else {
                fseek(index_reader_file, 0, SEEK_END);
                jak_offset_t file_size = ftell(index_reader_file);

                if (offset >= file_size) {
                        JAK_ERROR(err, JAK_ERR_INTERNALERR)
                        return false;
                }

                fseek(index_reader_file, offset, SEEK_SET);

                if (!jak_hashtable_deserialize(&result->mapping, err, index_reader_file)) {
                        JAK_ERROR(err, JAK_ERR_HASTABLE_DESERIALERR);
                        fclose(index_reader_file);
                        *index = NULL;
                        return false;
                }

                fclose(index_reader_file);
                *index = result;
                return true;
        }
}

static char *fetch_jak_string_from_file(bool *decode_success, FILE *disk_file, size_t offset, size_t jak_string_len,
                                    jak_error *err, jak_archive *archive)
{
        char *result = JAK_MALLOC(jak_string_len + 1);
        memset(result, 0, jak_string_len + 1);

        fseek(disk_file, offset, SEEK_SET);

        bool decode_result = jak_pack_decode(err, &archive->jak_string_table.compressor, result, jak_string_len, disk_file);

        *decode_success = decode_result;
        return result;
}

static char *fetch_jak_string_by_id_via_scan(jak_archive_query *query, jak_archive_field_sid_t id)
{
        JAK_ASSERT(query);

        jak_strid_iter strid_iter;
        jak_strid_info *info;
        size_t jak_vector_len;
        bool status;
        bool success;

        status = jak_query_scan_strids(&strid_iter, query);

        if (status) {
                while (jak_strid_iter_next(&success, &info, &query->err, &jak_vector_len, &strid_iter)) {
                        for (size_t i = 0; i < jak_vector_len; i++) {
                                if (info[i].id == id) {
                                        bool decode_result;
                                        char *result = fetch_jak_string_from_file(&decode_result,
                                                                              strid_iter.disk_file,
                                                                              info[i].offset,
                                                                              info[i].strlen,
                                                                              &query->err,
                                                                              query->archive);

                                        bool close_iter_result = jak_strid_iter_close(&strid_iter);

                                        if (!success || !close_iter_result) {
                                                if (result) {
                                                        free(result);
                                                }
                                                JAK_ERROR(&query->err,
                                                      !decode_result ? JAK_ERR_DECOMPRESSFAILED
                                                                     : JAK_ERR_ITERATORNOTCLOSED);
                                                return NULL;
                                        } else {
                                                return result;
                                        }
                                }
                        }
                }
                jak_strid_iter_close(&strid_iter);
                JAK_ERROR(&query->err, JAK_ERR_NOTFOUND);
                return NULL;
        } else {
                JAK_ERROR(&query->err, JAK_ERR_SCAN_FAILED);
                return NULL;
        }
}

static char *fetch_jak_string_by_id_via_index(jak_archive_query *query, struct jak_sid_to_offset *index,
                                          jak_archive_field_sid_t id)
{
        const struct jak_sid_to_offset_arg *args = jak_hashtable_get_value(&index->mapping, &id);
        if (args) {
                if (args->offset < index->disk_file_size) {
                        bool decode_result;
                        char *result = fetch_jak_string_from_file(&decode_result,
                                                              index->disk_file,
                                                              args->offset,
                                                              args->strlen,
                                                              &query->err,
                                                              query->archive);
                        if (decode_result) {
                                return result;
                        } else {
                                JAK_ERROR(&query->err, JAK_ERR_DECOMPRESSFAILED);
                                return NULL;
                        }

                } else {
                        JAK_ERROR(&query->err, JAK_ERR_INDEXCORRUPTED_OFFSET);
                        return NULL;
                }
        } else {
                JAK_ERROR(&query->err, JAK_ERR_NOTFOUND);
                return NULL;
        }
}

char *jak_query_fetch_jak_string_by_id(jak_archive_query *query, jak_archive_field_sid_t id)
{
        JAK_ASSERT(query);

        bool has_cache = false;
        jak_archive_hash_query_jak_string_id_cache(&has_cache, query->archive);
        if (has_cache) {
                return jak_string_id_cache_get(query->archive->jak_string_id_cache, id);
        } else {
                return jak_query_fetch_jak_string_by_id_nocache(query, id);
        }
}

char *jak_query_fetch_jak_string_by_id_nocache(jak_archive_query *query, jak_archive_field_sid_t id)
{
        bool has_index = false;
        jak_archive_has_query_index_jak_string_id_to_offset(&has_index, query->archive);
        if (has_index) {
                return fetch_jak_string_by_id_via_index(query, query->archive->query_index_jak_string_id_to_offset, id);
        } else {
                return fetch_jak_string_by_id_via_scan(query, id);
        }
}

char **jak_query_fetch_strings_by_offset(jak_archive_query *query, jak_offset_t *offs, jak_u32 *strlens,
                                         size_t num_offs)
{
        JAK_ASSERT(query);
        JAK_ASSERT(offs);
        JAK_ASSERT(strlens);

        FILE *file;

        if (num_offs == 0) {
                return NULL;
        }

        char **result = JAK_MALLOC(num_offs * sizeof(char *));
        if (!result) {
                JAK_ERROR(&query->err, JAK_ERR_MALLOCERR);
                return NULL;
        }
        for (size_t i = 0; i < num_offs; i++) {
                if ((result[i] = JAK_MALLOC((strlens[i] + 1) * sizeof(char))) == NULL) {
                        for (size_t k = 0; k < i; k++) {
                                free(result[k]);
                        }
                        free(result);
                        return NULL;
                }
                memset(result[i], 0, (strlens[i] + 1) * sizeof(char));
        }

        if (!result) {
                JAK_ERROR(jak_io_context_get_error(query->context), JAK_ERR_MALLOCERR);
                return NULL;
        } else {
                if (!(file = jak_io_context_lock_and_access(query->context))) {
                        jak_error_cpy(&query->err, jak_io_context_get_error(query->context));
                        goto cleanup_and_error;
                }

                for (size_t i = 0; i < num_offs; i++) {
                        fseek(file, offs[i], SEEK_SET);
                        if (!jak_pack_decode(&query->err,
                                         &query->archive->jak_string_table.compressor,
                                         result[i],
                                         strlens[i],
                                         file)) {
                                jak_io_context_unlock(query->context);
                                goto cleanup_and_error;
                        }
                }
                jak_io_context_unlock(query->context);
                return result;
        }

        cleanup_and_error:
        for (size_t i = 0; i < num_offs; i++) {
                free(result[i]);
        }
        free(result);
        return NULL;
}

jak_archive_field_sid_t *jak_query_find_ids(size_t *num_found, jak_archive_query *query,
                                            const jak_string_pred *pred, void *capture, jak_i64 limit)
{
        if (JAK_UNLIKELY(jak_string_pred_validate(&query->err, pred) == false)) {
                return NULL;
        }
        jak_i64 pred_limit;
        jak_string_pred_get_limit(&pred_limit, pred);
        pred_limit = pred_limit < 0 ? limit : JAK_MIN(pred_limit, limit);

        jak_strid_iter it;
        jak_strid_info *info = NULL;
        size_t info_len = 0;
        size_t step_len = 0;
        jak_offset_t *str_offs = NULL;
        jak_u32 *str_lens = NULL;
        size_t *idxs_matching = NULL;
        size_t num_matching = 0;
        void *tmp = NULL;
        size_t str_cap = 1024;
        jak_archive_field_sid_t *step_ids = NULL;
        jak_archive_field_sid_t *result_ids = NULL;
        size_t result_len = 0;
        size_t result_cap = pred_limit < 0 ? str_cap : (size_t) pred_limit;
        bool success = false;

        if (JAK_UNLIKELY(pred_limit == 0)) {
                *num_found = 0;
                return NULL;
        }

        if (JAK_UNLIKELY(!num_found || !query || !pred)) {
                JAK_ERROR(&query->err, JAK_ERR_NULLPTR);
                return NULL;
        }

        if (JAK_UNLIKELY((step_ids = JAK_MALLOC(str_cap * sizeof(jak_archive_field_sid_t))) == NULL)) {
                JAK_ERROR(&query->err, JAK_ERR_MALLOCERR);
                return NULL;
        }

        if (JAK_UNLIKELY((str_offs = JAK_MALLOC(str_cap * sizeof(jak_offset_t))) == NULL)) {
                JAK_ERROR(&query->err, JAK_ERR_MALLOCERR);
                goto cleanup_result_and_error;
                return NULL;
        }

        if (JAK_UNLIKELY((str_lens = JAK_MALLOC(str_cap * sizeof(jak_u32))) == NULL)) {
                JAK_ERROR(&query->err, JAK_ERR_MALLOCERR);
                free(str_offs);
                goto cleanup_result_and_error;
                return NULL;
        }

        if (JAK_UNLIKELY((idxs_matching = JAK_MALLOC(str_cap * sizeof(size_t))) == NULL)) {
                JAK_ERROR(&query->err, JAK_ERR_MALLOCERR);
                free(str_offs);
                free(str_lens);
                goto cleanup_result_and_error;
                return NULL;
        }

        if (JAK_UNLIKELY(jak_query_scan_strids(&it, query) == false)) {
                free(str_offs);
                free(str_lens);
                free(idxs_matching);
                goto cleanup_result_and_error;
        }

        if (JAK_UNLIKELY((result_ids = JAK_MALLOC(result_cap * sizeof(jak_archive_field_sid_t))) == NULL)) {
                JAK_ERROR(&query->err, JAK_ERR_MALLOCERR);
                free(str_offs);
                free(str_lens);
                free(idxs_matching);
                jak_strid_iter_close(&it);
                goto cleanup_result_and_error;
                return NULL;
        }

        while (jak_strid_iter_next(&success, &info, &query->err, &info_len, &it)) {
                if (JAK_UNLIKELY(info_len > str_cap)) {
                        str_cap = (info_len + 1) * 1.7f;
                        if (JAK_UNLIKELY((tmp = realloc(str_offs, str_cap * sizeof(jak_offset_t))) == NULL)) {
                                goto realloc_error;
                        } else {
                                str_offs = tmp;
                        }
                        if (JAK_UNLIKELY((tmp = realloc(str_lens, str_cap * sizeof(jak_u32))) == NULL)) {
                                goto realloc_error;
                        } else {
                                str_lens = tmp;
                        }
                        if (JAK_UNLIKELY((tmp = realloc(idxs_matching, str_cap * sizeof(size_t))) == NULL)) {
                                goto realloc_error;
                        } else {
                                idxs_matching = tmp;
                        }
                }
                JAK_ASSERT(info_len <= str_cap);
                for (step_len = 0; step_len < info_len; step_len++) {
                        JAK_ASSERT(step_len < str_cap);
                        str_offs[step_len] = info[step_len].offset;
                        str_lens[step_len] = info[step_len].strlen;
                }

                char **strings = jak_query_fetch_strings_by_offset(query,
                                                                   str_offs,
                                                                   str_lens,
                                                                   step_len); // TODO: buffer + cleanup buffer

                if (JAK_UNLIKELY(
                        jak_string_pred_eval(pred, idxs_matching, &num_matching, strings, step_len, capture) ==
                        false)) {
                        JAK_ERROR(&query->err, JAK_ERR_PREDEVAL_FAILED);
                        jak_strid_iter_close(&it);
                        goto cleanup_intermediate;
                }

                for (size_t i = 0; i < step_len; i++) {
                        free(strings[i]);
                }
                free(strings);

                for (size_t i = 0; i < num_matching; i++) {
                        JAK_ASSERT (idxs_matching[i] < info_len);
                        result_ids[result_len++] = info[idxs_matching[i]].id;
                        if (pred_limit > 0 && result_len == (size_t) pred_limit) {
                                goto stop_search_and_return;
                        }
                        if (JAK_UNLIKELY(result_len > result_cap)) {
                                result_cap = (result_len + 1) * 1.7f;
                                if (JAK_UNLIKELY(
                                        (tmp = realloc(result_ids, result_cap * sizeof(jak_archive_field_sid_t))) ==
                                        NULL)) {
                                        jak_strid_iter_close(&it);
                                        goto cleanup_intermediate;
                                } else {
                                        result_ids = tmp;
                                }
                        }
                }
        }

        stop_search_and_return:
        if (JAK_UNLIKELY(success == false)) {
                jak_strid_iter_close(&it);
                goto cleanup_intermediate;
        }

        *num_found = result_len;
        return result_ids;

        realloc_error:
        JAK_ERROR(&query->err, JAK_ERR_REALLOCERR);

        cleanup_intermediate:
        free(str_offs);
        free(str_lens);
        free(idxs_matching);
        free(result_ids);

        cleanup_result_and_error:
        free(step_ids);
        return NULL;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_archive_strid_it.h>

bool jak_strid_iter_open(jak_strid_iter *it, jak_error *err, jak_archive *archive)
{
        JAK_ERROR_IF_NULL(it)
        JAK_ERROR_IF_NULL(archive)

        memset(&it->vector, 0, sizeof(it->vector));
        it->disk_file = fopen(archive->disk_file_path, "r");
        if (!it->disk_file) {
                JAK_OPTIONAL(err, JAK_ERROR(err, JAK_ERR_FOPEN_FAILED))
                it->is_open = false;
                return false;
        }
        fseek(it->disk_file, archive->jak_string_table.first_entry_off, SEEK_SET);
        it->is_open = true;
        it->disk_offset = archive->jak_string_table.first_entry_off;
        return true;
}

bool jak_strid_iter_next(bool *success, jak_strid_info **info, jak_error *err, size_t *info_length,
                         jak_strid_iter *it)
{
        JAK_ERROR_IF_NULL(info)
        JAK_ERROR_IF_NULL(info_length)
        JAK_ERROR_IF_NULL(it)

        if (it->disk_offset != 0 && it->is_open) {
                jak_string_entry_header header;
                size_t jak_vector_pos = 0;
                do {
                        fseek(it->disk_file, it->disk_offset, SEEK_SET);
                        int num_read = fread(&header, sizeof(jak_string_entry_header), 1, it->disk_file);
                        if (header.marker != '-') {
                                JAK_ERROR_PRINT(JAK_ERR_INTERNALERR);
                                return false;
                        }
                        if (num_read != 1) {
                                JAK_OPTIONAL(err, JAK_ERROR(err, JAK_ERR_FREAD_FAILED))
                                *success = false;
                                return false;
                        } else {
                                it->vector[jak_vector_pos].id = header.jak_string_id;
                                it->vector[jak_vector_pos].offset = ftell(it->disk_file);
                                it->vector[jak_vector_pos].strlen = header.jak_string_len;
                                it->disk_offset = header.next_entry_off;
                                jak_vector_pos++;
                        }
                } while (header.next_entry_off != 0 && jak_vector_pos < JAK_ARRAY_LENGTH(it->vector));

                *info_length = jak_vector_pos;
                *success = true;
                *info = &it->vector[0];
                return true;
        } else {
                return false;
        }
}

bool jak_strid_iter_close(jak_strid_iter *it)
{
        JAK_ERROR_IF_NULL(it)
        if (it->is_open) {
                fclose(it->disk_file);
                it->is_open = false;
        }
        return true;
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_archive_visitor.h>
#include <jak_hash_table.h>
#include <jak_hash_set.h>
#include <jak_archive_visitor.h>
#include <jak_archive_query.h>

static void iterate_props(jak_archive *archive, jak_prop_iter *prop_iter,
                          jak_vector ofType(jak_path_entry) *path_stack,
                          jak_archive_visitor *visitor,
                          int mask, void *capture,
                          bool is_root_object, jak_archive_field_sid_t parent_key, jak_u32 parent_key_array_idx);

static void iterate_objects(jak_archive *archive, const jak_archive_field_sid_t *keys, jak_u32 num_pairs,
                            jak_archive_value_vector *value_iter,
                            jak_vector ofType(jak_path_entry) *path_stack,
                            jak_archive_visitor *visitor, int mask, void *capture, bool is_root_object)
{
        JAK_UNUSED(num_pairs);

        jak_u32 jak_vector_length;
        jak_archive_object object;
        jak_uid_t parent_object_id;
        jak_uid_t object_id;
        jak_prop_iter prop_iter;
        jak_error err;

        jak_archive_value_jak_vector_get_object_id(&parent_object_id, value_iter);
        jak_archive_value_jak_vector_get_length(&jak_vector_length, value_iter);
        JAK_ASSERT(num_pairs == jak_vector_length);

        for (jak_u32 i = 0; i < jak_vector_length; i++) {
                jak_archive_field_sid_t parent_key = keys[i];
                jak_u32 parent_key_array_idx = i;

//        jak_path_entry  e = { .key = parent_key, .idx = 0 };
//        jak_vector_push(path_stack, &e, 1);

                //  fprintf(stderr, "XXXX object: ");
                //  jak_archive_visitor_print_path(stderr, archive, path_stack);

                jak_archive_value_jak_vector_get_object_at(&object, i, value_iter);
                jak_archive_object_get_object_id(&object_id, &object);

                jak_archive_prop_iter_from_object(&prop_iter, mask, &err, &object);

                if (!is_root_object) {
                        jak_visit_policy_e visit = JAK_VISIT_INCLUDE;
                        if (visitor->before_object_visit) {
                                visit = visitor->before_object_visit(archive,
                                                                     path_stack,
                                                                     parent_object_id,
                                                                     object_id,
                                                                     i,
                                                                     jak_vector_length,
                                                                     keys[i],
                                                                     capture);
                        }
                        if (visit == JAK_VISIT_INCLUDE) {
                                iterate_props(archive,
                                              &prop_iter,
                                              path_stack,
                                              visitor,
                                              mask,
                                              capture,
                                              false,
                                              parent_key,
                                              parent_key_array_idx);
                                JAK_OPTIONAL_CALL(visitor,
                                                  after_object_visit,
                                                  archive,
                                                  path_stack,
                                                  object_id,
                                                  i,
                                                  jak_vector_length,
                                                  capture);
                        }
                } else {
                        JAK_OPTIONAL_CALL(visitor, visit_root_object, archive, object_id, capture);
                        iterate_props(archive,
                                      &prop_iter,
                                      path_stack,
                                      visitor,
                                      mask,
                                      capture,
                                      false,
                                      parent_key,
                                      parent_key_array_idx);
                }

                //  jak_vector_pop(path_stack);
        }
}

#define SET_TYPE_SWITCH_CASE(name, built_in_type)                                                                      \
{                                                                                                                      \
    if (is_array) {                                                                                                    \
        jak_visit_policy_e visit = JAK_VISIT_INCLUDE;                                                 \
        if (visitor->visit_enter_##name##_array_pairs) {                                                               \
            visit = visitor->visit_enter_##name##_array_pairs(archive, path_stack, this_object_oid, keys, num_pairs, capture);     \
        }                                                                                                              \
        if (visit == JAK_VISIT_INCLUDE) {                                                                  \
            for (jak_u32 prop_idx = 0; prop_idx < num_pairs; prop_idx++)                                              \
            {                                                                                                          \
                jak_u32 array_length;                                                                                 \
                const built_in_type *values = jak_archive_value_jak_vector_get_##name##_arrays_at(&array_length,        \
                                                                                             prop_idx,                 \
                                                                                             &value_iter);             \
                JAK_OPTIONAL_CALL(visitor, visit_enter_##name##_array_pair, archive, path_stack, this_object_oid, keys[prop_idx],      \
                              prop_idx, array_length, capture);                                                        \
                JAK_OPTIONAL_CALL(visitor, visit_##name##_array_pair, archive, path_stack, this_object_oid, keys[prop_idx],            \
                              prop_idx, num_pairs, values, array_length, capture)                                      \
                JAK_OPTIONAL_CALL(visitor, visit_leave_##name##_array_pair, archive, path_stack, this_object_oid, prop_idx, num_pairs, \
                                                                        capture);                                      \
            }                                                                                                          \
            JAK_OPTIONAL_CALL(visitor, visit_leave_##name##_array_pairs, archive, path_stack, this_object_oid, capture);               \
        }                                                                                                              \
    } else                                                                                                             \
    {                                                                                                                  \
        if (visitor->visit_##name##_pairs) {                                                                           \
            const built_in_type *values = jak_archive_value_jak_vector_get_##name##s(NULL, &value_iter);                \
            visitor->visit_##name##_pairs(archive, path_stack, this_object_oid, keys, values, num_pairs, capture);                 \
        }                                                                                                              \
    }                                                                                                                  \
}

#define SET_NESTED_ARRAY_SWITCH_CASE(name, built_in_type)                                                              \
{                                                                                                                      \
    const built_in_type *values = jak_archive_column_entry_get_##name(&entry_length, &entry_iter);                  \
    JAK_OPTIONAL_CALL(visitor, visit_object_array_object_property_##name,                                                  \
                  archive, path_stack, this_object_oid, group_key, current_nested_object_id,                           \
                  current_column_name, values, entry_length, capture);                                                 \
}

static void iterate_props(jak_archive *archive, jak_prop_iter *prop_iter,
                          jak_vector ofType(jak_path_entry) *path_stack,
                          jak_archive_visitor *visitor,
                          int mask, void *capture,
                          bool is_root_object, jak_archive_field_sid_t parent_key, jak_u32 parent_key_array_idx)
{
        jak_uid_t this_object_oid;
        jak_archive_value_vector value_iter;
        enum jak_archive_field_type type;
        bool is_array;
        const jak_archive_field_sid_t *keys;
        jak_u32 num_pairs;
        jak_prop_iter_mode_e iter_type;
        jak_independent_iter_state collection_iter;
        bool first_type_group = true;

        JAK_UNUSED(parent_key);
        JAK_UNUSED(parent_key_array_idx);

        jak_path_entry e = {.key = parent_key, .idx = parent_key_array_idx};
        jak_vector_push(path_stack, &e, 1);

        jak_archive_value_jak_vector_get_object_id(&this_object_oid, &value_iter);

        while (jak_archive_prop_iter_next(&iter_type, &value_iter, &collection_iter, prop_iter)) {

                if (iter_type == JAK_PROP_ITER_MODE_OBJECT) {

                        keys = jak_archive_value_jak_vector_get_keys(&num_pairs, &value_iter);
                        jak_archive_value_jak_vector_is_array_type(&is_array, &value_iter);
                        jak_archive_value_jak_vector_get_basic_type(&type, &value_iter);
                        jak_archive_value_jak_vector_get_object_id(&this_object_oid, &value_iter);

                        for (jak_u32 i = 0; i < num_pairs; i++) {
                                JAK_OPTIONAL_CALL(visitor,
                                                  visit_object_property,
                                                  archive,
                                                  path_stack,
                                                  this_object_oid,
                                                  keys[i],
                                                  type,
                                                  is_array,
                                                  capture);

                                jak_path_entry e = {.key = keys[i], .idx = 666};
                                jak_vector_push(path_stack, &e, 1);
                                //jak_archive_visitor_print_path(stderr, archive, path_stack);
                                JAK_OPTIONAL_CALL(visitor,
                                                  visit_object_array_prop,
                                                  archive,
                                                  path_stack,
                                                  this_object_oid,
                                                  keys[i],
                                                  type,
                                                  capture);
                                jak_vector_pop(path_stack);
                        }

                        if (JAK_UNLIKELY(first_type_group)) {
                                JAK_OPTIONAL_CALL(visitor,
                                                  first_prop_type_group,
                                                  archive,
                                                  path_stack,
                                                  this_object_oid,
                                                  keys,
                                                  type,
                                                  is_array,
                                                  num_pairs,
                                                  capture);
                        } else {
                                JAK_OPTIONAL_CALL(visitor,
                                                  next_prop_type_group,
                                                  archive,
                                                  path_stack,
                                                  this_object_oid,
                                                  keys,
                                                  type,
                                                  is_array,
                                                  num_pairs,
                                                  capture);
                        }

                        switch (type) {
                                case JAK_FIELD_OBJECT:
                                        JAK_ASSERT (!is_array);
                                        iterate_objects(archive,
                                                        keys,
                                                        num_pairs,
                                                        &value_iter,
                                                        path_stack,
                                                        visitor,
                                                        mask,
                                                        capture,
                                                        is_root_object);
                                        //for (size_t i = 0; i < num_pairs; i++) {
                                        //    iterate_objects(archive, &keys[i], 1, &value_iter, path_stack, visitor, mask, capture, is_root_object, keys[i], i);
                                        //}
                                        break;
                                case JAK_FIELD_NULL:
                                        if (is_array) {
                                                jak_visit_policy_e visit = JAK_VISIT_INCLUDE;
                                                if (visitor->visit_enter_null_array_pairs) {
                                                        visit = visitor->visit_enter_null_array_pairs(archive,
                                                                                                      path_stack,
                                                                                                      this_object_oid,
                                                                                                      keys,
                                                                                                      num_pairs,
                                                                                                      capture);
                                                }
                                                if (visit == JAK_VISIT_INCLUDE) {
                                                        const jak_archive_field_u32_t *num_values =
                                                                jak_archive_value_jak_vector_get_null_arrays(NULL,
                                                                                                         &value_iter);
                                                        for (jak_u32 prop_idx = 0; prop_idx < num_pairs; prop_idx++) {
                                                                JAK_OPTIONAL_CALL(visitor,
                                                                                  visit_enter_null_array_pair,
                                                                                  archive,
                                                                                  path_stack,
                                                                                  this_object_oid,
                                                                                  keys[prop_idx],
                                                                                  prop_idx,
                                                                                  num_values[prop_idx],
                                                                                  capture);
                                                                JAK_OPTIONAL_CALL(visitor,
                                                                                  visit_null_array_pair,
                                                                                  archive,
                                                                                  path_stack,
                                                                                  this_object_oid,
                                                                                  keys[prop_idx],
                                                                                  prop_idx,
                                                                                  num_pairs,
                                                                                  num_values[prop_idx],
                                                                                  capture)
                                                                JAK_OPTIONAL_CALL(visitor,
                                                                                  visit_leave_null_array_pair,
                                                                                  archive,
                                                                                  path_stack,
                                                                                  this_object_oid,
                                                                                  prop_idx,
                                                                                  num_pairs,
                                                                                  capture);
                                                        }
                                                        JAK_OPTIONAL_CALL(visitor,
                                                                          visit_leave_int8_array_pairs,
                                                                          archive,
                                                                          path_stack,
                                                                          this_object_oid,
                                                                          capture);
                                                }
                                        } else {
                                                if (visitor->visit_null_pairs) {
                                                        visitor->visit_null_pairs(archive,
                                                                                  path_stack,
                                                                                  this_object_oid,
                                                                                  keys,
                                                                                  num_pairs,
                                                                                  capture);
                                                }
                                        }
                                        break;
                                case JAK_FIELD_INT8: SET_TYPE_SWITCH_CASE(int8, jak_archive_field_i8_t)
                                        break;
                                case JAK_FIELD_INT16: SET_TYPE_SWITCH_CASE(int16, jak_archive_field_i16_t)
                                        break;
                                case JAK_FIELD_INT32: SET_TYPE_SWITCH_CASE(int32, jak_archive_field_i32_t)
                                        break;
                                case JAK_FIELD_INT64: SET_TYPE_SWITCH_CASE(int64, jak_archive_field_i64_t)
                                        break;
                                case JAK_FIELD_UINT8: SET_TYPE_SWITCH_CASE(uint8, jak_archive_field_u8_t)
                                        break;
                                case JAK_FIELD_UINT16: SET_TYPE_SWITCH_CASE(uint16, jak_archive_field_u16_t)
                                        break;
                                case JAK_FIELD_UINT32: SET_TYPE_SWITCH_CASE(uint32, jak_archive_field_u32_t)
                                        break;
                                case JAK_FIELD_UINT64: SET_TYPE_SWITCH_CASE(uint64, jak_archive_field_u64_t)
                                        break;
                                case JAK_FIELD_FLOAT: SET_TYPE_SWITCH_CASE(number, jak_archive_field_number_t)
                                        break;
                                case JAK_FIELD_STRING: SET_TYPE_SWITCH_CASE(string, jak_archive_field_sid_t)
                                        break;
                                case JAK_FIELD_BOOLEAN: SET_TYPE_SWITCH_CASE(boolean, jak_archive_field_boolean_t)
                                        break;
                                default:
                                        break;
                        }

                        first_type_group = false;
                } else {
                        jak_independent_iter_state group_iter;
                        jak_u32 num_column_groups;
                        keys = jak_archive_collection_iter_get_keys(&num_column_groups, &collection_iter);

                        bool *skip_groups_by_key = JAK_MALLOC(num_column_groups * sizeof(bool));
                        JAK_ZERO_MEMORY(skip_groups_by_key, num_column_groups * sizeof(bool));

                        if (visitor->before_visit_object_array) {
                                for (jak_u32 i = 0; i < num_column_groups; i++) {

                                        //     jak_path_entry  e = { .key = parent_key, .idx = i };
                                        //jak_vector_push(path_stack, &e, 1);


                                        jak_visit_policy_e policy = visitor->before_visit_object_array(archive,
                                                                                                          path_stack,
                                                                                                          this_object_oid,
                                                                                                          keys[i],
                                                                                                          capture);

                                        //     jak_vector_pop(path_stack);

                                        skip_groups_by_key[i] = policy == JAK_VISIT_EXCLUDE;
                                }
                        }

                        jak_u32 current_group_idx = 0;

                        while (jak_archive_collection_next_column_group(&group_iter, &collection_iter)) {
                                if (!skip_groups_by_key[current_group_idx]) {

                                        jak_u32 num_column_group_objs;
                                        jak_independent_iter_state column_iter;
                                        jak_archive_field_sid_t group_key = keys[current_group_idx];
                                        const jak_uid_t *column_group_object_ids =
                                                jak_archive_column_group_get_object_ids(&num_column_group_objs,
                                                                                        &group_iter);
                                        bool *skip_objects = JAK_MALLOC(num_column_group_objs * sizeof(bool));
                                        JAK_ZERO_MEMORY(skip_objects, num_column_group_objs * sizeof(bool));

                                        if (visitor->before_visit_object_array_objects) {
                                                visitor->before_visit_object_array_objects(skip_objects,
                                                                                           archive,
                                                                                           path_stack,
                                                                                           this_object_oid,
                                                                                           group_key,
                                                                                           column_group_object_ids,
                                                                                           num_column_group_objs,
                                                                                           capture);
                                        }

                                        jak_u32 current_column_group_obj_idx = 0;

                                        while (jak_archive_column_group_next_column(&column_iter, &group_iter)) {

                                                if (!skip_objects[current_column_group_obj_idx]) {
                                                        jak_archive_field_sid_t current_column_name;
                                                        enum jak_archive_field_type current_column_entry_type;

                                                        jak_archive_column_get_name(&current_column_name,
                                                                                    &current_column_entry_type,
                                                                                    &column_iter);

                                                        jak_path_entry e = {.key = current_column_name, .idx = 0};
                                                        jak_vector_push(path_stack, &e, 1);

                                                        /**
                                                            0/page_end/0/
                                                            /0/doi/0/
                                                            /0/page_start/0/
                                                            /0/venue/0/
                                                            /0/doc_type/0/
                                                            /0/n_citation/0/
                                                            /0/issue/0/
                                                            /0/volume/0/
                                                            /0/n_citation/0/
                                                         */

                                                        JAK_OPTIONAL_CALL(visitor,
                                                                          visit_object_array_prop,
                                                                          archive,
                                                                          path_stack,
                                                                          this_object_oid,
                                                                          current_column_name,
                                                                          current_column_entry_type,
                                                                          capture);

                                                        bool skip_column = false;
                                                        if (visitor->before_visit_object_array_object_property) {
                                                                jak_visit_policy_e policy =
                                                                        visitor->before_visit_object_array_object_property(
                                                                                archive,
                                                                                path_stack,
                                                                                this_object_oid,
                                                                                group_key,
                                                                                current_column_name,
                                                                                current_column_entry_type,
                                                                                capture);
                                                                skip_column = policy == JAK_VISIT_EXCLUDE;
                                                        }

                                                        if (!skip_column) {
                                                                jak_u32 num_positions;
                                                                const jak_u32 *entry_positions =
                                                                        jak_archive_column_get_entry_positions(
                                                                                &num_positions,
                                                                                &column_iter);
                                                                jak_independent_iter_state entry_iter;

                                                                jak_uid_t *entry_object_containments =
                                                                        JAK_MALLOC(num_positions *
                                                                                   sizeof(jak_uid_t));
                                                                for (jak_u32 m = 0; m < num_positions; m++) {
                                                                        entry_object_containments[m] =
                                                                                column_group_object_ids[entry_positions[m]];
                                                                }

                                                                if (visitor->get_column_entry_count) {
                                                                        bool shall_continue =
                                                                                visitor->get_column_entry_count(archive,
                                                                                                                path_stack,
                                                                                                                current_column_name,
                                                                                                                current_column_entry_type,
                                                                                                                num_positions,
                                                                                                                capture);
                                                                        if (!shall_continue) {
                                                                                break;
                                                                        }
                                                                }

                                                                jak_u32 current_entry_idx = 0;
                                                                while (jak_archive_column_next_entry(&entry_iter,
                                                                                                     &column_iter)) {

                                                                        jak_uid_t current_nested_object_id =
                                                                                entry_object_containments[current_entry_idx];
                                                                        jak_u32 entry_length;

                                                                        switch (current_column_entry_type) {
                                                                                case JAK_FIELD_INT8: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                int8s,
                                                                                                jak_archive_field_i8_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_INT16: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                int16s,
                                                                                                jak_archive_field_i16_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_INT32: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                int32s,
                                                                                                jak_archive_field_i32_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_INT64: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                int64s,
                                                                                                jak_archive_field_i64_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_UINT8: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                uint8s,
                                                                                                jak_archive_field_u8_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_UINT16: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                uint16s,
                                                                                                jak_archive_field_u16_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_UINT32: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                uint32s,
                                                                                                jak_archive_field_u32_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_UINT64: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                uint64s,
                                                                                                jak_archive_field_u64_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_FLOAT: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                numbers,
                                                                                                jak_archive_field_number_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_STRING: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                strings,
                                                                                                jak_archive_field_sid_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_BOOLEAN: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                booleans,
                                                                                                jak_archive_field_boolean_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_NULL: {
                                                                                        SET_NESTED_ARRAY_SWITCH_CASE(
                                                                                                nulls,
                                                                                                jak_archive_field_u32_t)
                                                                                }
                                                                                        break;
                                                                                case JAK_FIELD_OBJECT: {
                                                                                        jak_column_object_iter iter;
                                                                                        const jak_archive_object
                                                                                                *archive_object;
                                                                                        jak_archive_column_entry_get_objects(
                                                                                                &iter,
                                                                                                &entry_iter);

                                                                                        while ((archive_object =
                                                                                                        jak_archive_column_entry_object_iter_next_object(
                                                                                                                &iter))
                                                                                               != NULL) {
                                                                                                jak_uid_t id;
                                                                                                jak_archive_object_get_object_id(
                                                                                                        &id,
                                                                                                        archive_object);

                                                                                                bool skip_object = false;
                                                                                                if (visitor
                                                                                                        ->before_object_array_object_property_object) {
                                                                                                        jak_visit_policy_e
                                                                                                                policy =
                                                                                                                visitor->before_object_array_object_property_object(
                                                                                                                        archive,
                                                                                                                        path_stack,
                                                                                                                        this_object_oid,
                                                                                                                        group_key,
                                                                                                                        current_nested_object_id,
                                                                                                                        current_column_name,
                                                                                                                        id,
                                                                                                                        capture);
                                                                                                        skip_object =
                                                                                                                policy
                                                                                                                ==
                                                                                                                JAK_VISIT_EXCLUDE;
                                                                                                }

                                                                                                if (!skip_object) {


                                                                                                        //keys[i]

                                                                                                        //jak_path_entry  e = { .key = current_column_name, .idx = 0 };
                                                                                                        //jak_vector_push(path_stack, &e, 1);

                                                                                                        jak_vector_pop(path_stack);

                                                                                                        jak_error err;
                                                                                                        jak_prop_iter
                                                                                                                nested_obj_prop_iter;
                                                                                                        jak_archive_prop_iter_from_object(
                                                                                                                &nested_obj_prop_iter,
                                                                                                                mask,
                                                                                                                &err,
                                                                                                                archive_object);
                                                                                                        iterate_props(
                                                                                                                archive,
                                                                                                                &nested_obj_prop_iter,
                                                                                                                path_stack,
                                                                                                                visitor,
                                                                                                                mask,
                                                                                                                capture,
                                                                                                                false,
                                                                                                                current_column_name,
                                                                                                                current_group_idx);

                                                                                                        jak_path_entry e =
                                                                                                                {.key = current_column_name, .idx = 0};
                                                                                                        jak_vector_push(
                                                                                                                path_stack,
                                                                                                                &e,
                                                                                                                1);

                                                                                                }

                                                                                        }
                                                                                }
                                                                                        break;
                                                                                default:
                                                                                        break;
                                                                        }

                                                                        current_entry_idx++;
                                                                }

                                                                free(entry_object_containments);
                                                        }
                                                        jak_vector_pop(path_stack);
                                                }
                                                current_column_group_obj_idx++;

                                        }

                                        free(skip_objects);
                                }
                                current_group_idx++;
                        }
                        free(skip_groups_by_key);
                }
        }
        jak_vector_pop(path_stack);
}

bool jak_archive_visit_archive(jak_archive *archive, const jak_archive_visitor_desc *desc,
                               jak_archive_visitor *visitor, void *capture)
{
        JAK_ERROR_IF_NULL(archive)
        JAK_ERROR_IF_NULL(visitor)

        jak_prop_iter prop_iter;
        jak_vector ofType(path_entry) path_stack;

        int mask = desc ? desc->visit_mask : JAK_ARCHIVE_ITER_MASK_ANY;

        if (jak_archive_prop_iter_from_archive(&prop_iter, &archive->err, mask, archive)) {
                jak_vector_create(&path_stack, NULL, sizeof(jak_path_entry), 100);
                JAK_OPTIONAL_CALL(visitor, before_visit_starts, archive, capture);
                iterate_props(archive, &prop_iter, &path_stack, visitor, mask, capture, true, 0, 0);
                JAK_OPTIONAL_CALL(visitor, after_visit_ends, archive, capture);
                jak_vector_drop(&path_stack);
                return true;
        } else {
                return false;
        }
}

#include <inttypes.h>

void jak_archive_visitor_path_to_string(char path_buffer[2048], jak_archive *archive,
                                        const jak_vector ofType(jak_path_entry) *path_stack)
{

        jak_archive_query *query = jak_archive_query_default(archive);

        for (jak_u32 i = 0; i < path_stack->num_elems; i++) {
                const jak_path_entry *entry = JAK_VECTOR_GET(path_stack, i, jak_path_entry);
                if (entry->key != 0) {
                        char *key = jak_query_fetch_jak_string_by_id(query, entry->key);
                        size_t path_len = strlen(path_buffer);
                        sprintf(path_buffer + path_len, "%s%s", key, i + 1 < path_stack->num_elems ? ", " : "");
                        free(key);
                } else {
                        sprintf(path_buffer, "/");
                }
        }
}

bool jak_archive_visitor_print_path(FILE *file, jak_archive *archive,
                                    const jak_vector ofType(jak_path_entry) *path_stack)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(path_stack)
        JAK_ERROR_IF_NULL(archive)

        jak_archive_query *query = jak_archive_query_default(archive);

        for (jak_u32 i = 0; i < path_stack->num_elems; i++) {
                const jak_path_entry *entry = JAK_VECTOR_GET(path_stack, i, jak_path_entry);
                if (entry->key != 0) {
                        char *key = jak_query_fetch_jak_string_by_id(query, entry->key);
                        fprintf(file, "%s/", key);
                        free(key);
                } else {
                        fprintf(file, "/");
                }
        }
        fprintf(file, "\n");

        char buffer[2048];
        memset(buffer, 0, sizeof(buffer));
        jak_archive_visitor_path_to_string(buffer, archive, path_stack);
        fprintf(file, "%s\n", buffer);

        return true;
}

bool jak_archive_visitor_path_compare(const jak_vector ofType(jak_path_entry) *path,
                                      jak_archive_field_sid_t *group_name, const char *path_str,
                                      jak_archive *archive)
{
        char path_buffer[2048];
        memset(path_buffer, 0, sizeof(path_buffer));
        sprintf(path_buffer, "/");

        jak_archive_query *query = jak_archive_query_default(archive);

        for (jak_u32 i = 1; i < path->num_elems; i++) {
                const jak_path_entry *entry = JAK_VECTOR_GET(path, i, jak_path_entry);
                if (entry->key != 0) {
                        char *key = jak_query_fetch_jak_string_by_id(query, entry->key);
                        size_t path_len = strlen(path_buffer);
                        sprintf(path_buffer + path_len, "%s/", key);
                        free(key);
                }
        }

        if (group_name) {
                char *key = jak_query_fetch_jak_string_by_id(query, *group_name);
                size_t path_len = strlen(path_buffer);
                sprintf(path_buffer + path_len, "%s/", key);
                free(key);
        }

        fprintf(stderr, "'%s' <-> needle '%s'\n", path_buffer, path_str);

        return strcmp(path_buffer, path_str) == 0;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_async.h>

void *jak_async_for_proxy_function(void *args)
{
        JAK_cast(jak_async_func_proxy *, proxy_arg, args);
        proxy_arg->function(proxy_arg->start, proxy_arg->width, proxy_arg->len, proxy_arg->args, proxy_arg->tid);
        return NULL;
}

#define JAK_PARALLEL_ERROR(msg, retval)                                                                             \
{                                                                                                                      \
    perror(msg);                                                                                                       \
    return retval;                                                                                                     \
}

#define JAK_ASYNC_MATCH(forSingle, forMulti)                                                                            \
{                                                                                                                      \
    if (JAK_LIKELY(hint == JAK_THREADING_HINT_MULTI)) {                                             \
        return (forMulti);                                                                                             \
    } else if (hint == JAK_THREADING_HINT_SINGLE) {                                                           \
        return (forSingle);                                                                                            \
    } else JAK_PARALLEL_ERROR(JAK_ASYNC_MSG_UNKNOWN_HINT, false);                                                    \
}

bool jak_for(const void *base, size_t width, size_t len, jak_for_body_func_t f, void *args,
             jak_threading_hint hint, uint_fast16_t num_threads);

bool jak_map(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width,
             jak_map_body_func_t f, void *args, jak_threading_hint hint, uint_fast16_t num_threads);

bool jak_gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len,
                jak_threading_hint hint, uint_fast16_t num_threads);

bool jak_gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num,
                    jak_threading_hint hint, uint_fast16_t num_threads);

bool jak_scatter(void *dst, const void *src, size_t width, const size_t *idx, size_t num,
                 jak_threading_hint hint, uint_fast16_t num_threads);

bool jak_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                 const size_t *src_idx, size_t idxLen, jak_threading_hint hint);

bool jak_filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len,
                      jak_pred_func_t pred, void *args, jak_threading_hint hint,
                      uint_fast16_t num_threads);

bool jak_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len,
                     jak_pred_func_t pred, void *args, jak_threading_hint hint, size_t num_threads);

bool jak_sync_for(const void *base, size_t width, size_t len, jak_for_body_func_t f,
                  void *args);

bool jak_async_for(const void *base, size_t width, size_t len, jak_for_body_func_t f,
                   void *args, uint_fast16_t num_threads);

bool jak_async_map_exec(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width,
                        jak_map_body_func_t f, void *args, jak_threading_hint hint, uint_fast16_t num_threads);

bool jak_sync_gather(void *dst, const void *src, size_t width, const size_t *idx,
                     size_t dst_src_len);

bool jak_async_gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len,
                      uint_fast16_t num_threads);

bool jak_sync_gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx,
                         size_t num);

bool jak_int_async_gather_adr_func(void *dst, const void *src, size_t src_width, const size_t *idx,
                                   size_t num, uint_fast16_t num_threads);

bool jak_sync_scatter(void *dst, const void *src, size_t width, const size_t *idx,
                      size_t num);

bool jak_sync_scatter_func(void *dst, const void *src, size_t width, const size_t *idx, size_t num,
                           uint_fast16_t num_threads);

bool jak_sync_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                      const size_t *src_idx, size_t idx_len);

bool jak_async_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                       const size_t *src_idx, size_t idx_len);

bool jak_async_filter_early(void *result, size_t *result_size, const void *src, size_t width,
                            size_t len, jak_pred_func_t pred, void *args);

bool jak_int_async_filter_early(void *result, size_t *result_size, const void *src, size_t width,
                                size_t len, jak_pred_func_t pred, void *args, uint_fast16_t num_threads);

bool jak_int_sync_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width,
                              size_t len, jak_pred_func_t pred, void *args);

bool jak_async_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len,
                           jak_pred_func_t pred, void *args, size_t num_threads);

bool jak_for(const void *base, size_t width, size_t len, jak_for_body_func_t f, void *args,
             jak_threading_hint hint, uint_fast16_t num_threads)
{
        JAK_ASYNC_MATCH(jak_sync_for(base, width, len, f, args),
                        jak_async_for(base, width, len, f, args, num_threads))
}

bool jak_map(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width,
             jak_map_body_func_t f, void *args, jak_threading_hint hint, uint_fast16_t num_threads)
{
        return jak_async_map_exec(dst, src, src_width, len, dst_width, f, args, hint, num_threads);
}

bool jak_gather(void *dst, const void *src, size_t width, const size_t *idx, size_t dst_src_len,
                jak_threading_hint hint, uint_fast16_t num_threads)
{
        JAK_ASYNC_MATCH(jak_sync_gather(dst, src, width, idx, dst_src_len),
                        jak_async_gather(dst, src, width, idx, dst_src_len, num_threads))
}

bool jak_gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx, size_t num,
                    jak_threading_hint hint, uint_fast16_t num_threads)
{
        JAK_ASYNC_MATCH(jak_sync_gather_adr(dst, src, src_width, idx, num),
                        jak_int_async_gather_adr_func(dst, src, src_width, idx, num, num_threads))
}

bool jak_scatter(void *dst, const void *src, size_t width, const size_t *idx, size_t num,
                 jak_threading_hint hint, uint_fast16_t num_threads)
{
        JAK_ASYNC_MATCH(jak_sync_scatter(dst, src, width, idx, num),
                        jak_sync_scatter_func(dst, src, width, idx, num, num_threads))
}

bool jak_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                 const size_t *src_idx, size_t idx_len, jak_threading_hint hint)
{
        JAK_ASYNC_MATCH(jak_sync_shuffle(dst, src, width, dst_idx, src_idx, idx_len),
                        jak_async_shuffle(dst, src, width, dst_idx, src_idx, idx_len))
}

bool jak_filter_early(void *result, size_t *result_size, const void *src, size_t width, size_t len,
                      jak_pred_func_t pred, void *args, jak_threading_hint hint,
                      uint_fast16_t num_threads)
{
        JAK_ASYNC_MATCH(jak_async_filter_early(result, result_size, src, width, len, pred, args),
                        jak_int_async_filter_early(result, result_size, src, width, len, pred, args, num_threads))
}

bool jak_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len,
                     jak_pred_func_t pred, void *args, jak_threading_hint hint, size_t num_threads)
{
        JAK_ASYNC_MATCH(jak_int_sync_filter_late(pos, num_pos, src, width, len, pred, args),
                        jak_async_filter_late(pos, num_pos, src, width, len, pred, args, num_threads))
}

bool jak_sync_for(const void *base, size_t width, size_t len, jak_for_body_func_t f,
                  void *args)
{
        JAK_ERROR_IF_NULL(base)
        JAK_ERROR_IF_NULL(width)
        JAK_ERROR_IF_NULL(len)
        f(base, width, len, args, 0);
        return true;
}

bool jak_async_for(const void *base, size_t width, size_t len, jak_for_body_func_t f,
                   void *args, uint_fast16_t num_threads)
{
        JAK_ERROR_IF_NULL(base)
        JAK_ERROR_IF_NULL(width)

        if (len > 0) {
                uint_fast16_t num_thread = num_threads + 1; /** +1 since one is this thread */
                pthread_t threads[num_threads];
                jak_async_func_proxy proxyArgs[num_thread];
                size_t chunk_len = len / num_thread;
                size_t chunk_len_remain = len % num_thread;
                const void *main_thread_base = base + num_threads * chunk_len * width;

                JAK_PREFETCH_READ(f);
                JAK_PREFETCH_READ(args);

                /** run f on NTHREADS_FOR additional threads */
                for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                        jak_async_func_proxy *proxy_arg = proxyArgs + tid;
                        proxy_arg->start = base + tid * chunk_len * width;
                        proxy_arg->len = chunk_len;
                        proxy_arg->tid = (tid + 1);
                        proxy_arg->width = width;
                        proxy_arg->args = args;
                        proxy_arg->function = f;

                        JAK_PREFETCH_READ(proxy_arg->start);
                        pthread_create(threads + tid, NULL, jak_async_for_proxy_function, proxyArgs + tid);
                }
                /** run f on this thread */
                JAK_PREFETCH_READ(main_thread_base);
                f(main_thread_base, width, chunk_len + chunk_len_remain, args, 0);

                for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                        pthread_join(threads[tid], NULL);
                }
        }
        return true;
}

void jak_map_proxy(const void *src, size_t src_width, size_t len, void *args, jak_thread_id_t tid)
{
        JAK_UNUSED(tid);
        JAK_cast(jak_map_args *, mapArgs, args);
        size_t globalStart = (src - mapArgs->src) / src_width;

        JAK_PREFETCH_READ(mapArgs->src);
        JAK_PREFETCH_READ(mapArgs->args);
        JAK_PREFETCH_WRITE(mapArgs->dst);
        mapArgs->map_func(mapArgs->dst + globalStart * mapArgs->dst_width,
                          src,
                          src_width,
                          mapArgs->dst_width,
                          len,
                          mapArgs->args);
}

bool jak_async_map_exec(void *dst, const void *src, size_t src_width, size_t len, size_t dst_width,
                        jak_map_body_func_t f, void *args, jak_threading_hint hint, uint_fast16_t num_threads)
{
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NULL(src_width)
        JAK_ERROR_IF_NULL(dst_width)
        JAK_ERROR_IF_NULL(f)

        JAK_PREFETCH_READ(f);
        JAK_PREFETCH_WRITE(dst);

        jak_map_args mapArgs = {.args = args, .map_func = f, .dst = dst, .dst_width = dst_width, .src = src};

        return jak_for((void *) src, src_width, len, &jak_map_proxy, &mapArgs, hint, num_threads);
}

void jak_int_async_gather(const void *start, size_t width, size_t len, void *args, jak_thread_id_t tid)
{
        JAK_UNUSED(tid);
        JAK_cast(jak_gather_scatter_args *, gather_args, args);
        size_t global_index_start = (start - gather_args->dst) / width;

        JAK_PREFETCH_WRITE(gather_args->dst);
        JAK_PREFETCH_WRITE(gather_args->idx);
        JAK_PREFETCH_READ((len > 0) ? gather_args->src + gather_args->idx[0] * width : NULL);

        for (register size_t i = 0, next_i = 1; i < len; next_i = ++i + 1) {
                size_t global_index_cur = global_index_start + i;
                size_t global_index_next = global_index_start + next_i;
                memcpy(gather_args->dst + global_index_cur * width,
                       gather_args->src + gather_args->idx[global_index_cur] * width,
                       width);

                bool has_next = (next_i < len);
                JAK_PREFETCH_READ(has_next ? gather_args->idx + global_index_next : NULL);
                JAK_PREFETCH_READ(has_next ? gather_args->src + gather_args->idx[global_index_next] * width : NULL);
                JAK_PREFETCH_WRITE(has_next ? gather_args->dst + global_index_next * width : NULL);
        }
}

bool jak_sync_gather(void *dst, const void *src, size_t width, const size_t *idx,
                     size_t dst_src_len)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NULL(idx)
        JAK_ERROR_IF_NULL(width)

        JAK_PREFETCH_READ(src);
        JAK_PREFETCH_READ(idx);
        JAK_PREFETCH_WRITE(dst);

        JAK_PREFETCH_READ(idx);
        JAK_PREFETCH_WRITE(dst);
        JAK_PREFETCH_READ((dst_src_len > 0) ? src + idx[0] * width : NULL);

        for (register size_t i = 0, next_i = 1; i < dst_src_len; next_i = ++i + 1) {
                memcpy(dst + i * width, src + idx[i] * width, width);

                bool has_next = (next_i < dst_src_len);
                JAK_PREFETCH_READ(has_next ? idx + next_i : NULL);
                JAK_PREFETCH_READ(has_next ? src + idx[next_i] * width : NULL);
                JAK_PREFETCH_WRITE(has_next ? dst + next_i * width : NULL);
        }

        return true;
}

bool jak_async_gather(void *dst, const void *src, size_t width, const size_t *idx,
                      size_t dst_src_len, uint_fast16_t num_threads)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NULL(idx)
        JAK_ERROR_IF_NULL(width)

        JAK_PREFETCH_READ(src);
        JAK_PREFETCH_READ(idx);
        JAK_PREFETCH_WRITE(dst);

        jak_gather_scatter_args args = {.idx           = idx, .src           = src, .dst           = dst,};
        return jak_async_for(dst, width, dst_src_len, jak_int_async_gather, &args, num_threads);
}

bool jak_sync_gather_adr(void *dst, const void *src, size_t src_width, const size_t *idx,
                         size_t num)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NULL(idx)
        JAK_ERROR_IF_NULL(src_width)

        JAK_PREFETCH_READ(src);
        JAK_PREFETCH_READ(idx);
        JAK_PREFETCH_WRITE(dst);

        JAK_PREFETCH_READ(idx);
        JAK_PREFETCH_WRITE(dst);
        JAK_PREFETCH_READ(num > 0 ? src + idx[0] * src_width : NULL);

        for (register size_t i = 0, next_i = 1; i < num; next_i = ++i + 1) {
                const void *ptr = src + idx[i] * src_width;
                size_t adr = (size_t) ptr;
                memcpy(dst + i * sizeof(void *), &adr, sizeof(size_t));

                bool has_next = (next_i < num);
                JAK_PREFETCH_READ(has_next ? idx + next_i : NULL);
                JAK_PREFETCH_READ(has_next ? src + idx[next_i] * src_width : NULL);
                JAK_PREFETCH_WRITE(has_next ? dst + next_i * sizeof(void *) : NULL);
        }
        return true;
}

void jak_async_gather_adr_func(const void *start, size_t width, size_t len, void *args, jak_thread_id_t tid)
{
        JAK_UNUSED(tid);
        JAK_cast(jak_gather_scatter_args *, gather_args, args);

        JAK_PREFETCH_READ(gather_args->idx);
        JAK_PREFETCH_WRITE(gather_args->dst);
        JAK_PREFETCH_READ((len > 0) ? gather_args->src + gather_args->idx[0] * width : NULL);

        size_t global_index_start = (start - gather_args->dst) / width;
        for (register size_t i = 0, next_i = 1; i < len; next_i = ++i + 1) {
                size_t global_index_cur = global_index_start + i;
                size_t global_index_next = global_index_start + next_i;
                const void *ptr = gather_args->src + gather_args->idx[global_index_cur] * width;
                size_t adr = (size_t) ptr;
                memcpy(gather_args->dst + global_index_cur * sizeof(void *), &adr, sizeof(size_t));

                bool has_next = (next_i < len);
                JAK_PREFETCH_READ(has_next ? gather_args->idx + global_index_next : NULL);
                JAK_PREFETCH_READ(has_next ? gather_args->src + gather_args->idx[global_index_next] * width : NULL);
                JAK_PREFETCH_WRITE(has_next ? gather_args->dst + global_index_next * sizeof(void *) : NULL);
        }
}

bool jak_int_async_gather_adr_func(void *dst, const void *src, size_t src_width, const size_t *idx,
                                   size_t num, uint_fast16_t num_threads)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NULL(idx)
        JAK_ERROR_IF_NULL(src_width)

        JAK_PREFETCH_READ(src);
        JAK_PREFETCH_READ(idx);
        JAK_PREFETCH_WRITE(dst);

        jak_gather_scatter_args args = {.idx = idx, .src = src, .dst = dst};
        return jak_async_for(dst, src_width, num, jak_async_gather_adr_func, &args, num_threads);
}

void jak_async_scatter(const void *start, size_t width, size_t len, void *args, jak_thread_id_t tid)
{
        JAK_UNUSED(tid);
        JAK_cast(jak_gather_scatter_args *, scatter_args, args);

        JAK_PREFETCH_READ(scatter_args->idx);
        JAK_PREFETCH_READ(scatter_args->src);
        JAK_PREFETCH_WRITE((len > 0) ? scatter_args->dst + scatter_args->idx[0] * width : NULL);

        size_t global_index_start = (start - scatter_args->dst) / width;
        for (register size_t i = 0, next_i = 1; i < len; next_i = ++i + 1) {
                size_t global_index_cur = global_index_start + i;
                size_t global_index_next = global_index_start + next_i;

                memcpy(scatter_args->dst + scatter_args->idx[global_index_cur] * width,
                       scatter_args->src + global_index_cur * width,
                       width);

                bool has_next = (next_i < len);
                JAK_PREFETCH_READ(has_next ? scatter_args->idx + global_index_next : NULL);
                JAK_PREFETCH_READ(has_next ? scatter_args->src + global_index_next * width : NULL);
                JAK_PREFETCH_WRITE(has_next ? scatter_args->dst + scatter_args->idx[global_index_next] * width : NULL);
        }
}

bool jak_sync_scatter(void *dst, const void *src, size_t width, const size_t *idx,
                      size_t num)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NULL(idx)
        JAK_ERROR_IF_NULL(width)

        JAK_PREFETCH_READ(idx);
        JAK_PREFETCH_READ(src);
        JAK_PREFETCH_WRITE((num > 0) ? dst + idx[0] * width : NULL);

        for (register size_t i = 0, next_i = 1; i < num; next_i = ++i + 1) {
                memcpy(dst + idx[i] * width, src + i * width, width);

                bool has_next = (next_i < num);
                JAK_PREFETCH_READ(has_next ? idx + next_i : NULL);
                JAK_PREFETCH_READ(has_next ? src + next_i * width : NULL);
                JAK_PREFETCH_WRITE(has_next ? dst + idx[next_i] * width : NULL);
        }
        return true;
}

bool jak_sync_scatter_func(void *dst, const void *src, size_t width, const size_t *idx, size_t num,
                           uint_fast16_t num_threads)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NULL(idx)
        JAK_ERROR_IF_NULL(width)

        JAK_PREFETCH_READ(src);
        JAK_PREFETCH_READ(idx);
        JAK_PREFETCH_WRITE(dst);

        jak_gather_scatter_args args = {.idx = idx, .src = src, .dst = dst};
        return jak_async_for(dst, width, num, jak_async_scatter, &args, num_threads);
}

bool jak_sync_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                      const size_t *src_idx, size_t idx_len)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NULL(dst_idx)
        JAK_ERROR_IF_NULL(src_idx)
        JAK_ERROR_IF_NULL(width)

        bool has_first = (idx_len > 0);
        JAK_PREFETCH_READ(src_idx);
        JAK_PREFETCH_READ(dst_idx);
        JAK_PREFETCH_READ(has_first ? src + src_idx[0] * width : NULL);
        JAK_PREFETCH_WRITE(has_first ? dst + dst_idx[0] * width : NULL);

        for (register size_t i = 0, next_i = 1; i < idx_len; next_i = ++i + 1) {
                memcpy(dst + dst_idx[i] * width, src + src_idx[i] * width, width);

                bool has_next = (next_i < idx_len);
                JAK_PREFETCH_READ(has_next ? src_idx + next_i : NULL);
                JAK_PREFETCH_READ(has_next ? dst_idx + next_i : NULL);
                JAK_PREFETCH_READ(has_next ? src + src_idx[next_i] * width : NULL);
                JAK_PREFETCH_WRITE(has_next ? dst + dst_idx[next_i] * width : NULL);
        }

        return true;
}

bool jak_async_shuffle(void *dst, const void *src, size_t width, const size_t *dst_idx,
                       const size_t *src_idx, size_t idx_len)
{
        JAK_UNUSED(dst);
        JAK_UNUSED(src);
        JAK_UNUSED(width);
        JAK_UNUSED(dst_idx);
        JAK_UNUSED(src_idx);
        JAK_UNUSED(idx_len);
        JAK_NOT_IMPLEMENTED
}

bool jak_int_sync_filter_late(size_t *positions, size_t *num_positions, const void *source,
                              size_t width, size_t length, jak_pred_func_t predicate,
                              void *arguments)
{
        JAK_ERROR_IF_NULL(positions);
        JAK_ERROR_IF_NULL(num_positions);
        JAK_ERROR_IF_NULL(source);
        JAK_ERROR_IF_NULL(width);
        JAK_ERROR_IF_NULL(length);
        JAK_ERROR_IF_NULL(predicate);

        predicate(positions, num_positions, source, width, length, arguments, 0);

        return true;
}

void *jak_int_sync_filter_procy_func(void *args)
{
        JAK_cast(jak_filter_arg  *, proxy_arg, args);
        proxy_arg->pred(proxy_arg->src_positions,
                        &proxy_arg->num_positions,
                        proxy_arg->start,
                        proxy_arg->width,
                        proxy_arg->len,
                        proxy_arg->args,
                        proxy_arg->position_offset_to_add);
        return NULL;
}

bool jak_async_filter_late(size_t *pos, size_t *num_pos, const void *src, size_t width, size_t len,
                           jak_pred_func_t pred, void *args, size_t num_threads)
{
        JAK_ERROR_IF_NULL(pos);
        JAK_ERROR_IF_NULL(num_pos);
        JAK_ERROR_IF_NULL(src);
        JAK_ERROR_IF_NULL(width);
        JAK_ERROR_IF_NULL(pred);

        if (JAK_UNLIKELY(len == 0)) {
                *num_pos = 0;
                return true;
        }

        uint_fast16_t num_thread = num_threads + 1; /** +1 since one is this thread */

        pthread_t threads[num_threads];
        jak_filter_arg thread_args[num_thread];

        register size_t chunk_len = len / num_thread;
        size_t chunk_len_remain = len % num_thread;
        size_t main_position_offset_to_add = num_threads * chunk_len;
        const void *main_thread_base = src + main_position_offset_to_add * width;

        JAK_PREFETCH_READ(pred);
        JAK_PREFETCH_READ(args);

        /** run f on NTHREADS_FOR additional threads */
        if (JAK_LIKELY(chunk_len > 0)) {
                for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                        jak_filter_arg *arg = thread_args + tid;
                        arg->num_positions = 0;
                        arg->src_positions = JAK_MALLOC(chunk_len * sizeof(size_t));
                        arg->position_offset_to_add = tid * chunk_len;
                        arg->start = src + arg->position_offset_to_add * width;
                        arg->len = chunk_len;
                        arg->width = width;
                        arg->args = args;
                        arg->pred = pred;

                        JAK_PREFETCH_READ(arg->start);
                        pthread_create(threads + tid, NULL, jak_int_sync_filter_procy_func, arg);
                }
        }
        /** run f on this thread */
        JAK_PREFETCH_READ(main_thread_base);
        size_t main_chunk_len = chunk_len + chunk_len_remain;
        size_t *main_src_positions = JAK_MALLOC(main_chunk_len * sizeof(size_t));
        size_t main_num_positions = 0;

        pred(main_src_positions,
             &main_num_positions,
             main_thread_base,
             width,
             main_chunk_len,
             args,
             main_position_offset_to_add);

        size_t total_num_matching_positions = 0;

        if (JAK_LIKELY(chunk_len > 0)) {
                for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                        pthread_join(threads[tid], NULL);
                        const jak_filter_arg *thread_arg = (thread_args + tid);
                        if (thread_arg->num_positions > 0) {
                                memcpy(pos + total_num_matching_positions,
                                       thread_arg->src_positions,
                                       thread_arg->num_positions * sizeof(size_t));
                                total_num_matching_positions += thread_arg->num_positions;
                        }
                        free(thread_args[tid].src_positions);
                }
        }

        if (JAK_LIKELY(main_num_positions > 0)) {
                memcpy(pos + total_num_matching_positions, main_src_positions, main_num_positions * sizeof(size_t));
                total_num_matching_positions += main_num_positions;
        }
        free(main_src_positions);

        *num_pos = total_num_matching_positions;

        return true;
}

bool jak_async_filter_early(void *result, size_t *result_size, const void *src, size_t width,
                            size_t len, jak_pred_func_t pred, void *args)
{
        JAK_ERROR_IF_NULL(result);
        JAK_ERROR_IF_NULL(result_size);
        JAK_ERROR_IF_NULL(src);
        JAK_ERROR_IF_NULL(width);
        JAK_ERROR_IF_NULL(len);
        JAK_ERROR_IF_NULL(pred);

        size_t num_matching_positions;
        size_t *matching_positions = JAK_MALLOC(len * sizeof(size_t));

        pred(matching_positions, &num_matching_positions, src, width, len, args, 0);

        jak_gather(result, src, width, matching_positions, num_matching_positions, JAK_THREADING_HINT_SINGLE, 0);
        *result_size = num_matching_positions;

        free(matching_positions);

        return true;
}

bool jak_int_async_filter_early(void *result, size_t *result_size, const void *src, size_t width,
                                size_t len, jak_pred_func_t pred, void *args, uint_fast16_t num_threads)
{
        JAK_ERROR_IF_NULL(result);
        JAK_ERROR_IF_NULL(result_size);
        JAK_ERROR_IF_NULL(src);
        JAK_ERROR_IF_NULL(width);
        JAK_ERROR_IF_NULL(len);
        JAK_ERROR_IF_NULL(pred);

        uint_fast16_t num_thread = num_threads + 1; /** +1 since one is this thread */

        pthread_t threads[num_threads];
        jak_filter_arg thread_args[num_thread];

        register size_t chunk_len = len / num_thread;
        size_t chunk_len_remain = len % num_thread;
        size_t main_position_offset_to_add = num_threads * chunk_len;
        const void *main_thread_base = src + main_position_offset_to_add * width;

        JAK_PREFETCH_READ(pred);
        JAK_PREFETCH_READ(args);

        /** run f on NTHREADS_FOR additional threads */
        for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                jak_filter_arg *arg = thread_args + tid;
                arg->num_positions = 0;
                arg->src_positions = JAK_MALLOC(chunk_len * sizeof(size_t));
                arg->position_offset_to_add = tid * chunk_len;
                arg->start = src + arg->position_offset_to_add * width;
                arg->len = chunk_len;
                arg->width = width;
                arg->args = args;
                arg->pred = pred;

                JAK_PREFETCH_READ(arg->start);
                pthread_create(threads + tid, NULL, jak_int_sync_filter_procy_func, arg);
        }
        /** run f on this thread */
        JAK_PREFETCH_READ(main_thread_base);
        size_t main_chunk_len = chunk_len + chunk_len_remain;
        size_t *main_src_positions = JAK_MALLOC(main_chunk_len * sizeof(size_t));
        size_t main_num_positions = 0;

        pred(main_src_positions,
             &main_num_positions,
             main_thread_base,
             width,
             main_chunk_len,
             args,
             main_position_offset_to_add);

        size_t total_num_matching_positions = main_num_positions;
        size_t partial_num_matching_positions = 0;

        for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                pthread_join(threads[tid], NULL);
                const jak_filter_arg *thread_arg = (thread_args + tid);
                total_num_matching_positions += thread_arg->num_positions;
                JAK_PREFETCH_READ(thread_arg->src_positions);
        }

        for (register uint_fast16_t tid = 0; tid < num_threads; tid++) {
                const jak_filter_arg *thread_arg = (thread_args + tid);

                if (JAK_LIKELY(thread_arg->num_positions > 0)) {
                        jak_gather(result + partial_num_matching_positions * width,
                                   src,
                                   width,
                                   thread_arg->src_positions,
                                   thread_arg->num_positions,
                                   JAK_THREADING_HINT_MULTI,
                                   num_threads);
                }

                partial_num_matching_positions += thread_arg->num_positions;
                free(thread_arg->src_positions);
        }

        if (JAK_LIKELY(main_num_positions > 0)) {
                jak_gather(result + partial_num_matching_positions * width,
                           src,
                           width,
                           main_src_positions,
                           main_num_positions,
                           JAK_THREADING_HINT_MULTI,
                           num_threads);
        }
        free(main_src_positions);

        *result_size = total_num_matching_positions;

        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_bitmap.h>

bool jak_bitmap_create(jak_bitmap *bitmap, jak_u16 num_bits)
{
        JAK_ERROR_IF_NULL(bitmap);

        jak_allocator alloc;
        jak_alloc_create_std(&alloc);
        jak_vector_create(&bitmap->data, &alloc, sizeof(jak_u32), ceil(num_bits / (double) JAK_BIT_NUM_OF(jak_u32)));
        size_t cap = jak_vector_capacity(&bitmap->data);
        jak_u32 zero = 0;
        jak_vector_repeated_push(&bitmap->data, &zero, cap);
        bitmap->num_bits = num_bits;

        return true;
}

bool jak_bitmap_cpy(jak_bitmap *dst, const jak_bitmap *src)
{
        dst->num_bits = src->num_bits;
        return jak_vector_cpy(&dst->data, &src->data);
}

bool jak_bitmap_drop(jak_bitmap *bitset)
{
        return jak_vector_drop(&bitset->data);
}

size_t jak_bitmap_nbits(const jak_bitmap *bitset)
{
        JAK_ERROR_IF_NULL(bitset);
        return bitset->num_bits;
}

bool jak_bitmap_clear(jak_bitmap *bitset)
{
        JAK_ERROR_IF_NULL(bitset);
        void *data = (void *) jak_vector_data(&bitset->data);
        memset(data, 0, sizeof(jak_u32) * jak_vector_capacity(&bitset->data));
        return true;
}

bool jak_bitmap_set(jak_bitmap *bitset, jak_u16 bit_position, bool on)
{
        JAK_ERROR_IF_NULL(bitset)
        size_t block_pos = floor(bit_position / (double) JAK_BIT_NUM_OF(jak_u32));
        size_t block_bit = bit_position % JAK_BIT_NUM_OF(jak_u32);
        jak_u32 block = *JAK_VECTOR_GET(&bitset->data, block_pos, jak_u32);
        jak_u32 mask = JAK_SET_BIT(block_bit);
        if (on) {
                JAK_SET_BITS(block, mask);
        } else {
                JAK_UNSET_BITS(block, mask);
        }
        jak_vector_set(&bitset->data, block_pos, &block);
        return true;
}

bool jak_bitmap_get(jak_bitmap *bitset, jak_u16 bit_position)
{
        JAK_ERROR_IF_NULL(bitset)
        size_t block_pos = floor(bit_position / (double) JAK_BIT_NUM_OF(jak_u32));
        size_t block_bit = bit_position % JAK_BIT_NUM_OF(jak_u32);
        jak_u32 block = *JAK_VECTOR_GET(&bitset->data, block_pos, jak_u32);
        jak_u32 mask = JAK_SET_BIT(block_bit);
        return ((mask & block) >> bit_position) == true;
}

bool jak_bitmap_lshift(jak_bitmap *map)
{
        JAK_ERROR_IF_NULL(map)
        for (int i = map->num_bits - 1; i >= 0; i--) {
                bool f = i > 0 ? jak_bitmap_get(map, i - 1) : false;
                jak_bitmap_set(map, i, f);
        }
        return true;
}

void jak_bitmap_print_bits(FILE *file, jak_u32 n)
{
        for (int i = 31; i >= 0; i--) {
                jak_u32 mask = 1 << i;
                jak_u32 k = n & mask;
                fprintf(file, "%s", k == 0 ? "0" : "1");
        }
}

void jak_bitmap_print_bits_in_char(FILE *file, char n)
{
        fprintf(file, "0b");
        for (int i = 7; i >= 0; i--) {
                char mask = 1 << i;
                char k = n & mask;
                fprintf(file, "%s", k == 0 ? "0" : "1");
        }
}

bool jak_bitmap_blocks(jak_u32 **blocks, jak_u32 *num_blocks, const jak_bitmap *map)
{
        JAK_ERROR_IF_NULL(blocks)
        JAK_ERROR_IF_NULL(num_blocks)
        JAK_ERROR_IF_NULL(map)

        jak_u32 *result = JAK_MALLOC(map->data.num_elems * sizeof(jak_u32));
        jak_i32 k = 0;
        for (jak_i32 i = map->data.num_elems - 1; i >= 0; i--) {
                result[k++] = *JAK_VECTOR_GET(&map->data, i, jak_u32);
        }
        *blocks = result;
        *num_blocks = map->data.num_elems;

        return true;
}

bool jak_bitmap_print(FILE *file, const jak_bitmap *map)
{
        JAK_ERROR_IF_NULL(map)

        jak_u32 *blocks, num_blocks;

        jak_bitmap_blocks(&blocks, &num_blocks, map);

        for (jak_u32 i = 0; i < num_blocks; i++) {
                fprintf(file, " %"PRIu32 " |", blocks[i]);
        }

        free(blocks);

        for (jak_i32 i = map->data.num_elems - 1; i >= 0; i--) {
                jak_u32 block = *JAK_VECTOR_GET(&map->data, i, jak_u32);
                jak_bitmap_print_bits(stdout, block);
                fprintf(file, " |");
        }

        fprintf(file, "\n");
        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_bloom.h>

bool jak_bloom_create(jak_bitmap *filter, size_t size)
{
        return jak_bitmap_create(filter, size);
}

bool jak_bloom_drop(jak_bitmap *filter)
{
        return jak_bitmap_drop(filter);
}

bool jak_bloom_clear(jak_bitmap *filter)
{
        return jak_bitmap_clear(filter);
}

size_t jak_bloom_nbits(jak_bitmap *filter)
{
        return jak_bitmap_nbits(filter);
}

unsigned jak_bloom_nhashs()
{
        return 4;
}



/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements an (read-/write) iterator for (JSON) arrays in carbon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_uintvar_stream.h>
#include <jak_carbon.h>
#include <jak_carbon_array_it.h>
#include <jak_carbon_column_it.h>
#include <jak_carbon_object_it.h>
#include <jak_carbon_insert.h>
#include <jak_carbon_media.h>
#include <jak_carbon_int.h>

#define DEFINE_IN_PLACE_UPDATE_FUNCTION(type_name, field_type)                                                         \
bool jak_carbon_array_it_update_in_place_##type_name(jak_carbon_array_it *it, jak_##type_name value)                \
{                                                                                                                      \
        jak_offset_t datum = 0;                                                                                                \
        JAK_ERROR_IF_NULL(it);                                                                                             \
        if (JAK_LIKELY(it->field_access.it_field_type == field_type)) {                                                    \
                jak_memfile_save_position(&it->memfile);                                                                   \
                jak_carbon_int_array_it_offset(&datum, it);                                                                 \
                jak_memfile_seek(&it->memfile, datum + sizeof(jak_u8));                                                        \
                jak_memfile_write(&it->memfile, &value, sizeof(jak_##type_name));                                                \
                jak_memfile_restore_position(&it->memfile);                                                                \
                return true;                                                                                           \
        } else {                                                                                                       \
                JAK_ERROR(&it->err, JAK_ERR_TYPEMISMATCH);                                                                 \
                return false;                                                                                          \
        }                                                                                                              \
}

DEFINE_IN_PLACE_UPDATE_FUNCTION(u8, JAK_CARBON_FIELD_TYPE_NUMBER_U8)

DEFINE_IN_PLACE_UPDATE_FUNCTION(u16, JAK_CARBON_FIELD_TYPE_NUMBER_U16)

DEFINE_IN_PLACE_UPDATE_FUNCTION(u32, JAK_CARBON_FIELD_TYPE_NUMBER_U32)

DEFINE_IN_PLACE_UPDATE_FUNCTION(u64, JAK_CARBON_FIELD_TYPE_NUMBER_U64)

DEFINE_IN_PLACE_UPDATE_FUNCTION(i8, JAK_CARBON_FIELD_TYPE_NUMBER_I8)

DEFINE_IN_PLACE_UPDATE_FUNCTION(i16, JAK_CARBON_FIELD_TYPE_NUMBER_I16)

DEFINE_IN_PLACE_UPDATE_FUNCTION(i32, JAK_CARBON_FIELD_TYPE_NUMBER_I32)

DEFINE_IN_PLACE_UPDATE_FUNCTION(i64, JAK_CARBON_FIELD_TYPE_NUMBER_I64)

DEFINE_IN_PLACE_UPDATE_FUNCTION(float, JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT)

static bool update_in_place_constant(jak_carbon_array_it *it, jak_carbon_constant_e constant)
{
        JAK_ERROR_IF_NULL(it);

        jak_memfile_save_position(&it->memfile);

        if (jak_carbon_field_type_is_constant(it->field_access.it_field_type)) {
                jak_u8 value;
                switch (constant) {
                        case JAK_CARBON_CONSTANT_TRUE:
                                value = JAK_CARBON_FIELD_TYPE_TRUE;
                                break;
                        case JAK_CARBON_CONSTANT_FALSE:
                                value = JAK_CARBON_FIELD_TYPE_FALSE;
                                break;
                        case JAK_CARBON_CONSTANT_NULL:
                                value = JAK_CARBON_FIELD_TYPE_NULL;
                                break;
                        default: JAK_ERROR(&it->err, JAK_ERR_INTERNALERR);
                                break;
                }
                jak_offset_t datum = 0;
                jak_carbon_int_array_it_offset(&datum, it);
                jak_memfile_seek(&it->memfile, datum);
                jak_memfile_write(&it->memfile, &value, sizeof(jak_u8));
        } else {
                jak_carbon_insert ins;
                jak_carbon_array_it_remove(it);
                jak_carbon_array_it_insert_begin(&ins, it);

                switch (constant) {
                        case JAK_CARBON_CONSTANT_TRUE:
                                jak_carbon_insert_true(&ins);
                                break;
                        case JAK_CARBON_CONSTANT_FALSE:
                                jak_carbon_insert_false(&ins);
                                break;
                        case JAK_CARBON_CONSTANT_NULL:
                                jak_carbon_insert_null(&ins);
                                break;
                        default: JAK_ERROR(&it->err, JAK_ERR_INTERNALERR);
                                break;
                }

                jak_carbon_array_it_insert_end(&ins);
        }

        jak_memfile_restore_position(&it->memfile);
        return true;
}

bool jak_carbon_array_it_update_in_place_true(jak_carbon_array_it *it)
{
        return update_in_place_constant(it, JAK_CARBON_CONSTANT_TRUE);
}

bool jak_carbon_array_it_update_in_place_false(jak_carbon_array_it *it)
{
        return update_in_place_constant(it, JAK_CARBON_CONSTANT_FALSE);
}

bool jak_carbon_array_it_update_in_place_null(jak_carbon_array_it *it)
{
        return update_in_place_constant(it, JAK_CARBON_CONSTANT_NULL);
}

bool jak_carbon_array_it_create(jak_carbon_array_it *it, jak_memfile *memfile, jak_error *err,
                            jak_offset_t payload_start)
{
        JAK_ERROR_IF_NULL(it);
        JAK_ERROR_IF_NULL(memfile);
        JAK_ERROR_IF_NULL(err);

        JAK_ZERO_MEMORY(it, sizeof(jak_carbon_array_it));

        it->payload_start = payload_start;
        it->mod_size = 0;
        it->array_end_reached = false;
        it->field_offset = 0;

        jak_error_init(&it->err);
        jak_spinlock_init(&it->lock);
        jak_vector_create(&it->history, NULL, sizeof(jak_offset_t), 40);
        jak_memfile_open(&it->memfile, memfile->memblock, memfile->mode);
        jak_memfile_seek(&it->memfile, payload_start);

        JAK_ERROR_IF(jak_memfile_remain_size(&it->memfile) < sizeof(jak_u8), err, JAK_ERR_CORRUPTED);

        jak_u8 marker = *jak_memfile_read(&it->memfile, sizeof(jak_u8));
        JAK_ERROR_IF_WDETAILS(marker != JAK_CARBON_MARKER_ARRAY_BEGIN, err, JAK_ERR_ILLEGALOP,
                              "array begin marker ('[') not found");

        it->payload_start += sizeof(jak_u8);

        jak_carbon_int_field_access_create(&it->field_access);

        jak_carbon_array_it_rewind(it);

        return true;
}

bool jak_carbon_array_it_copy(jak_carbon_array_it *dst, jak_carbon_array_it *src)
{
        JAK_ERROR_IF_NULL(dst);
        JAK_ERROR_IF_NULL(src);
        jak_carbon_array_it_create(dst, &src->memfile, &src->err, src->payload_start - sizeof(jak_u8));
        return true;
}

bool jak_carbon_array_it_clone(jak_carbon_array_it *dst, jak_carbon_array_it *src)
{
        jak_memfile_clone(&dst->memfile, &src->memfile);
        dst->payload_start = src->payload_start;
        jak_spinlock_init(&dst->lock);
        jak_error_cpy(&dst->err, &src->err);
        dst->mod_size = src->mod_size;
        dst->array_end_reached = src->array_end_reached;
        jak_vector_cpy(&dst->history, &src->history);
        jak_carbon_int_field_access_clone(&dst->field_access, &src->field_access);
        dst->field_offset = src->field_offset;
        return true;
}

bool jak_carbon_array_it_readonly(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        it->memfile.mode = JAK_READ_ONLY;
        return true;
}

bool jak_carbon_array_it_length(jak_u64 *len, jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(len)
        JAK_ERROR_IF_NULL(it)

        jak_u64 num_elem = 0;
        jak_carbon_array_it_rewind(it);
        while (jak_carbon_array_it_next(it)) {
                num_elem++;
        }
        *len = num_elem;

        return true;
}

bool jak_carbon_array_it_is_empty(jak_carbon_array_it *it)
{
        jak_carbon_array_it_rewind(it);
        return jak_carbon_array_it_next(it);
}

bool jak_carbon_array_it_drop(jak_carbon_array_it *it)
{
        jak_carbon_int_field_auto_close(&it->field_access);
        jak_carbon_int_field_access_drop(&it->field_access);
        jak_vector_drop(&it->history);
        return true;
}

/**
 * Locks the iterator with a spinlock. A call to <code>jak_carbon_array_it_unlock</code> is required for unlocking.
 */
bool jak_carbon_array_it_lock(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_spinlock_acquire(&it->lock);
        return true;
}

/**
 * Unlocks the iterator
 */
bool jak_carbon_array_it_unlock(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_spinlock_release(&it->lock);
        return true;
}

bool jak_carbon_array_it_rewind(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        JAK_ERROR_IF(it->payload_start >= jak_memfile_size(&it->memfile), &it->err, JAK_ERR_OUTOFBOUNDS);
        jak_carbon_int_history_clear(&it->history);
        return jak_memfile_seek(&it->memfile, it->payload_start);
}

static void auto_adjust_pos_after_mod(jak_carbon_array_it *it)
{
        if (jak_carbon_int_field_access_object_it_opened(&it->field_access)) {
                jak_memfile_skip(&it->memfile, it->field_access.nested_object_it->mod_size);
        } else if (jak_carbon_int_field_access_array_it_opened(&it->field_access)) {
                //jak_memfile_skip(&it->memfile, it->field_access.nested_array_it->mod_size);
                //abort(); // TODO: implement!
        }
}

bool jak_carbon_array_it_has_next(jak_carbon_array_it *it)
{
        bool has_next = jak_carbon_array_it_next(it);
        jak_carbon_array_it_prev(it);
        return has_next;
}

bool jak_carbon_array_it_is_unit(jak_carbon_array_it *it)
{
        bool has_next = jak_carbon_array_it_next(it);
        if (has_next) {
                has_next = jak_carbon_array_it_next(it);
                jak_carbon_array_it_prev(it);
                jak_carbon_array_it_prev(it);
                return !has_next;
        }
        jak_carbon_array_it_prev(it);
        return false;
}

bool jak_carbon_array_it_next(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        bool is_empty_slot = true;

        auto_adjust_pos_after_mod(it);
        jak_offset_t last_off = jak_memfile_tell(&it->memfile);

        if (jak_carbon_int_array_it_next(&is_empty_slot, &it->array_end_reached, it)) {
                jak_carbon_int_history_push(&it->history, last_off);
                return true;
        } else {
                /* skip remaining zeros until end of array is reached */
                if (!it->array_end_reached) {
                        JAK_ERROR_IF(!is_empty_slot, &it->err, JAK_ERR_CORRUPTED);

                        while (*jak_memfile_peek(&it->memfile, 1) == 0) {
                                jak_memfile_skip(&it->memfile, 1);
                        }
                }
                JAK_ASSERT(*jak_memfile_peek(&it->memfile, sizeof(char)) == JAK_CARBON_MARKER_ARRAY_END);
                jak_carbon_int_field_auto_close(&it->field_access);
                return false;
        }
}

bool jak_carbon_array_it_prev(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        if (jak_carbon_int_history_has(&it->history)) {
                jak_offset_t prev_off = jak_carbon_int_history_pop(&it->history);
                jak_memfile_seek(&it->memfile, prev_off);
                return jak_carbon_int_array_it_refresh(NULL, NULL, it);
        } else {
                return false;
        }
}

jak_offset_t jak_carbon_array_it_memfilepos(jak_carbon_array_it *it)
{
        if (JAK_LIKELY(it != NULL)) {
                return jak_memfile_tell(&it->memfile);
        } else {
                JAK_ERROR(&it->err, JAK_ERR_NULLPTR);
                return 0;
        }
}

jak_offset_t jak_carbon_array_it_tell(jak_carbon_array_it *it)
{
        return it ? it->field_offset : 0;
}

bool jak_carbon_int_array_it_offset(jak_offset_t *off, jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(off)
        JAK_ERROR_IF_NULL(it)
        if (jak_carbon_int_history_has(&it->history)) {
                *off = jak_carbon_int_history_peek(&it->history);
                return true;
        }
        return false;
}

bool jak_carbon_array_it_fast_forward(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        while (jak_carbon_array_it_next(it)) {}

        JAK_ASSERT(*jak_memfile_peek(&it->memfile, sizeof(char)) == JAK_CARBON_MARKER_ARRAY_END);
        jak_memfile_skip(&it->memfile, sizeof(char));
        return true;
}

bool jak_carbon_array_it_field_type(jak_carbon_field_type_e *type, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_field_type(type, &it->field_access);
}

bool jak_carbon_array_it_u8_value(jak_u8 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_u8_value(value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_u16_value(jak_u16 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_u16_value(value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_u32_value(jak_u32 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_u32_value(value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_u64_value(jak_u64 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_u64_value(value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_i8_value(jak_i8 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_i8_value(value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_i16_value(jak_i16 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_i16_value(value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_i32_value(jak_i32 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_i32_value(value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_i64_value(jak_i64 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_i64_value(value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_float_value(bool *is_null_in, float *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_float_value(is_null_in, value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_signed_value(bool *is_null_in, jak_i64 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_signed_value(is_null_in, value, &it->field_access, &it->err);
}

bool jak_carbon_array_it_unsigned_value(bool *is_null_in, jak_u64 *value, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_unsigned_value(is_null_in, value, &it->field_access, &it->err);
}

const char *jak_carbon_array_it_jak_string_value(jak_u64 *strlen, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_jak_string_value(strlen, &it->field_access, &it->err);
}

bool jak_carbon_array_it_binary_value(jak_carbon_binary *out, jak_carbon_array_it *it)
{
        return jak_carbon_int_field_access_binary_value(out, &it->field_access, &it->err);
}

jak_carbon_array_it *jak_carbon_array_it_array_value(jak_carbon_array_it *it_in)
{
        return jak_carbon_int_field_access_array_value(&it_in->field_access, &it_in->err);
}

jak_carbon_object_it *jak_carbon_array_it_object_value(jak_carbon_array_it *it_in)
{
        return jak_carbon_int_field_access_object_value(&it_in->field_access, &it_in->err);
}

jak_carbon_column_it *jak_carbon_array_it_column_value(jak_carbon_array_it *it_in)
{
        return jak_carbon_int_field_access_column_value(&it_in->field_access, &it_in->err);
}

bool jak_carbon_array_it_insert_begin(jak_carbon_insert *inserter, jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(inserter)
        JAK_ERROR_IF_NULL(it)
        return jak_carbon_int_insert_create_for_array(inserter, it);
}

bool jak_carbon_array_it_insert_end(jak_carbon_insert *inserter)
{
        JAK_ERROR_IF_NULL(inserter)
        return jak_carbon_insert_drop(inserter);
}

bool jak_carbon_array_it_remove(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_carbon_field_type_e type;
        if (jak_carbon_array_it_field_type(&type, it)) {
                jak_offset_t prev_off = jak_carbon_int_history_pop(&it->history);
                jak_memfile_seek(&it->memfile, prev_off);
                if (jak_carbon_int_field_remove(&it->memfile, &it->err, type)) {
                        jak_carbon_int_array_it_refresh(NULL, NULL, it);
                        return true;
                } else {
                        return false;
                }
        } else {
                JAK_ERROR(&it->err, JAK_ERR_ILLEGALSTATE);
                return false;
        }
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements the document format itself
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <inttypes.h>

#include <jak_uintvar_stream.h>
#include <jak_carbon.h>
#include <jak_carbon_array_it.h>
#include <jak_carbon_column_it.h>
#include <jak_carbon_object_it.h>
#include <jak_carbon_printers.h>
#include <jak_carbon_int.h>
#include <jak_carbon_dot.h>
#include <jak_carbon_find.h>
#include <jak_carbon_insert.h>
#include <jak_carbon_revise.h>
#include <jak_carbon_string.h>
#include <jak_carbon_key.h>
#include <jak_carbon_commit.h>
#include <jak_json_printer_compact.h>
#include <jak_json_printer_extended.h>

#define MIN_DOC_CAPACITY 17 /* minimum number of bytes required to store header and empty document array */

static bool internal_drop(jak_carbon *doc);

static void carbon_header_init(jak_carbon *doc, jak_carbon_key_e key_type);

// ---------------------------------------------------------------------------------------------------------------------

jak_carbon_insert *jak_carbon_create_begin(jak_carbon_new *context, jak_carbon *doc,
                                           jak_carbon_key_e type, int options)
{
        if (JAK_LIKELY(context != NULL && doc != NULL)) {
                JAK_ERROR_IF (options != JAK_CARBON_KEEP && options != JAK_CARBON_SHRINK && options != JAK_CARBON_COMPACT &&
                          options != JAK_CARBON_OPTIMIZE,
                          &doc->err, JAK_ERR_ILLEGALARG);

                JAK_SUCCESS_ELSE_NULL(jak_error_init(&context->err), &doc->err);
                context->content_it = JAK_MALLOC(sizeof(jak_carbon_array_it));
                context->inserter = JAK_MALLOC(sizeof(jak_carbon_insert));
                context->mode = options;

                JAK_SUCCESS_ELSE_NULL(jak_carbon_create_empty(&context->original, type), &doc->err);
                JAK_SUCCESS_ELSE_NULL(jak_carbon_revise_begin(&context->revision_context, doc, &context->original), &doc->err);
                JAK_SUCCESS_ELSE_NULL(jak_carbon_revise_iterator_open(context->content_it, &context->revision_context),
                                  &doc->err);
                JAK_SUCCESS_ELSE_NULL(jak_carbon_array_it_insert_begin(context->inserter, context->content_it), &doc->err);
                return context->inserter;
        } else {
                return NULL;
        }
}

bool jak_carbon_create_end(jak_carbon_new *context)
{
        bool success = true;
        if (JAK_LIKELY(context != NULL)) {
                success &= jak_carbon_array_it_insert_end(context->inserter);
                success &= jak_carbon_revise_iterator_close(context->content_it);
                if (context->mode & JAK_CARBON_COMPACT) {
                        jak_carbon_revise_pack(&context->revision_context);
                }
                if (context->mode & JAK_CARBON_SHRINK) {
                        jak_carbon_revise_shrink(&context->revision_context);
                }
                success &= jak_carbon_revise_end(&context->revision_context) != NULL;
                free(context->content_it);
                free(context->inserter);
                jak_carbon_drop(&context->original);
                if (JAK_UNLIKELY(!success)) {
                        JAK_ERROR(&context->err, JAK_ERR_CLEANUP);
                        return false;
                } else {
                        return true;
                }
        } else {
                JAK_ERROR_PRINT(JAK_ERR_NULLPTR);
                return false;
        }
}

bool jak_carbon_create_empty(jak_carbon *doc, jak_carbon_key_e type)
{
        return jak_carbon_create_empty_ex(doc, type, 1024, 1);
}

bool jak_carbon_create_empty_ex(jak_carbon *doc, jak_carbon_key_e type, jak_u64 doc_cap,
                                jak_u64 array_cap)
{
        JAK_ERROR_IF_NULL(doc);

        doc_cap = JAK_MAX(MIN_DOC_CAPACITY, doc_cap);

        jak_error_init(&doc->err);
        jak_memblock_create(&doc->memblock, doc_cap);
        jak_memblock_zero_out(doc->memblock);
        jak_memfile_open(&doc->memfile, doc->memblock, JAK_READ_WRITE);

        jak_spinlock_init(&doc->versioning.write_lock);

        doc->versioning.commit_lock = false;
        doc->versioning.is_latest = true;

        carbon_header_init(doc, type);
        jak_carbon_int_insert_array(&doc->memfile, array_cap);

        return true;
}

bool jak_carbon_from_json(jak_carbon *doc, const char *json, jak_carbon_key_e type,
                      const void *key, jak_error *err)
{
        JAK_ERROR_IF_NULL(doc)
        JAK_ERROR_IF_NULL(json)

        jak_json data;
        jak_json_err status;
        jak_json_parser parser;

        jak_json_parser_create(&parser);

        if (!(jak_json_parse(&data, &status, &parser, json))) {
                jak_string sb;
                jak_string_create(&sb);

                if (status.token) {
                        jak_string_add(&sb, status.msg);
                        jak_string_add(&sb, " but token ");
                        jak_string_add(&sb, status.token_type_str);
                        jak_string_add(&sb, " was found in line ");
                        jak_string_add_u32(&sb, status.token->line);
                        jak_string_add(&sb, " column ");
                        jak_string_add_u32(&sb, status.token->column);
                } else {
                        jak_string_add(&sb, status.msg);
                }

                JAK_ERROR_WDETAILS(err, JAK_ERR_JSONPARSEERR, jak_string_cstr(&sb));
                jak_string_drop(&sb);

                return false;
        } else {
                jak_carbon_int_from_json(doc, &data, type, key, JAK_CARBON_OPTIMIZE);
                jak_json_drop(&data);
                return true;
        }
}

bool jak_carbon_drop(jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(doc);
        return internal_drop(doc);
}

const void *jak_carbon_raw_data(jak_u64 *len, jak_carbon *doc)
{
        if (len && doc) {
                jak_memblock_size(len, doc->memfile.memblock);
                return jak_memblock_raw_data(doc->memfile.memblock);
        } else {
                return NULL;
        }
}

bool jak_carbon_is_up_to_date(jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(doc);
        return doc->versioning.is_latest;
}

bool jak_carbon_key_type(jak_carbon_key_e *out, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(out)
        JAK_ERROR_IF_NULL(doc)
        jak_memfile_save_position(&doc->memfile);
        jak_carbon_key_skip(out, &doc->memfile);
        jak_memfile_restore_position(&doc->memfile);
        return true;
}

const void *jak_carbon_key_raw_value(jak_u64 *len, jak_carbon_key_e *type, jak_carbon *doc)
{
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);
        const void *result = jak_carbon_key_read(len, type, &doc->memfile);
        jak_memfile_restore_position(&doc->memfile);
        return result;
}

bool jak_carbon_key_signed_value(jak_i64 *key, jak_carbon *doc)
{
        jak_carbon_key_e type;
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);
        const void *result = jak_carbon_key_read(NULL, &type, &doc->memfile);
        jak_memfile_restore_position(&doc->memfile);
        if (JAK_LIKELY(jak_carbon_key_is_signed(type))) {
                *key = *((const jak_i64 *) result);
                return true;
        } else {
                JAK_ERROR(&doc->err, JAK_ERR_TYPEMISMATCH);
                return false;
        }
}

bool jak_carbon_key_unsigned_value(jak_u64 *key, jak_carbon *doc)
{
        jak_carbon_key_e type;
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);
        const void *result = jak_carbon_key_read(NULL, &type, &doc->memfile);
        jak_memfile_restore_position(&doc->memfile);
        if (JAK_LIKELY(jak_carbon_key_is_unsigned(type))) {
                *key = *((const jak_u64 *) result);
                return true;
        } else {
                JAK_ERROR(&doc->err, JAK_ERR_TYPEMISMATCH);
                return false;
        }
}

const char *jak_carbon_key_jak_string_value(jak_u64 *len, jak_carbon *doc)
{
        jak_carbon_key_e type;
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);
        const void *result = jak_carbon_key_read(len, &type, &doc->memfile);
        jak_memfile_restore_position(&doc->memfile);
        if (JAK_LIKELY(jak_carbon_key_is_string(type))) {
                return result;
        } else {
                JAK_ERROR(&doc->err, JAK_ERR_TYPEMISMATCH);
                return false;
        }
}

bool jak_carbon_key_is_unsigned(jak_carbon_key_e type)
{
        return type == JAK_CARBON_KEY_UKEY || type == JAK_CARBON_KEY_AUTOKEY;
}

bool jak_carbon_key_is_signed(jak_carbon_key_e type)
{
        return type == JAK_CARBON_KEY_IKEY;
}

bool jak_carbon_key_is_string(jak_carbon_key_e type)
{
        return type == JAK_CARBON_KEY_SKEY;
}

bool jak_carbon_has_key(jak_carbon_key_e type)
{
        return type != JAK_CARBON_KEY_NOKEY;
}

bool jak_carbon_clone(jak_carbon *clone, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(clone);
        JAK_ERROR_IF_NULL(doc);
        JAK_CHECK_SUCCESS(jak_memblock_cpy(&clone->memblock, doc->memblock));
        JAK_CHECK_SUCCESS(jak_memfile_open(&clone->memfile, clone->memblock, JAK_READ_WRITE));
        JAK_CHECK_SUCCESS(jak_error_init(&clone->err));

        jak_spinlock_init(&clone->versioning.write_lock);
        clone->versioning.commit_lock = false;
        clone->versioning.is_latest = true;

        return true;
}

bool jak_carbon_commit_hash(jak_u64 *hash, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(doc);
        *hash = jak_carbon_int_header_get_commit_hash(doc);
        return true;
}

bool jak_carbon_to_str(jak_string *dst, jak_carbon_printer_impl_e printer, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(doc);

        jak_carbon_printer p;
        jak_string b;
        jak_carbon_key_e key_type;
        jak_u64 key_len;
        jak_u64 rev;

        jak_string_clear(dst);

        jak_memfile_save_position(&doc->memfile);

        JAK_ZERO_MEMORY(&p, sizeof(jak_carbon_printer));
        jak_string_create(&b);

        jak_carbon_commit_hash(&rev, doc);

        jak_carbon_printer_by_type(&p, printer);

        jak_carbon_printer_begin(&p, &b);
        jak_carbon_printer_header_begin(&p, &b);

        const void *key = jak_carbon_key_raw_value(&key_len, &key_type, doc);
        jak_carbon_printer_header_contents(&p, &b, key_type, key, key_len, rev);

        jak_carbon_printer_header_end(&p, &b);
        jak_carbon_printer_payload_begin(&p, &b);

        jak_carbon_array_it it;
        jak_carbon_iterator_open(&it, doc);

        jak_carbon_printer_print_array(&it, &p, &b, true);
        jak_carbon_array_it_drop(&it);

        jak_carbon_printer_payload_end(&p, &b);
        jak_carbon_printer_end(&p, &b);

        jak_carbon_printer_drop(&p);
        jak_string_add(dst, jak_string_cstr(&b));
        jak_string_drop(&b);

        jak_memfile_restore_position(&doc->memfile);
        return true;
}

const char *jak_carbon_to_json_extended(jak_string *dst, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(doc)
        jak_carbon_to_str(dst, JAK_JSON_EXTENDED, doc);
        return jak_string_cstr(dst);
}

const char *jak_carbon_to_json_compact(jak_string *dst, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(doc)
        jak_carbon_to_str(dst, JAK_JSON_COMPACT, doc);
        return jak_string_cstr(dst);
}

char *jak_carbon_to_json_extended_dup(jak_carbon *doc)
{
        jak_string sb;
        jak_string_create(&sb);
        char *result = strdup(jak_carbon_to_json_extended(&sb, doc));
        jak_string_drop(&sb);
        return result;
}

char *jak_carbon_to_json_compact_dup(jak_carbon *doc)
{
        jak_string sb;
        jak_string_create(&sb);
        char *result = strdup(jak_carbon_to_json_compact(&sb, doc));
        jak_string_drop(&sb);
        return result;
}

bool jak_carbon_iterator_open(jak_carbon_array_it *it, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(it);
        JAK_ERROR_IF_NULL(doc);
        jak_offset_t payload_start = jak_carbon_int_payload_after_header(doc);
        jak_carbon_array_it_create(it, &doc->memfile, &doc->err, payload_start);
        jak_carbon_array_it_readonly(it);
        return true;
}

bool jak_carbon_iterator_close(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        return jak_carbon_array_it_drop(it);
}

bool jak_carbon_print(FILE *file, jak_carbon_printer_impl_e printer, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(file);
        JAK_ERROR_IF_NULL(doc);

        jak_string builder;
        jak_string_create(&builder);
        jak_carbon_to_str(&builder, printer, doc);
        printf("%s\n", jak_string_cstr(&builder));
        jak_string_drop(&builder);

        return true;
}

bool jak_carbon_hexdump_print(FILE *file, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(file);
        JAK_ERROR_IF_NULL(doc);
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);
        bool status = jak_hexdump_print(file, jak_memfile_peek(&doc->memfile, 1), jak_memfile_size(&doc->memfile));
        jak_memfile_restore_position(&doc->memfile);
        return status;
}

// ---------------------------------------------------------------------------------------------------------------------

static bool internal_drop(jak_carbon *doc)
{
        JAK_ASSERT(doc);
        jak_memblock_drop(doc->memblock);
        return true;
}

static void carbon_header_init(jak_carbon *doc, jak_carbon_key_e key_type)
{
        JAK_ASSERT(doc);

        jak_memfile_seek(&doc->memfile, 0);
        jak_carbon_key_create(&doc->memfile, key_type, &doc->err);

        if (key_type != JAK_CARBON_KEY_NOKEY) {
                jak_carbon_commit_hash_create(&doc->memfile);
        }
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements an (read-/write) iterator for (JSON) arrays in carbon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_carbon_column_it.h>
#include <jak_carbon_array_it.h>
#include <jak_carbon_media.h>
#include <jak_carbon_insert.h>
#include <jak_carbon_int.h>

#define safe_cast(builtin_type, nvalues, it, field_type_expr)                                                          \
({                                                                                                                     \
        jak_carbon_field_type_e type;                                                                                    \
        const void *raw = jak_carbon_column_it_values(&type, nvalues, it);                                                  \
        JAK_ERROR_IF(!(field_type_expr), &it->err, JAK_ERR_TYPEMISMATCH);                                                  \
        (const builtin_type *) raw;                                                                                    \
})

bool jak_carbon_column_it_create(jak_carbon_column_it *it, jak_memfile *memfile, jak_error *err,
                             jak_offset_t column_start_offset)
{
        JAK_ERROR_IF_NULL(it);
        JAK_ERROR_IF_NULL(memfile);
        JAK_ERROR_IF_NULL(err);

        it->column_start_offset = column_start_offset;
        it->mod_size = 0;

        jak_error_init(&it->err);
        jak_spinlock_init(&it->lock);
        jak_memfile_open(&it->memfile, memfile->memblock, memfile->mode);
        jak_memfile_seek(&it->memfile, column_start_offset);

        JAK_ERROR_IF(jak_memfile_remain_size(&it->memfile) < sizeof(jak_u8) + sizeof(jak_media_type), err, JAK_ERR_CORRUPTED);

        jak_u8 marker = *jak_memfile_read(&it->memfile, sizeof(jak_u8));
        JAK_ERROR_IF_WDETAILS(marker != JAK_CARBON_MARKER_COLUMN_U8 &&
                              marker != JAK_CARBON_MARKER_COLUMN_U16 &&
                              marker != JAK_CARBON_MARKER_COLUMN_U32 &&
                              marker != JAK_CARBON_MARKER_COLUMN_U64 &&
                              marker != JAK_CARBON_MARKER_COLUMN_I8 &&
                              marker != JAK_CARBON_MARKER_COLUMN_I16 &&
                              marker != JAK_CARBON_MARKER_COLUMN_I32 &&
                              marker != JAK_CARBON_MARKER_COLUMN_I64 &&
                              marker != JAK_CARBON_MARKER_COLUMN_FLOAT &&
                              marker != JAK_CARBON_MARKER_COLUMN_BOOLEAN, err, JAK_ERR_ILLEGALOP,
                              "column begin marker ('(') not found");

        jak_carbon_field_type_e type = (jak_carbon_field_type_e) marker;
        it->type = type;

        it->num_and_capacity_start_offset = jak_memfile_tell(&it->memfile);
        it->column_num_elements = (jak_u32) jak_memfile_read_uintvar_stream(NULL, &it->memfile);
        it->column_capacity = (jak_u32) jak_memfile_read_uintvar_stream(NULL, &it->memfile);

        jak_carbon_column_it_rewind(it);

        return true;
}

bool jak_carbon_column_it_clone(jak_carbon_column_it *dst, jak_carbon_column_it *src)
{
        jak_memfile_clone(&dst->memfile, &src->memfile);
        dst->num_and_capacity_start_offset = src->num_and_capacity_start_offset;
        dst->column_start_offset = src->column_start_offset;
        jak_error_cpy(&dst->err, &src->err);
        dst->type = src->type;
        dst->mod_size = src->mod_size;
        dst->column_capacity = src->column_capacity;
        dst->column_num_elements = src->column_num_elements;
        jak_spinlock_init(&dst->lock);
        return true;
}

bool jak_carbon_column_it_insert(jak_carbon_insert *inserter, jak_carbon_column_it *it)
{
        JAK_ERROR_IF_NULL(inserter)
        JAK_ERROR_IF_NULL(it)
        return jak_carbon_int_insert_create_for_column(inserter, it);
}

bool jak_carbon_column_it_fast_forward(jak_carbon_column_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_carbon_column_it_values(NULL, NULL, it);
        return true;
}

jak_offset_t jak_carbon_column_it_memfilepos(jak_carbon_column_it *it)
{
        if (JAK_LIKELY(it != NULL)) {
                return jak_memfile_tell(&it->memfile);
        } else {
                JAK_ERROR(&it->err, JAK_ERR_NULLPTR);
                return 0;
        }
}

jak_offset_t jak_carbon_column_it_tell(jak_carbon_column_it *it, jak_u32 elem_idx)
{
        if (it) {
                jak_memfile_save_position(&it->memfile);
                jak_memfile_seek(&it->memfile, it->num_and_capacity_start_offset);
                jak_u32 num_elements = (jak_u32) jak_memfile_read_uintvar_stream(NULL, &it->memfile);
                jak_memfile_read_uintvar_stream(NULL, &it->memfile);
                jak_offset_t payload_start = jak_memfile_tell(&it->memfile);
                JAK_ERROR_IF(elem_idx >= num_elements, &it->err, JAK_ERR_OUTOFBOUNDS);
                jak_offset_t ret = payload_start + elem_idx * jak_carbon_int_get_type_value_size(it->type);
                jak_memfile_restore_position(&it->memfile);
                return ret;
        } else {
                JAK_ERROR_PRINT(JAK_ERR_NULLPTR);
                return 0;
        }
}

bool jak_carbon_column_it_values_info(jak_carbon_field_type_e *type, jak_u32 *nvalues, jak_carbon_column_it *it)
{
        JAK_ERROR_IF_NULL(it);

        if (nvalues) {
                jak_memfile_seek(&it->memfile, it->num_and_capacity_start_offset);
                jak_u32 num_elements = (jak_u32) jak_memfile_read_uintvar_stream(NULL, &it->memfile);
                *nvalues = num_elements;
        }

        JAK_OPTIONAL_SET(type, it->type);

        return true;
}

bool jak_carbon_column_it_value_is_null(jak_carbon_column_it *it, jak_u32 pos)
{
        JAK_ERROR_IF_NULL(it);
        jak_carbon_field_type_e type;
        jak_u32 nvalues = 0;
        jak_carbon_column_it_values_info(&type, &nvalues, it);
        JAK_ERROR_IF(pos >= nvalues, &it->err, JAK_ERR_OUTOFBOUNDS);
        switch (type) {
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                        return JAK_IS_NULL_U8(jak_carbon_column_it_u8_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                        return JAK_IS_NULL_U16(jak_carbon_column_it_u16_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                        return JAK_IS_NULL_U32(jak_carbon_column_it_u32_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                        return JAK_IS_NULL_U64(jak_carbon_column_it_u64_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                        return JAK_IS_NULL_I8(jak_carbon_column_it_i8_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                        return JAK_IS_NULL_I16(jak_carbon_column_it_i16_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                        return JAK_IS_NULL_I32(jak_carbon_column_it_i32_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                        return JAK_IS_NULL_I64(jak_carbon_column_it_i64_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                        return JAK_IS_NULL_FLOAT(jak_carbon_column_it_float_values(NULL, it)[pos]);
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        return JAK_IS_NULL_BOOLEAN(jak_carbon_column_it_boolean_values(NULL, it)[pos]);
                default: JAK_ERROR(&it->err, JAK_ERR_UNSUPPCONTAINER)
                        return false;
        }
}

const void *jak_carbon_column_it_values(jak_carbon_field_type_e *type, jak_u32 *nvalues, jak_carbon_column_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_memfile_seek(&it->memfile, it->num_and_capacity_start_offset);
        jak_u32 num_elements = (jak_u32) jak_memfile_read_uintvar_stream(NULL, &it->memfile);
        jak_u32 cap_elements = (jak_u32) jak_memfile_read_uintvar_stream(NULL, &it->memfile);
        jak_offset_t payload_start = jak_memfile_tell(&it->memfile);

        const void *result = jak_memfile_peek(&it->memfile, sizeof(void));

        JAK_OPTIONAL_SET(type, it->type);
        JAK_OPTIONAL_SET(nvalues, num_elements);

        jak_u32 skip = cap_elements * jak_carbon_int_get_type_value_size(it->type);
        jak_memfile_seek(&it->memfile, payload_start + skip);

        return result;
}

const jak_u8 *jak_carbon_column_it_boolean_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_u8, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN));
}

const jak_u8 *jak_carbon_column_it_u8_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_u8, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_U8));
}

const jak_u16 *jak_carbon_column_it_u16_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_u16, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_U16));
}

const jak_u32 *jak_carbon_column_it_u32_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_u32, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_U32));
}

const jak_u64 *jak_carbon_column_it_u64_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_u64, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_U64));
}

const jak_i8 *jak_carbon_column_it_i8_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_i8, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_I8));
}

const jak_i16 *jak_carbon_column_it_i16_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_i16, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_I16));
}

const jak_i32 *jak_carbon_column_it_i32_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_i32, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_I32));
}

const jak_i64 *jak_carbon_column_it_i64_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(jak_i64, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_I64));
}

const float *jak_carbon_column_it_float_values(jak_u32 *nvalues, jak_carbon_column_it *it)
{
        return safe_cast(float, nvalues, it, (type == JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT));
}

bool jak_carbon_column_it_remove(jak_carbon_column_it *it, jak_u32 pos)
{
        JAK_ERROR_IF_NULL(it);

        JAK_ERROR_IF(pos >= it->column_num_elements, &it->err, JAK_ERR_OUTOFBOUNDS);
        jak_memfile_save_position(&it->memfile);

        jak_offset_t payload_start = jak_carbon_int_column_get_payload_off(it);

        /* remove element */
        size_t elem_size = jak_carbon_int_get_type_value_size(it->type);
        jak_memfile_seek(&it->memfile, payload_start + pos * elem_size);
        jak_memfile_inplace_remove(&it->memfile, elem_size);

        /* add an empty element at the end to restore the column capacity property */
        jak_memfile_seek(&it->memfile, payload_start + it->column_num_elements * elem_size);
        jak_memfile_inplace_insert(&it->memfile, elem_size);

        /* update element counter */
        jak_memfile_seek(&it->memfile, it->num_and_capacity_start_offset);
        jak_u32 num_elems = jak_memfile_peek_uintvar_stream(NULL, &it->memfile);
        JAK_ASSERT(num_elems > 0);
        num_elems--;
        signed_offset_t shift = jak_memfile_update_uintvar_stream(&it->memfile, num_elems);
        it->column_num_elements = num_elems;

        jak_memfile_restore_position(&it->memfile);
        jak_memfile_seek_from_here(&it->memfile, shift);

        return true;
}

bool jak_carbon_column_it_update_set_null(jak_carbon_column_it *it, jak_u32 pos)
{
        JAK_ERROR_IF_NULL(it)
        JAK_ERROR_IF(pos >= it->column_num_elements, &it->err, JAK_ERR_OUTOFBOUNDS)

        jak_memfile_save_position(&it->memfile);

        jak_offset_t payload_start = jak_carbon_int_column_get_payload_off(it);
        jak_memfile_seek(&it->memfile, payload_start + pos * jak_carbon_int_get_type_value_size(it->type));

        switch (it->type) {
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                        jak_u8 null_value = JAK_CARBON_BOOLEAN_COLUMN_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u8));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8: {
                        jak_u8 null_value = JAK_U8_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u8));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16: {
                        jak_u16 null_value = JAK_U16_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u16));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32: {
                        jak_u32 null_value = JAK_U32_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u32));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64: {
                        jak_u64 null_value = JAK_U64_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u64));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8: {
                        jak_i8 null_value = JAK_I8_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_i8));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16: {
                        jak_i16 null_value = JAK_I16_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_i16));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32: {
                        jak_i32 null_value = JAK_I32_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_i32));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64: {
                        jak_i64 null_value = JAK_I64_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_i64));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT: {
                        float null_value = JAK_FLOAT_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(float));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                case JAK_CARBON_FIELD_TYPE_STRING:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        jak_memfile_restore_position(&it->memfile);
                        JAK_ERROR(&it->err, JAK_ERR_UNSUPPCONTAINER)
                        return false;
                default:
                        jak_memfile_restore_position(&it->memfile);
                        JAK_ERROR(&it->err, JAK_ERR_INTERNALERR);
                        return false;
        }

        jak_memfile_restore_position(&it->memfile);

        return true;
}

#define push_array_element(num_values, data, data_cast_type, null_check, insert_func)                                  \
for (jak_u32 i = 0; i < num_values; i++) {                                                                                 \
        data_cast_type datum = ((data_cast_type *)data)[i];                                                            \
        if (JAK_LIKELY(null_check(datum) == false)) {                                                                      \
                insert_func(&array_ins);                                                                               \
        } else {                                                                                                       \
                jak_carbon_insert_null(&array_ins);                                                                         \
        }                                                                                                              \
}

#define push_array_element_wvalue(num_values, data, data_cast_type, null_check, insert_func)                           \
for (jak_u32 i = 0; i < num_values; i++) {                                                                                 \
        data_cast_type datum = ((data_cast_type *)data)[i];                                                            \
        if (JAK_LIKELY(null_check(datum) == false)) {                                                                      \
                insert_func(&array_ins, datum);                                                                        \
        } else {                                                                                                       \
                jak_carbon_insert_null(&array_ins);                                                                         \
        }                                                                                                              \
}

static bool rewrite_column_to_array(jak_carbon_column_it *it)
{
        jak_carbon_array_it array_it;
        jak_carbon_insert array_ins;

        jak_memfile_save_position(&it->memfile);

        /* Potentially tailing space after the last ']' marker of the outer most array is used for temporary space */
        jak_memfile_seek_to_end(&it->memfile);
        jak_offset_t array_marker_begin = jak_memfile_tell(&it->memfile);

        size_t capacity = it->column_num_elements * jak_carbon_int_get_type_value_size(it->type);
        jak_carbon_int_insert_array(&it->memfile, capacity);
        jak_carbon_array_it_create(&array_it, &it->memfile, &it->err, array_marker_begin);
        jak_carbon_array_it_insert_begin(&array_ins, &array_it);

        jak_carbon_field_type_e type;
        jak_u32 num_values;
        const void *data = jak_carbon_column_it_values(&type, &num_values, it);
        switch (type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                        while (num_values--) {
                                jak_carbon_insert_null(&array_ins);
                        }
                        break;
                case JAK_CARBON_FIELD_TYPE_TRUE:
                        push_array_element(num_values, data, jak_u8, JAK_IS_NULL_BOOLEAN, jak_carbon_insert_true);
                        break;
                case JAK_CARBON_FIELD_TYPE_FALSE:
                        push_array_element(num_values, data, jak_u8, JAK_IS_NULL_BOOLEAN, jak_carbon_insert_false);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                        push_array_element_wvalue(num_values, data, jak_u8, JAK_IS_NULL_U8, jak_carbon_insert_u8);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                        push_array_element_wvalue(num_values, data, jak_u16, JAK_IS_NULL_U16, jak_carbon_insert_u16);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                        push_array_element_wvalue(num_values, data, jak_u32, JAK_IS_NULL_U32, jak_carbon_insert_u32);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                        push_array_element_wvalue(num_values, data, jak_u64, JAK_IS_NULL_U64, jak_carbon_insert_u64);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                        push_array_element_wvalue(num_values, data, jak_i8, JAK_IS_NULL_I8, jak_carbon_insert_i8);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                        push_array_element_wvalue(num_values, data, jak_i16, JAK_IS_NULL_I16, jak_carbon_insert_i16);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                        push_array_element_wvalue(num_values, data, jak_i32, JAK_IS_NULL_I32, jak_carbon_insert_i32);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                        push_array_element_wvalue(num_values, data, jak_i64, JAK_IS_NULL_I64, jak_carbon_insert_i64);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        push_array_element_wvalue(num_values, data, float, JAK_IS_NULL_FLOAT, jak_carbon_insert_float);
                        break;
                default: JAK_ERROR(&it->err, JAK_ERR_UNSUPPORTEDTYPE);
                        return false;
        }

        jak_carbon_array_it_insert_end(&array_ins);
        JAK_ASSERT(array_marker_begin < jak_carbon_array_it_memfilepos(&array_it));
        jak_carbon_array_it_drop(&array_it);

        jak_memfile_restore_position(&it->memfile);
        return true;
}

bool jak_carbon_column_it_update_set_true(jak_carbon_column_it *it, jak_u32 pos)
{
        JAK_ERROR_IF_NULL(it)
        JAK_ERROR_IF(pos >= it->column_num_elements, &it->err, JAK_ERR_OUTOFBOUNDS)

        jak_memfile_save_position(&it->memfile);

        jak_offset_t payload_start = jak_carbon_int_column_get_payload_off(it);
        jak_memfile_seek(&it->memfile, payload_start + pos * jak_carbon_int_get_type_value_size(it->type));

        switch (it->type) {
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                        jak_u8 value = JAK_CARBON_BOOLEAN_COLUMN_TRUE;
                        jak_memfile_write(&it->memfile, &value, sizeof(jak_u8));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8: {
                        jak_u8 null_value = JAK_U8_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u8));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16: {
                        jak_u16 null_value = JAK_U16_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u16));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32: {
                        //jak_u32 null_value = JAK_U32_NULL;
                        //jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u32));
                        rewrite_column_to_array(it);


                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64: {
                        jak_u64 null_value = JAK_U64_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_u64));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8: {
                        jak_i8 null_value = JAK_I8_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_i8));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16: {
                        jak_i16 null_value = JAK_I16_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_i16));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32: {
                        jak_i32 null_value = JAK_I32_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_i32));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64: {
                        jak_i64 null_value = JAK_I64_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(jak_i64));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT: {
                        float null_value = JAK_FLOAT_NULL;
                        jak_memfile_write(&it->memfile, &null_value, sizeof(float));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                case JAK_CARBON_FIELD_TYPE_STRING:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        jak_memfile_restore_position(&it->memfile);
                        JAK_ERROR(&it->err, JAK_ERR_UNSUPPCONTAINER)
                        return false;
                default:
                        jak_memfile_restore_position(&it->memfile);
                        JAK_ERROR(&it->err, JAK_ERR_INTERNALERR);
                        return false;
        }

        jak_memfile_restore_position(&it->memfile);

        return true;
}

bool jak_carbon_column_it_update_set_false(jak_carbon_column_it *it, jak_u32 pos)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_u8(jak_carbon_column_it *it, jak_u32 pos, jak_u8 value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_u16(jak_carbon_column_it *it, jak_u32 pos, jak_u16 value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_u32(jak_carbon_column_it *it, jak_u32 pos, jak_u32 value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_u64(jak_carbon_column_it *it, jak_u32 pos, jak_u64 value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_i8(jak_carbon_column_it *it, jak_u32 pos, jak_i8 value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_i16(jak_carbon_column_it *it, jak_u32 pos, jak_i16 value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_i32(jak_carbon_column_it *it, jak_u32 pos, jak_i32 value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_i64(jak_carbon_column_it *it, jak_u32 pos, jak_i64 value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

bool jak_carbon_column_it_update_set_float(jak_carbon_column_it *it, jak_u32 pos, float value)
{
        JAK_UNUSED(it)
        JAK_UNUSED(pos)
        JAK_UNUSED(value)
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED); // TODO: implement
        return false;
}

/**
 * Locks the iterator with a spinlock. A call to <code>jak_carbon_column_it_unlock</code> is required for unlocking.
 */
bool jak_carbon_column_it_lock(jak_carbon_column_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_spinlock_acquire(&it->lock);
        return true;
}

/**
 * Unlocks the iterator
 */
bool jak_carbon_column_it_unlock(jak_carbon_column_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_spinlock_release(&it->lock);
        return true;
}

bool jak_carbon_column_it_rewind(jak_carbon_column_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_offset_t playload_start = jak_carbon_int_column_get_payload_off(it);
        JAK_ERROR_IF(playload_start >= jak_memfile_size(&it->memfile), &it->err, JAK_ERR_OUTOFBOUNDS);
        return jak_memfile_seek(&it->memfile, playload_start);
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_carbon_commit.h>
#include <jak_unique_id.h>
#include <jak_hash.h>

bool jak_carbon_commit_hash_create(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)

        jak_u64 init_rev = 0;
        jak_unique_id_create(&init_rev);

        jak_memfile_ensure_space(file, sizeof(jak_u64));
        jak_memfile_write(file, &init_rev, sizeof(jak_u64));

        return true;
}

bool jak_carbon_commit_hash_skip(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)
        jak_memfile_skip(file, sizeof(jak_u64));
        return true;
}

bool jak_carbon_commit_hash_read(jak_u64 *commit_hash, jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(commit_hash)
        *commit_hash = *JAK_MEMFILE_READ_TYPE(file, jak_u64);
        return true;
}

bool jak_carbon_commit_hash_peek(jak_u64 *commit_hash, jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(commit_hash)
        *commit_hash = *JAK_MEMFILE_PEEK(file, jak_u64);
        return true;
}

bool jak_carbon_commit_hash_update(jak_memfile *file, const char *base, jak_u64 len)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(base)
        JAK_ERROR_IF_NULL(len)
        jak_u64 commit_hash;
        jak_carbon_commit_hash_compute(&commit_hash, base, len);
        jak_memfile_write(file, &commit_hash, sizeof(jak_u64));
        return true;
}

bool jak_carbon_commit_hash_compute(jak_u64 *commit_hash, const void *base, jak_u64 len)
{
        JAK_ERROR_IF_NULL(commit_hash)
        JAK_ERROR_IF_NULL(base)
        JAK_ERROR_IF_NULL(len)
        *commit_hash = JAK_HASH64_FNV(len, base);
        return true;
}

const char *jak_carbon_commit_hash_to_str(jak_string *dst, jak_u64 commit_hash)
{
        if (dst) {
                jak_string_clear(dst);
                jak_string_add_u64_as_hex(dst, commit_hash);
                return jak_string_cstr(dst);
        } else {
                return NULL;
        }
}

bool jak_carbon_commit_hash_append_to_str(jak_string *dst, jak_u64 commit_hash)
{
        JAK_ERROR_IF_NULL(dst)
        jak_string_add_u64_as_hex(dst, commit_hash);
        return true;
}

jak_u64 jak_carbon_commit_hash_from_str(const char *commit_str, jak_error *err)
{
        if (commit_str && strlen(commit_str) == 16) {
                char *illegal_char;
                errno = 0;
                jak_u64 ret = strtoull(commit_str, &illegal_char, 16);
                if (ret == 0 && commit_str == illegal_char) {
                        JAK_OPTIONAL(err, JAK_ERROR(err, JAK_ERR_NONUMBER))
                        return 0;
                } else if (ret == ULLONG_MAX && errno) {
                        JAK_OPTIONAL(err, JAK_ERROR(err, JAK_ERR_BUFFERTOOTINY))
                        return 0;
                } else if (*illegal_char) {
                        JAK_OPTIONAL(err, JAK_ERROR(err, JAK_ERR_TAILINGJUNK))
                        return 0;
                } else {
                        return ret;
                }
        } else {
                JAK_ERROR(err, JAK_ERR_ILLEGALARG)
                return 0;
        }
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <ctype.h>
#include <jak_utils_convert.h>
#include <jak_carbon_dot.h>
#include <jak_carbon_dot.h>
#include <jak_string.h>
#include <jak_string_utils.h>

enum dot_token_type {
        TOKEN_DOT,
        TOKEN_STRING,
        TOKEN_NUMBER,
        TOKEN_UNKNOWN,
        TOKEN_EOF
};

struct dot_token {
        enum dot_token_type type;
        const char *str;
        jak_u32 len;
};

static const char *next_token(struct dot_token *token, const char *str)
{
        JAK_ASSERT(token);
        JAK_ASSERT(str);

        str = jak_strings_skip_blanks(str);
        char c = *str;
        if (c) {
                if (isalpha(c)) {
                        token->type = TOKEN_STRING;
                        token->str = str;
                        bool skip_esc = false;
                        jak_u32 strlen = 0;
                        while (c && (isalpha(c) && (c != '\n') && (c != '\t') && (c != '\r') && (c != ' '))) {
                                if (!skip_esc) {
                                        if (c == '\\') {
                                                skip_esc = true;
                                        }
                                } else {
                                        skip_esc = false;
                                }
                                strlen++;
                                c = *(++str);
                        }
                        token->len = strlen;
                } else if (c == '\"') {
                        token->type = TOKEN_STRING;
                        token->str = str;
                        c = *(++str);
                        bool skip_esc = false;
                        bool end_found = false;
                        jak_u32 strlen = 1;
                        while (c && !end_found) {
                                if (!skip_esc) {
                                        if (c == '\\') {
                                                skip_esc = true;
                                        } else if (c == '\"') {
                                                end_found = true;
                                        }
                                } else {
                                        skip_esc = false;
                                }

                                strlen++;
                                c = *(++str);
                        }
                        token->len = strlen;
                } else if (c == '.') {
                        token->type = TOKEN_DOT;
                        token->str = str;
                        token->len = 1;
                        str++;
                } else if (isdigit(c)) {
                        token->type = TOKEN_NUMBER;
                        token->str = str;
                        jak_u32 strlen = 0;
                        while (c && isdigit(c)) {
                                c = *(++str);
                                strlen++;
                        }
                        token->len = strlen;
                } else {
                        token->type = TOKEN_UNKNOWN;
                        token->str = str;
                        token->len = strlen(str);
                }
        } else {
                token->type = TOKEN_EOF;
        }
        return str;
}

bool jak_carbon_dot_path_create(jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(path)
        jak_error_init(&path->err);
        path->path_len = 0;
        JAK_ZERO_MEMORY(&path->nodes, JAK_ARRAY_LENGTH(path->nodes) * sizeof(jak_carbon_dot_node));
        return true;
}

bool jak_carbon_dot_path_from_string(jak_carbon_dot_path *path, const char *path_string)
{
        JAK_ERROR_IF_NULL(path)
        JAK_UNUSED(path_string);

        struct dot_token token;
        int status = JAK_ERR_NOERR;
        jak_carbon_dot_path_create(path);

        enum path_entry {
                DOT, ENTRY
        } expected_entry = ENTRY;
        path_string = next_token(&token, path_string);
        while (token.type != TOKEN_EOF) {
                expected_entry = token.type == TOKEN_DOT ? DOT : ENTRY;
                switch (token.type) {
                        case TOKEN_DOT:
                                if (expected_entry != DOT) {
                                        status = JAK_ERR_PARSE_DOT_EXPECTED;
                                        goto cleanup_and_error;
                                }
                                break;
                        case TOKEN_STRING:
                                if (expected_entry != ENTRY) {
                                        status = JAK_ERR_PARSE_ENTRY_EXPECTED;
                                        goto cleanup_and_error;
                                } else {
                                        jak_carbon_dot_path_add_nkey(path, token.str, token.len);
                                }
                                break;
                        case TOKEN_NUMBER:
                                if (expected_entry != ENTRY) {
                                        status = JAK_ERR_PARSE_ENTRY_EXPECTED;
                                        goto cleanup_and_error;
                                } else {
                                        jak_u64 num = jak_convert_atoiu64(token.str);
                                        jak_carbon_dot_path_add_idx(path, num);
                                }
                                break;
                        case TOKEN_UNKNOWN:
                                status = JAK_ERR_PARSE_UNKNOWN_TOKEN;
                                goto cleanup_and_error;
                        default: JAK_ERROR(&path->err, JAK_ERR_INTERNALERR);
                                break;
                }
                path_string = next_token(&token, path_string);
        }

        return true;

        cleanup_and_error:
        jak_carbon_dot_path_drop(path);
        JAK_ERROR_NO_ABORT(&path->err, status);
        return false;
}

bool jak_carbon_dot_path_add_key(jak_carbon_dot_path *dst, const char *key)
{
        return jak_carbon_dot_path_add_nkey(dst, key, strlen(key));
}

bool jak_carbon_dot_path_add_nkey(jak_carbon_dot_path *dst, const char *key, size_t len)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(key)
        if (JAK_LIKELY(dst->path_len < JAK_ARRAY_LENGTH(dst->nodes))) {
                jak_carbon_dot_node *node = dst->nodes + dst->path_len++;
                bool enquoted = jak_strings_is_enquoted_wlen(key, len);
                node->type = JAK_DOT_NODE_KEY_NAME;
                node->identifier.string = strndup(enquoted ? key + 1 : key, len);
                if (enquoted) {
                        char *str_wo_rightspaces = jak_strings_remove_tailing_blanks(node->identifier.string);
                        size_t l = strlen(str_wo_rightspaces);
                        node->identifier.string[l - 1] = '\0';
                }
                JAK_ASSERT(!jak_strings_is_enquoted(node->identifier.string));
                return true;
        } else {
                JAK_ERROR(&dst->err, JAK_ERR_OUTOFBOUNDS)
                return false;
        }
}

bool jak_carbon_dot_path_add_idx(jak_carbon_dot_path *dst, jak_u32 idx)
{
        JAK_ERROR_IF_NULL(dst)
        if (JAK_LIKELY(dst->path_len < JAK_ARRAY_LENGTH(dst->nodes))) {
                jak_carbon_dot_node *node = dst->nodes + dst->path_len++;
                node->type = JAK_DOT_NODE_ARRAY_IDX;
                node->identifier.idx = idx;
                return true;
        } else {
                JAK_ERROR(&dst->err, JAK_ERR_OUTOFBOUNDS)
                return false;
        }
}

bool jak_carbon_dot_path_len(jak_u32 *len, const jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(len)
        JAK_ERROR_IF_NULL(path)
        *len = path->path_len;
        return true;
}

bool jak_carbon_dot_path_is_empty(const jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(path)
        return (path->path_len == 0);
}

bool jak_carbon_dot_path_type_at(carbon_dot_node_e *type_out, jak_u32 pos, const jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(type_out)
        JAK_ERROR_IF_NULL(path)
        if (JAK_LIKELY(pos < JAK_ARRAY_LENGTH(path->nodes))) {
                *type_out = path->nodes[pos].type;
        } else {
                JAK_ERROR(&((jak_carbon_dot_path *) path)->err, JAK_ERR_OUTOFBOUNDS)
                return false;
        }
        return true;
}

bool jak_carbon_dot_path_idx_at(jak_u32 *idx, jak_u32 pos, const jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(idx)
        JAK_ERROR_IF_NULL(path)
        JAK_ERROR_IF_AND_RETURN(pos >= JAK_ARRAY_LENGTH(path->nodes), &((jak_carbon_dot_path *) path)->err,
                            JAK_ERR_OUTOFBOUNDS, NULL);
        JAK_ERROR_IF_AND_RETURN(path->nodes[pos].type != JAK_DOT_NODE_ARRAY_IDX, &((jak_carbon_dot_path *) path)->err,
                            JAK_ERR_TYPEMISMATCH, NULL);

        *idx = path->nodes[pos].identifier.idx;
        return true;
}

const char *jak_carbon_dot_path_key_at(jak_u32 pos, const jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(path)
        JAK_ERROR_IF_AND_RETURN(pos >= JAK_ARRAY_LENGTH(path->nodes), &((jak_carbon_dot_path *) path)->err,
                            JAK_ERR_OUTOFBOUNDS, NULL);
        JAK_ERROR_IF_AND_RETURN(path->nodes[pos].type != JAK_DOT_NODE_KEY_NAME, &((jak_carbon_dot_path *) path)->err,
                            JAK_ERR_TYPEMISMATCH, NULL);

        return path->nodes[pos].identifier.string;
}

bool jak_carbon_dot_path_drop(jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(path)
        for (jak_u32 i = 0; i < path->path_len; i++) {
                jak_carbon_dot_node *node = path->nodes + i;
                if (node->type == JAK_DOT_NODE_KEY_NAME) {
                        free(node->identifier.string);
                }
        }
        path->path_len = 0;
        return true;
}

bool jak_carbon_dot_path_to_str(jak_string *sb, jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(path)
        for (jak_u32 i = 0; i < path->path_len; i++) {
                jak_carbon_dot_node *node = path->nodes + i;
                switch (node->type) {
                        case JAK_DOT_NODE_KEY_NAME: {
                                bool empty_str = strlen(node->identifier.string) == 0;
                                bool quotes_required =
                                        empty_str || jak_strings_contains_blank_char(node->identifier.string);
                                if (quotes_required) {
                                        jak_string_add_char(sb, '"');
                                }
                                if (!empty_str) {
                                        jak_string_add(sb, node->identifier.string);
                                }
                                if (quotes_required) {
                                        jak_string_add_char(sb, '"');
                                }
                        }
                                break;
                        case JAK_DOT_NODE_ARRAY_IDX:
                                jak_string_add_u32(sb, node->identifier.idx);
                                break;
                }
                if (i + 1 < path->path_len) {
                        jak_string_add_char(sb, '.');
                }
        }
        return true;
}

bool jak_carbon_dot_path_fprint(FILE *file, jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(file);
        JAK_ERROR_IF_NULL(path);
        jak_string sb;
        jak_string_create(&sb);
        jak_carbon_dot_path_to_str(&sb, path);
        fprintf(file, "%s", jak_string_cstr(&sb));
        jak_string_drop(&sb);
        return true;
}

bool jak_carbon_dot_path_print(jak_carbon_dot_path *path)
{
        return jak_carbon_dot_path_fprint(stdout, path);
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_memfile.h>
#include <jak_carbon_field.h>
#include <jak_carbon_column_it.h>
#include <jak_carbon_media.h>
#include <jak_carbon_array_it.h>
#include <jak_carbon_object_it.h>

const char *jak_carbon_field_type_str(jak_error *err, jak_carbon_field_type_e type)
{
        switch (type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                        return JAK_CARBON_FIELD_TYPE_NULL_STR;
                case JAK_CARBON_FIELD_TYPE_TRUE:
                        return JAK_CARBON_FIELD_TYPE_TRUE_STR;
                case JAK_CARBON_FIELD_TYPE_FALSE:
                        return JAK_CARBON_FIELD_TYPE_FALSE_STR;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                        return JAK_CARBON_FIELD_TYPE_OBJECT_STR;
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                        return JAK_CARBON_FIELD_TYPE_ARRAY_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_U8_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_U16_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_U32_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_U64_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_I8_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_I16_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_I32_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_I64_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT_STR;
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN_STR;
                case JAK_CARBON_FIELD_TYPE_STRING:
                        return JAK_CARBON_FIELD_TYPE_STRING_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_U8_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_U16_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_U32_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_U64_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_I8_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_I16_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_I32_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_I64_STR;
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        return JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT_STR;
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                case JAK_CARBON_FIELD_TYPE_BINARY:
                        return JAK_CARBON_FIELD_TYPE_BINARY_STR;
                default:
                        if (err) {
                                JAK_ERROR(err, JAK_ERR_NOTFOUND);
                        }
                        return NULL;
        }
}

bool jak_carbon_field_type_is_traversable(jak_carbon_field_type_e type)
{
        switch (type) {
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        return true;
                default:
                        return false;
        }
}

bool jak_carbon_field_type_is_signed(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_NUMBER_I8 || type == JAK_CARBON_FIELD_TYPE_NUMBER_I16 ||
                type == JAK_CARBON_FIELD_TYPE_NUMBER_I32 || type == JAK_CARBON_FIELD_TYPE_NUMBER_I64 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_I8 || type == JAK_CARBON_FIELD_TYPE_COLUMN_I16 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_I32 || type == JAK_CARBON_FIELD_TYPE_COLUMN_I64);
}

bool jak_carbon_field_type_is_unsigned(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_NUMBER_U8 || type == JAK_CARBON_FIELD_TYPE_NUMBER_U16 ||
                type == JAK_CARBON_FIELD_TYPE_NUMBER_U32 || type == JAK_CARBON_FIELD_TYPE_NUMBER_U64 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_U8 || type == JAK_CARBON_FIELD_TYPE_COLUMN_U16 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_U32 || type == JAK_CARBON_FIELD_TYPE_COLUMN_U64);
}

bool jak_carbon_field_type_is_floating(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT || type == JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT);
}

bool jak_carbon_field_type_is_number(jak_carbon_field_type_e type)
{
        return jak_carbon_field_type_is_integer(type) || jak_carbon_field_type_is_floating(type);
}

bool jak_carbon_field_type_is_integer(jak_carbon_field_type_e type)
{
        return jak_carbon_field_type_is_signed(type) || jak_carbon_field_type_is_unsigned(type);
}

bool jak_carbon_field_type_is_binary(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_BINARY || type == JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM);
}

bool jak_carbon_field_type_is_boolean(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_TRUE || type == JAK_CARBON_FIELD_TYPE_FALSE ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN);
}

bool jak_carbon_field_type_is_string(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_STRING);
}

bool jak_carbon_field_type_is_constant(jak_carbon_field_type_e type)
{
        return (jak_carbon_field_type_is_null(type) || jak_carbon_field_type_is_boolean(type));
}

bool jak_carbon_field_skip(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)
        jak_u8 type_marker = *JAK_MEMFILE_PEEK(file, jak_u8);

        switch (type_marker) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                        jak_carbon_field_skip_null(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                        jak_carbon_field_skip_boolean(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                        jak_carbon_field_skip_8(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                        jak_carbon_field_skip_16(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                        jak_carbon_field_skip_32(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                        jak_carbon_field_skip_64(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        jak_carbon_field_skip_float(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_STRING:
                        jak_carbon_field_skip_string(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_BINARY:
                        jak_carbon_field_skip_binary(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        jak_carbon_field_skip_custom_binary(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                        jak_carbon_field_skip_array(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        jak_carbon_field_skip_column(file);
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                        jak_carbon_field_skip_object(file);
                        break;
                default: JAK_ERROR(&file->err, JAK_ERR_CORRUPTED);
                        return false;
        }
        return true;
}

bool jak_carbon_field_skip_object(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_OBJECT, &file->err, JAK_ERR_TYPEMISMATCH);
        jak_carbon_object_it skip_it;
        jak_carbon_object_it_create(&skip_it, file, &file->err, jak_memfile_tell(file) - sizeof(jak_u8));
        jak_carbon_object_it_fast_forward(&skip_it);
        jak_memfile_seek(file, jak_memfile_tell(&skip_it.memfile));
        jak_carbon_object_it_drop(&skip_it);
        return true;
}

bool jak_carbon_field_skip_array(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_ARRAY, &file->err, JAK_ERR_TYPEMISMATCH);
        jak_carbon_array_it skip_it;
        jak_carbon_array_it_create(&skip_it, file, &file->err, jak_memfile_tell(file) - sizeof(jak_u8));
        jak_carbon_array_it_fast_forward(&skip_it);
        jak_memfile_seek(file, jak_memfile_tell(&skip_it.memfile));
        jak_carbon_array_it_drop(&skip_it);
        return true;
}

bool jak_carbon_field_skip_column(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_U8 &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_U16 &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_U32 &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_U64 &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_I8 &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_I16 &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_I32 &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_I64 &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN &&
                 type_marker != JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT, &file->err, JAK_ERR_TYPEMISMATCH);

        jak_carbon_column_it skip_it;
        jak_carbon_column_it_create(&skip_it, file, &file->err,
                                jak_memfile_tell(file) - sizeof(jak_u8));
        jak_carbon_column_it_fast_forward(&skip_it);
        jak_memfile_seek(file, jak_memfile_tell(&skip_it.memfile));
        return true;
}

bool jak_carbon_field_skip_binary(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_BINARY, &file->err, JAK_ERR_TYPEMISMATCH);
        /* read and skip mime type with variable-length integer type */
        jak_u64 mime_type = jak_memfile_read_uintvar_stream(NULL, file);
        JAK_UNUSED(mime_type);

        /* read blob length */
        jak_u64 blob_len = jak_memfile_read_uintvar_stream(NULL, file);

        /* skip blob */
        jak_memfile_skip(file, blob_len);
        return true;
}

bool jak_carbon_field_skip_custom_binary(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM, &file->err, JAK_ERR_TYPEMISMATCH);
        /* read custom type string length, and skip the type string */
        jak_u64 custom_type_str_len = jak_memfile_read_uintvar_stream(NULL, file);
        jak_memfile_skip(file, custom_type_str_len);

        /* read blob length, and skip blob data */
        jak_u64 blob_len = jak_memfile_read_uintvar_stream(NULL, file);
        jak_memfile_skip(file, blob_len);
        return true;
}

bool jak_carbon_field_skip_string(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_STRING, &file->err, JAK_ERR_TYPEMISMATCH);
        jak_u64 strlen = jak_memfile_read_uintvar_stream(NULL, file);
        jak_memfile_skip(file, strlen);
        return true;
}

bool jak_carbon_field_skip_float(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT, &file->err, JAK_ERR_TYPEMISMATCH);
        jak_memfile_skip(file, sizeof(float));
        return true;
}

bool jak_carbon_field_skip_boolean(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_TRUE && type_marker != JAK_CARBON_FIELD_TYPE_FALSE, &file->err,
                 JAK_ERR_TYPEMISMATCH);
        return true;
}

bool jak_carbon_field_skip_null(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_NULL, &file->err, JAK_ERR_TYPEMISMATCH);
        return true;
}

bool jak_carbon_field_skip_8(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_I8 && type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_U8,
                 &file->err, JAK_ERR_TYPEMISMATCH);
        JAK_ASSERT(sizeof(jak_u8) == sizeof(jak_i8));
        jak_memfile_skip(file, sizeof(jak_u8));
        return true;
}

bool jak_carbon_field_skip_16(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_I16 && type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_U16,
                 &file->err, JAK_ERR_TYPEMISMATCH);
        JAK_ASSERT(sizeof(jak_u16) == sizeof(jak_i16));
        jak_memfile_skip(file, sizeof(jak_u16));
        return true;
}

bool jak_carbon_field_skip_32(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_I32 && type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_U32,
                 &file->err, JAK_ERR_TYPEMISMATCH);
        JAK_ASSERT(sizeof(jak_u32) == sizeof(jak_i32));
        jak_memfile_skip(file, sizeof(jak_u32));
        return true;
}

bool jak_carbon_field_skip_64(jak_memfile *file)
{
        jak_u8 type_marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ERROR_IF(type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_I64 && type_marker != JAK_CARBON_FIELD_TYPE_NUMBER_U64,
                 &file->err, JAK_ERR_TYPEMISMATCH);
        JAK_ASSERT(sizeof(jak_u64) == sizeof(jak_i64));
        jak_memfile_skip(file, sizeof(jak_u64));
        return true;
}

jak_carbon_field_type_e jak_carbon_field_type_for_column(jak_carbon_column_type_e type)
{
        switch (type) {
                case JAK_CARBON_COLUMN_TYPE_U8:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_U8;
                case JAK_CARBON_COLUMN_TYPE_U16:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_U16;
                case JAK_CARBON_COLUMN_TYPE_U32:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_U32;
                case JAK_CARBON_COLUMN_TYPE_U64:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_U64;
                case JAK_CARBON_COLUMN_TYPE_I8:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_I8;
                case JAK_CARBON_COLUMN_TYPE_I16:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_I16;
                case JAK_CARBON_COLUMN_TYPE_I32:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_I32;
                case JAK_CARBON_COLUMN_TYPE_I64:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_I64;
                case JAK_CARBON_COLUMN_TYPE_FLOAT:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT;
                case JAK_CARBON_COLUMN_TYPE_BOOLEAN:
                        return JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN;
                default: JAK_ERROR_PRINT(JAK_ERR_INTERNALERR)
                        return 0;
        }
}

jak_carbon_field_type_e
jak_carbon_field_type_column_entry_to_regular_type(jak_carbon_field_type_e type, bool is_null, bool is_true)
{
        if (is_null) {
                return JAK_CARBON_FIELD_TYPE_NULL;
        } else {
                switch (type) {
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_U8;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_U16;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_U32;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_U64;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_I8;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_I16;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_I32;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_I64;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                                return JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                                return is_true ? JAK_CARBON_FIELD_TYPE_TRUE : JAK_CARBON_FIELD_TYPE_FALSE;
                        default: JAK_ERROR_PRINT(JAK_ERR_INTERNALERR)
                                return 0;
                }
        }
}

jak_carbon_field_class_e jak_carbon_field_type_get_class(jak_carbon_field_type_e type, jak_error *err)
{
        switch (type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                        return JAK_CARBON_FIELD_CLASS_CONSTANT;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        return JAK_CARBON_FIELD_CLASS_CONTAINER;
                case JAK_CARBON_FIELD_TYPE_STRING:
                        return JAK_CARBON_FIELD_CLASS_CHARACTER_STRING;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        return JAK_CARBON_FIELD_CLASS_NUMBER;
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        return JAK_CARBON_FIELD_CLASS_BINARY_STRING;
                default: JAK_ERROR(err, JAK_ERR_INTERNALERR);
                        return 0;
        }
}

bool jak_carbon_field_type_is_array(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_ARRAY);
}

bool jak_carbon_field_type_is_column(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_COLUMN_U8 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_U16 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_U32 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_U64 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_I8 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_I16 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_I32 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_I64 ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT ||
                type == JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN);
}

bool jak_carbon_field_type_is_object(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_OBJECT);
}

bool jak_carbon_field_type_is_null(jak_carbon_field_type_e type)
{
        return (type == JAK_CARBON_FIELD_TYPE_NULL);
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_carbon_dot.h>
#include <jak_carbon_find.h>
#include "jak_carbon_find.h"

static void result_from_array(jak_carbon_find *find, jak_carbon_array_it *it);

static void result_from_object(jak_carbon_find *find, jak_carbon_object_it *it);

static inline bool
result_from_column(jak_carbon_find *find, jak_u32 requested_idx, jak_carbon_column_it *it);

bool jak_carbon_find_open(jak_carbon_find *out, const char *dot_path, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(out)
        JAK_ERROR_IF_NULL(dot_path)
        JAK_ERROR_IF_NULL(doc)
        jak_carbon_dot_path path;
        jak_carbon_dot_path_from_string(&path, dot_path);
        jak_carbon_find_create(out, &path, doc);
        jak_carbon_dot_path_drop(&path);
        return true;
}

bool jak_carbon_find_close(jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        if (jak_carbon_find_has_result(find)) {
                jak_carbon_field_type_e type;
                jak_carbon_find_result_type(&type, find);
                switch (type) {
                        case JAK_CARBON_FIELD_TYPE_OBJECT:
                                jak_carbon_object_it_drop(find->value.object_it);
                                break;
                        case JAK_CARBON_FIELD_TYPE_ARRAY:
                                jak_carbon_array_it_drop(find->value.array_it);
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                                break;
                        default:
                                break;
                }
                return jak_carbon_find_drop(find);
        }
        return true;
}

bool jak_carbon_find_create(jak_carbon_find *find, jak_carbon_dot_path *path, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF_NULL(path)
        JAK_ERROR_IF_NULL(doc)

        JAK_ZERO_MEMORY(find, sizeof(jak_carbon_find));
        jak_error_init(&find->err);
        find->doc = doc;

        JAK_CHECK_SUCCESS(jak_carbon_path_evaluator_begin(&find->path_evaluater, path, doc));
        if (jak_carbon_path_evaluator_has_result(&find->path_evaluater)) {
                switch (find->path_evaluater.result.container_type) {
                        case JAK_CARBON_ARRAY:
                                result_from_array(find, &find->path_evaluater.result.containers.array.it);
                                break;
                        case JAK_CARBON_COLUMN:
                                result_from_column(find, find->path_evaluater.result.containers.column.elem_pos,
                                                   &find->path_evaluater.result.containers.column.it);
                                break;
                        case JAK_CARBON_OBJECT:
                                result_from_object(find, &find->path_evaluater.result.containers.object.it);
                                break;
                        default: JAK_ERROR(&path->err, JAK_ERR_INTERNALERR);
                                return false;
                }
        }
        return true;
}

bool jak_carbon_find_has_result(jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        return jak_carbon_path_evaluator_has_result(&find->path_evaluater);
}

const char *
jak_carbon_find_result_to_str(jak_string *dst_str, jak_carbon_printer_impl_e print_type, jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(dst_str)
        JAK_ERROR_IF_NULL(find)

        jak_string_clear(dst_str);

        jak_carbon_printer printer;
        jak_carbon_printer_by_type(&printer, print_type);

        if (jak_carbon_find_has_result(find)) {
                jak_carbon_field_type_e result_type;
                jak_carbon_find_result_type(&result_type, find);
                switch (result_type) {
                        case JAK_CARBON_FIELD_TYPE_NULL:
                                jak_carbon_printer_null(&printer, dst_str);
                                break;
                        case JAK_CARBON_FIELD_TYPE_TRUE:
                                jak_carbon_printer_true(&printer, false, dst_str);
                                break;
                        case JAK_CARBON_FIELD_TYPE_FALSE:
                                jak_carbon_printer_false(&printer, false, dst_str);
                                break;
                        case JAK_CARBON_FIELD_TYPE_OBJECT: {
                                jak_carbon_object_it *sub_it = jak_carbon_find_result_object(find);
                                jak_carbon_printer_print_object(sub_it, &printer, dst_str);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_ARRAY: {
                                jak_carbon_array_it *sub_it = jak_carbon_find_result_array(find);
                                jak_carbon_printer_print_array(sub_it, &printer, dst_str, false);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                                jak_carbon_column_it *sub_it = jak_carbon_find_result_column(find);
                                jak_carbon_printer_print_column(sub_it, &printer, dst_str);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_STRING: {
                                jak_u64 str_len = 0;
                                const char *str = jak_carbon_find_result_string(&str_len, find);
                                jak_carbon_printer_string(&printer, dst_str, str, str_len);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U8: {
                                jak_u64 val = 0;
                                jak_carbon_find_result_unsigned(&val, find);
                                jak_carbon_printer_u8_or_null(&printer, dst_str, (jak_u8) val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U16: {
                                jak_u64 val = 0;
                                jak_carbon_find_result_unsigned(&val, find);
                                jak_carbon_printer_u16_or_null(&printer, dst_str, (jak_u16) val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U32: {
                                jak_u64 val = 0;
                                jak_carbon_find_result_unsigned(&val, find);
                                jak_carbon_printer_u32_or_null(&printer, dst_str, (jak_u32) val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U64: {
                                jak_u64 val = 0;
                                jak_carbon_find_result_unsigned(&val, find);
                                jak_carbon_printer_u64_or_null(&printer, dst_str, (jak_u64) val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I8: {
                                jak_i64 val = 0;
                                jak_carbon_find_result_signed(&val, find);
                                jak_carbon_printer_i8_or_null(&printer, dst_str, (jak_i8) val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I16: {
                                jak_i64 val = 0;
                                jak_carbon_find_result_signed(&val, find);
                                jak_carbon_printer_i16_or_null(&printer, dst_str, (jak_i16) val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I32: {
                                jak_i64 val = 0;
                                jak_carbon_find_result_signed(&val, find);
                                jak_carbon_printer_i32_or_null(&printer, dst_str, (jak_i32) val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I64: {
                                jak_i64 val = 0;
                                jak_carbon_find_result_signed(&val, find);
                                jak_carbon_printer_i64_or_null(&printer, dst_str, (jak_i64) val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT: {
                                float val = 0;
                                jak_carbon_find_result_float(&val, find);
                                jak_carbon_printer_float(&printer, dst_str, &val);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_BINARY:
                        case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM: {
                                const jak_carbon_binary *val = jak_carbon_find_result_binary(find);
                                jak_carbon_printer_binary(&printer, dst_str, val);
                        }
                                break;
                        default: JAK_ERROR(&find->err, JAK_ERR_INTERNALERR)
                                return NULL;
                }

        } else {
                jak_string_add(dst_str, JAK_CARBON_NIL_STR);
        }
        jak_carbon_printer_drop(&printer);

        return jak_string_cstr(dst_str);
}

const char *jak_carbon_find_result_to_json_compact(jak_string *dst_str, jak_carbon_find *find)
{
        return jak_carbon_find_result_to_str(dst_str, JAK_JSON_COMPACT, find);
}

char *jak_carbon_find_result_to_json_compact_dup(jak_carbon_find *find)
{
        jak_string str;
        jak_string_create(&str);
        char *ret = strdup(jak_carbon_find_result_to_json_compact(&str, find));
        jak_string_drop(&str);
        return ret;
}

bool jak_carbon_find_result_type(jak_carbon_field_type_e *type, jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(type)
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        *type = find->type;
        return true;
}

jak_carbon_array_it *jak_carbon_find_result_array(jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(find->type != JAK_CARBON_FIELD_TYPE_ARRAY, &find->err, JAK_ERR_TYPEMISMATCH)
        return find->value.array_it;
}

jak_carbon_object_it *jak_carbon_find_result_object(jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(find->type != JAK_CARBON_FIELD_TYPE_OBJECT, &find->err, JAK_ERR_TYPEMISMATCH)
        return find->value.object_it;
}

jak_carbon_column_it *jak_carbon_find_result_column(jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(find->type != JAK_CARBON_FIELD_TYPE_COLUMN_U8 &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_U16 &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_U32 &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_U64 &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_I8 &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_I16 &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_I32 &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_I64 &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT &&
                 find->type != JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN, &find->err, JAK_ERR_TYPEMISMATCH)
        return find->value.column_it;
}

bool jak_carbon_find_result_boolean(bool *out, jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(!jak_carbon_field_type_is_boolean(find->type), &find->err, JAK_ERR_TYPEMISMATCH)
        *out = find->value.boolean;
        return true;
}

bool jak_carbon_find_result_unsigned(jak_u64 *out, jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(!jak_carbon_field_type_is_unsigned(find->type), &find->err, JAK_ERR_TYPEMISMATCH)
        *out = find->value.unsigned_number;
        return true;
}

bool jak_carbon_find_result_signed(jak_i64 *out, jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(!jak_carbon_field_type_is_signed(find->type), &find->err, JAK_ERR_TYPEMISMATCH)
        *out = find->value.signed_number;
        return true;
}

bool jak_carbon_find_result_float(float *out, jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(!jak_carbon_field_type_is_floating(find->type), &find->err, JAK_ERR_TYPEMISMATCH)
        *out = find->value.float_number;
        return true;
}

const char *jak_carbon_find_result_string(jak_u64 *str_len, jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF_NULL(str_len)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(find->type != JAK_CARBON_FIELD_TYPE_STRING, &find->err, JAK_ERR_TYPEMISMATCH)
        *str_len = find->value.string.len;
        return find->value.string.base;
}

jak_carbon_binary *jak_carbon_find_result_binary(jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        JAK_ERROR_IF(!jak_carbon_path_evaluator_has_result(&find->path_evaluater), &find->err, JAK_ERR_ILLEGALSTATE)
        JAK_ERROR_IF(!jak_carbon_field_type_is_binary(find->type), &find->err, JAK_ERR_TYPEMISMATCH)
        return &find->value.binary;
}

bool jak_carbon_find_drop(jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        jak_carbon_path_evaluator_end(&find->path_evaluater);
        return true;
}

static void result_from_array(jak_carbon_find *find, jak_carbon_array_it *it)
{
        find->type = it->field_access.it_field_type;
        switch (find->type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                        /* no value to be stored */
                        break;
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                        find->value.array_it = jak_carbon_array_it_array_value(it);
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        find->value.column_it = jak_carbon_array_it_column_value(it);
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                        find->value.object_it = jak_carbon_array_it_object_value(it);
                        break;
                case JAK_CARBON_FIELD_TYPE_STRING:
                        find->value.string.base = jak_carbon_array_it_jak_string_value(&find->value.string.len, it);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                        jak_carbon_array_it_unsigned_value(&find->value_is_nulled, &find->value.unsigned_number, it);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                        jak_carbon_array_it_signed_value(&find->value_is_nulled, &find->value.signed_number, it);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        jak_carbon_array_it_float_value(&find->value_is_nulled, &find->value.float_number, it);
                        break;
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        jak_carbon_array_it_binary_value(&find->value.binary, it);
                        break;
                default: JAK_ERROR(&find->err, JAK_ERR_INTERNALERR);
                        break;
        }
}

static void result_from_object(jak_carbon_find *find, jak_carbon_object_it *it)
{
        jak_carbon_object_it_prop_type(&find->type, it);
        switch (find->type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                        /* no value to be stored */
                        break;
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                        find->value.array_it = jak_carbon_object_it_array_value(it);
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        find->value.column_it = jak_carbon_object_it_column_value(it);
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                        find->value.object_it = jak_carbon_object_it_object_value(it);
                        break;
                case JAK_CARBON_FIELD_TYPE_STRING:
                        find->value.string.base = jak_carbon_object_it_jak_string_value(&find->value.string.len, it);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                        jak_carbon_object_it_unsigned_value(&find->value_is_nulled, &find->value.unsigned_number, it);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                        jak_carbon_object_it_signed_value(&find->value_is_nulled, &find->value.signed_number, it);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        jak_carbon_object_it_float_value(&find->value_is_nulled, &find->value.float_number, it);
                        break;
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        jak_carbon_object_it_binary_value(&find->value.binary, it);
                        break;
                default: JAK_ERROR(&find->err, JAK_ERR_INTERNALERR);
                        break;
        }
}

static inline bool
result_from_column(jak_carbon_find *find, jak_u32 requested_idx, jak_carbon_column_it *it)
{
        jak_u32 num_contained_values;
        jak_carbon_column_it_values_info(&find->type, &num_contained_values, it);
        JAK_ASSERT(requested_idx < num_contained_values);

        switch (find->type) {
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                        jak_u8 field_value = jak_carbon_column_it_boolean_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_BOOLEAN(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else if (field_value == JAK_CARBON_BOOLEAN_COLUMN_TRUE) {
                                find->type = JAK_CARBON_FIELD_TYPE_TRUE;
                        } else if (field_value == JAK_CARBON_BOOLEAN_COLUMN_FALSE) {
                                find->type = JAK_CARBON_FIELD_TYPE_FALSE;
                        } else {
                                JAK_ERROR(&it->err, JAK_ERR_INTERNALERR);
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8: {
                        jak_u8 field_value = jak_carbon_column_it_u8_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_U8(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_U8;
                                find->value.unsigned_number = jak_carbon_column_it_u8_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16: {
                        jak_u16 field_value = jak_carbon_column_it_u16_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_U16(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_U16;
                                find->value.unsigned_number = jak_carbon_column_it_u16_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32: {
                        jak_u32 field_value = jak_carbon_column_it_u32_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_U32(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_U32;
                                find->value.unsigned_number = jak_carbon_column_it_u32_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64: {
                        jak_u64 field_value = jak_carbon_column_it_u64_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_U64(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_U64;
                                find->value.unsigned_number = jak_carbon_column_it_u64_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8: {
                        jak_i8 field_value = jak_carbon_column_it_i8_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_I8(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_I8;
                                find->value.signed_number = jak_carbon_column_it_i8_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16: {
                        jak_i16 field_value = jak_carbon_column_it_i16_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_I16(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_I16;
                                find->value.signed_number = jak_carbon_column_it_i16_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32: {
                        jak_i32 field_value = jak_carbon_column_it_i32_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_I32(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_I32;
                                find->value.signed_number = jak_carbon_column_it_i32_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64: {
                        jak_i64 field_value = jak_carbon_column_it_i64_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_I64(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_I64;
                                find->value.signed_number = jak_carbon_column_it_i64_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT: {
                        float field_value = jak_carbon_column_it_float_values(NULL, it)[requested_idx];
                        if (JAK_IS_NULL_FLOAT(field_value)) {
                                find->type = JAK_CARBON_FIELD_TYPE_NULL;
                        } else {
                                find->type = JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT;
                                find->value.float_number = jak_carbon_column_it_float_values(NULL, it)[requested_idx];
                        }
                }
                        break;
                default: JAK_ERROR(&it->err, JAK_ERR_UNSUPPORTEDTYPE)
                        return false;
        }
        return true;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file implements the document format itself
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon_get.h>
#include <jak_carbon_find.h>

#define get_or_default(doc, path, type_name, default_val, test_fn, get_fn)                                             \
({                                                                                                                     \
        jak_carbon_find find;                                                                                        \
        jak_carbon_field_type_e field_type;                                                                              \
        type_name result = default_val;                                                                                \
                                                                                                                       \
        if (jak_carbon_find_open(&find, path, doc)) {                                                                       \
                jak_carbon_find_result_type(&field_type, &find);                                                            \
                if (test_fn(field_type)) {                                                                             \
                        get_fn(&result, &find);                                                                        \
                }                                                                                                      \
        }                                                                                                              \
                                                                                                                       \
        jak_carbon_find_close(&find);                                                                                       \
        result;                                                                                                        \
})


jak_u64 jak_carbon_get_or_default_unsigned(jak_carbon *doc, const char *path, jak_u64 default_val)
{
        return get_or_default(doc, path, jak_u64, default_val, jak_carbon_field_type_is_unsigned,
                              jak_carbon_find_result_unsigned);
}

jak_i64 jak_carbon_get_or_default_signed(jak_carbon *doc, const char *path, jak_i64 default_val)
{
        return get_or_default(doc, path, jak_i64, default_val, jak_carbon_field_type_is_signed,
                              jak_carbon_find_result_signed);
}

float jak_carbon_get_or_default_float(jak_carbon *doc, const char *path, float default_val)
{
        return get_or_default(doc, path, float, default_val, jak_carbon_field_type_is_floating,
                              jak_carbon_find_result_float);
}

bool jak_carbon_get_or_default_boolean(jak_carbon *doc, const char *path, bool default_val)
{
        return get_or_default(doc, path, bool, default_val, jak_carbon_field_type_is_boolean, jak_carbon_find_result_boolean);
}

const char *
jak_carbon_get_or_default_string(jak_u64 *len_out, jak_carbon *doc, const char *path, const char *default_val)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        const char *result = default_val;
        *len_out = result ? strlen(default_val) : 0;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                if (jak_carbon_field_type_is_string(field_type)) {
                        result = jak_carbon_find_result_string(len_out, &find);
                }
        }

        jak_carbon_find_close(&find);
        return result;
}

jak_carbon_binary *
jak_carbon_get_or_default_binary(jak_carbon *doc, const char *path, jak_carbon_binary *default_val)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        jak_carbon_binary *result = default_val;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                if (jak_carbon_field_type_is_binary(field_type)) {
                        result = jak_carbon_find_result_binary(&find);
                }
        }

        jak_carbon_find_close(&find);
        return result;
}

jak_carbon_array_it *carbon_get_array_or_null(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        jak_carbon_array_it *result = NULL;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                if (jak_carbon_field_type_is_array(field_type)) {
                        result = jak_carbon_find_result_array(&find);
                }
        }

        jak_carbon_find_close(&find);
        return result;
}

jak_carbon_column_it *carbon_get_column_or_null(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        jak_carbon_column_it *result = NULL;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                if (jak_carbon_field_type_is_column(field_type)) {
                        result = jak_carbon_find_result_column(&find);
                }
        }

        jak_carbon_find_close(&find);
        return result;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_uintvar_stream.h>
#include <jak_carbon_array_it.h>
#include <jak_carbon_column_it.h>
#include <jak_carbon_insert.h>
#include <jak_carbon_media.h>
#include <jak_carbon_int.h>
#include <jak_carbon_string.h>
#include <jak_carbon_object_it.h>
#include <jak_carbon_int.h>
#include <jak_utils_numbers.h>

#define check_type_if_container_is_column(inserter, expected)                                                          \
if (JAK_UNLIKELY(inserter->context_type == JAK_CARBON_COLUMN && inserter->context.column->type != expected)) {                 \
        JAK_ERROR_WDETAILS(&inserter->err, JAK_ERR_TYPEMISMATCH, "Element type does not match container type");        \
}

#define check_type_range_if_container_is_column(inserter, expected1, expected2, expected3)                             \
if (JAK_UNLIKELY(inserter->context_type == JAK_CARBON_COLUMN && inserter->context.column->type != expected1 &&                 \
        inserter->context.column->type != expected2 && inserter->context.column->type != expected3)) {                 \
        JAK_ERROR_WDETAILS(&inserter->err, JAK_ERR_TYPEMISMATCH, "Element type does not match container type");        \
}

static bool
write_field_data(jak_carbon_insert *inserter, jak_u8 field_type_marker, const void *base, jak_u64 nbytes);

static bool push_in_column(jak_carbon_insert *inserter, const void *base, jak_carbon_field_type_e type);

static bool push_media_type_for_array(jak_carbon_insert *inserter, jak_carbon_field_type_e type);

static void internal_create(jak_carbon_insert *inserter, jak_memfile *src, jak_offset_t pos);

static void write_binary_blob(jak_carbon_insert *inserter, const void *value, size_t nbytes);

bool jak_carbon_int_insert_create_for_array(jak_carbon_insert *inserter, jak_carbon_array_it *context)
{
        JAK_ERROR_IF_NULL(inserter)
        JAK_ERROR_IF_NULL(context)
        jak_carbon_array_it_lock(context);
        inserter->context_type = JAK_CARBON_ARRAY;
        inserter->context.array = context;
        inserter->position = 0;

        jak_offset_t pos = 0;
        if (context->array_end_reached) {
                pos = jak_memfile_tell(&context->memfile);
        } else {
                pos = jak_carbon_int_history_has(&context->history) ? jak_carbon_int_history_peek(&context->history) : 0;
        }

        internal_create(inserter, &context->memfile, pos);
        return true;
}

bool jak_carbon_int_insert_create_for_column(jak_carbon_insert *inserter, jak_carbon_column_it *context)
{
        JAK_ERROR_IF_NULL(inserter)
        JAK_ERROR_IF_NULL(context)
        jak_carbon_column_it_lock(context);
        inserter->context_type = JAK_CARBON_COLUMN;
        inserter->context.column = context;
        internal_create(inserter, &context->memfile, jak_memfile_tell(&context->memfile));
        return true;
}

bool jak_carbon_int_insert_create_for_object(jak_carbon_insert *inserter, jak_carbon_object_it *context)
{
        JAK_ERROR_IF_NULL(inserter)
        JAK_ERROR_IF_NULL(context)
        jak_carbon_object_it_lock(context);
        inserter->context_type = JAK_CARBON_OBJECT;
        inserter->context.object = context;

        jak_offset_t pos;
        if (context->object_end_reached) {
                pos = jak_memfile_tell(&context->memfile);
        } else {
                pos = jak_carbon_int_history_has(&context->history) ? jak_carbon_int_history_peek(&context->history) : 0;
        }

        internal_create(inserter, &context->memfile, pos);
        return true;
}

bool jak_carbon_insert_null(jak_carbon_insert *inserter)
{
        if (JAK_UNLIKELY(inserter->context_type == JAK_CARBON_COLUMN &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_U8 &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_U16 &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_U32 &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_U64 &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_I8 &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_I16 &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_I32 &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_I64 &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT &&
                         inserter->context.column->type != JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN)) {
                JAK_ERROR_WDETAILS(&inserter->err, JAK_ERR_TYPEMISMATCH, "Element type does not match container type");
        }

        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        return push_media_type_for_array(inserter, JAK_CARBON_FIELD_TYPE_NULL);
                case JAK_CARBON_COLUMN: {
                        switch (inserter->context.column->type) {
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U8: {
                                        jak_u8 value = JAK_U8_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U16: {
                                        jak_u16 value = JAK_U16_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U32: {
                                        jak_u32 value = JAK_U32_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U64: {
                                        jak_u64 value = JAK_U64_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I8: {
                                        jak_i8 value = JAK_I8_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I16: {
                                        jak_i16 value = JAK_I16_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I32: {
                                        jak_i32 value = JAK_I32_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I64: {
                                        jak_i64 value = JAK_I64_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT: {
                                        float value = JAK_FLOAT_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                                        jak_u8 value = JAK_CARBON_BOOLEAN_COLUMN_NULL;
                                        return push_in_column(inserter, &value, inserter->context.column->type);
                                }
                                        break;
                                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR)
                                        return false;
                        }
                }
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_insert_true(jak_carbon_insert *inserter)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        return push_media_type_for_array(inserter, JAK_CARBON_FIELD_TYPE_TRUE);
                case JAK_CARBON_COLUMN: {
                        jak_u8 value = JAK_CARBON_BOOLEAN_COLUMN_TRUE;
                        return push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN);
                }
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_insert_false(jak_carbon_insert *inserter)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        return push_media_type_for_array(inserter, JAK_CARBON_FIELD_TYPE_FALSE);
                case JAK_CARBON_COLUMN: {
                        jak_u8 value = JAK_CARBON_BOOLEAN_COLUMN_FALSE;
                        return push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN);
                }
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_insert_u8(jak_carbon_insert *inserter, jak_u8 value)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_U8);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_U8, &value, sizeof(jak_u8));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_U8);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_u16(jak_carbon_insert *inserter, jak_u16 value)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_U16);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_U16, &value, sizeof(jak_u16));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_U16);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_u32(jak_carbon_insert *inserter, jak_u32 value)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_U32);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_U32, &value, sizeof(jak_u32));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_U32);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_u64(jak_carbon_insert *inserter, jak_u64 value)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_U64);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_U64, &value, sizeof(jak_u64));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_U64);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_i8(jak_carbon_insert *inserter, jak_i8 value)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_I8);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_I8, &value, sizeof(jak_i8));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_I8);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_i16(jak_carbon_insert *inserter, jak_i16 value)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_I16);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_I16, &value, sizeof(jak_i16));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_I16);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_i32(jak_carbon_insert *inserter, jak_i32 value)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_I32);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_I32, &value, sizeof(jak_i32));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_I32);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_i64(jak_carbon_insert *inserter, jak_i64 value)
{
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_I64);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_I64, &value, sizeof(jak_i64));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_I64);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_unsigned(jak_carbon_insert *inserter, jak_u64 value)
{
        JAK_ERROR_IF(inserter->context_type == JAK_CARBON_COLUMN, &inserter->err, JAK_ERR_INSERT_TOO_DANGEROUS)

        switch (jak_number_min_type_signed(value)) {
                case JAK_NUMBER_I8:
                        return jak_carbon_insert_u8(inserter, (jak_u8) value);
                case JAK_NUMBER_I16:
                        return jak_carbon_insert_u16(inserter, (jak_u16) value);
                case JAK_NUMBER_I32:
                        return jak_carbon_insert_u32(inserter, (jak_u32) value);
                case JAK_NUMBER_I64:
                        return jak_carbon_insert_u64(inserter, (jak_u64) value);
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_insert_signed(jak_carbon_insert *inserter, jak_i64 value)
{
        JAK_ERROR_IF(inserter->context_type == JAK_CARBON_COLUMN, &inserter->err, JAK_ERR_INSERT_TOO_DANGEROUS)

        switch (jak_number_min_type_signed(value)) {
                case JAK_NUMBER_I8:
                        return jak_carbon_insert_i8(inserter, (jak_i8) value);
                case JAK_NUMBER_I16:
                        return jak_carbon_insert_i16(inserter, (jak_i16) value);
                case JAK_NUMBER_I32:
                        return jak_carbon_insert_i32(inserter, (jak_i32) value);
                case JAK_NUMBER_I64:
                        return jak_carbon_insert_i64(inserter, (jak_i64) value);
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_insert_float(jak_carbon_insert *inserter, float value)
{
        JAK_ERROR_IF_NULL(inserter)
        check_type_if_container_is_column(inserter, JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT);
        switch (inserter->context_type) {
                case JAK_CARBON_ARRAY:
                        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT, &value, sizeof(float));
                        break;
                case JAK_CARBON_COLUMN:
                        push_in_column(inserter, &value, JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT);
                        break;
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
        return true;
}

bool jak_carbon_insert_string(jak_carbon_insert *inserter, const char *value)
{
        return jak_carbon_insert_nchar(inserter, value, strlen(value));
}

bool jak_carbon_insert_nchar(jak_carbon_insert *inserter, const char *value, jak_u64 value_len)
{
        JAK_UNUSED(inserter);
        JAK_UNUSED(value);
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_ARRAY, &inserter->err, JAK_ERR_UNSUPPCONTAINER);

        return jak_carbon_jak_string_nchar_write(&inserter->memfile, value, value_len);
}

static void insert_binary(jak_carbon_insert *inserter, const void *value, size_t nbytes,
                          const char *file_ext, const char *user_type)
{
        if (user_type && strlen(user_type) > 0) {
                /* write media type 'user binary' */
                push_media_type_for_array(inserter, JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM);

                /* write length of 'user_type' string with variable-length integer type */
                jak_u64 user_type_strlen = strlen(user_type);

                jak_memfile_write_uintvar_stream(NULL, &inserter->memfile, user_type_strlen);

                /* write 'user_type' string */
                jak_memfile_ensure_space(&inserter->memfile, user_type_strlen);
                jak_memfile_write(&inserter->memfile, user_type, user_type_strlen);

                /* write binary blob */
                write_binary_blob(inserter, value, nbytes);

        } else {
                /* write media type 'binary' */
                push_media_type_for_array(inserter, JAK_CARBON_FIELD_TYPE_BINARY);

                /* write mime type with variable-length integer type */
                jak_u64 mime_type_id = jak_carbon_media_mime_type_by_ext(file_ext);

                /* write mime type id */
                jak_memfile_write_uintvar_stream(NULL, &inserter->memfile, mime_type_id);

                /* write binary blob */
                write_binary_blob(inserter, value, nbytes);
        }
}

bool jak_carbon_insert_binary(jak_carbon_insert *inserter, const void *value, size_t nbytes,
                          const char *file_ext, const char *user_type)
{
        JAK_ERROR_IF_NULL(inserter)
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_ARRAY, &inserter->err, JAK_ERR_UNSUPPCONTAINER);

        insert_binary(inserter, value, nbytes, file_ext, user_type);

        return true;
}

jak_carbon_insert *jak_carbon_insert_object_begin(jak_carbon_insert_object_state *out,
                                                     jak_carbon_insert *inserter, jak_u64 object_capacity)
{
        JAK_ERROR_IF_NULL(out)
        JAK_ERROR_IF_NULL(inserter)

        JAK_ERROR_IF_AND_RETURN(!out, &inserter->err, JAK_ERR_NULLPTR, NULL);
        if (!inserter) {
                JAK_ERROR_PRINT(JAK_ERR_NULLPTR);
                return false;
        }

        *out = (jak_carbon_insert_object_state) {
                .parent_inserter = inserter,
                .it = JAK_MALLOC(sizeof(jak_carbon_object_it)),
                .object_begin = jak_memfile_tell(&inserter->memfile),
                .object_end = 0
        };


        jak_carbon_int_insert_object(&inserter->memfile, object_capacity);
        jak_u64 payload_start = jak_memfile_tell(&inserter->memfile) - 1;

        jak_carbon_object_it_create(out->it, &inserter->memfile, &inserter->err, payload_start);
        jak_carbon_object_it_insert_begin(&out->inserter, out->it);

        return &out->inserter;
}

bool jak_carbon_insert_object_end(jak_carbon_insert_object_state *state)
{
        JAK_ERROR_IF_NULL(state);

        jak_carbon_object_it scan;
        jak_carbon_object_it_create(&scan, &state->parent_inserter->memfile, &state->parent_inserter->err,
                                jak_memfile_tell(&state->parent_inserter->memfile) - 1);
        while (jak_carbon_object_it_next(&scan)) {}

        JAK_ASSERT(*jak_memfile_peek(&scan.memfile, sizeof(char)) == JAK_CARBON_MARKER_OBJECT_END);
        jak_memfile_read(&scan.memfile, sizeof(char));

        state->object_end = jak_memfile_tell(&scan.memfile);

        jak_memfile_skip(&scan.memfile, 1);

        jak_memfile_seek(&state->parent_inserter->memfile, jak_memfile_tell(&scan.memfile) - 1);
        jak_carbon_object_it_drop(&scan);
        jak_carbon_insert_drop(&state->inserter);
        jak_carbon_object_it_drop(state->it);
        free(state->it);
        return true;
}

jak_carbon_insert *jak_carbon_insert_array_begin(jak_carbon_insert_array_state *state_out,
                                                    jak_carbon_insert *inserter_in, jak_u64 array_capacity)
{
        JAK_ERROR_IF_AND_RETURN(!state_out, &inserter_in->err, JAK_ERR_NULLPTR, NULL);
        if (!inserter_in) {
                JAK_ERROR_PRINT(JAK_ERR_NULLPTR);
                return false;
        }

        JAK_ERROR_IF(inserter_in->context_type != JAK_CARBON_ARRAY && inserter_in->context_type != JAK_CARBON_OBJECT,
                 &inserter_in->err, JAK_ERR_UNSUPPCONTAINER);

        *state_out = (jak_carbon_insert_array_state) {
                .parent_inserter = inserter_in,
                .nested_array = JAK_MALLOC(sizeof(jak_carbon_array_it)),
                .array_begin = jak_memfile_tell(&inserter_in->memfile),
                .array_end = 0
        };

        jak_carbon_int_insert_array(&inserter_in->memfile, array_capacity);
        jak_u64 payload_start = jak_memfile_tell(&inserter_in->memfile) - 1;

        jak_carbon_array_it_create(state_out->nested_array, &inserter_in->memfile, &inserter_in->err, payload_start);
        jak_carbon_array_it_insert_begin(&state_out->nested_inserter, state_out->nested_array);

        return &state_out->nested_inserter;
}

bool jak_carbon_insert_array_end(jak_carbon_insert_array_state *state_in)
{
        JAK_ERROR_IF_NULL(state_in);

        jak_carbon_array_it scan;
        jak_carbon_array_it_create(&scan, &state_in->parent_inserter->memfile, &state_in->parent_inserter->err,
                               jak_memfile_tell(&state_in->parent_inserter->memfile) - 1);

        jak_carbon_array_it_fast_forward(&scan);

        state_in->array_end = jak_memfile_tell(&scan.memfile);
        jak_memfile_skip(&scan.memfile, 1);

        jak_memfile_seek(&state_in->parent_inserter->memfile, jak_memfile_tell(&scan.memfile) - 1);
        jak_carbon_array_it_drop(&scan);
        jak_carbon_insert_drop(&state_in->nested_inserter);
        jak_carbon_array_it_drop(state_in->nested_array);
        free(state_in->nested_array);
        return true;
}

jak_carbon_insert *jak_carbon_insert_column_begin(jak_carbon_insert_column_state *state_out,
                                                     jak_carbon_insert *inserter_in,
                                                     jak_carbon_column_type_e type,
                                                     jak_u64 column_capacity)
{
        JAK_ERROR_IF_AND_RETURN(!state_out, &inserter_in->err, JAK_ERR_NULLPTR, NULL);
        JAK_ERROR_IF_AND_RETURN(!inserter_in, &inserter_in->err, JAK_ERR_NULLPTR, NULL);
        JAK_ERROR_IF(inserter_in->context_type != JAK_CARBON_ARRAY && inserter_in->context_type != JAK_CARBON_OBJECT,
                 &inserter_in->err, JAK_ERR_UNSUPPCONTAINER);

        jak_carbon_field_type_e field_type = jak_carbon_field_type_for_column(type);

        *state_out = (jak_carbon_insert_column_state) {
                .parent_inserter = inserter_in,
                .nested_column = JAK_MALLOC(sizeof(jak_carbon_column_it)),
                .type = field_type,
                .column_begin = jak_memfile_tell(&inserter_in->memfile),
                .column_end = 0
        };

        jak_u64 container_start_off = jak_memfile_tell(&inserter_in->memfile);
        jak_carbon_int_insert_column(&inserter_in->memfile, &inserter_in->err, type, column_capacity);

        jak_carbon_column_it_create(state_out->nested_column, &inserter_in->memfile, &inserter_in->err,
                                container_start_off);
        jak_carbon_column_it_insert(&state_out->nested_inserter, state_out->nested_column);

        return &state_out->nested_inserter;
}

bool jak_carbon_insert_column_end(jak_carbon_insert_column_state *state_in)
{
        JAK_ERROR_IF_NULL(state_in);

        jak_carbon_column_it scan;
        jak_carbon_column_it_create(&scan, &state_in->parent_inserter->memfile, &state_in->parent_inserter->err,
                                state_in->nested_column->column_start_offset);
        jak_carbon_column_it_fast_forward(&scan);

        state_in->column_end = jak_memfile_tell(&scan.memfile);
        jak_memfile_seek(&state_in->parent_inserter->memfile, jak_memfile_tell(&scan.memfile));

        jak_carbon_insert_drop(&state_in->nested_inserter);
        free(state_in->nested_column);
        return true;
}

static void inserter_refresh_mod_size(jak_carbon_insert *inserter, jak_i64 mod_size)
{
        JAK_ASSERT(mod_size > 0);

        jak_i64 *target = NULL;
        switch (inserter->context_type) {
                case JAK_CARBON_OBJECT:
                        target = &inserter->context.object->mod_size;
                        break;
                case JAK_CARBON_ARRAY:
                        target = &inserter->context.array->mod_size;
                        break;
                case JAK_CARBON_COLUMN:
                        target = &inserter->context.column->mod_size;
                        break;
                default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPCONTAINER);
        }
        *target += mod_size;
}

bool jak_carbon_insert_prop_null(jak_carbon_insert *inserter, const char *key)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        push_media_type_for_array(inserter, JAK_CARBON_FIELD_TYPE_NULL);
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_true(jak_carbon_insert *inserter, const char *key)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        push_media_type_for_array(inserter, JAK_CARBON_FIELD_TYPE_TRUE);
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_false(jak_carbon_insert *inserter, const char *key)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        push_media_type_for_array(inserter, JAK_CARBON_FIELD_TYPE_FALSE);
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_u8(jak_carbon_insert *inserter, const char *key, jak_u8 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_U8, &value, sizeof(jak_u8));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_u16(jak_carbon_insert *inserter, const char *key, jak_u16 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_U16, &value, sizeof(jak_u16));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_u32(jak_carbon_insert *inserter, const char *key, jak_u32 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_U32, &value, sizeof(jak_u32));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_u64(jak_carbon_insert *inserter, const char *key, jak_u64 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_U64, &value, sizeof(jak_u64));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_i8(jak_carbon_insert *inserter, const char *key, jak_i8 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_I8, &value, sizeof(jak_i8));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_i16(jak_carbon_insert *inserter, const char *key, jak_i16 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_I16, &value, sizeof(jak_i16));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_i32(jak_carbon_insert *inserter, const char *key, jak_i32 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_I32, &value, sizeof(jak_i32));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_i64(jak_carbon_insert *inserter, const char *key, jak_i64 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_I64, &value, sizeof(jak_i64));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_unsigned(jak_carbon_insert *inserter, const char *key, jak_u64 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER)

        switch (jak_number_min_type_unsigned(value)) {
                case JAK_NUMBER_U8:
                        return jak_carbon_insert_prop_u8(inserter, key, (jak_u8) value);
                case JAK_NUMBER_U16:
                        return jak_carbon_insert_prop_u16(inserter, key, (jak_u16) value);
                case JAK_NUMBER_U32:
                        return jak_carbon_insert_prop_u32(inserter, key, (jak_u32) value);
                case JAK_NUMBER_U64:
                        return jak_carbon_insert_prop_u64(inserter, key, (jak_u64) value);
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_insert_prop_signed(jak_carbon_insert *inserter, const char *key, jak_i64 value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER)

        switch (jak_number_min_type_signed(value)) {
                case JAK_NUMBER_I8:
                        return jak_carbon_insert_prop_i8(inserter, key, (jak_i8) value);
                case JAK_NUMBER_I16:
                        return jak_carbon_insert_prop_i16(inserter, key, (jak_i16) value);
                case JAK_NUMBER_I32:
                        return jak_carbon_insert_prop_i32(inserter, key, (jak_i32) value);
                case JAK_NUMBER_I64:
                        return jak_carbon_insert_prop_i64(inserter, key, (jak_i64) value);
                default: JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_insert_prop_float(jak_carbon_insert *inserter, const char *key, float value)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        write_field_data(inserter, JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT, &value, sizeof(float));
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_string(jak_carbon_insert *inserter, const char *key, const char *value)
{
        return jak_carbon_insert_prop_nchar(inserter, key, value, strlen(value));
}

bool jak_carbon_insert_prop_nchar(jak_carbon_insert *inserter, const char *key, const char *value, jak_u64 value_len)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        jak_carbon_jak_string_nchar_write(&inserter->memfile, value, value_len);
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

bool jak_carbon_insert_prop_binary(jak_carbon_insert *inserter, const char *key, const void *value,
                               size_t nbytes, const char *file_ext, const char *user_type)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_offset_t prop_start = jak_memfile_tell(&inserter->memfile);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        insert_binary(inserter, value, nbytes, file_ext, user_type);
        jak_offset_t prop_end = jak_memfile_tell(&inserter->memfile);
        inserter_refresh_mod_size(inserter, prop_end - prop_start);
        return true;
}

jak_carbon_insert *jak_carbon_insert_prop_object_begin(jak_carbon_insert_object_state *out,
                                                          jak_carbon_insert *inserter, const char *key,
                                                          jak_u64 object_capacity)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        return jak_carbon_insert_object_begin(out, inserter, object_capacity);
}

jak_u64 jak_carbon_insert_prop_object_end(jak_carbon_insert_object_state *state)
{
        jak_carbon_insert_object_end(state);
        return state->object_end - state->object_begin;
}

jak_carbon_insert *jak_carbon_insert_prop_array_begin(jak_carbon_insert_array_state *state,
                                                         jak_carbon_insert *inserter, const char *key,
                                                         jak_u64 array_capacity)
{
        JAK_ERROR_IF(inserter->context_type != JAK_CARBON_OBJECT, &inserter->err, JAK_ERR_UNSUPPCONTAINER);
        jak_carbon_jak_string_nomarker_write(&inserter->memfile, key);
        return jak_carbon_insert_array_begin(state, inserter, array_capacity);
}

jak_u64 jak_carbon_insert_prop_array_end(jak_carbon_insert_array_state *state)
{
        jak_carbon_insert_array_end(state);
        return state->array_end - state->array_begin;
}

jak_carbon_insert *jak_carbon_insert_prop_column_begin(jak_carbon_insert_column_state *state_out,
                                                          jak_carbon_insert *inserter_in, const char *key,
                                                          jak_carbon_column_type_e type, jak_u64 column_capacity)
{
        JAK_ERROR_IF(inserter_in->context_type != JAK_CARBON_OBJECT, &inserter_in->err, JAK_ERR_UNSUPPCONTAINER);
        jak_carbon_jak_string_nomarker_write(&inserter_in->memfile, key);
        return jak_carbon_insert_column_begin(state_out, inserter_in, type, column_capacity);
}

jak_u64 jak_carbon_insert_prop_column_end(jak_carbon_insert_column_state *state_in)
{
        jak_carbon_insert_column_end(state_in);
        return state_in->column_end - state_in->column_begin;
}

bool jak_carbon_insert_drop(jak_carbon_insert *inserter)
{
        JAK_ERROR_IF_NULL(inserter)
        if (inserter->context_type == JAK_CARBON_ARRAY) {
                jak_carbon_array_it_unlock(inserter->context.array);
        } else if (inserter->context_type == JAK_CARBON_COLUMN) {
                jak_carbon_column_it_unlock(inserter->context.column);
        } else if (inserter->context_type == JAK_CARBON_OBJECT) {
                jak_carbon_object_it_unlock(inserter->context.object);
        } else {
                JAK_ERROR(&inserter->err, JAK_ERR_INTERNALERR);
        }

        return true;
}

static bool
write_field_data(jak_carbon_insert *inserter, jak_u8 field_type_marker, const void *base, jak_u64 nbytes)
{
        JAK_ASSERT(inserter->context_type == JAK_CARBON_ARRAY || inserter->context_type == JAK_CARBON_OBJECT);

        jak_memfile_ensure_space(&inserter->memfile, sizeof(jak_u8) + nbytes);
        jak_memfile_write(&inserter->memfile, &field_type_marker, sizeof(jak_u8));
        return jak_memfile_write(&inserter->memfile, base, nbytes);
}

static bool push_in_column(jak_carbon_insert *inserter, const void *base, jak_carbon_field_type_e type)
{
        JAK_ASSERT(inserter->context_type == JAK_CARBON_COLUMN);

        size_t type_size = jak_carbon_int_get_type_value_size(type);

        jak_memfile_save_position(&inserter->memfile);

        // Increase element counter
        jak_memfile_seek(&inserter->memfile, inserter->context.column->num_and_capacity_start_offset);
        jak_u32 num_elems = jak_memfile_peek_uintvar_stream(NULL, &inserter->memfile);
        num_elems++;
        jak_memfile_update_uintvar_stream(&inserter->memfile, num_elems);
        inserter->context.column->column_num_elements = num_elems;

        jak_u32 capacity = jak_memfile_read_uintvar_stream(NULL, &inserter->memfile);

        if (JAK_UNLIKELY(num_elems > capacity)) {
                jak_memfile_save_position(&inserter->memfile);

                jak_u32 new_capacity = (capacity + 1) * 1.7f;

                // Update capacity counter
                jak_memfile_seek(&inserter->memfile, inserter->context.column->num_and_capacity_start_offset);
                jak_memfile_skip_uintvar_stream(&inserter->memfile); // skip num element counter
                jak_memfile_update_uintvar_stream(&inserter->memfile, new_capacity);
                inserter->context.column->column_capacity = new_capacity;

                size_t payload_start = jak_carbon_int_column_get_payload_off(inserter->context.column);
                jak_memfile_seek(&inserter->memfile, payload_start + (num_elems - 1) * type_size);
                jak_memfile_ensure_space(&inserter->memfile, (new_capacity - capacity) * type_size);

                jak_memfile_restore_position(&inserter->memfile);
        }

        size_t payload_start = jak_carbon_int_column_get_payload_off(inserter->context.column);
        jak_memfile_seek(&inserter->memfile, payload_start + (num_elems - 1) * type_size);
        jak_memfile_write(&inserter->memfile, base, type_size);

        jak_memfile_restore_position(&inserter->memfile);
        return true;
}

static bool push_media_type_for_array(jak_carbon_insert *inserter, jak_carbon_field_type_e type)
{
        jak_memfile_ensure_space(&inserter->memfile, sizeof(jak_media_type));
        return jak_carbon_media_write(&inserter->memfile, type);
}

static void internal_create(jak_carbon_insert *inserter, jak_memfile *src, jak_offset_t pos)
{
        jak_memfile_clone(&inserter->memfile, src);
        jak_error_init(&inserter->err);
        inserter->position = pos ? pos : jak_memfile_tell(src);
        jak_memfile_seek(&inserter->memfile, inserter->position);
}

static void write_binary_blob(jak_carbon_insert *inserter, const void *value, size_t nbytes)
{
        /* write blob length */
        jak_memfile_write_uintvar_stream(NULL, &inserter->memfile, nbytes);

        /* write blob */
        jak_memfile_ensure_space(&inserter->memfile, nbytes);
        jak_memfile_write(&inserter->memfile, value, nbytes);
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 * This file is for internal usage only; do not call these functions from outside
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_uintvar_stream.h>
#include <jak_carbon.h>
#include <jak_carbon_insert.h>
#include <jak_carbon_media.h>
#include <jak_carbon_int.h>
#include <jak_carbon_array_it.h>
#include <jak_carbon_column_it.h>
#include <jak_carbon_object_it.h>
#include <jak_carbon_key.h>
#include <jak_carbon_commit.h>
#include <jak_json.h>
#include "jak_carbon_object_it.h"

static void marker_insert(jak_memfile *memfile, jak_u8 marker);

static bool array_it_is_slot_occupied(bool *is_empty_slot, bool *is_array_end, jak_carbon_array_it *it);

static bool object_it_is_slot_occupied(bool *is_empty_slot, bool *is_object_end, jak_carbon_object_it *it);

static bool is_slot_occupied(bool *is_empty_slot, bool *is_array_end, jak_memfile *file, jak_u8 end_marker);

static bool array_it_next_no_load(bool *is_empty_slot, bool *is_array_end, jak_carbon_array_it *it);

static bool object_it_next_no_load(bool *is_empty_slot, bool *is_array_end, jak_carbon_object_it *it);

static void int_carbon_from_json_elem(jak_carbon_insert *ins, const jak_json_element *elem, bool is_root);

static void int_insert_prop_object(jak_carbon_insert *oins, jak_json_object *obj);

static void
insert_embedded_container(jak_memfile *memfile, jak_u8 begin_marker, jak_u8 end_marker, jak_u8 capacity)
{
        jak_memfile_ensure_space(memfile, sizeof(jak_u8));
        marker_insert(memfile, begin_marker);

        jak_memfile_ensure_space(memfile, capacity + sizeof(jak_u8));

        jak_offset_t payload_begin = jak_memfile_tell(memfile);
        jak_memfile_seek(memfile, payload_begin + capacity);

        marker_insert(memfile, end_marker);

        /* seek to first entry in container */
        jak_memfile_seek(memfile, payload_begin);
}

bool jak_carbon_int_insert_object(jak_memfile *memfile, size_t nbytes)
{
        JAK_ERROR_IF_NULL(memfile);
        insert_embedded_container(memfile, JAK_CARBON_MARKER_OBJECT_BEGIN, JAK_CARBON_MARKER_OBJECT_END, nbytes);
        return true;
}

bool jak_carbon_int_insert_array(jak_memfile *memfile, size_t nbytes)
{
        JAK_ERROR_IF_NULL(memfile);
        insert_embedded_container(memfile, JAK_CARBON_MARKER_ARRAY_BEGIN, JAK_CARBON_MARKER_ARRAY_END, nbytes);
        return true;
}

bool jak_carbon_int_insert_column(jak_memfile *jak_memfile_in, jak_error *err_in, jak_carbon_column_type_e type,
                              size_t capactity)
{
        JAK_ERROR_IF_NULL(jak_memfile_in);
        JAK_ERROR_IF_NULL(err_in);

        JAK_DECLARE_AND_INIT(jak_carbon_field_type_e, column_type)

        switch (type) {
                case JAK_CARBON_COLUMN_TYPE_BOOLEAN:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN;
                        break;
                case JAK_CARBON_COLUMN_TYPE_U8:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_U8;
                        break;
                case JAK_CARBON_COLUMN_TYPE_U16:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_U16;
                        break;
                case JAK_CARBON_COLUMN_TYPE_U32:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_U32;
                        break;
                case JAK_CARBON_COLUMN_TYPE_U64:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_U64;
                        break;
                case JAK_CARBON_COLUMN_TYPE_I8:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_I8;
                        break;
                case JAK_CARBON_COLUMN_TYPE_I16:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_I16;
                        break;
                case JAK_CARBON_COLUMN_TYPE_I32:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_I32;
                        break;
                case JAK_CARBON_COLUMN_TYPE_I64:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_I64;
                        break;
                case JAK_CARBON_COLUMN_TYPE_FLOAT:
                        column_type = JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT;
                        break;
                default:
                        JAK_ERROR_WDETAILS(err_in, JAK_ERR_BADTYPE, "jakson-tool column supports fixed-length types only")
        }

        jak_memfile_ensure_space(jak_memfile_in, sizeof(jak_u8));
        marker_insert(jak_memfile_in, column_type);

        jak_u32 num_elements = 0;
        jak_u32 cap_elements = capactity;

        jak_memfile_write_uintvar_stream(NULL, jak_memfile_in, num_elements);
        jak_memfile_write_uintvar_stream(NULL, jak_memfile_in, cap_elements);

        jak_offset_t payload_begin = jak_memfile_tell(jak_memfile_in);

        size_t type_size = jak_carbon_int_get_type_value_size(column_type);

        size_t nbytes = capactity * type_size;
        jak_memfile_ensure_space(jak_memfile_in, nbytes + sizeof(jak_u8) + 2 * sizeof(jak_u32));

        /* seek to first entry in column */
        jak_memfile_seek(jak_memfile_in, payload_begin);

        return true;
}

size_t jak_carbon_int_get_type_size_encoded(jak_carbon_field_type_e type)
{
        size_t type_size = sizeof(jak_media_type); /* at least the media type marker is required */
        switch (type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                        /* only media type marker is required */
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                        type_size += sizeof(jak_u8);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                        type_size += sizeof(jak_u16);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                        type_size += sizeof(jak_u32);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                        type_size += sizeof(jak_u64);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        type_size += sizeof(float);
                        break;
                default: JAK_ERROR_PRINT(JAK_ERR_INTERNALERR);
                        return 0;
        }
        return type_size;
}

size_t jak_carbon_int_get_type_value_size(jak_carbon_field_type_e type)
{
        switch (type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        return sizeof(jak_media_type); /* these constant values are determined by their media type markers */
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                        return sizeof(jak_u8);
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                        return sizeof(jak_u16);
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                        return sizeof(jak_u32);
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                        return sizeof(jak_u64);
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                        return sizeof(float);
                default: JAK_ERROR_PRINT(JAK_ERR_INTERNALERR);
                        return 0;
        }
}

bool jak_carbon_int_array_it_next(bool *is_empty_slot, bool *is_array_end, jak_carbon_array_it *it)
{
        if (jak_carbon_int_array_it_refresh(is_empty_slot, is_array_end, it)) {
                jak_carbon_field_skip(&it->memfile);
                return true;
        } else {
                return false;
        }
}

bool jak_carbon_int_object_it_next(bool *is_empty_slot, bool *is_object_end, jak_carbon_object_it *it)
{
        if (jak_carbon_int_object_it_refresh(is_empty_slot, is_object_end, it)) {
                jak_carbon_int_object_it_prop_value_skip(it);
                return true;
        } else {
                return false;
        }
}

bool jak_carbon_int_object_it_refresh(bool *is_empty_slot, bool *is_object_end, jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it);
        if (object_it_is_slot_occupied(is_empty_slot, is_object_end, it)) {
                jak_carbon_int_object_it_prop_key_access(it);
                jak_carbon_int_field_data_access(&it->memfile, &it->err, &it->field.value.data);
                return true;
        } else {
                return false;
        }
}

bool jak_carbon_int_object_it_prop_key_access(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it)
        //jak_memfile_skip(&it->memfile, sizeof(jak_media_type));

        it->field.key.offset = jak_memfile_tell(&it->memfile);
        it->field.key.name_len = jak_memfile_read_uintvar_stream(NULL, &it->memfile);
        it->field.key.name = jak_memfile_peek(&it->memfile, it->field.key.name_len);
        jak_memfile_skip(&it->memfile, it->field.key.name_len);
        it->field.value.offset = jak_memfile_tell(&it->memfile);
        it->field.value.data.it_field_type = *JAK_MEMFILE_PEEK(&it->memfile, jak_u8);

        return true;
}

bool jak_carbon_int_object_it_prop_value_skip(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it)
        jak_memfile_seek(&it->memfile, it->field.value.offset);
        return jak_carbon_field_skip(&it->memfile);
}

bool jak_carbon_int_object_it_prop_skip(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it)

        it->field.key.name_len = jak_memfile_read_uintvar_stream(NULL, &it->memfile);
        jak_memfile_skip(&it->memfile, it->field.key.name_len);

        return jak_carbon_field_skip(&it->memfile);
}

bool jak_carbon_int_object_skip_contents(bool *is_empty_slot, bool *is_array_end, jak_carbon_object_it *it)
{
        while (object_it_next_no_load(is_empty_slot, is_array_end, it)) {}
        return true;
}

bool jak_carbon_int_array_skip_contents(bool *is_empty_slot, bool *is_array_end, jak_carbon_array_it *it)
{
        while (array_it_next_no_load(is_empty_slot, is_array_end, it)) {}
        return true;
}

bool jak_carbon_int_array_it_refresh(bool *is_empty_slot, bool *is_array_end, jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_carbon_int_field_access_drop(&it->field_access);
        if (array_it_is_slot_occupied(is_empty_slot, is_array_end, it)) {
                jak_carbon_int_array_it_field_type_read(it);
                jak_carbon_int_field_data_access(&it->memfile, &it->err, &it->field_access);
                return true;
        } else {
                return false;
        }
}

bool jak_carbon_int_array_it_field_type_read(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it)
        JAK_ERROR_IF(jak_memfile_remain_size(&it->memfile) < 1, &it->err, JAK_ERR_ILLEGALOP);
        jak_memfile_save_position(&it->memfile);
        it->field_offset = jak_memfile_tell(&it->memfile);
        jak_u8 media_type = *jak_memfile_read(&it->memfile, 1);
        JAK_ERROR_IF(media_type == 0, &it->err, JAK_ERR_NOTFOUND)
        JAK_ERROR_IF(media_type == JAK_CARBON_MARKER_ARRAY_END, &it->err, JAK_ERR_OUTOFBOUNDS)
        it->field_access.it_field_type = media_type;
        jak_memfile_restore_position(&it->memfile);
        return true;
}

bool jak_carbon_int_field_data_access(jak_memfile *file, jak_error *err, jak_field_access *field_access)
{
        jak_memfile_save_position(file);
        jak_memfile_skip(file, sizeof(jak_media_type));

        switch (field_access->it_field_type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        break;
                case JAK_CARBON_FIELD_TYPE_STRING: {
                        jak_u8 nbytes;
                        jak_uintvar_stream_t len = (jak_uintvar_stream_t) jak_memfile_peek(file, 1);
                        field_access->it_field_len = jak_uintvar_stream_read(&nbytes, len);

                        jak_memfile_skip(file, nbytes);
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_BINARY: {
                        /* read mime type with variable-length integer type */
                        jak_u64 mime_type_id = jak_memfile_read_uintvar_stream(NULL, file);

                        field_access->it_mime_type = jak_carbon_media_mime_type_by_id(mime_type_id);
                        field_access->it_mime_type_strlen = strlen(field_access->it_mime_type);

                        /* read blob length */
                        field_access->it_field_len = jak_memfile_read_uintvar_stream(NULL, file);

                        /* the memfile points now to the actual blob data, which is used by the iterator to set the field */
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM: {
                        /* read mime type string */
                        field_access->it_mime_type_strlen = jak_memfile_read_uintvar_stream(NULL, file);
                        field_access->it_mime_type = jak_memfile_read(file, field_access->it_mime_type_strlen);

                        /* read blob length */
                        field_access->it_field_len = jak_memfile_read_uintvar_stream(NULL, file);

                        /* the memfile points now to the actual blob data, which is used by the iterator to set the field */
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                        jak_carbon_int_field_access_create(field_access);
                        field_access->nested_array_it_is_created = true;
                        jak_carbon_array_it_create(field_access->nested_array_it, file, err,
                                               jak_memfile_tell(file) - sizeof(jak_u8));
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                        jak_carbon_int_field_access_create(field_access);
                        field_access->nested_column_it_is_created = true;
                        jak_carbon_column_it_create(field_access->nested_column_it, file, err,
                                                jak_memfile_tell(file) - sizeof(jak_u8));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                        jak_carbon_int_field_access_create(field_access);
                        field_access->nested_object_it_is_created = true;
                        jak_carbon_object_it_create(field_access->nested_object_it, file, err,
                                                jak_memfile_tell(file) - sizeof(jak_u8));
                        break;
                default: JAK_ERROR(err, JAK_ERR_CORRUPTED)
                        return false;
        }

        field_access->it_field_data = jak_memfile_peek(file, 1);
        jak_memfile_restore_position(file);
        return true;
}

jak_offset_t jak_carbon_int_column_get_payload_off(jak_carbon_column_it *it)
{
        jak_memfile_save_position(&it->memfile);
        jak_memfile_seek(&it->memfile, it->num_and_capacity_start_offset);
        jak_memfile_skip_uintvar_stream(&it->memfile); // skip num of elements
        jak_memfile_skip_uintvar_stream(&it->memfile); // skip capacity of elements
        jak_offset_t result = jak_memfile_tell(&it->memfile);
        jak_memfile_restore_position(&it->memfile);
        return result;
}

jak_offset_t jak_carbon_int_payload_after_header(jak_carbon *doc)
{
        jak_offset_t result = 0;
        jak_carbon_key_e key_type;

        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);

        if (JAK_LIKELY(jak_carbon_key_skip(&key_type, &doc->memfile))) {
                if (key_type != JAK_CARBON_KEY_NOKEY) {
                        jak_carbon_commit_hash_skip(&doc->memfile);
                }
                result = jak_memfile_tell(&doc->memfile);
        }

        jak_memfile_restore_position(&doc->memfile);

        return result;
}

jak_u64 jak_carbon_int_header_get_commit_hash(jak_carbon *doc)
{
        JAK_ASSERT(doc);
        jak_u64 rev = 0;
        jak_carbon_key_e key_type;

        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);

        jak_carbon_key_skip(&key_type, &doc->memfile);
        if (key_type != JAK_CARBON_KEY_NOKEY) {
                jak_carbon_commit_hash_read(&rev, &doc->memfile);
        }

        jak_memfile_restore_position(&doc->memfile);
        return rev;
}

void jak_carbon_int_history_push(jak_vector ofType(jak_offset_t) *vec, jak_offset_t off)
{
        JAK_ASSERT(vec);
        jak_vector_push(vec, &off, 1);
}

void jak_carbon_int_history_clear(jak_vector ofType(jak_offset_t) *vec)
{
        JAK_ASSERT(vec);
        jak_vector_clear(vec);
}

jak_offset_t jak_carbon_int_history_pop(jak_vector ofType(jak_offset_t) *vec)
{
        JAK_ASSERT(vec);
        JAK_ASSERT(jak_carbon_int_history_has(vec));
        return *(jak_offset_t *) jak_vector_pop(vec);
}

jak_offset_t jak_carbon_int_history_peek(jak_vector ofType(jak_offset_t) *vec)
{
        JAK_ASSERT(vec);
        JAK_ASSERT(jak_carbon_int_history_has(vec));
        return *(jak_offset_t *) jak_vector_peek(vec);
}

bool jak_carbon_int_history_has(jak_vector ofType(jak_offset_t) *vec)
{
        JAK_ASSERT(vec);
        return !jak_vector_is_empty(vec);
}

bool jak_carbon_int_field_access_create(jak_field_access *field)
{
        field->nested_array_it_is_created = false;
        field->nested_array_it_accessed = false;
        field->nested_object_it_is_created = false;
        field->nested_object_it_accessed = false;
        field->nested_column_it_is_created = false;
        field->nested_array_it = JAK_MALLOC(sizeof(jak_carbon_array_it));
        field->nested_object_it = JAK_MALLOC(sizeof(jak_carbon_object_it));
        field->nested_column_it = JAK_MALLOC(sizeof(jak_carbon_column_it));
        return true;
}

bool jak_carbon_int_field_access_clone(jak_field_access *dst, jak_field_access *src)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)

        dst->it_field_type = src->it_field_type;
        dst->it_field_data = src->it_field_data;
        dst->it_field_len = src->it_field_len;
        dst->it_mime_type = src->it_mime_type;
        dst->it_mime_type_strlen = src->it_mime_type_strlen;
        dst->nested_array_it_is_created = src->nested_array_it_is_created;
        dst->nested_array_it_accessed = src->nested_array_it_accessed;
        dst->nested_object_it_is_created = src->nested_object_it_is_created;
        dst->nested_object_it_accessed = src->nested_object_it_accessed;
        dst->nested_column_it_is_created = src->nested_column_it_is_created;
        dst->nested_array_it = JAK_MALLOC(sizeof(jak_carbon_array_it));
        dst->nested_object_it = JAK_MALLOC(sizeof(jak_carbon_object_it));
        dst->nested_column_it = JAK_MALLOC(sizeof(jak_carbon_column_it));

        if (jak_carbon_int_field_access_object_it_opened(src)) {
                jak_carbon_object_it_clone(dst->nested_object_it, src->nested_object_it);
        } else if (jak_carbon_int_field_access_column_it_opened(src)) {
                jak_carbon_column_it_clone(dst->nested_column_it, src->nested_column_it);
        } else if (jak_carbon_int_field_access_array_it_opened(src)) {
                jak_carbon_array_it_clone(dst->nested_array_it, src->nested_array_it);
        }
        return true;
}

bool jak_carbon_int_field_access_drop(jak_field_access *field)
{
        jak_carbon_int_field_auto_close(field);
        free(field->nested_array_it);
        free(field->nested_object_it);
        free(field->nested_column_it);
        field->nested_array_it = NULL;
        field->nested_object_it = NULL;
        field->nested_column_it = NULL;
        return true;
}

bool jak_carbon_int_field_access_object_it_opened(jak_field_access *field)
{
        JAK_ASSERT(field);
        return field->nested_object_it_is_created && field->nested_object_it != NULL;
}

bool jak_carbon_int_field_access_array_it_opened(jak_field_access *field)
{
        JAK_ASSERT(field);
        return field->nested_array_it_is_created && field->nested_array_it != NULL;
}

bool jak_carbon_int_field_access_column_it_opened(jak_field_access *field)
{
        JAK_ASSERT(field);
        return field->nested_column_it_is_created && field->nested_column_it != NULL;
}

void jak_carbon_int_auto_close_nested_array_it(jak_field_access *field)
{
        if (jak_carbon_int_field_access_array_it_opened(field)) {
                jak_carbon_array_it_drop(field->nested_array_it);
                JAK_ZERO_MEMORY(field->nested_array_it, sizeof(jak_carbon_array_it));
        }
}

void jak_carbon_int_auto_close_nested_object_it(jak_field_access *field)
{
        if (jak_carbon_int_field_access_object_it_opened(field)) {
                jak_carbon_object_it_drop(field->nested_object_it);
                JAK_ZERO_MEMORY(field->nested_object_it, sizeof(jak_carbon_object_it));
        }
}

void jak_carbon_int_auto_close_nested_column_it(jak_field_access *field)
{
        if (jak_carbon_int_field_access_column_it_opened(field)) {
                JAK_ZERO_MEMORY(field->nested_column_it, sizeof(jak_carbon_column_it));
        }
}

bool jak_carbon_int_field_auto_close(jak_field_access *field)
{
        JAK_ERROR_IF_NULL(field)
        if (field->nested_array_it_is_created && !field->nested_array_it_accessed) {
                jak_carbon_int_auto_close_nested_array_it(field);
                field->nested_array_it_is_created = false;
                field->nested_array_it_accessed = false;
        }
        if (field->nested_object_it_is_created && !field->nested_object_it_accessed) {
                jak_carbon_int_auto_close_nested_object_it(field);
                field->nested_object_it_is_created = false;
                field->nested_object_it_accessed = false;
        }
        if (field->nested_column_it_is_created) {
                jak_carbon_int_auto_close_nested_column_it(field);
                field->nested_object_it_is_created = false;
        }

        return true;
}

bool jak_carbon_int_field_access_field_type(jak_carbon_field_type_e *type, jak_field_access *field)
{
        JAK_ERROR_IF_NULL(type)
        JAK_ERROR_IF_NULL(field)
        *type = field->it_field_type;
        return true;
}

bool jak_carbon_int_field_access_u8_value(jak_u8 *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_U8, err, JAK_ERR_TYPEMISMATCH);
        *value = *(jak_u8 *) field->it_field_data;
        return true;
}

bool jak_carbon_int_field_access_u16_value(jak_u16 *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_U16, err, JAK_ERR_TYPEMISMATCH);
        *value = *(jak_u16 *) field->it_field_data;
        return true;
}

bool jak_carbon_int_field_access_u32_value(jak_u32 *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_U32, err, JAK_ERR_TYPEMISMATCH);
        *value = *(jak_u32 *) field->it_field_data;
        return true;
}

bool jak_carbon_int_field_access_u64_value(jak_u64 *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_U64, err, JAK_ERR_TYPEMISMATCH);
        *value = *(jak_u64 *) field->it_field_data;
        return true;
}

bool jak_carbon_int_field_access_i8_value(jak_i8 *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_I8, err, JAK_ERR_TYPEMISMATCH);
        *value = *(jak_i8 *) field->it_field_data;
        return true;
}

bool jak_carbon_int_field_access_i16_value(jak_i16 *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_I16, err, JAK_ERR_TYPEMISMATCH);
        *value = *(jak_i16 *) field->it_field_data;
        return true;
}

bool jak_carbon_int_field_access_i32_value(jak_i32 *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_I32, err, JAK_ERR_TYPEMISMATCH);
        *value = *(jak_i32 *) field->it_field_data;
        return true;
}

bool jak_carbon_int_field_access_i64_value(jak_i64 *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(value)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_I64, err, JAK_ERR_TYPEMISMATCH);
        *value = *(jak_i64 *) field->it_field_data;
        return true;
}

bool
jak_carbon_int_field_access_float_value(bool *is_null_in, float *value, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT, err, JAK_ERR_TYPEMISMATCH);
        float read_value = *(float *) field->it_field_data;
        JAK_OPTIONAL_SET(value, read_value);
        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_FLOAT(read_value));

        return true;
}

bool jak_carbon_int_field_access_signed_value(bool *is_null_in, jak_i64 *value, jak_field_access *field,
                                          jak_error *err)
{
        JAK_ERROR_IF_NULL(field)
        switch (field->it_field_type) {
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8: {
                        jak_i8 read_value;
                        jak_carbon_int_field_access_i8_value(&read_value, field, err);
                        JAK_OPTIONAL_SET(value, read_value);
                        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_I8(read_value));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16: {
                        jak_i16 read_value;
                        jak_carbon_int_field_access_i16_value(&read_value, field, err);
                        JAK_OPTIONAL_SET(value, read_value);
                        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_I16(read_value));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32: {
                        jak_i32 read_value;
                        jak_carbon_int_field_access_i32_value(&read_value, field, err);
                        JAK_OPTIONAL_SET(value, read_value);
                        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_I32(read_value));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64: {
                        jak_i64 read_value;
                        jak_carbon_int_field_access_i64_value(&read_value, field, err);
                        JAK_OPTIONAL_SET(value, read_value);
                        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_I64(read_value));
                }
                        break;
                default: JAK_ERROR(err, JAK_ERR_TYPEMISMATCH);
                        return false;
        }
        return true;
}

bool jak_carbon_int_field_access_unsigned_value(bool *is_null_in, jak_u64 *value, jak_field_access *field,
                                            jak_error *err)
{
        JAK_ERROR_IF_NULL(field)
        switch (field->it_field_type) {
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8: {
                        jak_u8 read_value;
                        jak_carbon_int_field_access_u8_value(&read_value, field, err);
                        JAK_OPTIONAL_SET(value, read_value);
                        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_U8(read_value));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16: {
                        jak_u16 read_value;
                        jak_carbon_int_field_access_u16_value(&read_value, field, err);
                        JAK_OPTIONAL_SET(value, read_value);
                        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_U16(read_value));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32: {
                        jak_u32 read_value;
                        jak_carbon_int_field_access_u32_value(&read_value, field, err);
                        JAK_OPTIONAL_SET(value, read_value);
                        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_U32(read_value));
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64: {
                        jak_u64 read_value;
                        jak_carbon_int_field_access_u64_value(&read_value, field, err);
                        JAK_OPTIONAL_SET(value, read_value);
                        JAK_OPTIONAL_SET(is_null_in, JAK_IS_NULL_U64(read_value));
                }
                        break;
                default: JAK_ERROR(err, JAK_ERR_TYPEMISMATCH);
                        return false;
        }
        return true;
}

const char *jak_carbon_int_field_access_jak_string_value(jak_u64 *strlen, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(strlen);
        JAK_ERROR_IF_AND_RETURN(field == NULL, err, JAK_ERR_NULLPTR, NULL);
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_STRING, err, JAK_ERR_TYPEMISMATCH);
        *strlen = field->it_field_len;
        return field->it_field_data;
}

bool
jak_carbon_int_field_access_binary_value(jak_carbon_binary *out, jak_field_access *field, jak_error *err)
{
        JAK_ERROR_IF_NULL(out)
        JAK_ERROR_IF_NULL(field)
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_BINARY &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM,
                 err, JAK_ERR_TYPEMISMATCH);
        out->blob = field->it_field_data;
        out->blob_len = field->it_field_len;
        out->mime_type = field->it_mime_type;
        out->mime_type_strlen = field->it_mime_type_strlen;
        return true;
}

jak_carbon_array_it *jak_carbon_int_field_access_array_value(jak_field_access *field, jak_error *err)
{
        JAK_ERROR_PRINT_IF(!field, JAK_ERR_NULLPTR);
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_ARRAY, err, JAK_ERR_TYPEMISMATCH);
        field->nested_array_it_accessed = true;
        return field->nested_array_it;
}

jak_carbon_object_it *jak_carbon_int_field_access_object_value(jak_field_access *field, jak_error *err)
{
        JAK_ERROR_PRINT_IF(!field, JAK_ERR_NULLPTR);
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_OBJECT, err, JAK_ERR_TYPEMISMATCH);
        field->nested_object_it_accessed = true;
        return field->nested_object_it;
}

jak_carbon_column_it *jak_carbon_int_field_access_column_value(jak_field_access *field, jak_error *err)
{
        JAK_ERROR_PRINT_IF(!field, JAK_ERR_NULLPTR);
        JAK_ERROR_IF(field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_U8 &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_U16 &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_U32 &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_U64 &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_I8 &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_I16 &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_I32 &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_I64 &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT &&
                 field->it_field_type != JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN, err, JAK_ERR_TYPEMISMATCH);
        return field->nested_column_it;
}

bool jak_carbon_int_field_remove(jak_memfile *memfile, jak_error *err, jak_carbon_field_type_e type)
{
        JAK_ASSERT((jak_carbon_field_type_e) *jak_memfile_peek(memfile, sizeof(jak_u8)) == type);
        jak_offset_t start_off = jak_memfile_tell(memfile);
        jak_memfile_skip(memfile, sizeof(jak_u8));
        size_t rm_nbytes = sizeof(jak_u8); /* at least the type marker must be removed */
        switch (type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                        /* nothing to do */
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                        rm_nbytes += sizeof(jak_u8);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                        rm_nbytes += sizeof(jak_u16);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                        rm_nbytes += sizeof(jak_u32);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                        rm_nbytes += sizeof(jak_u64);
                        break;
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                        rm_nbytes += sizeof(float);
                        break;
                case JAK_CARBON_FIELD_TYPE_STRING: {
                        jak_u8 len_nbytes;  /* number of bytes used to store string length */
                        jak_u64 str_len; /* the number of characters of the string field */

                        str_len = jak_memfile_read_uintvar_stream(&len_nbytes, memfile);

                        rm_nbytes += len_nbytes + str_len;
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_BINARY: {
                        jak_u8 mime_type_nbytes; /* number of bytes for mime type */
                        jak_u8 blob_length_nbytes; /* number of bytes to store blob length */
                        jak_u64 blob_nbytes; /* number of bytes to store actual blob data */

                        /* get bytes used for mime type id */
                        jak_memfile_read_uintvar_stream(&mime_type_nbytes, memfile);

                        /* get bytes used for blob length info */
                        blob_nbytes = jak_memfile_read_uintvar_stream(&blob_length_nbytes, memfile);

                        rm_nbytes += mime_type_nbytes + blob_length_nbytes + blob_nbytes;
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM: {
                        jak_u8 custom_type_strlen_nbytes; /* number of bytes for type name string length info */
                        jak_u8 custom_type_strlen; /* number of characters to encode type name string */
                        jak_u8 blob_length_nbytes; /* number of bytes to store blob length */
                        jak_u64 blob_nbytes; /* number of bytes to store actual blob data */

                        /* get bytes for custom type string len, and the actual length */
                        custom_type_strlen = jak_memfile_read_uintvar_stream(&custom_type_strlen_nbytes, memfile);
                        jak_memfile_skip(memfile, custom_type_strlen);

                        /* get bytes used for blob length info */
                        blob_nbytes = jak_memfile_read_uintvar_stream(&blob_length_nbytes, memfile);

                        rm_nbytes += custom_type_strlen_nbytes + custom_type_strlen + blob_length_nbytes + blob_nbytes;
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_ARRAY: {
                        jak_carbon_array_it it;

                        jak_offset_t begin_off = jak_memfile_tell(memfile);
                        jak_carbon_array_it_create(&it, memfile, err, begin_off - sizeof(jak_u8));
                        jak_carbon_array_it_fast_forward(&it);
                        jak_offset_t end_off = jak_carbon_array_it_memfilepos(&it);
                        jak_carbon_array_it_drop(&it);

                        JAK_ASSERT(begin_off < end_off);
                        rm_nbytes += (end_off - begin_off);
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                        jak_carbon_column_it it;

                        jak_offset_t begin_off = jak_memfile_tell(memfile);
                        jak_carbon_column_it_create(&it, memfile, err, begin_off - sizeof(jak_u8));
                        jak_carbon_column_it_fast_forward(&it);
                        jak_offset_t end_off = jak_carbon_column_it_memfilepos(&it);

                        JAK_ASSERT(begin_off < end_off);
                        rm_nbytes += (end_off - begin_off);
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT: {
                        jak_carbon_object_it it;

                        jak_offset_t begin_off = jak_memfile_tell(memfile);
                        jak_carbon_object_it_create(&it, memfile, err, begin_off - sizeof(jak_u8));
                        jak_carbon_object_it_fast_forward(&it);
                        jak_offset_t end_off = jak_carbon_object_it_jak_memfile_pos(&it);
                        jak_carbon_object_it_drop(&it);

                        JAK_ASSERT(begin_off < end_off);
                        rm_nbytes += (end_off - begin_off);
                }
                        break;
                default: JAK_ERROR(err, JAK_ERR_INTERNALERR)
                        return false;
        }
        jak_memfile_seek(memfile, start_off);
        jak_memfile_inplace_remove(memfile, rm_nbytes);

        return true;
}

static void int_insert_array_array(jak_carbon_insert *array_ins, jak_json_array *array)
{
        jak_carbon_insert_array_state state;
        jak_carbon_insert *sub_ins = jak_carbon_insert_array_begin(&state, array_ins,
                                                                      array->elements.elements.num_elems * 256);
        for (jak_u32 i = 0; i < array->elements.elements.num_elems; i++) {
                const jak_json_element *elem = JAK_VECTOR_GET(&array->elements.elements, i, jak_json_element);
                int_carbon_from_json_elem(sub_ins, elem, false);
        }
        jak_carbon_insert_array_end(&state);
}

static void int_insert_array_string(jak_carbon_insert *array_ins, jak_json_string *string)
{
        jak_carbon_insert_string(array_ins, string->value);
}

static void int_insert_array_number(jak_carbon_insert *array_ins, jak_json_number *number)
{
        switch (number->value_type) {
                case JAK_JSON_NUMBER_FLOAT:
                        jak_carbon_insert_float(array_ins, number->value.float_number);
                        break;
                case JAK_JSON_NUMBER_UNSIGNED:
                        jak_carbon_insert_unsigned(array_ins, number->value.unsigned_integer);
                        break;
                case JAK_JSON_NUMBER_SIGNED:
                        jak_carbon_insert_signed(array_ins, number->value.signed_integer);
                        break;
                default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE)
        }
}

static void int_insert_array_true(jak_carbon_insert *array_ins)
{
        jak_carbon_insert_true(array_ins);
}

static void int_insert_array_false(jak_carbon_insert *array_ins)
{
        jak_carbon_insert_false(array_ins);
}

static void int_insert_array_null(jak_carbon_insert *array_ins)
{
        jak_carbon_insert_null(array_ins);
}

static void int_insert_array_elements(jak_carbon_insert *array_ins, jak_json_array *array)
{
        for (jak_u32 i = 0; i < array->elements.elements.num_elems; i++) {
                jak_json_element *elem = JAK_VECTOR_GET(&array->elements.elements, i, jak_json_element);
                switch (elem->value.value_type) {
                        case JAK_JSON_VALUE_OBJECT: {
                                jak_carbon_insert_object_state state;
                                jak_carbon_insert *sub_obj = jak_carbon_insert_object_begin(&state, array_ins,
                                                                                               elem->value.value.object->value->members.num_elems *
                                                                                               256);
                                int_insert_prop_object(sub_obj, elem->value.value.object);
                                jak_carbon_insert_object_end(&state);
                        }
                                break;
                        case JAK_JSON_VALUE_ARRAY:
                                int_insert_array_array(array_ins, elem->value.value.array);
                                break;
                        case JAK_JSON_VALUE_STRING:
                                int_insert_array_string(array_ins, elem->value.value.string);
                                break;
                        case JAK_JSON_VALUE_NUMBER:
                                int_insert_array_number(array_ins, elem->value.value.number);
                                break;
                        case JAK_JSON_VALUE_TRUE:
                                int_insert_array_true(array_ins);
                                break;
                        case JAK_JSON_VALUE_FALSE:
                                int_insert_array_false(array_ins);
                                break;
                        case JAK_JSON_VALUE_NULL:
                                int_insert_array_null(array_ins);
                                break;
                        default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE)
                                break;
                }
        }
}

#define insert_into_array(ins, elem, ctype, accessor)                                                                  \
{                                                                                                                      \
        for (jak_u32 k = 0; k < elem->value.value.array->elements.elements.num_elems; k++) {                               \
                jak_json_element *array_elem = JAK_VECTOR_GET(                                                             \
                        &elem->value.value.array->elements.elements, k, jak_json_element);                          \
                if (array_elem->value.value_type == JAK_JSON_VALUE_NULL) {                                                 \
                        jak_carbon_insert_null(ins);                                                                       \
                } else {                                                                                               \
                        jak_carbon_insert_##ctype(ins, array_elem->value.value.number->value.accessor);                    \
                }                                                                                                      \
        }                                                                                                              \
}

#define insert_into_column(ins, elem, field_type, column_type, ctype, accessor)                                        \
({                                                                                                                     \
        jak_carbon_insert_column_state state;                                                                       \
        jak_u64 approx_cap_nbytes = elem->value.value.array->elements.elements.num_elems *                                 \
                                jak_carbon_int_get_type_value_size(field_type);                                            \
        jak_carbon_insert *cins = jak_carbon_insert_column_begin(&state, ins,                                           \
                                                                column_type, approx_cap_nbytes);                       \
        for (jak_u32 k = 0; k < elem->value.value.array->elements.elements.num_elems; k++) {                               \
                jak_json_element *array_elem = JAK_VECTOR_GET(&elem->value.value.array->elements.elements,                 \
                                                          k, jak_json_element);                                     \
                if (array_elem->value.value_type == JAK_JSON_VALUE_NULL) {                                                 \
                        jak_carbon_insert_null(cins);                                                                      \
                } else {                                                                                               \
                        jak_carbon_insert_##ctype(cins, (jak_##ctype) array_elem->value.value.number->value.accessor);           \
                }                                                                                                      \
        }                                                                                                              \
        jak_carbon_insert_column_end(&state);                                                                              \
})

#define prop_insert_into_column(ins, prop, key, field_type, column_type, ctype, accessor)                                   \
({                                                                                                                     \
        jak_carbon_insert_column_state state;                                                                       \
        jak_u64 approx_cap_nbytes = prop->value.value.value.array->elements.elements.num_elems *                                 \
                                jak_carbon_int_get_type_value_size(field_type);                                            \
        jak_carbon_insert *cins = jak_carbon_insert_prop_column_begin(&state, ins, key,                                          \
                                                                column_type, approx_cap_nbytes);                       \
        for (jak_u32 k = 0; k < prop->value.value.value.array->elements.elements.num_elems; k++) {                               \
                jak_json_element *array_elem = JAK_VECTOR_GET(&prop->value.value.value.array->elements.elements,                 \
                                                          k, jak_json_element);                                     \
                if (array_elem->value.value_type == JAK_JSON_VALUE_NULL) {                                                 \
                        jak_carbon_insert_null(cins);                                                                      \
                } else {                                                                                               \
                        jak_carbon_insert_##ctype(cins, (jak_##ctype) array_elem->value.value.number->value.accessor);           \
                }                                                                                                      \
        }                                                                                                              \
        jak_carbon_insert_prop_column_end(&state);                                                                              \
})

static void int_insert_prop_object(jak_carbon_insert *oins, jak_json_object *obj)
{
        for (jak_u32 i = 0; i < obj->value->members.num_elems; i++) {
                jak_json_prop *prop = JAK_VECTOR_GET(&obj->value->members, i, jak_json_prop);
                switch (prop->value.value.value_type) {
                        case JAK_JSON_VALUE_OBJECT: {
                                jak_carbon_insert_object_state state;
                                jak_carbon_insert *sub_obj = jak_carbon_insert_prop_object_begin(&state, oins,
                                                                                                    prop->key.value,
                                                                                                    prop->value.value.value.object->value->members.num_elems *
                                                                                                    256);
                                int_insert_prop_object(sub_obj, prop->value.value.value.object);
                                jak_carbon_insert_prop_object_end(&state);
                        }
                                break;
                        case JAK_JSON_VALUE_ARRAY: {
                                jak_json_list_type_e type;
                                jak_json_array_get_type(&type, prop->value.value.value.array);
                                switch (type) {
                                        case JAK_JSON_LIST_EMPTY: {
                                                jak_carbon_insert_array_state state;
                                                jak_carbon_insert_prop_array_begin(&state, oins, prop->key.value, 0);
                                                jak_carbon_insert_prop_array_end(&state);
                                        }
                                                break;
                                        case JAK_JSON_LIST_VARIABLE_OR_NESTED: {
                                                jak_carbon_insert_array_state state;
                                                jak_u64 approx_cap_nbytes =
                                                        prop->value.value.value.array->elements.elements.num_elems *
                                                        256;
                                                jak_carbon_insert *array_ins = jak_carbon_insert_prop_array_begin(
                                                        &state, oins,
                                                        prop->key.value, approx_cap_nbytes);
                                                int_insert_array_elements(array_ins, prop->value.value.value.array);
                                                jak_carbon_insert_prop_array_end(&state);
                                        }
                                                break;
                                        case JAK_JSON_LIST_FIXED_U8:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_U8,
                                                                        JAK_CARBON_COLUMN_TYPE_U8,
                                                                        u8, unsigned_integer);
                                                break;
                                        case JAK_JSON_LIST_FIXED_U16:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_U16,
                                                                        JAK_CARBON_COLUMN_TYPE_U16,
                                                                        u16, unsigned_integer);
                                                break;
                                        case JAK_JSON_LIST_FIXED_U32:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_U32,
                                                                        JAK_CARBON_COLUMN_TYPE_U32,
                                                                        u32, unsigned_integer);
                                                break;
                                        case JAK_JSON_LIST_FIXED_U64:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_U64,
                                                                        JAK_CARBON_COLUMN_TYPE_U64,
                                                                        u64, unsigned_integer);
                                                break;
                                        case JAK_JSON_LIST_FIXED_I8:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_I8,
                                                                        JAK_CARBON_COLUMN_TYPE_I8,
                                                                        i8, signed_integer);
                                                break;
                                        case JAK_JSON_LIST_FIXED_I16:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_I16,
                                                                        JAK_CARBON_COLUMN_TYPE_I16,
                                                                        i16, signed_integer);
                                                break;
                                        case JAK_JSON_LIST_FIXED_I32:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_I32,
                                                                        JAK_CARBON_COLUMN_TYPE_I32,
                                                                        i32, signed_integer);
                                                break;
                                        case JAK_JSON_LIST_FIXED_I64:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_I64,
                                                                        JAK_CARBON_COLUMN_TYPE_I64,
                                                                        i64, signed_integer);
                                                break;
                                        case JAK_JSON_LIST_FIXED_FLOAT:
                                                prop_insert_into_column(oins, prop, prop->key.value,
                                                                        JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT,
                                                                        JAK_CARBON_COLUMN_TYPE_FLOAT,
                                                                        float, float_number);
                                                break;
                                        case JAK_JSON_LIST_FIXED_NULL: {
                                                jak_carbon_insert_array_state state;
                                                jak_u64 approx_cap_nbytes = prop->value.value.value.array->elements.elements.num_elems;
                                                jak_carbon_insert *array_ins = jak_carbon_insert_prop_array_begin(
                                                        &state, oins, prop->key.value,
                                                        approx_cap_nbytes);
                                                for (jak_u32 k = 0; k <
                                                                    prop->value.value.value.array->elements.elements.num_elems; k++) {
                                                        jak_carbon_insert_null(array_ins);
                                                }
                                                jak_carbon_insert_prop_array_end(&state);
                                        }
                                                break;
                                        case JAK_JSON_LIST_FIXED_BOOLEAN: {
                                                jak_carbon_insert_column_state state;
                                                jak_u64 cap_nbytes = prop->value.value.value.array->elements.elements.num_elems;
                                                jak_carbon_insert *array_ins = jak_carbon_insert_prop_column_begin(
                                                        &state, oins,
                                                        prop->key.value,
                                                        JAK_CARBON_COLUMN_TYPE_BOOLEAN, cap_nbytes);
                                                for (jak_u32 k = 0; k <
                                                                    prop->value.value.value.array->elements.elements.num_elems; k++) {
                                                        jak_json_element *array_elem = JAK_VECTOR_GET(
                                                                &prop->value.value.value.array->elements.elements, k,
                                                                jak_json_element);
                                                        if (array_elem->value.value_type == JAK_JSON_VALUE_TRUE) {
                                                                jak_carbon_insert_true(array_ins);
                                                        } else if (array_elem->value.value_type == JAK_JSON_VALUE_FALSE) {
                                                                jak_carbon_insert_false(array_ins);
                                                        } else if (array_elem->value.value_type == JAK_JSON_VALUE_NULL) {
                                                                jak_carbon_insert_null(array_ins);
                                                        } else {
                                                                JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE);
                                                        }
                                                }
                                                jak_carbon_insert_prop_column_end(&state);
                                        }
                                                break;
                                        default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE)
                                                break;
                                }
                        }
                                break;
                        case JAK_JSON_VALUE_STRING:
                                jak_carbon_insert_prop_string(oins, prop->key.value, prop->value.value.value.string->value);
                                break;
                        case JAK_JSON_VALUE_NUMBER:
                                switch (prop->value.value.value.number->value_type) {
                                        case JAK_JSON_NUMBER_FLOAT:
                                                jak_carbon_insert_prop_float(oins, prop->key.value,
                                                                         prop->value.value.value.number->value.float_number);
                                                break;
                                        case JAK_JSON_NUMBER_UNSIGNED:
                                                jak_carbon_insert_prop_unsigned(oins, prop->key.value,
                                                                            prop->value.value.value.number->value.unsigned_integer);
                                                break;
                                        case JAK_JSON_NUMBER_SIGNED:
                                                jak_carbon_insert_prop_signed(oins, prop->key.value,
                                                                          prop->value.value.value.number->value.signed_integer);
                                                break;
                                        default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE);
                                                break;
                                }
                                break;
                        case JAK_JSON_VALUE_TRUE:
                                jak_carbon_insert_prop_true(oins, prop->key.value);
                                break;
                        case JAK_JSON_VALUE_FALSE:
                                jak_carbon_insert_prop_false(oins, prop->key.value);
                                break;
                        case JAK_JSON_VALUE_NULL:
                                jak_carbon_insert_prop_null(oins, prop->key.value);
                                break;
                        default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE)
                                break;
                }
        }
}

static void int_carbon_from_json_elem(jak_carbon_insert *ins, const jak_json_element *elem, bool is_root)
{
        switch (elem->value.value_type) {
                case JAK_JSON_VALUE_OBJECT: {
                        jak_carbon_insert_object_state state;
                        jak_carbon_insert *oins = jak_carbon_insert_object_begin(&state, ins,
                                                                                    elem->value.value.object->value->members.num_elems *
                                                                                    256);
                        int_insert_prop_object(oins, elem->value.value.object);
                        jak_carbon_insert_object_end(&state);
                }
                        break;
                case JAK_JSON_VALUE_ARRAY: {
                        jak_json_list_type_e type;
                        jak_json_array_get_type(&type, elem->value.value.array);
                        switch (type) {
                                case JAK_JSON_LIST_EMPTY: {
                                        if (is_root) {
                                                /* nothing to do */
                                        } else {
                                                jak_carbon_insert_array_state state;
                                                jak_carbon_insert_array_begin(&state, ins, 0);
                                                jak_carbon_insert_array_end(&state);
                                        }
                                }
                                        break;
                                case JAK_JSON_LIST_VARIABLE_OR_NESTED: {
                                        jak_u64 approx_cap_nbytes =
                                                elem->value.value.array->elements.elements.num_elems * 256;
                                        if (is_root) {
                                                int_insert_array_elements(ins, elem->value.value.array);
                                        } else {
                                                jak_carbon_insert_array_state state;
                                                jak_carbon_insert *array_ins = jak_carbon_insert_array_begin(&state,
                                                                                                                ins,
                                                                                                                approx_cap_nbytes);
                                                int_insert_array_elements(array_ins, elem->value.value.array);
                                                jak_carbon_insert_array_end(&state);
                                        }
                                }
                                        break;
                                case JAK_JSON_LIST_FIXED_U8:
                                        if (is_root) {
                                                insert_into_array(ins, elem, unsigned, unsigned_integer)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_U8,
                                                                   JAK_CARBON_COLUMN_TYPE_U8,
                                                                   u8, unsigned_integer);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_U16:
                                        if (is_root) {
                                                insert_into_array(ins, elem, unsigned, unsigned_integer)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_U16,
                                                                   JAK_CARBON_COLUMN_TYPE_U16,
                                                                   u16, unsigned_integer);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_U32:
                                        if (is_root) {
                                                insert_into_array(ins, elem, unsigned, unsigned_integer)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_U32,
                                                                   JAK_CARBON_COLUMN_TYPE_U32,
                                                                   u32, unsigned_integer);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_U64:
                                        if (is_root) {
                                                insert_into_array(ins, elem, unsigned, unsigned_integer)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_U64,
                                                                   JAK_CARBON_COLUMN_TYPE_U64,
                                                                   u64, unsigned_integer);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_I8:
                                        if (is_root) {
                                                insert_into_array(ins, elem, signed, signed_integer)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_I8,
                                                                   JAK_CARBON_COLUMN_TYPE_I8,
                                                                   i8, signed_integer);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_I16:
                                        if (is_root) {
                                                insert_into_array(ins, elem, signed, signed_integer)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_I16,
                                                                   JAK_CARBON_COLUMN_TYPE_I16,
                                                                   u16, signed_integer);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_I32:
                                        if (is_root) {
                                                insert_into_array(ins, elem, signed, signed_integer)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_I32,
                                                                   JAK_CARBON_COLUMN_TYPE_I32,
                                                                   u32, signed_integer);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_I64:
                                        if (is_root) {
                                                insert_into_array(ins, elem, signed, signed_integer)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_I64,
                                                                   JAK_CARBON_COLUMN_TYPE_I64,
                                                                   u64, signed_integer);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_FLOAT:
                                        if (is_root) {
                                                insert_into_array(ins, elem, float, float_number)
                                        } else {
                                                insert_into_column(ins, elem, JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT,
                                                                   JAK_CARBON_COLUMN_TYPE_FLOAT,
                                                                   float, float_number);
                                        }
                                        break;
                                case JAK_JSON_LIST_FIXED_NULL: {
                                        jak_u64 approx_cap_nbytes = elem->value.value.array->elements.elements.num_elems;
                                        if (is_root) {
                                                for (jak_u32 i = 0;
                                                     i < elem->value.value.array->elements.elements.num_elems; i++) {
                                                        jak_carbon_insert_null(ins);
                                                }
                                        } else {
                                                jak_carbon_insert_array_state state;
                                                jak_carbon_insert *array_ins = jak_carbon_insert_array_begin(&state,
                                                                                                                ins,
                                                                                                                approx_cap_nbytes);
                                                for (jak_u32 i = 0;
                                                     i < elem->value.value.array->elements.elements.num_elems; i++) {
                                                        jak_carbon_insert_null(array_ins);
                                                }
                                                jak_carbon_insert_array_end(&state);
                                        }
                                }
                                        break;
                                case JAK_JSON_LIST_FIXED_BOOLEAN: {
                                        if (is_root) {
                                                for (jak_u32 i = 0;
                                                     i < elem->value.value.array->elements.elements.num_elems; i++) {
                                                        jak_json_element *array_elem = JAK_VECTOR_GET(
                                                                &elem->value.value.array->elements.elements, i,
                                                                jak_json_element);
                                                        if (array_elem->value.value_type == JAK_JSON_VALUE_TRUE) {
                                                                jak_carbon_insert_true(ins);
                                                        } else if (array_elem->value.value_type == JAK_JSON_VALUE_FALSE) {
                                                                jak_carbon_insert_false(ins);
                                                        } else if (array_elem->value.value_type == JAK_JSON_VALUE_NULL) {
                                                                jak_carbon_insert_null(ins);
                                                        } else {
                                                                JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE);
                                                        }
                                                }
                                        } else {
                                                jak_carbon_insert_column_state state;
                                                jak_u64 cap_nbytes = elem->value.value.array->elements.elements.num_elems;
                                                jak_carbon_insert *array_ins = jak_carbon_insert_column_begin(&state,
                                                                                                                 ins,
                                                                                                                 JAK_CARBON_COLUMN_TYPE_BOOLEAN,
                                                                                                                 cap_nbytes);
                                                for (jak_u32 i = 0;
                                                     i < elem->value.value.array->elements.elements.num_elems; i++) {
                                                        jak_json_element *array_elem = JAK_VECTOR_GET(
                                                                &elem->value.value.array->elements.elements, i,
                                                                jak_json_element);
                                                        if (array_elem->value.value_type == JAK_JSON_VALUE_TRUE) {
                                                                jak_carbon_insert_true(array_ins);
                                                        } else if (array_elem->value.value_type == JAK_JSON_VALUE_FALSE) {
                                                                jak_carbon_insert_false(array_ins);
                                                        } else if (array_elem->value.value_type == JAK_JSON_VALUE_NULL) {
                                                                jak_carbon_insert_null(array_ins);
                                                        } else {
                                                                JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE);
                                                        }
                                                }
                                                jak_carbon_insert_column_end(&state);
                                        }
                                }
                                        break;
                                default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE)
                                        break;
                        }
                }
                        break;
                case JAK_JSON_VALUE_STRING:
                        jak_carbon_insert_string(ins, elem->value.value.string->value);
                        break;
                case JAK_JSON_VALUE_NUMBER:
                        switch (elem->value.value.number->value_type) {
                                case JAK_JSON_NUMBER_FLOAT:
                                        jak_carbon_insert_float(ins, elem->value.value.number->value.float_number);
                                        break;
                                case JAK_JSON_NUMBER_UNSIGNED:
                                        jak_carbon_insert_unsigned(ins, elem->value.value.number->value.unsigned_integer);
                                        break;
                                case JAK_JSON_NUMBER_SIGNED:
                                        jak_carbon_insert_signed(ins, elem->value.value.number->value.signed_integer);
                                        break;
                                default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE)
                                        break;
                        }
                        break;
                case JAK_JSON_VALUE_TRUE:
                        jak_carbon_insert_true(ins);
                        break;
                case JAK_JSON_VALUE_FALSE:
                        jak_carbon_insert_false(ins);
                        break;
                case JAK_JSON_VALUE_NULL:
                        jak_carbon_insert_null(ins);
                        break;
                default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE)
                        break;
        }
}

bool jak_carbon_int_from_json(jak_carbon *doc, const jak_json *data,
                          jak_carbon_key_e key_type, const void *primary_key, int mode)
{
        JAK_UNUSED(data)
        JAK_UNUSED(primary_key)

        jak_carbon_new context;
        jak_carbon_insert *ins = jak_carbon_create_begin(&context, doc, key_type, mode);
        int_carbon_from_json_elem(ins, data->element, true);

        jak_carbon_create_end(&context);

        return true;
}

static void marker_insert(jak_memfile *memfile, jak_u8 marker)
{
        /* check whether marker can be written, otherwise make space for it */
        char c = *jak_memfile_peek(memfile, sizeof(jak_u8));
        if (c != 0) {
                jak_memfile_inplace_insert(memfile, sizeof(jak_u8));
        }
        jak_memfile_write(memfile, &marker, sizeof(jak_u8));
}

static bool array_it_is_slot_occupied(bool *is_empty_slot, bool *is_array_end, jak_carbon_array_it *it)
{
        jak_carbon_int_field_auto_close(&it->field_access);
        return is_slot_occupied(is_empty_slot, is_array_end, &it->memfile, JAK_CARBON_MARKER_ARRAY_END);
}

static bool object_it_is_slot_occupied(bool *is_empty_slot, bool *is_object_end, jak_carbon_object_it *it)
{
        jak_carbon_int_field_auto_close(&it->field.value.data);
        return is_slot_occupied(is_empty_slot, is_object_end, &it->memfile, JAK_CARBON_MARKER_OBJECT_END);
}

static bool is_slot_occupied(bool *is_empty_slot, bool *is_end_reached, jak_memfile *file, jak_u8 end_marker)
{
        JAK_ERROR_IF_NULL(file);
        char c = *jak_memfile_peek(file, 1);
        bool is_empty = c == 0, is_end = c == end_marker;
        JAK_OPTIONAL_SET(is_empty_slot, is_empty)
        JAK_OPTIONAL_SET(is_end_reached, is_end)
        if (!is_empty && !is_end) {
                return true;
        } else {
                return false;
        }
}

static bool object_it_next_no_load(bool *is_empty_slot, bool *is_array_end, jak_carbon_object_it *it)
{
        if (object_it_is_slot_occupied(is_empty_slot, is_array_end, it)) {
                jak_carbon_int_object_it_prop_skip(it);
                return true;
        } else {
                return false;
        }
}

static bool array_it_next_no_load(bool *is_empty_slot, bool *is_array_end, jak_carbon_array_it *it)
{
        if (array_it_is_slot_occupied(is_empty_slot, is_array_end, it)) {
                jak_carbon_int_array_it_field_type_read(it);
                jak_carbon_field_skip(&it->memfile);
                return true;
        } else {
                return false;
        }
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon_key.h>
#include <jak_carbon_string.h>

static void write_nokey(jak_memfile *file)
{
        jak_u8 marker = JAK_CARBON_MARKER_KEY_NOKEY;
        jak_memfile_write(file, &marker, sizeof(jak_u8));
}

static void write_autokey(jak_memfile *file)
{
        jak_u8 marker = JAK_CARBON_MARKER_KEY_AUTOKEY;
        jak_uid_t key = 0;
        jak_memfile_write(file, &marker, sizeof(jak_u8));
        jak_memfile_write(file, &key, sizeof(jak_uid_t));
}

static void write_ukey(jak_memfile *file)
{
        jak_u8 marker = JAK_CARBON_MARKER_KEY_UKEY;
        jak_u64 key = 0;
        jak_memfile_write(file, &marker, sizeof(jak_u8));
        jak_memfile_write(file, &key, sizeof(jak_u64));
}

static void write_ikey(jak_memfile *file)
{
        jak_u8 marker = JAK_CARBON_MARKER_KEY_IKEY;
        jak_i64 key = 0;
        jak_memfile_write(file, &marker, sizeof(jak_u8));
        jak_memfile_write(file, &key, sizeof(jak_u64));
}

static void write_skey(jak_memfile *file)
{
        jak_u8 marker = JAK_CARBON_MARKER_KEY_SKEY;
        const char *key = "";
        jak_memfile_write(file, &marker, sizeof(jak_u8));
        jak_carbon_jak_string_write(file, key);
}

bool jak_carbon_key_create(jak_memfile *file, jak_carbon_key_e type, jak_error *err)
{
        JAK_ERROR_IF_NULL(file)

        switch (type) {
                case JAK_CARBON_KEY_NOKEY:
                        write_nokey(file);
                        break;
                case JAK_CARBON_KEY_AUTOKEY:
                        write_autokey(file);
                        break;
                case JAK_CARBON_KEY_UKEY:
                        write_ukey(file);
                        break;
                case JAK_CARBON_KEY_IKEY:
                        write_ikey(file);
                        break;
                case JAK_CARBON_KEY_SKEY:
                        write_skey(file);
                        break;
                default:
                        JAK_OPTIONAL(err != NULL, JAK_ERROR(err, JAK_ERR_INTERNALERR))
                        return false;
        }
        return true;
}

bool jak_carbon_key_skip(jak_carbon_key_e *out, jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)
        jak_carbon_key_read(NULL, out, file);
        return true;
}

bool jak_carbon_key_write_unsigned(jak_memfile *file, jak_u64 key)
{
        JAK_ERROR_IF_NULL(file)

        JAK_DECLARE_AND_INIT(jak_carbon_key_e, key_type)

        jak_carbon_key_read_type(&key_type, file);
        if (jak_carbon_key_is_unsigned(key_type)) {
                jak_memfile_write(file, &key, sizeof(jak_u64));
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_TYPEMISMATCH)
                return false;
        }
}

bool jak_carbon_key_write_signed(jak_memfile *file, jak_i64 key)
{
        JAK_ERROR_IF_NULL(file)

        JAK_DECLARE_AND_INIT(jak_carbon_key_e, key_type)

        jak_carbon_key_read_type(&key_type, file);
        if (jak_carbon_key_is_signed(key_type)) {
                jak_memfile_write(file, &key, sizeof(jak_i64));
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_TYPEMISMATCH)
                return false;
        }
}

bool jak_carbon_key_update_string(jak_memfile *file, const char *key)
{
        return jak_carbon_key_update_jak_string_wnchar(file, key, strlen(key));
}

bool jak_carbon_key_update_jak_string_wnchar(jak_memfile *file, const char *key, size_t length)
{
        JAK_ERROR_IF_NULL(file)
        JAK_DECLARE_AND_INIT(jak_carbon_key_e, key_type)
        jak_carbon_key_read_type(&key_type, file);
        if (jak_carbon_key_is_string(key_type)) {
                jak_carbon_jak_string_update_wnchar(file, key, length);
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_TYPEMISMATCH)
                return false;
        }
}

bool jak_carbon_key_write_string(jak_memfile *file, const char *key)
{
        JAK_ERROR_IF_NULL(file)

        JAK_DECLARE_AND_INIT(jak_carbon_key_e, key_type)

        jak_carbon_key_read_type(&key_type, file);
        if (jak_carbon_key_is_string(key_type)) {
                jak_carbon_jak_string_write(file, key);
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_TYPEMISMATCH)
                return false;
        }
}

bool jak_carbon_key_read_type(jak_carbon_key_e *out, jak_memfile *file)
{
        jak_u8 marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);

        JAK_ASSERT(marker == JAK_CARBON_MARKER_KEY_NOKEY || marker == JAK_CARBON_MARKER_KEY_AUTOKEY || marker ==
                                                                                                       JAK_CARBON_MARKER_KEY_UKEY ||
                   marker == JAK_CARBON_MARKER_KEY_IKEY || marker == JAK_CARBON_MARKER_KEY_SKEY);

        switch (marker) {
                case JAK_CARBON_MARKER_KEY_NOKEY:
                        JAK_OPTIONAL_SET(out, JAK_CARBON_KEY_NOKEY)
                        break;
                case JAK_CARBON_MARKER_KEY_AUTOKEY:
                        JAK_OPTIONAL_SET(out, JAK_CARBON_KEY_AUTOKEY)
                        break;
                case JAK_CARBON_MARKER_KEY_UKEY:
                        JAK_OPTIONAL_SET(out, JAK_CARBON_KEY_UKEY)
                        break;
                case JAK_CARBON_MARKER_KEY_IKEY:
                        JAK_OPTIONAL_SET(out, JAK_CARBON_KEY_IKEY)
                        break;
                case JAK_CARBON_MARKER_KEY_SKEY:
                        JAK_OPTIONAL_SET(out, JAK_CARBON_KEY_SKEY)
                        break;
                default: JAK_ERROR(&file->err, JAK_ERR_INTERNALERR)
                        return false;
        }
        return true;
}

const void *jak_carbon_key_read(jak_u64 *len, jak_carbon_key_e *out, jak_memfile *file)
{
        jak_carbon_key_e key_type = 0;
        jak_carbon_key_read_type(&key_type, file);

        JAK_OPTIONAL_SET(out, key_type)

        switch (key_type) {
                case JAK_CARBON_KEY_NOKEY:
                        JAK_OPTIONAL_SET(len, 0)
                        return NULL;
                case JAK_CARBON_KEY_AUTOKEY:
                        JAK_OPTIONAL_SET(len, sizeof(jak_uid_t))
                        return JAK_MEMFILE_READ_TYPE(file, jak_uid_t);
                case JAK_CARBON_KEY_UKEY:
                        JAK_OPTIONAL_SET(len, sizeof(jak_u64))
                        return JAK_MEMFILE_READ_TYPE(file, jak_u64);
                case JAK_CARBON_KEY_IKEY:
                        JAK_OPTIONAL_SET(len, sizeof(jak_i64))
                        return JAK_MEMFILE_READ_TYPE(file, jak_i64);
                case JAK_CARBON_KEY_SKEY:
                        return jak_carbon_jak_string_read(len, file);
                default: JAK_ERROR(&file->err, JAK_ERR_INTERNALERR)
                        return NULL;
        }
}

const char *jak_carbon_key_type_str(jak_carbon_key_e type)
{
        switch (type) {
                case JAK_CARBON_KEY_NOKEY:
                        return "nokey";
                case JAK_CARBON_KEY_AUTOKEY:
                        return "autokey";
                case JAK_CARBON_KEY_UKEY:
                        return "ukey";
                case JAK_CARBON_KEY_IKEY:
                        return "ikey";
                case JAK_CARBON_KEY_SKEY:
                        return "skey";
                default: JAK_ERROR_PRINT(JAK_ERR_INTERNALERR);
                        return NULL;
        }
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon_media.h>

#define find_mime_by_ext(needle_ext)                                                    \
({                                                                                      \
        register size_t l = 0;                                                          \
        register size_t r = _jak_global_mime_type_register - 1;                                   \
        jak_u32 result = _jak_global_mime_type_register;                                              \
        while (l <= r && r < SIZE_MAX) {                                                \
                register size_t m = l + (r - l) / 2;                                    \
                register int comp = strcmp(jak_global_mime_type_register[m].ext, needle_ext);      \
                if (comp == 0) {                                                        \
                        result = m;                                                     \
                        break;                                                          \
                }                                                                       \
                if (comp < 0) {                                                         \
                        l = m + 1;                                                      \
                } else {                                                                \
                        r = m - 1;                                                      \
                }                                                                       \
        }                                                                               \
        result;                                                                         \
})

bool jak_carbon_media_write(jak_memfile *dst, jak_carbon_field_type_e type)
{
        JAK_ERROR_IF_NULL(dst);
        jak_media_type t = type;
        jak_memfile_write(dst, &t, sizeof(jak_media_type));
        return true;
}

jak_u32 jak_carbon_media_mime_type_by_ext(const char *ext)
{
        jak_u32 id;
        if (JAK_LIKELY(ext != NULL)) {
                if (JAK_LIKELY((id = find_mime_by_ext(ext)) < (jak_u32) _jak_global_mime_type_register)) {
                        return id;
                }
        }
        id = find_mime_by_ext("bin");
        JAK_ASSERT(id < _jak_global_mime_type_register);
        return id;
}

const char *jak_carbon_media_mime_type_by_id(jak_u32 id)
{
        if (JAK_UNLIKELY(id >= _jak_global_mime_type_register)) {
                id = find_mime_by_ext("bin");
                JAK_ASSERT(id < _jak_global_mime_type_register);
        }
        return jak_global_mime_type_register[id].type;
}

const char *jak_carbon_media_mime_ext_by_id(jak_u32 id)
{
        if (JAK_UNLIKELY(id >= _jak_global_mime_type_register)) {
                id = find_mime_by_ext("bin");
                JAK_ASSERT(id < _jak_global_mime_type_register);
        }
        return jak_global_mime_type_register[id].ext;
}


/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon.h>
#include <jak_carbon_object_it.h>
#include <jak_carbon_column_it.h>
#include <jak_carbon_insert.h>
#include <jak_carbon_string.h>
#include <jak_carbon_prop.h>
#include "jak_carbon_object_it.h"

bool jak_carbon_object_it_create(jak_carbon_object_it *it, jak_memfile *memfile, jak_error *err,
                             jak_offset_t payload_start)
{
        JAK_ERROR_IF_NULL(it);
        JAK_ERROR_IF_NULL(memfile);
        JAK_ERROR_IF_NULL(err);

        it->object_contents_off = payload_start;
        it->mod_size = 0;
        it->object_end_reached = false;

        jak_spinlock_init(&it->lock);
        jak_error_init(&it->err);

        jak_vector_create(&it->history, NULL, sizeof(jak_offset_t), 40);

        jak_memfile_open(&it->memfile, memfile->memblock, memfile->mode);
        jak_memfile_seek(&it->memfile, payload_start);

        JAK_ERROR_IF(jak_memfile_remain_size(&it->memfile) < sizeof(jak_u8), err, JAK_ERR_CORRUPTED);

        jak_u8 marker = *jak_memfile_read(&it->memfile, sizeof(jak_u8));
        JAK_ERROR_IF_WDETAILS(marker != JAK_CARBON_MARKER_OBJECT_BEGIN, err, JAK_ERR_ILLEGALOP,
                              "object begin marker ('{') not found");

        it->object_contents_off += sizeof(jak_u8);

        jak_carbon_int_field_access_create(&it->field.value.data);

        jak_carbon_object_it_rewind(it);

        return true;
}

bool jak_carbon_object_it_copy(jak_carbon_object_it *dst, jak_carbon_object_it *src)
{
        JAK_ERROR_IF_NULL(dst);
        JAK_ERROR_IF_NULL(src);
        jak_carbon_object_it_create(dst, &src->memfile, &src->err, src->object_contents_off - sizeof(jak_u8));
        return true;
}

bool jak_carbon_object_it_clone(jak_carbon_object_it *dst, jak_carbon_object_it *src)
{
        JAK_ERROR_IF_NULL(dst);
        JAK_ERROR_IF_NULL(src);
        jak_memfile_clone(&dst->memfile, &src->memfile);
        dst->object_contents_off = src->object_contents_off;
        jak_spinlock_init(&dst->lock);
        jak_error_cpy(&dst->err, &src->err);
        dst->mod_size = src->mod_size;
        dst->object_end_reached = src->object_end_reached;
        jak_vector_cpy(&dst->history, &src->history);
        dst->field.key.name_len = src->field.key.name_len;
        dst->field.key.name = src->field.key.name;
        dst->field.key.offset = src->field.key.offset;
        dst->field.value.offset = src->field.value.offset;
        jak_carbon_int_field_access_clone(&dst->field.value.data, &src->field.value.data);
        return true;
}

bool jak_carbon_object_it_drop(jak_carbon_object_it *it)
{
        jak_carbon_int_field_auto_close(&it->field.value.data);
        jak_carbon_int_field_access_drop(&it->field.value.data);
        jak_vector_drop(&it->history);
        return true;
}

bool jak_carbon_object_it_rewind(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it);
        JAK_ERROR_IF(it->object_contents_off >= jak_memfile_size(&it->memfile), &it->err, JAK_ERR_OUTOFBOUNDS);
        jak_carbon_int_history_clear(&it->history);
        return jak_memfile_seek(&it->memfile, it->object_contents_off);
}

bool jak_carbon_object_it_next(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it);
        bool is_empty_slot;
        jak_offset_t last_off = jak_memfile_tell(&it->memfile);
        jak_carbon_int_field_access_drop(&it->field.value.data);
        if (jak_carbon_int_object_it_next(&is_empty_slot, &it->object_end_reached, it)) {
                jak_carbon_int_history_push(&it->history, last_off);
                return true;
        } else {
                /* skip remaining zeros until end of array is reached */
                if (!it->object_end_reached) {
                        JAK_ERROR_IF(!is_empty_slot, &it->err, JAK_ERR_CORRUPTED);

                        while (*jak_memfile_peek(&it->memfile, 1) == 0) {
                                jak_memfile_skip(&it->memfile, 1);
                        }
                }

                JAK_ASSERT(*jak_memfile_peek(&it->memfile, sizeof(char)) == JAK_CARBON_MARKER_OBJECT_END);
                return false;
        }
}

bool jak_carbon_object_it_has_next(jak_carbon_object_it *it)
{
        bool has_next = jak_carbon_object_it_next(it);
        jak_carbon_object_it_prev(it);
        return has_next;
}

bool jak_carbon_object_it_prev(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it);
        if (jak_carbon_int_history_has(&it->history)) {
                jak_offset_t prev_off = jak_carbon_int_history_pop(&it->history);
                jak_memfile_seek(&it->memfile, prev_off);
                return jak_carbon_int_object_it_refresh(NULL, NULL, it);
        } else {
                return false;
        }
}

jak_offset_t jak_carbon_object_it_jak_memfile_pos(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it)
        return jak_memfile_tell(&it->memfile);
}

bool jak_carbon_object_it_tell(jak_offset_t *key_off, jak_offset_t *value_off, jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it)
        JAK_OPTIONAL_SET(key_off, it->field.key.offset);
        JAK_OPTIONAL_SET(value_off, it->field.value.offset);
        return true;
}

const char *jak_carbon_object_it_prop_name(jak_u64 *key_len, jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it)
        JAK_ERROR_IF_NULL(key_len)
        *key_len = it->field.key.name_len;
        return it->field.key.name;
}

static jak_i64 prop_remove(jak_carbon_object_it *it, jak_carbon_field_type_e type)
{
        jak_i64 prop_size = jak_carbon_prop_size(&it->memfile);
        jak_carbon_jak_string_nomarker_remove(&it->memfile);
        if (jak_carbon_int_field_remove(&it->memfile, &it->err, type)) {
                jak_carbon_int_object_it_refresh(NULL, NULL, it);
                return prop_size;
        } else {
                return 0;
        }
}

bool jak_carbon_object_it_remove(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it);
        jak_carbon_field_type_e type;
        if (jak_carbon_object_it_prop_type(&type, it)) {
                jak_offset_t prop_off = jak_carbon_int_history_pop(&it->history);
                jak_memfile_seek(&it->memfile, prop_off);
                it->mod_size -= prop_remove(it, type);
                return true;
        } else {
                JAK_ERROR(&it->err, JAK_ERR_ILLEGALSTATE);
                return false;
        }
}

bool jak_carbon_object_it_prop_type(jak_carbon_field_type_e *type, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_field_type(type, &it->field.value.data);
}

bool jak_carbon_object_it_u8_value(jak_u8 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_u8_value(value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_u16_value(jak_u16 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_u16_value(value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_u32_value(jak_u32 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_u32_value(value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_u64_value(jak_u64 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_u64_value(value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_i8_value(jak_i8 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_i8_value(value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_i16_value(jak_i16 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_i16_value(value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_i32_value(jak_i32 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_i32_value(value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_i64_value(jak_i64 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_i64_value(value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_float_value(bool *is_null_in, float *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_float_value(is_null_in, value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_signed_value(bool *is_null_in, jak_i64 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_signed_value(is_null_in, value, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_unsigned_value(bool *is_null_in, jak_u64 *value, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_unsigned_value(is_null_in, value, &it->field.value.data, &it->err);
}

const char *jak_carbon_object_it_jak_string_value(jak_u64 *strlen, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_jak_string_value(strlen, &it->field.value.data, &it->err);
}

bool jak_carbon_object_it_binary_value(jak_carbon_binary *out, jak_carbon_object_it *it)
{
        return jak_carbon_int_field_access_binary_value(out, &it->field.value.data, &it->err);
}

jak_carbon_array_it *jak_carbon_object_it_array_value(jak_carbon_object_it *it_in)
{
        return jak_carbon_int_field_access_array_value(&it_in->field.value.data, &it_in->err);
}

jak_carbon_object_it *jak_carbon_object_it_object_value(jak_carbon_object_it *it_in)
{
        return jak_carbon_int_field_access_object_value(&it_in->field.value.data, &it_in->err);
}

jak_carbon_column_it *jak_carbon_object_it_column_value(jak_carbon_object_it *it_in)
{
        return jak_carbon_int_field_access_column_value(&it_in->field.value.data, &it_in->err);
}

bool jak_carbon_object_it_insert_begin(jak_carbon_insert *inserter, jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(inserter)
        JAK_ERROR_IF_NULL(it)
        return jak_carbon_int_insert_create_for_object(inserter, it);
}

bool jak_carbon_object_it_insert_end(jak_carbon_insert *inserter)
{
        JAK_ERROR_IF_NULL(inserter)
        return jak_carbon_insert_drop(inserter);
}

bool jak_carbon_object_it_lock(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it)
        jak_spinlock_acquire(&it->lock);
        return true;
}

bool jak_carbon_object_it_unlock(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it)
        jak_spinlock_release(&it->lock);
        return true;
}

bool jak_carbon_object_it_fast_forward(jak_carbon_object_it *it)
{
        JAK_ERROR_IF_NULL(it);
        while (jak_carbon_object_it_next(it)) {}

        JAK_ASSERT(*jak_memfile_peek(&it->memfile, sizeof(jak_u8)) == JAK_CARBON_MARKER_OBJECT_END);
        jak_memfile_skip(&it->memfile, sizeof(jak_u8));
        return true;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon_path.h>
#include <jak_carbon_find.h>
#include <jak_carbon_revise.h>
#include "jak_carbon_path.h"

static inline jak_carbon_path_status_e traverse_column(jak_carbon_path_evaluator *state,
                                                      const jak_carbon_dot_path *path, jak_u32 current_path_pos,
                                                      jak_carbon_column_it *it);

static inline jak_carbon_path_status_e traverse_array(jak_carbon_path_evaluator *state,
                                                     const jak_carbon_dot_path *path, jak_u32 current_path_pos,
                                                     jak_carbon_array_it *it, bool is_record);

bool jak_carbon_path_evaluator_begin(jak_carbon_path_evaluator *eval, jak_carbon_dot_path *path,
                                 jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(eval)
        JAK_ERROR_IF_NULL(path)
        JAK_ERROR_IF_NULL(doc)

        JAK_ZERO_MEMORY(eval, sizeof(jak_carbon_path_evaluator));
        eval->doc = doc;
        JAK_CHECK_SUCCESS(jak_error_init(&eval->err));
        JAK_CHECK_SUCCESS(jak_carbon_iterator_open(&eval->root_it, eval->doc));
        eval->status = traverse_array(eval, path, 0, &eval->root_it, true);
        JAK_CHECK_SUCCESS(jak_carbon_iterator_close(&eval->root_it));
        return true;
}

bool jak_carbon_path_evaluator_begin_mutable(jak_carbon_path_evaluator *eval, const jak_carbon_dot_path *path,
                                         jak_carbon_revise *context)
{
        JAK_ERROR_IF_NULL(eval)
        JAK_ERROR_IF_NULL(path)
        JAK_ERROR_IF_NULL(context)

        eval->doc = context->revised_doc;
        JAK_CHECK_SUCCESS(jak_error_init(&eval->err));
        JAK_CHECK_SUCCESS(jak_carbon_revise_iterator_open(&eval->root_it, context));
        eval->status = traverse_array(eval, path, 0, &eval->root_it, true);
        JAK_CHECK_SUCCESS(jak_carbon_iterator_close(&eval->root_it));
        return true;
}

bool jak_carbon_path_evaluator_status(jak_carbon_path_status_e *status, jak_carbon_path_evaluator *state)
{
        JAK_ERROR_IF_NULL(status)
        JAK_ERROR_IF_NULL(state)
        *status = state->status;
        return true;
}

bool jak_carbon_path_evaluator_has_result(jak_carbon_path_evaluator *state)
{
        JAK_ERROR_IF_NULL(state)
        return state->status == JAK_CARBON_PATH_RESOLVED;
}

bool jak_carbon_path_evaluator_end(jak_carbon_path_evaluator *state)
{
        JAK_ERROR_IF_NULL(state)
        switch (state->result.container_type) {
                case JAK_CARBON_OBJECT:
                        jak_carbon_object_it_drop(&state->result.containers.object.it);
                        break;
                case JAK_CARBON_ARRAY:
                        jak_carbon_array_it_drop(&state->result.containers.array.it);
                        break;
                case JAK_CARBON_COLUMN:
                        break;
                default: JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);
        }
        return true;
}

bool jak_carbon_path_exists(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        bool result = jak_carbon_find_open(&find, path, doc);
        jak_carbon_find_close(&find);
        return result;
}

bool jak_carbon_path_is_array(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        bool result = false;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                result = jak_carbon_field_type_is_array(field_type);
        }

        jak_carbon_find_close(&find);
        return result;
}

bool jak_carbon_path_is_column(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        bool result = false;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                result = jak_carbon_field_type_is_column(field_type);
        }

        jak_carbon_find_close(&find);
        return result;
}

bool jak_carbon_path_is_object(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        bool result = false;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                result = jak_carbon_field_type_is_object(field_type);
        }

        jak_carbon_find_close(&find);
        return result;
}

bool jak_carbon_path_is_container(jak_carbon *doc, const char *path)
{
        return (jak_carbon_path_is_array(doc, path) || jak_carbon_path_is_column(doc, path) ||
                jak_carbon_path_is_object(doc, path));
}

bool jak_carbon_path_is_null(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        bool result = false;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                result = jak_carbon_field_type_is_null(field_type);
        }

        jak_carbon_find_close(&find);
        return result;
}

bool jak_carbon_path_is_number(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        bool result = false;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                result = jak_carbon_field_type_is_number(field_type);
        }

        jak_carbon_find_close(&find);
        return result;
}

bool jak_carbon_path_is_boolean(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        bool result = false;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                result = jak_carbon_field_type_is_boolean(field_type);
        }

        jak_carbon_find_close(&find);
        return result;
}

bool jak_carbon_path_is_string(jak_carbon *doc, const char *path)
{
        jak_carbon_find find;
        jak_carbon_field_type_e field_type;
        bool result = false;

        if (jak_carbon_find_open(&find, path, doc)) {
                jak_carbon_find_result_type(&field_type, &find);
                result = jak_carbon_field_type_is_string(field_type);
        }

        jak_carbon_find_close(&find);
        return result;
}

static inline jak_carbon_path_status_e traverse_object(jak_carbon_path_evaluator *state,
                                                      const jak_carbon_dot_path *path, jak_u32 current_path_pos,
                                                      jak_carbon_object_it *it)
{
        carbon_dot_node_e node_type;
        jak_u32 path_length;
        bool status;

        jak_carbon_dot_path_type_at(&node_type, current_path_pos, path);
        JAK_ASSERT(node_type == JAK_DOT_NODE_KEY_NAME);

        status = jak_carbon_object_it_next(it);
        jak_carbon_dot_path_len(&path_length, path);
        const char *needle = jak_carbon_dot_path_key_at(current_path_pos, path);
        jak_u64 needle_len = strlen(needle);
        jak_u32 next_path_pos = current_path_pos + 1;

        if (!status) {
                /* empty document */
                return JAK_CARBON_PATH_EMPTY_DOC;
        } else {
                jak_u64 key_len;
                do {
                        const char *key_name = jak_carbon_object_it_prop_name(&key_len, it);
                        if (key_len == needle_len && strncmp(key_name, needle, needle_len) == 0) {
                                if (next_path_pos == path_length) {
                                        state->result.container_type = JAK_CARBON_OBJECT;
                                        jak_carbon_object_it_clone(&state->result.containers.object.it, it);
                                        return JAK_CARBON_PATH_RESOLVED;
                                } else {
                                        /* path end not reached, traverse further if possible */
                                        JAK_ASSERT(next_path_pos < path_length);

                                        jak_carbon_field_type_e prop_type;
                                        jak_carbon_object_it_prop_type(&prop_type, it);

                                        if (!jak_carbon_field_type_is_traversable(prop_type)) {
                                                return JAK_CARBON_PATH_NOTTRAVERSABLE;
                                        } else {
                                                JAK_ASSERT(prop_type == JAK_CARBON_FIELD_TYPE_OBJECT ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_ARRAY ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_U8 ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_U16 ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_U32 ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_U64 ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_I8 ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_I16 ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_I32 ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_I64 ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT ||
                                                           prop_type == JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN);
                                                switch (prop_type) {
                                                        case JAK_CARBON_FIELD_TYPE_OBJECT: {
                                                                jak_carbon_object_it *sub_it = jak_carbon_object_it_object_value(
                                                                        it);
                                                                jak_carbon_path_status_e ret = traverse_object(state,
                                                                                                              path,
                                                                                                              next_path_pos,
                                                                                                              sub_it);
                                                                jak_carbon_object_it_drop(sub_it);
                                                                return ret;
                                                        }
                                                        case JAK_CARBON_FIELD_TYPE_ARRAY: {
                                                                jak_carbon_array_it *sub_it = jak_carbon_object_it_array_value(
                                                                        it);
                                                                jak_carbon_path_status_e ret = traverse_array(state,
                                                                                                             path,
                                                                                                             next_path_pos,
                                                                                                             sub_it,
                                                                                                             false);
                                                                jak_carbon_array_it_drop(sub_it);
                                                                return ret;
                                                        }
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                                                        case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                                                                jak_carbon_column_it *sub_it = jak_carbon_object_it_column_value(
                                                                        it);
                                                                return traverse_column(state,
                                                                                       path,
                                                                                       next_path_pos,
                                                                                       sub_it);
                                                        }
                                                        default: JAK_ERROR(&it->err, JAK_ERR_UNSUPPORTEDTYPE)
                                                                return JAK_CARBON_PATH_INTERNAL;
                                                }
                                        }
                                }
                        }
                } while (jak_carbon_object_it_next(it));
        }

        return JAK_CARBON_PATH_NOSUCHKEY;
}

static inline jak_carbon_path_status_e traverse_array(jak_carbon_path_evaluator *state,
                                                     const jak_carbon_dot_path *path, jak_u32 current_path_pos,
                                                     jak_carbon_array_it *it, bool is_record)
{
        JAK_ASSERT(state);
        JAK_ASSERT(path);
        JAK_ASSERT(it);
        JAK_ASSERT(current_path_pos < path->path_len);

        jak_carbon_field_type_e elem_type;
        carbon_dot_node_e node_type;
        jak_u32 path_length;
        jak_carbon_path_status_e status;
        jak_u32 requested_array_idx;
        jak_u32 current_array_idx = 0;
        bool is_unit_array = jak_carbon_array_it_is_unit(it);

        jak_carbon_dot_path_type_at(&node_type, current_path_pos, path);

        jak_carbon_dot_path_len(&path_length, path);

        if (!jak_carbon_array_it_next(it)) {
                /* empty document */
                return JAK_CARBON_PATH_EMPTY_DOC;
        } else {
                switch (node_type) {
                        case JAK_DOT_NODE_ARRAY_IDX:
                                jak_carbon_dot_path_idx_at(&requested_array_idx, current_path_pos, path);
                                while (current_array_idx < requested_array_idx &&
                                       jak_carbon_array_it_next(it)) { current_array_idx++; }
                                JAK_ASSERT(current_array_idx <= requested_array_idx);
                                if (current_array_idx != requested_array_idx) {
                                        /* root array has too less elements to reach the requested index */
                                        return JAK_CARBON_PATH_NOSUCHINDEX;
                                } else {
                                        /* requested index is reached; depending on the subsequent path, lookup may stops */
                                        jak_carbon_array_it_field_type(&elem_type, it);
                                        jak_u32 next_path_pos = current_path_pos + 1;
                                        if (is_unit_array && is_record && jak_carbon_field_type_is_column(elem_type)) {
                                                jak_carbon_column_it *sub_it = jak_carbon_array_it_column_value(
                                                        it);
                                                return traverse_column(state,
                                                                       path,
                                                                       next_path_pos,
                                                                       sub_it);
                                        } else {
                                                if (next_path_pos < path_length) {
                                                        /* path must be further evaluated in the next step, which requires a container
                                                         * type (for traversability) */
                                                        carbon_dot_node_e next_node_type;
                                                        jak_carbon_dot_path_type_at(&next_node_type, next_path_pos, path);
                                                        if (!jak_carbon_field_type_is_traversable(elem_type)) {
                                                                /* the array element is not a container; path evaluation stops here */
                                                                return JAK_CARBON_PATH_NOTTRAVERSABLE;
                                                        } else {
                                                                /* array element is traversable */
                                                                switch (next_node_type) {
                                                                        case JAK_DOT_NODE_ARRAY_IDX:
                                                                                /* next node in path is an array index which requires that
                                                                                 * the current array element is an array or column */
                                                                                if (elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_ARRAY &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_U8 &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_U16 &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_U32 &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_U64 &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_I8 &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_I16 &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_I32 &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_I64 &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT &&
                                                                                    elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN) {
                                                                                        return JAK_CARBON_PATH_NOCONTAINER;
                                                                                } else {
                                                                                        if (elem_type ==
                                                                                            JAK_CARBON_FIELD_TYPE_ARRAY) {
                                                                                                jak_carbon_array_it *sub_it = jak_carbon_array_it_array_value(
                                                                                                        it);
                                                                                                status = traverse_array(
                                                                                                        state,
                                                                                                        path,
                                                                                                        next_path_pos,
                                                                                                        sub_it, false);
                                                                                                jak_carbon_array_it_drop(
                                                                                                        sub_it);
                                                                                                return status;
                                                                                        } else {
                                                                                                JAK_ASSERT(elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_U8 ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_U16 ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_U32 ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_U64 ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_I8 ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_I16 ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_I32 ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_I64 ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT ||
                                                                                                           elem_type ==
                                                                                                           JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN);
                                                                                                jak_carbon_column_it *sub_it = jak_carbon_array_it_column_value(
                                                                                                        it);
                                                                                                return traverse_column(
                                                                                                        state,
                                                                                                        path,
                                                                                                        next_path_pos,
                                                                                                        sub_it);
                                                                                        }
                                                                                }
                                                                        case JAK_DOT_NODE_KEY_NAME:
                                                                                /* next node in path is a key name which requires that
                                                                                 * the current array element is of type object */
                                                                                if (elem_type !=
                                                                                    JAK_CARBON_FIELD_TYPE_OBJECT) {
                                                                                        return JAK_CARBON_PATH_NOTANOBJECT;
                                                                                } else {
                                                                                        jak_carbon_object_it *sub_it = jak_carbon_array_it_object_value(
                                                                                                it);
                                                                                        status = traverse_object(state,
                                                                                                                 path,
                                                                                                                 next_path_pos,
                                                                                                                 sub_it);
                                                                                        jak_carbon_object_it_drop(sub_it);
                                                                                        return status;
                                                                                }
                                                                        default: JAK_ERROR_PRINT(JAK_ERR_INTERNALERR);
                                                                                return JAK_CARBON_PATH_INTERNAL;
                                                                }
                                                        }
                                                } else {
                                                        /* path end is reached */
                                                        state->result.container_type = JAK_CARBON_ARRAY;
                                                        jak_carbon_array_it_clone(&state->result.containers.array.it, it);
                                                        return JAK_CARBON_PATH_RESOLVED;
                                                }
                                        }
                                }
                        case JAK_DOT_NODE_KEY_NAME:
                                /* first array element exists, which must be of type object */
                                jak_carbon_array_it_field_type(&elem_type, it);
                                if (elem_type != JAK_CARBON_FIELD_TYPE_OBJECT) {
                                        /* first array element is not of type object and a key lookup cannot
                                         * be executed, consequentially */
                                        return JAK_CARBON_PATH_NOTANOBJECT;
                                } else {
                                        /* next node in path is a key name which requires that
                                                                         * the current array element is of type object */
                                        if (elem_type != JAK_CARBON_FIELD_TYPE_OBJECT) {
                                                return JAK_CARBON_PATH_NOTANOBJECT;
                                        } else {
                                                if (is_unit_array && is_record) {
                                                        jak_carbon_object_it *sub_it = jak_carbon_array_it_object_value(
                                                                it);
                                                        status = traverse_object(state,
                                                                                 path,
                                                                                 current_path_pos,
                                                                                 sub_it);
                                                        jak_carbon_object_it_drop(sub_it);
                                                        return status;
                                                } else {
                                                        return JAK_CARBON_PATH_NOSUCHKEY;
                                                }
                                        }
                                }
                                break;
                        default: JAK_ERROR(&((jak_carbon_dot_path *) path)->err, JAK_ERR_INTERNALERR);
                                return JAK_CARBON_PATH_INTERNAL;
                }
        }
}

static inline jak_carbon_path_status_e traverse_column(jak_carbon_path_evaluator *state,
                                                      const jak_carbon_dot_path *path, jak_u32 current_path_pos,
                                                      jak_carbon_column_it *it)
{
        jak_u32 total_path_len;
        jak_u32 requested_idx;
        jak_u32 nun_values_contained;
        carbon_dot_node_e node_type;
        jak_carbon_field_type_e column_type;
        jak_carbon_dot_path_len(&total_path_len, path);
        if (current_path_pos + 1 != total_path_len) {
                /* a column cannot contain further containers; since the current path node is not
                 * the last one, traversal cannot be continued */
                return JAK_CARBON_PATH_NONESTING;
        } else {
                jak_carbon_dot_path_type_at(&node_type, current_path_pos, path);
                JAK_ASSERT(node_type == JAK_DOT_NODE_ARRAY_IDX);
                jak_carbon_dot_path_idx_at(&requested_idx, current_path_pos, path);
                jak_carbon_column_it_values_info(&column_type, &nun_values_contained, it);
                if (requested_idx >= nun_values_contained) {
                        /* requested index does not exists in this column */
                        return JAK_CARBON_PATH_NOSUCHINDEX;
                } else {
                        state->result.container_type = JAK_CARBON_COLUMN;
                        jak_carbon_column_it_clone(&state->result.containers.column.it, it);
                        state->result.containers.column.elem_pos = requested_idx;
                        return JAK_CARBON_PATH_RESOLVED;
                }
        }
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------
//  includes
// ---------------------------------------------------------------------------------------------------------------------

#include <jak_utils_hexdump.h>
#include <jak_carbon_path_index.h>
#include <jak_carbon_key.h>
#include "jak_carbon_int.h"
#include "jak_carbon_string.h"
#include "jak_carbon_insert.h"
#include "jak_carbon_commit.h"

// ---------------------------------------------------------------------------------------------------------------------
//  config
// ---------------------------------------------------------------------------------------------------------------------

#define PATH_INDEX_CAPACITY 1024

#define PATH_MARKER_PROP_NODE 'P'
#define PATH_MARKER_ARRAY_NODE 'a'
#define PATH_MARKER_COLUMN_NODE 'A'

// ---------------------------------------------------------------------------------------------------------------------
//  types
// ---------------------------------------------------------------------------------------------------------------------

struct path_index_node {
        jak_path_index_node_e type;

        union {
                jak_u64 pos;
                struct {
                        const char *name;
                        jak_u64 name_len;
                        jak_offset_t offset;
                } key;
        } entry;

        jak_carbon_field_type_e field_type;
        jak_offset_t field_offset;

        jak_vector ofType(struct path_index_node) sub_entries;
};

// ---------------------------------------------------------------------------------------------------------------------
//  helper prototypes
// ---------------------------------------------------------------------------------------------------------------------

static void
array_to_str(jak_string *str, jak_carbon_path_index *index, bool is_root, unsigned intent_level);

static void array_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index, bool is_root);

static void prop_to_str(jak_string *str, jak_carbon_path_index *index, unsigned intent_level);

static void prop_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index);

static void column_to_str(jak_string *str, jak_carbon_path_index *index, unsigned intent_level);

static void column_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index);

static void object_build_index(struct path_index_node *parent, jak_carbon_object_it *elem_it);

static void array_build_index(struct path_index_node *parent, jak_carbon_array_it *elem_it);

static void node_flat(jak_memfile *file, struct path_index_node *node);

// ---------------------------------------------------------------------------------------------------------------------
//  helper
// ---------------------------------------------------------------------------------------------------------------------

static void intent(jak_string *str, unsigned intent)
{
        jak_string_add_char(str, '\n');
        for (unsigned i = 0; i < intent; i++) {
                jak_string_add(str, "    ");
        }
}

static void path_index_node_init(struct path_index_node *node)
{
        JAK_ZERO_MEMORY(node, sizeof(struct path_index_node));
        jak_vector_create(&node->sub_entries, NULL, sizeof(struct path_index_node), 10);
        node->type = JAK_PATH_ROOT;
}

static void path_index_node_drop(struct path_index_node *node)
{
        for (jak_u32 i = 0; i < node->sub_entries.num_elems; i++) {
                struct path_index_node *sub = JAK_VECTOR_GET(&node->sub_entries, i, struct path_index_node);
                path_index_node_drop(sub);
        }
        jak_vector_drop(&node->sub_entries);
}

static void path_index_node_new_array_element(struct path_index_node *node, jak_u64 pos, jak_offset_t value_off)
{
        path_index_node_init(node);
        node->type = JAK_PATH_INDEX_ARRAY_INDEX;
        node->entry.pos = pos;
        node->field_offset = value_off;
}

static void path_index_node_new_column_element(struct path_index_node *node, jak_u64 pos, jak_offset_t value_off)
{
        path_index_node_init(node);
        node->type = JAK_PATH_INDEX_COLUMN_INDEX;
        node->entry.pos = pos;
        node->field_offset = value_off;
}

static void path_index_node_new_object_prop(struct path_index_node *node, jak_offset_t key_off, const char *name,
                                            jak_u64 name_len, jak_offset_t value_off)
{
        path_index_node_init(node);
        node->type = JAK_PATH_INDEX_PROP_KEY;
        node->entry.key.offset = key_off;
        node->entry.key.name = name;
        node->entry.key.name_len = name_len;
        node->field_offset = value_off;
}

static void path_index_node_set_field_type(struct path_index_node *node, jak_carbon_field_type_e field_type)
{
        node->field_type = field_type;
}

static struct path_index_node *
path_index_node_add_array_elem(struct path_index_node *parent, jak_u64 pos, jak_offset_t value_off)
{
        /* For elements in array, the type marker (e.g., [c]) is contained. That is needed since the element might
         * be a container */
        struct path_index_node *sub = JAK_VECTOR_NEW_AND_GET(&parent->sub_entries, struct path_index_node);
        path_index_node_new_array_element(sub, pos, value_off);
        return sub;
}

static struct path_index_node *
path_index_node_add_column_elem(struct path_index_node *parent, jak_u64 pos, jak_offset_t value_off)
{
        /* For elements in column, there is no type marker since no value is allowed to be a container */
        struct path_index_node *sub = JAK_VECTOR_NEW_AND_GET(&parent->sub_entries, struct path_index_node);
        path_index_node_new_column_element(sub, pos, value_off);
        return sub;
}

static struct path_index_node *path_index_node_add_key_elem(struct path_index_node *parent, jak_offset_t key_off,
                                                            const char *name, jak_u64 name_len, jak_offset_t value_off)
{
        struct path_index_node *sub = JAK_VECTOR_NEW_AND_GET(&parent->sub_entries, struct path_index_node);
        path_index_node_new_object_prop(sub, key_off, name, name_len, value_off);
        return sub;
}

static void path_index_node_print_level(FILE *file, struct path_index_node *node, unsigned level)
{
        for (unsigned i = 0; i < level; i++) {
                fprintf(file, " ");
        }
        if (node->type == JAK_PATH_ROOT) {
                fprintf(file, "root");
        } else if (node->type == JAK_PATH_INDEX_ARRAY_INDEX) {
                fprintf(file, "array_idx(%"PRIu64"), ", node->entry.pos);
        } else if (node->type == JAK_PATH_INDEX_COLUMN_INDEX) {
                fprintf(file, "column_idx(%"PRIu64"), ", node->entry.pos);
        } else {
                fprintf(file, "key('%*.*s', offset: 0x%x), ", 0, (int) node->entry.key.name_len, node->entry.key.name,
                        (unsigned) node->entry.key.offset);
        }
        if (node->type != JAK_PATH_ROOT) {
                fprintf(file, "field(type: %s, offset: 0x%x)\n", jak_carbon_field_type_str(NULL, node->field_type),
                        (unsigned) node->field_offset);
        } else {
                fprintf(file, "\n");
        }

        for (jak_u32 i = 0; i < node->sub_entries.num_elems; i++) {
                struct path_index_node *sub = JAK_VECTOR_GET(&node->sub_entries, i, struct path_index_node);
                path_index_node_print_level(file, sub, level + 1);
        }
}

static const void *
record_ref_read(jak_carbon_key_e *key_type, jak_u64 *key_length, jak_u64 *commit_hash, jak_memfile *memfile)
{
        jak_memfile_save_position(memfile);
        jak_memfile_seek(memfile, 0);
        const void *ret = jak_carbon_key_read(key_length, key_type, memfile);
        jak_u64 *hash = JAK_MEMFILE_READ_TYPE(memfile, jak_u64);
        JAK_OPTIONAL_SET(commit_hash, *hash);
        jak_memfile_restore_position(memfile);
        return ret;
}

static void record_ref_create(jak_memfile *memfile, jak_carbon *doc)
{
        jak_carbon_key_e key_type;
        jak_u64 commit_hash;
        jak_carbon_key_type(&key_type, doc);
        jak_carbon_commit_hash(&commit_hash, doc);

        /* write record key */
        jak_memfile_seek(memfile, 0);
        jak_carbon_key_create(memfile, key_type, &doc->err);
        switch (key_type) {
                case JAK_CARBON_KEY_NOKEY: {
                        /* nothing to do */
                }
                        break;
                case JAK_CARBON_KEY_AUTOKEY:
                case JAK_CARBON_KEY_UKEY: {
                        jak_u64 key;
                        jak_carbon_key_unsigned_value(&key, doc);
                        jak_memfile_seek(memfile, 0);
                        jak_carbon_key_write_unsigned(memfile, key);
                }
                        break;
                case JAK_CARBON_KEY_IKEY: {
                        jak_i64 key;
                        jak_carbon_key_signed_value(&key, doc);
                        jak_memfile_seek(memfile, 0);
                        jak_carbon_key_write_signed(memfile, key);
                }
                        break;
                case JAK_CARBON_KEY_SKEY: {
                        jak_u64 len;
                        const char *key = jak_carbon_key_jak_string_value(&len, doc);
                        jak_memfile_seek(memfile, 0);
                        jak_carbon_key_update_jak_string_wnchar(memfile, key, len);
                }
                        break;
                default: JAK_ERROR(&doc->err, JAK_ERR_TYPEMISMATCH)
        }

        /* write record version */
        jak_memfile_write(memfile, &commit_hash, sizeof(jak_u64));
}

static void array_traverse(struct path_index_node *parent, jak_carbon_array_it *it)
{
        jak_u64 sub_elem_pos = 0;
        while (jak_carbon_array_it_next(it)) {
                jak_offset_t sub_elem_off = jak_carbon_array_it_tell(it);
                struct path_index_node *elem_node = path_index_node_add_array_elem(parent, sub_elem_pos, sub_elem_off);
                array_build_index(elem_node, it);

                sub_elem_pos++;
        }
}

static void column_traverse(struct path_index_node *parent, jak_carbon_column_it *it)
{
        jak_carbon_field_type_e column_type, entry_type;
        jak_u32 nvalues;

        jak_carbon_column_it_values_info(&column_type, &nvalues, it);

        for (jak_u32 i = 0; i < nvalues; i++) {
                bool is_null = jak_carbon_column_it_value_is_null(it, i);
                bool is_true = false;
                if (column_type == JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN) {
                        is_true = jak_carbon_column_it_boolean_values(NULL, it)[i];
                }
                entry_type = jak_carbon_field_type_column_entry_to_regular_type(column_type, is_null, is_true);
                jak_offset_t sub_elem_off = jak_carbon_column_it_tell(it, i);

                struct path_index_node *node = path_index_node_add_column_elem(parent, i, sub_elem_off);
                path_index_node_set_field_type(node, entry_type);
        }
}

static void object_traverse(struct path_index_node *parent, jak_carbon_object_it *it)
{
        while (jak_carbon_object_it_next(it)) {
                jak_u64 prop_name_len = 0;
                jak_offset_t key_off, value_off;
                jak_carbon_object_it_tell(&key_off, &value_off, it);
                const char *prop_name = jak_carbon_object_it_prop_name(&prop_name_len, it);
                struct path_index_node *elem_node = path_index_node_add_key_elem(parent, key_off,
                                                                                 prop_name, prop_name_len, value_off);
                object_build_index(elem_node, it);
        }
}

static void object_build_index(struct path_index_node *parent, jak_carbon_object_it *elem_it)
{
        jak_carbon_field_type_e field_type;
        jak_carbon_object_it_prop_type(&field_type, elem_it);
        path_index_node_set_field_type(parent, field_type);

        switch (field_type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_STRING:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        /* path ends here */
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64: {
                        jak_carbon_column_it *it = jak_carbon_object_it_column_value(elem_it);
                        column_traverse(parent, it);

                }
                        break;
                case JAK_CARBON_FIELD_TYPE_ARRAY: {
                        jak_carbon_array_it *it = jak_carbon_object_it_array_value(elem_it);
                        array_traverse(parent, it);
                        jak_carbon_array_it_drop(it);
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT: {
                        jak_carbon_object_it *it = jak_carbon_object_it_object_value(elem_it);
                        object_traverse(parent, it);
                        jak_carbon_object_it_drop(it);
                }
                        break;
                default: JAK_ERROR(&elem_it->err, JAK_ERR_INTERNALERR);
        }
}

static void array_build_index(struct path_index_node *parent, jak_carbon_array_it *elem_it)
{
        jak_carbon_field_type_e field_type;
        jak_carbon_array_it_field_type(&field_type, elem_it);
        path_index_node_set_field_type(parent, field_type);

        switch (field_type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_STRING:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        /* path ends here */
                        break;
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64: {
                        jak_carbon_column_it *it = jak_carbon_array_it_column_value(elem_it);
                        column_traverse(parent, it);

                }
                        break;
                case JAK_CARBON_FIELD_TYPE_ARRAY: {
                        jak_carbon_array_it *it = jak_carbon_array_it_array_value(elem_it);
                        array_traverse(parent, it);
                        jak_carbon_array_it_drop(it);
                }
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT: {
                        jak_carbon_object_it *it = jak_carbon_array_it_object_value(elem_it);
                        object_traverse(parent, it);
                        jak_carbon_object_it_drop(it);
                }
                        break;
                default: JAK_ERROR(&elem_it->err, JAK_ERR_INTERNALERR);
        }
}

static void field_ref_write(jak_memfile *file, struct path_index_node *node)
{
        jak_memfile_write_byte(file, node->field_type);
        if (node->field_type != JAK_CARBON_FIELD_TYPE_NULL && node->field_type != JAK_CARBON_FIELD_TYPE_TRUE &&
            node->field_type != JAK_CARBON_FIELD_TYPE_FALSE) {
                /* only in case of field type that is not null, true, or false, there is more information behind
                 * the field offset */
                jak_memfile_write_uintvar_stream(NULL, file, node->field_offset);
        }
}

static void container_contents_flat(jak_memfile *file, struct path_index_node *node)
{
        jak_memfile_write_uintvar_stream(NULL, file, node->sub_entries.num_elems);

        /* write position offsets */
        jak_offset_t position_off_latest = jak_memfile_tell(file);
        for (jak_u32 i = 0; i < node->sub_entries.num_elems; i++) {
                jak_memfile_write_uintvar_stream(NULL, file, 0);
        }

        for (jak_u32 i = 0; i < node->sub_entries.num_elems; i++) {
                jak_offset_t node_off = jak_memfile_tell(file);
                struct path_index_node *sub = JAK_VECTOR_GET(&node->sub_entries, i, struct path_index_node);
                node_flat(file, sub);
                jak_memfile_save_position(file);
                jak_memfile_seek(file, position_off_latest);
                signed_offset_t shift = jak_memfile_update_uintvar_stream(file, node_off);
                position_off_latest = jak_memfile_tell(file);
                jak_memfile_restore_position(file);
                jak_memfile_seek_from_here(file, shift);
        }
}

static void container_field_flat(jak_memfile *file, struct path_index_node *node)
{
        switch (node->field_type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_STRING:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        /* any path will end with this kind of field, and therefore no subsequent elements exists */
                        JAK_ASSERT(node->sub_entries.num_elems == 0);
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                        /* each of these field types allows for further path traversals, and therefore at least one
                         * subsequent path element must exist */
                        container_contents_flat(file, node);
                        break;
                default: JAK_ERROR(&file->err, JAK_ERR_INTERNALERR);
        }
}

static void prop_flat(jak_memfile *file, struct path_index_node *node)
{
        jak_memfile_write_byte(file, PATH_MARKER_PROP_NODE);
        field_ref_write(file, node);
        jak_memfile_write_uintvar_stream(NULL, file, node->entry.key.offset);
        container_field_flat(file, node);
}

static void array_flat(jak_memfile *file, struct path_index_node *node)
{
        jak_memfile_write_byte(file, PATH_MARKER_ARRAY_NODE);
        field_ref_write(file, node);
        if (JAK_UNLIKELY(node->type == JAK_PATH_ROOT)) {
                container_contents_flat(file, node);
        } else {
                container_field_flat(file, node);
        }
}

JAK_FUNC_UNUSED
static void node_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index)
{
        jak_u8 next = jak_memfile_peek_byte(&index->memfile);
        switch (next) {
                case PATH_MARKER_PROP_NODE:
                        prop_into_carbon(ins, index);
                        break;
                case PATH_MARKER_ARRAY_NODE:
                        array_into_carbon(ins, index, false);
                        break;
                case PATH_MARKER_COLUMN_NODE:
                        column_into_carbon(ins, index);
                        break;
                default: JAK_ERROR(&index->err, JAK_ERR_CORRUPTED)
        }
}

static void node_to_str(jak_string *str, jak_carbon_path_index *index, unsigned intent_level)
{
        jak_u8 next = jak_memfile_peek_byte(&index->memfile);
        intent_level++;

        switch (next) {
                case PATH_MARKER_PROP_NODE:
                        prop_to_str(str, index, intent_level);
                        break;
                case PATH_MARKER_ARRAY_NODE:
                        array_to_str(str, index, false, intent_level);
                        break;
                case PATH_MARKER_COLUMN_NODE:
                        column_to_str(str, index, intent_level);
                        break;
                default: JAK_ERROR(&index->err, JAK_ERR_CORRUPTED)
        }
}

static jak_u8 field_ref_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index, bool is_root)
{
        jak_u8 field_type = jak_memfile_read_byte(&index->memfile);

        if (is_root) {
                jak_carbon_insert_prop_null(ins, "container");
        } else {
                jak_carbon_insert_prop_string(ins, "container", jak_carbon_field_type_str(NULL, field_type));
        }


        if (field_type != JAK_CARBON_FIELD_TYPE_NULL && field_type != JAK_CARBON_FIELD_TYPE_TRUE &&
            field_type != JAK_CARBON_FIELD_TYPE_FALSE) {
                /* only in case of field type that is not null, true, or false, there is more information behind
                 * the field offset */
                jak_u64 field_offset = jak_memfile_read_uintvar_stream(NULL, &index->memfile);
                if (is_root) {
                        jak_carbon_insert_prop_null(ins, "offset");
                } else {
                        jak_string str;
                        jak_string_create(&str);
                        jak_string_add_u64_as_hex_0x_prefix_compact(&str, field_offset);
                        jak_carbon_insert_prop_string(ins, "offset", jak_string_cstr(&str));
                        jak_string_drop(&str);
                }
        } else {
                jak_carbon_insert_prop_null(ins, "offset");
        }
        return field_type;
}

static jak_u8 field_ref_to_str(jak_string *str, jak_carbon_path_index *index)
{
        jak_u8 field_type = jak_memfile_read_byte(&index->memfile);

        jak_string_add_char(str, '[');
        jak_string_add_char(str, field_type);
        jak_string_add_char(str, ']');

        if (field_type != JAK_CARBON_FIELD_TYPE_NULL && field_type != JAK_CARBON_FIELD_TYPE_TRUE &&
            field_type != JAK_CARBON_FIELD_TYPE_FALSE) {
                /* only in case of field type that is not null, true, or false, there is more information behind
                 * the field offset */
                jak_u64 field_offset = jak_memfile_read_uintvar_stream(NULL, &index->memfile);
                jak_string_add_char(str, '(');
                jak_string_add_u64_as_hex_0x_prefix_compact(str, field_offset);
                jak_string_add_char(str, ')');
        }

        return field_type;
}

static void column_to_str(jak_string *str, jak_carbon_path_index *index, unsigned intent_level)
{
        intent(str, intent_level);
        jak_u8 marker = jak_memfile_read_byte(&index->memfile);
        jak_string_add_char(str, '[');
        jak_string_add_char(str, marker);
        jak_string_add_char(str, ']');

        field_ref_to_str(str, index);
}

static jak_u8 _insert_field_ref(jak_carbon_insert *ins, jak_carbon_path_index *index, bool is_root)
{
        jak_carbon_insert_object_state object;
        jak_carbon_insert *oins = jak_carbon_insert_prop_object_begin(&object, ins, "record-reference", 1024);
        jak_u8 ret = field_ref_into_carbon(oins, index, is_root);
        jak_carbon_insert_prop_object_end(&object);
        return ret;
}

JAK_FUNC_UNUSED
static void column_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index)
{
        JAK_MEMFILE_SKIP_BYTE(&index->memfile);
        jak_carbon_insert_prop_string(ins, "type", "column");
        _insert_field_ref(ins, index, false);
}

static void container_contents_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index)
{
        jak_u64 num_elems = jak_memfile_read_uintvar_stream(NULL, &index->memfile);
        jak_carbon_insert_prop_unsigned(ins, "element-count", num_elems);

        jak_carbon_insert_array_state array;
        jak_carbon_insert *ains = jak_carbon_insert_prop_array_begin(&array, ins, "element-offsets", 1024);

        jak_string str;
        jak_string_create(&str);
        for (jak_u32 i = 0; i < num_elems; i++) {
                jak_u64 pos_offs = jak_memfile_read_uintvar_stream(NULL, &index->memfile);
                jak_string_clear(&str);
                jak_string_add_u64_as_hex_0x_prefix_compact(&str, pos_offs);
                jak_carbon_insert_string(ains, jak_string_cstr(&str));
        }
        jak_string_drop(&str);

        jak_carbon_insert_prop_array_end(&array);

        ains = jak_carbon_insert_prop_array_begin(&array, ins, "elements", 1024);
        JAK_UNUSED(ains)
        for (jak_u32 i = 0; i < num_elems; i++) {
                jak_carbon_insert_object_state node_obj;
                jak_carbon_insert *node_obj_ins = jak_carbon_insert_object_begin(&node_obj, ains, 1024);
                node_into_carbon(node_obj_ins, index);
                jak_carbon_insert_object_end(&node_obj);
        }
        jak_carbon_insert_prop_array_end(&array);

}

static void
container_contents_to_str(jak_string *str, jak_carbon_path_index *index, unsigned intent_level)
{
        jak_u64 num_elems = jak_memfile_read_uintvar_stream(NULL, &index->memfile);
        jak_string_add_char(str, '(');
        jak_string_add_u64(str, num_elems);
        jak_string_add_char(str, ')');

        for (jak_u32 i = 0; i < num_elems; i++) {
                jak_u64 pos_offs = jak_memfile_read_uintvar_stream(NULL, &index->memfile);
                jak_string_add_char(str, '(');
                jak_string_add_u64_as_hex_0x_prefix_compact(str, pos_offs);
                jak_string_add_char(str, ')');
        }

        for (jak_u32 i = 0; i < num_elems; i++) {
                node_to_str(str, index, intent_level);
        }
}

static void
container_to_str(jak_string *str, jak_carbon_path_index *index, jak_u8 field_type, unsigned intent_level)
{
        switch (field_type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_STRING:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        /* nothing to do */
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                        /* subsequent path elements to be printed */
                        container_contents_to_str(str, index, ++intent_level);
                }
                        break;
                default: JAK_ERROR(&index->err, JAK_ERR_INTERNALERR);
        }
}

static void container_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index, jak_u8 field_type)
{
        switch (field_type) {
                case JAK_CARBON_FIELD_TYPE_NULL:
                case JAK_CARBON_FIELD_TYPE_TRUE:
                case JAK_CARBON_FIELD_TYPE_FALSE:
                case JAK_CARBON_FIELD_TYPE_STRING:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                case JAK_CARBON_FIELD_TYPE_BINARY:
                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                        /* nothing to do */
                        break;
                case JAK_CARBON_FIELD_TYPE_OBJECT:
                case JAK_CARBON_FIELD_TYPE_ARRAY:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                        /* subsequent path elements to be printed */
                        container_contents_into_carbon(ins, index);
                }
                        break;
                default: JAK_ERROR(&index->err, JAK_ERR_INTERNALERR);
        }
}

static void prop_to_str(jak_string *str, jak_carbon_path_index *index, unsigned intent_level)
{
        intent(str, intent_level++);

        jak_u8 marker = jak_memfile_read_byte(&index->memfile);
        jak_string_add_char(str, '[');
        jak_string_add_char(str, marker);
        jak_string_add_char(str, ']');

        jak_u8 field_type = field_ref_to_str(str, index);

        jak_u64 key_offset = jak_memfile_read_uintvar_stream(NULL, &index->memfile);

        jak_string_add_char(str, '(');
        jak_string_add_u64_as_hex_0x_prefix_compact(str, key_offset);
        jak_string_add_char(str, ')');

        container_to_str(str, index, field_type, intent_level);
}

JAK_FUNC_UNUSED
static void prop_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index)
{
        JAK_MEMFILE_SKIP_BYTE(&index->memfile);
        jak_carbon_insert_prop_string(ins, "type", "key");
        jak_u8 field_type = _insert_field_ref(ins, index, false);

        jak_string str;
        jak_string_create(&str);

        jak_u64 key_offset = jak_memfile_read_uintvar_stream(NULL, &index->memfile);
        jak_string_add_u64_as_hex_0x_prefix_compact(&str, key_offset);
        jak_carbon_insert_prop_string(ins, "key", jak_string_cstr(&str));
        jak_string_drop(&str);

        container_into_carbon(ins, index, field_type);
}

static void array_into_carbon(jak_carbon_insert *ins, jak_carbon_path_index *index, bool is_root)
{
        JAK_MEMFILE_SKIP_BYTE(&index->memfile);
        jak_u8 field_type;

        jak_carbon_insert_prop_string(ins, "parent", is_root ? "record" : "array");
        field_type = _insert_field_ref(ins, index, is_root);

        jak_carbon_insert_object_state object;
        jak_carbon_insert *oins = jak_carbon_insert_prop_object_begin(&object, ins, "nodes", 1024);
        if (JAK_UNLIKELY(is_root)) {
                container_contents_into_carbon(oins, index);
        } else {
                container_into_carbon(oins, index, field_type);
        }
        jak_carbon_insert_prop_object_end(&object);
}

static void
array_to_str(jak_string *str, jak_carbon_path_index *index, bool is_root, unsigned intent_level)
{
        intent(str, intent_level++);

        jak_u8 marker = jak_memfile_read_byte(&index->memfile);
        jak_string_add_char(str, '[');
        jak_string_add_char(str, marker);
        jak_string_add_char(str, ']');

        jak_u8 field_type = field_ref_to_str(str, index);

        if (JAK_UNLIKELY(is_root)) {
                container_contents_to_str(str, index, intent_level);
        } else {
                container_to_str(str, index, field_type, intent_level);
        }
}

static void column_flat(jak_memfile *file, struct path_index_node *node)
{
        jak_memfile_write_byte(file, PATH_MARKER_COLUMN_NODE);
        field_ref_write(file, node);
        JAK_ASSERT(node->sub_entries.num_elems == 0);
}

static void node_flat(jak_memfile *file, struct path_index_node *node)
{
        switch (node->type) {
                case JAK_PATH_INDEX_PROP_KEY:
                        prop_flat(file, node);
                        break;
                case JAK_PATH_INDEX_ARRAY_INDEX:
                        array_flat(file, node);
                        break;
                case JAK_PATH_INDEX_COLUMN_INDEX:
                        column_flat(file, node);
                        break;
                default: JAK_ERROR(&file->err, JAK_ERR_INTERNALERR);
                        return;
        }
}

static void index_flat(jak_memfile *file, struct path_index_node *root_array)
{
        array_flat(file, root_array);
}

static void index_build(jak_memfile *file, jak_carbon *doc)
{
        struct path_index_node root_array;

        /* init */
        path_index_node_init(&root_array);

        jak_carbon_array_it it;
        jak_u64 array_pos = 0;
        jak_carbon_iterator_open(&it, doc);

        /* build index as tree structure */
        while (jak_carbon_array_it_next(&it)) {
                jak_offset_t entry_offset = jak_carbon_array_it_tell(&it);
                struct path_index_node *node = path_index_node_add_array_elem(&root_array, array_pos, entry_offset);
                array_build_index(node, &it);
                array_pos++;
        }
        jak_carbon_iterator_close(&it);

        /* for debug */
        path_index_node_print_level(stdout, &root_array, 0); // TODO: Debug remove

        index_flat(file, &root_array);
        jak_memfile_shrink(file);

        /* cleanup */
        path_index_node_drop(&root_array);
}

static void record_ref_to_str(jak_string *str, jak_carbon_path_index *index)
{
        jak_u8 key_type = jak_memfile_read_byte(&index->memfile);
        jak_string_add_char(str, '[');
        jak_string_add_char(str, key_type);
        jak_string_add_char(str, ']');

        switch (key_type) {
                case JAK_CARBON_KEY_NOKEY:
                        /* nothing to do */
                        break;
                case JAK_CARBON_KEY_AUTOKEY:
                case JAK_CARBON_KEY_UKEY: {
                        jak_u64 key = jak_memfile_read_u64(&index->memfile);
                        jak_string_add_char(str, '[');
                        jak_string_add_u64(str, key);
                        jak_string_add_char(str, ']');
                }
                        break;
                case JAK_CARBON_KEY_IKEY: {
                        jak_i64 key = jak_memfile_read_i64(&index->memfile);
                        jak_string_add_char(str, '[');;
                        jak_string_add_i64(str, key);
                        jak_string_add_char(str, ']');
                }
                        break;
                case JAK_CARBON_KEY_SKEY: {
                        jak_u64 key_len;
                        const char *key = jak_carbon_jak_string_read(&key_len, &index->memfile);
                        jak_string_add_char(str, '(');
                        jak_string_add_nchar(str, key, key_len);
                        jak_string_add_char(str, ')');
                }
                        break;
                default: JAK_ERROR(&index->err, JAK_ERR_INTERNALERR);
        }
        jak_u64 commit_hash = jak_memfile_read_u64(&index->memfile);
        jak_string_add_char(str, '[');
        jak_string_add_u64(str, commit_hash);
        jak_string_add_char(str, ']');
}

static void record_ref_to_carbon(jak_carbon_insert *roins, jak_carbon_path_index *index)
{
        char key_type = jak_memfile_read_byte(&index->memfile);
        jak_carbon_insert_prop_string(roins, "key-type", jak_carbon_key_type_str(key_type));

        switch (key_type) {
                case JAK_CARBON_KEY_NOKEY:
                        /* nothing to do */
                        break;
                case JAK_CARBON_KEY_AUTOKEY:
                case JAK_CARBON_KEY_UKEY: {
                        jak_u64 key = jak_memfile_read_u64(&index->memfile);
                        jak_carbon_insert_prop_unsigned(roins, "key-value", key);
                }
                        break;
                case JAK_CARBON_KEY_IKEY: {
                        jak_i64 key = jak_memfile_read_i64(&index->memfile);
                        jak_carbon_insert_prop_signed(roins, "key-value", key);
                }
                        break;
                case JAK_CARBON_KEY_SKEY: {
                        jak_u64 key_len;
                        const char *key = jak_carbon_jak_string_read(&key_len, &index->memfile);
                        jak_carbon_insert_prop_nchar(roins, "key-value", key, key_len);
                }
                        break;
                default: JAK_ERROR(&index->err, JAK_ERR_INTERNALERR);
        }
        jak_u64 commit_hash = jak_memfile_read_u64(&index->memfile);
        jak_string str;
        jak_string_create(&str);
        jak_carbon_commit_hash_to_str(&str, commit_hash);
        jak_carbon_insert_prop_string(roins, "commit-hash", jak_string_cstr(&str));
        jak_string_drop(&str);
}

// ---------------------------------------------------------------------------------------------------------------------
//  construction and deconstruction
// ---------------------------------------------------------------------------------------------------------------------

bool jak_carbon_path_index_create(jak_carbon_path_index *index, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(index);
        JAK_ERROR_IF_NULL(doc);
        jak_memblock_create(&index->memblock, PATH_INDEX_CAPACITY);
        jak_memfile_open(&index->memfile, index->memblock, JAK_READ_WRITE);
        jak_error_init(&index->err);
        record_ref_create(&index->memfile, doc);
        index_build(&index->memfile, doc);
        return true;
}

bool jak_carbon_path_index_drop(jak_carbon_path_index *index)
{
        JAK_UNUSED(index)
        return false;
}

// ---------------------------------------------------------------------------------------------------------------------
//  index data access and meta information
// ---------------------------------------------------------------------------------------------------------------------

const void *jak_carbon_path_index_raw_data(jak_u64 *size, jak_carbon_path_index *index)
{
        if (size && index) {
                const char *raw = jak_memblock_raw_data(index->memfile.memblock);
                jak_memblock_size(size, index->memfile.memblock);
                return raw;
        } else {
                return NULL;
        }
}

bool jak_carbon_path_index_commit_hash(jak_u64 *commit_hash, jak_carbon_path_index *index)
{
        JAK_ERROR_IF_NULL(commit_hash)
        JAK_ERROR_IF_NULL(index)
        record_ref_read(NULL, NULL, commit_hash, &index->memfile);
        return true;
}

bool jak_carbon_path_index_key_type(jak_carbon_key_e *key_type, jak_carbon_path_index *index)
{
        JAK_ERROR_IF_NULL(key_type)
        JAK_ERROR_IF_NULL(index)
        record_ref_read(key_type, NULL, NULL, &index->memfile);
        return true;
}

bool jak_carbon_path_index_key_unsigned_value(jak_u64 *key, jak_carbon_path_index *index)
{
        JAK_ERROR_IF_NULL(key)
        JAK_ERROR_IF_NULL(index)
        jak_carbon_key_e key_type;
        jak_u64 ret = *(jak_u64 *) record_ref_read(&key_type, NULL, NULL, &index->memfile);
        JAK_ERROR_IF(key_type != JAK_CARBON_KEY_AUTOKEY && key_type != JAK_CARBON_KEY_UKEY, &index->err, JAK_ERR_TYPEMISMATCH);
        *key = ret;
        return true;
}

bool jak_carbon_path_index_key_signed_value(jak_i64 *key, jak_carbon_path_index *index)
{
        JAK_ERROR_IF_NULL(key)
        JAK_ERROR_IF_NULL(index)
        jak_carbon_key_e key_type;
        jak_i64 ret = *(jak_i64 *) record_ref_read(&key_type, NULL, NULL, &index->memfile);
        JAK_ERROR_IF(key_type != JAK_CARBON_KEY_IKEY, &index->err, JAK_ERR_TYPEMISMATCH);
        *key = ret;
        return true;
}

const char *jak_carbon_path_index_key_jak_string_value(jak_u64 *str_len, jak_carbon_path_index *index)
{
        if (str_len && index) {
                jak_carbon_key_e key_type;
                const char *ret = (const char *) record_ref_read(&key_type, str_len, NULL, &index->memfile);
                JAK_ERROR_IF(key_type != JAK_CARBON_KEY_SKEY, &index->err, JAK_ERR_TYPEMISMATCH);
                return ret;
        } else {
                JAK_ERROR(&index->err, JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool jak_carbon_path_index_indexes_doc(jak_carbon_path_index *index, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(doc);

        jak_u64 index_hash = 0, doc_hash = 0;
        jak_carbon_path_index_commit_hash(&index_hash, index);
        jak_carbon_commit_hash(&doc_hash, doc);
        if (JAK_LIKELY(index_hash == doc_hash)) {
                jak_carbon_key_e index_key_type, doc_key_type;
                jak_carbon_path_index_key_type(&index_key_type, index);
                jak_carbon_key_type(&doc_key_type, doc);
                if (JAK_LIKELY(index_key_type == doc_key_type)) {
                        switch (index_key_type) {
                                case JAK_CARBON_KEY_NOKEY:
                                        return true;
                                case JAK_CARBON_KEY_AUTOKEY:
                                case JAK_CARBON_KEY_UKEY: {
                                        jak_u64 index_key, doc_key;
                                        jak_carbon_path_index_key_unsigned_value(&index_key, index);
                                        jak_carbon_key_unsigned_value(&doc_key, doc);
                                        return index_key == doc_key;
                                }
                                case JAK_CARBON_KEY_IKEY: {
                                        jak_i64 index_key, doc_key;
                                        jak_carbon_path_index_key_signed_value(&index_key, index);
                                        jak_carbon_key_signed_value(&doc_key, doc);
                                        return index_key == doc_key;
                                }
                                case JAK_CARBON_KEY_SKEY: {
                                        jak_u64 index_key_len, doc_key_len;
                                        const char *index_key = jak_carbon_path_index_key_jak_string_value(&index_key_len,
                                                                                                   index);
                                        const char *doc_key = jak_carbon_key_jak_string_value(&doc_key_len, doc);
                                        return (index_key_len == doc_key_len) && (strcmp(index_key, doc_key) == 0);
                                }
                                default: JAK_ERROR(&doc->err, JAK_ERR_TYPEMISMATCH)
                                        return false;
                        }
                } else {
                        return false;
                }
        } else {
                return false;
        }
}

// ---------------------------------------------------------------------------------------------------------------------
//  index access and type information
// ---------------------------------------------------------------------------------------------------------------------

bool jak_carbon_path_index_it_open(jak_carbon_path_index_it *it, jak_carbon_path_index *index,
                               jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(it)
        JAK_ERROR_IF_NULL(index)
        JAK_ERROR_IF_NULL(doc)
        if (jak_carbon_path_index_indexes_doc(index, doc)) {
                JAK_ZERO_MEMORY(it, sizeof(jak_carbon_path_index_it));
                jak_error_init(&it->err);
                jak_memfile_open(&it->memfile, index->memfile.memblock, JAK_READ_ONLY);
                it->doc = doc;
                it->container_type = JAK_CARBON_ARRAY;
                return true;
        } else {
                JAK_ERROR(&index->err, JAK_ERR_NOTINDEXED)
                return false;
        }
}

//bool jak_carbon_path_index_it_type(jak_carbon_container_e *type, jak_carbon_path_index_it *it)
//{
//
//}
//
//// ---------------------------------------------------------------------------------------------------------------------
////  array and column container functions
//// ---------------------------------------------------------------------------------------------------------------------
//
//bool jak_carbon_path_index_it_list_length(jak_u64 *key_len, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_list_goto(jak_u64 pos, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_list_pos(jak_u64 *pos, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_list_can_enter(jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_list_enter(jak_carbon_path_index_it *it)
//{
//
//}
//
//// ---------------------------------------------------------------------------------------------------------------------
////  object container functions
//// ---------------------------------------------------------------------------------------------------------------------
//
//bool jak_carbon_path_index_it_obj_num_props(jak_u64 *num_props, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_obj_goto(const char *key_name, jak_carbon_path_index_it *it)
//{
//
//}
//
//const char *jak_carbon_path_index_it_key_name(jak_u64 *name_len, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_obj_can_enter(jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_obj_enter(jak_carbon_path_index_it *it)
//{
//
//}
//
//// ---------------------------------------------------------------------------------------------------------------------
////  field access
//// ---------------------------------------------------------------------------------------------------------------------
//
//bool jak_carbon_path_index_it_field_type(jak_carbon_field_type_e *type, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_u8_value(jak_u8 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_u16_value(jak_u16 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_u32_value(jak_u32 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_u64_value(jak_u64 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_i8_value(jak_i8 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_i16_value(jak_i16 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_i32_value(jak_i32 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_i64_value(jak_i64 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_float_value(bool *is_null_in, float *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_signed_value(bool *is_null_in, jak_i64 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_unsigned_value(bool *is_null_in, jak_u64 *value, jak_carbon_path_index_it *it)
//{
//
//}
//
//const char *jak_carbon_path_index_it_field_jak_string_value(jak_u64 *strlen, jak_carbon_path_index_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_binary_value(jak_carbon_binary *out, jak_carbon_array_it *it)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_array_value(jak_carbon_array_it *it_out, jak_carbon_path_index_it *it_in)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_object_value(jak_carbon_object_it *it_out, jak_carbon_path_index_it *it_in)
//{
//
//}
//
//bool jak_carbon_path_index_it_field_column_value(jak_carbon_column_it *it_out, jak_carbon_path_index_it *it_in)
//{
//
//}

// ---------------------------------------------------------------------------------------------------------------------
//  diagnostics
// ---------------------------------------------------------------------------------------------------------------------

bool jak_carbon_path_index_hexdump(FILE *file, jak_carbon_path_index *index)
{
        return jak_memfile_hexdump_printf(file, &index->memfile);
}

bool jak_carbon_path_index_to_carbon(jak_carbon *doc, jak_carbon_path_index *index)
{
        jak_carbon_new context;
        jak_carbon_insert_object_state object;

        jak_memfile_seek_to_start(&index->memfile);

        jak_carbon_insert *ins = jak_carbon_create_begin(&context, doc, JAK_CARBON_KEY_NOKEY, JAK_CARBON_OPTIMIZE);
        jak_carbon_insert *oins = jak_carbon_insert_object_begin(&object, ins, 1024);

        {
                jak_carbon_insert_object_state ref_object;
                jak_carbon_insert *roins = jak_carbon_insert_prop_object_begin(&ref_object, oins,
                                                                                  "record-association", 1024);
                record_ref_to_carbon(roins, index);
                jak_carbon_insert_prop_object_end(&ref_object);
        }
        {
                jak_carbon_insert_object_state root_object;
                jak_carbon_insert *roins = jak_carbon_insert_prop_object_begin(&root_object, oins, "index", 1024);
                array_into_carbon(roins, index, true);
                jak_carbon_insert_prop_object_end(&root_object);
        }

        jak_carbon_insert_object_end(&object);
        jak_carbon_create_end(&context);
        return true;
}

const char *jak_carbon_path_index_to_str(jak_string *str, jak_carbon_path_index *index)
{
        jak_memfile_seek_to_start(&index->memfile);
        record_ref_to_str(str, index);
        array_to_str(str, index, true, 0);
        return jak_string_cstr(str);
}

bool jak_carbon_path_index_print(FILE *file, jak_carbon_path_index *index)
{
        jak_string str;
        jak_string_create(&str);
        jak_memfile_save_position(&index->memfile);
        jak_memfile_seek_to_start(&index->memfile);
        fprintf(file, "%s", jak_carbon_path_index_to_str(&str, index));
        jak_memfile_restore_position(&index->memfile);
        jak_string_drop(&str);
        return true;
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon_printers.h>
#include <jak_json_printer_compact.h>
#include <jak_json_printer_extended.h>
#include <jak_carbon_object_it.h>
#include <jak_carbon_array_it.h>
#include <jak_carbon_column_it.h>

bool jak_carbon_printer_by_type(jak_carbon_printer *printer, int impl)
{
        JAK_ERROR_IF_NULL(printer)

        switch (impl) {
                case JAK_JSON_EXTENDED:
                        jak_json_extended_printer_create(printer);
                        break;
                case JAK_JSON_COMPACT:
                        jak_json_compact_printer_create(printer);
                        break;
                default: JAK_ERROR_PRINT(JAK_ERR_NOTFOUND)
                        return false;
        }
        return true;
}

bool jak_carbon_printer_drop(jak_carbon_printer *printer)
{
        JAK_ERROR_IF_NULL(printer->drop);
        printer->drop(printer);
        return true;
}

bool jak_carbon_printer_begin(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->record_begin);
        printer->record_begin(printer, str);
        return true;
}

bool jak_carbon_printer_end(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->record_end);
        printer->record_end(printer, str);
        return true;
}

bool jak_carbon_printer_header_begin(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->meta_begin);
        printer->meta_begin(printer, str);
        return true;
}

bool jak_carbon_printer_header_contents(jak_carbon_printer *printer, jak_string *str,
                                    int key_type, const void *key, jak_u64 key_length,
                                    jak_u64 rev)
{
        JAK_ERROR_IF_NULL(printer->drop);
        printer->meta_data(printer, str, key_type, key, key_length, rev);
        return true;
}

bool jak_carbon_printer_header_end(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->meta_end);
        printer->meta_end(printer, str);
        return true;
}

bool jak_carbon_printer_payload_begin(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->doc_begin);
        printer->doc_begin(printer, str);
        return true;
}

bool jak_carbon_printer_payload_end(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->doc_end);
        printer->doc_end(printer, str);
        return true;
}

bool jak_carbon_printer_empty_record(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->empty_record);
        printer->empty_record(printer, str);
        return true;
}

bool jak_carbon_printer_array_begin(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->array_begin);
        printer->array_begin(printer, str);
        return true;
}

bool jak_carbon_printer_array_end(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->array_end);
        printer->array_end(printer, str);
        return true;
}

bool jak_carbon_printer_unit_array_begin(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->unit_array_begin);
        printer->unit_array_begin(printer, str);
        return true;
}

bool jak_carbon_printer_unit_array_end(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->unit_array_end);
        printer->unit_array_end(printer, str);
        return true;
}

bool jak_carbon_printer_object_begin(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->obj_begin);
        printer->obj_begin(printer, str);
        return true;
}

bool jak_carbon_printer_object_end(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->obj_end);
        printer->obj_end(printer, str);
        return true;
}

bool jak_carbon_printer_null(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->const_null);
        printer->const_null(printer, str);
        return true;
}

bool jak_carbon_printer_true(jak_carbon_printer *printer, bool is_null, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->const_true);
        printer->const_true(printer, is_null, str);
        return true;
}

bool jak_carbon_printer_false(jak_carbon_printer *printer, bool is_null, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->const_false);
        printer->const_false(printer, is_null, str);
        return true;
}

bool jak_carbon_printer_comma(jak_carbon_printer *printer, jak_string *str)
{
        JAK_ERROR_IF_NULL(printer->comma);
        printer->comma(printer, str);
        return true;
}

bool jak_carbon_printer_signed_nonull(jak_carbon_printer *printer, jak_string *str, const jak_i64 *value)
{
        JAK_ERROR_IF_NULL(printer->val_signed);
        printer->val_signed(printer, str, value);
        return true;
}

bool jak_carbon_printer_unsigned_nonull(jak_carbon_printer *printer, jak_string *str, const jak_u64 *value)
{
        JAK_ERROR_IF_NULL(printer->val_unsigned);
        printer->val_unsigned(printer, str, value);
        return true;
}

#define delegate_print_call(printer, str, value, null_test_func, print_func, ctype)                                    \
({                                                                                                                     \
        JAK_ERROR_IF_NULL(printer)                                                                                         \
        JAK_ERROR_IF_NULL(str)                                                                                             \
        bool status = false;                                                                                           \
        if (null_test_func(value)) {                                                                                       \
                status = jak_carbon_printer_null(printer, str);                                                            \
        } else {                                                                                                       \
                ctype val = value;                                                                                     \
                status = print_func(printer, str, &val);                                                               \
        }                                                                                                              \
        status;                                                                                                        \
})

bool jak_carbon_printer_u8_or_null(jak_carbon_printer *printer, jak_string *str, jak_u8 value)
{
        return delegate_print_call(printer, str, value, JAK_IS_NULL_U8, jak_carbon_printer_unsigned_nonull, jak_u64);
}

bool jak_carbon_printer_u16_or_null(jak_carbon_printer *printer, jak_string *str, jak_u16 value)
{
        return delegate_print_call(printer, str, value, JAK_IS_NULL_U16, jak_carbon_printer_unsigned_nonull, jak_u64);
}

bool jak_carbon_printer_u32_or_null(jak_carbon_printer *printer, jak_string *str, jak_u32 value)
{
        return delegate_print_call(printer, str, value, JAK_IS_NULL_U32, jak_carbon_printer_unsigned_nonull, jak_u64);
}

bool jak_carbon_printer_u64_or_null(jak_carbon_printer *printer, jak_string *str, jak_u64 value)
{
        return delegate_print_call(printer, str, value, JAK_IS_NULL_U64, jak_carbon_printer_unsigned_nonull, jak_u64);
}

bool jak_carbon_printer_i8_or_null(jak_carbon_printer *printer, jak_string *str, jak_i8 value)
{
        return delegate_print_call(printer, str, value, JAK_IS_NULL_I8, jak_carbon_printer_signed_nonull, jak_i64);
}

bool jak_carbon_printer_i16_or_null(jak_carbon_printer *printer, jak_string *str, jak_i16 value)
{
        return delegate_print_call(printer, str, value, JAK_IS_NULL_I16, jak_carbon_printer_signed_nonull, jak_i64);
}

bool jak_carbon_printer_i32_or_null(jak_carbon_printer *printer, jak_string *str, jak_i32 value)
{
        return delegate_print_call(printer, str, value, JAK_IS_NULL_I32, jak_carbon_printer_signed_nonull, jak_i64);
}

bool jak_carbon_printer_i64_or_null(jak_carbon_printer *printer, jak_string *str, jak_i64 value)
{
        return delegate_print_call(printer, str, value, JAK_IS_NULL_I64, jak_carbon_printer_signed_nonull, jak_i64);
}

bool jak_carbon_printer_float(jak_carbon_printer *printer, jak_string *str, const float *value)
{
        JAK_ERROR_IF_NULL(printer->val_float);
        printer->val_float(printer, str, value);
        return true;
}

bool jak_carbon_printer_string(jak_carbon_printer *printer, jak_string *str, const char *value, jak_u64 strlen)
{
        JAK_ERROR_IF_NULL(printer->val_string);
        printer->val_string(printer, str, value, strlen);
        return true;
}

bool jak_carbon_printer_binary(jak_carbon_printer *printer, jak_string *str, const jak_carbon_binary *binary)
{
        JAK_ERROR_IF_NULL(printer->val_binary);
        printer->val_binary(printer, str, binary);
        return true;
}

bool jak_carbon_printer_prop_null(jak_carbon_printer *printer, jak_string *str,
                              const char *key_name, jak_u64 key_len)
{
        JAK_ERROR_IF_NULL(printer->prop_null);
        printer->prop_null(printer, str, key_name, key_len);
        return true;
}

bool jak_carbon_printer_prop_true(jak_carbon_printer *printer, jak_string *str,
                              const char *key_name, jak_u64 key_len)
{
        JAK_ERROR_IF_NULL(printer->prop_true);
        printer->prop_true(printer, str, key_name, key_len);
        return true;
}

bool jak_carbon_printer_prop_false(jak_carbon_printer *printer, jak_string *str,
                               const char *key_name, jak_u64 key_len)
{
        JAK_ERROR_IF_NULL(printer->prop_false);
        printer->prop_false(printer, str, key_name, key_len);
        return true;
}

bool jak_carbon_printer_prop_signed(jak_carbon_printer *printer, jak_string *str,
                                const char *key_name, jak_u64 key_len, const jak_i64 *value)
{
        JAK_ERROR_IF_NULL(printer->prop_signed);
        printer->prop_signed(printer, str, key_name, key_len, value);
        return true;
}

bool jak_carbon_printer_prop_unsigned(jak_carbon_printer *printer, jak_string *str,
                                  const char *key_name, jak_u64 key_len, const jak_u64 *value)
{
        JAK_ERROR_IF_NULL(printer->prop_unsigned);
        printer->prop_unsigned(printer, str, key_name, key_len, value);
        return true;
}

bool jak_carbon_printer_prop_float(jak_carbon_printer *printer, jak_string *str,
                               const char *key_name, jak_u64 key_len, const float *value)
{
        JAK_ERROR_IF_NULL(printer->prop_float);
        printer->prop_float(printer, str, key_name, key_len, value);
        return true;
}

bool jak_carbon_printer_prop_string(jak_carbon_printer *printer, jak_string *str,
                                const char *key_name, jak_u64 key_len, const char *value, jak_u64 strlen)
{
        JAK_ERROR_IF_NULL(printer->prop_string);
        printer->prop_string(printer, str, key_name, key_len, value, strlen);
        return true;
}

bool jak_carbon_printer_prop_binary(jak_carbon_printer *printer, jak_string *str,
                                const char *key_name, jak_u64 key_len, const jak_carbon_binary *binary)
{
        JAK_ERROR_IF_NULL(printer->prop_binary);
        printer->prop_binary(printer, str, key_name, key_len, binary);
        return true;
}

bool jak_carbon_printer_array_prop_name(jak_carbon_printer *printer, jak_string *str,
                                    const char *key_name, jak_u64 key_len)
{
        JAK_ERROR_IF_NULL(printer->array_prop_name);
        printer->array_prop_name(printer, str, key_name, key_len);
        return true;
}

bool jak_carbon_printer_column_prop_name(jak_carbon_printer *printer, jak_string *str,
                                     const char *key_name, jak_u64 key_len)
{
        JAK_ERROR_IF_NULL(printer->column_prop_name);
        printer->column_prop_name(printer, str, key_name, key_len);
        return true;
}

bool jak_carbon_printer_object_prop_name(jak_carbon_printer *printer, jak_string *str,
                                     const char *key_name, jak_u64 key_len)
{
        JAK_ERROR_IF_NULL(printer->obj_prop_name);
        printer->obj_prop_name(printer, str, key_name, key_len);
        return true;
}

bool jak_carbon_printer_print_object(jak_carbon_object_it *it, jak_carbon_printer *printer, jak_string *builder)
{
        JAK_ASSERT(it);
        JAK_ASSERT(printer);
        JAK_ASSERT(builder);
        bool is_null_value;
        bool first_entry = true;
        jak_carbon_printer_object_begin(printer, builder);

        while (jak_carbon_object_it_next(it)) {
                if (JAK_LIKELY(!first_entry)) {
                        jak_carbon_printer_comma(printer, builder);
                }
                jak_carbon_field_type_e type;
                jak_u64 key_len;
                const char *key_name = jak_carbon_object_it_prop_name(&key_len, it);

                jak_carbon_object_it_prop_type(&type, it);
                switch (type) {
                        case JAK_CARBON_FIELD_TYPE_NULL:
                                jak_carbon_printer_prop_null(printer, builder, key_name, key_len);
                                break;
                        case JAK_CARBON_FIELD_TYPE_TRUE:
                                /* in an array, there is no TRUE constant that is set to NULL because it will be replaced with
                                 * a constant NULL. In columns, there might be a NULL-encoded value */
                                jak_carbon_printer_prop_true(printer, builder, key_name, key_len);
                                break;
                        case JAK_CARBON_FIELD_TYPE_FALSE:
                                /* in an array, there is no FALSE constant that is set to NULL because it will be replaced with
                                 * a constant NULL. In columns, there might be a NULL-encoded value */
                                jak_carbon_printer_prop_false(printer, builder, key_name, key_len);
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U64: {
                                jak_u64 value;
                                jak_carbon_object_it_unsigned_value(&is_null_value, &value, it);
                                jak_carbon_printer_prop_unsigned(printer, builder, key_name, key_len,
                                                             is_null_value ? NULL : &value);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I64: {
                                jak_i64 value;
                                jak_carbon_object_it_signed_value(&is_null_value, &value, it);
                                jak_carbon_printer_prop_signed(printer, builder, key_name, key_len,
                                                           is_null_value ? NULL : &value);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT: {
                                float value;
                                jak_carbon_object_it_float_value(&is_null_value, &value, it);
                                jak_carbon_printer_prop_float(printer, builder, key_name, key_len,
                                                          is_null_value ? NULL : &value);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_STRING: {
                                jak_u64 strlen;
                                const char *value = jak_carbon_object_it_jak_string_value(&strlen, it);
                                jak_carbon_printer_prop_string(printer, builder, key_name, key_len, value, strlen);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_BINARY:
                        case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM: {
                                jak_carbon_binary binary;
                                jak_carbon_object_it_binary_value(&binary, it);
                                jak_carbon_printer_prop_binary(printer, builder, key_name, key_len, &binary);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_ARRAY: {
                                jak_carbon_array_it *array = jak_carbon_object_it_array_value(it);
                                jak_carbon_printer_array_prop_name(printer, builder, key_name, key_len);
                                jak_carbon_printer_print_array(array, printer, builder, false);
                                jak_carbon_array_it_drop(array);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                                jak_carbon_column_it *column = jak_carbon_object_it_column_value(it);
                                jak_carbon_printer_column_prop_name(printer, builder, key_name, key_len);
                                jak_carbon_printer_print_column(column, printer, builder);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_OBJECT: {
                                jak_carbon_object_it *object = jak_carbon_object_it_object_value(it);
                                jak_carbon_printer_object_prop_name(printer, builder, key_name, key_len);
                                jak_carbon_printer_print_object(object, printer, builder);
                                jak_carbon_object_it_drop(object);
                        }
                                break;
                        default:
                                jak_carbon_printer_object_end(printer, builder);
                                JAK_ERROR(&it->err, JAK_ERR_CORRUPTED);
                                return false;
                }
                first_entry = false;
        }

        jak_carbon_printer_object_end(printer, builder);
        return true;
}

bool jak_carbon_printer_print_array(jak_carbon_array_it *it, jak_carbon_printer *printer, jak_string *builder,
                                bool is_record_container)
{
        JAK_ASSERT(it);
        JAK_ASSERT(printer);
        JAK_ASSERT(builder);

        bool first_entry = true;
        bool has_entries = false;
        bool is_single_entry_array = jak_carbon_array_it_is_unit(it);

        while (jak_carbon_array_it_next(it)) {
                bool is_null_value;

                if (JAK_LIKELY(!first_entry)) {
                        jak_carbon_printer_comma(printer, builder);
                } else {
                        if (is_single_entry_array && is_record_container) {
                                jak_carbon_printer_unit_array_begin(printer, builder);
                        } else {
                                jak_carbon_printer_array_begin(printer, builder);
                        }
                        has_entries = true;
                }
                jak_carbon_field_type_e type;
                jak_carbon_array_it_field_type(&type, it);
                switch (type) {
                        case JAK_CARBON_FIELD_TYPE_NULL:
                                jak_carbon_printer_null(printer, builder);
                                break;
                        case JAK_CARBON_FIELD_TYPE_TRUE:
                                /* in an array, there is no TRUE constant that is set to NULL because it will be replaced with
                                 * a constant NULL. In columns, there might be a NULL-encoded value */
                                jak_carbon_printer_true(printer, false, builder);
                                break;
                        case JAK_CARBON_FIELD_TYPE_FALSE:
                                /* in an array, there is no FALSE constant that is set to NULL because it will be replaced with
                                 * a constant NULL. In columns, there might be a NULL-encoded value */
                                jak_carbon_printer_false(printer, false, builder);
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_U64: {
                                jak_u64 value;
                                jak_carbon_array_it_unsigned_value(&is_null_value, &value, it);
                                jak_carbon_printer_unsigned_nonull(printer, builder, is_null_value ? NULL : &value);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                        case JAK_CARBON_FIELD_TYPE_NUMBER_I64: {
                                jak_i64 value;
                                jak_carbon_array_it_signed_value(&is_null_value, &value, it);
                                jak_carbon_printer_signed_nonull(printer, builder, is_null_value ? NULL : &value);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT: {
                                float value;
                                jak_carbon_array_it_float_value(&is_null_value, &value, it);
                                jak_carbon_printer_float(printer, builder, is_null_value ? NULL : &value);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_STRING: {
                                jak_u64 strlen;
                                const char *value = jak_carbon_array_it_jak_string_value(&strlen, it);
                                jak_carbon_printer_string(printer, builder, value, strlen);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_BINARY:
                        case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM: {
                                jak_carbon_binary binary;
                                jak_carbon_array_it_binary_value(&binary, it);
                                jak_carbon_printer_binary(printer, builder, &binary);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_ARRAY: {
                                jak_carbon_array_it *array = jak_carbon_array_it_array_value(it);
                                jak_carbon_printer_print_array(array, printer, builder, false);
                                jak_carbon_array_it_drop(array);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                        case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                                jak_carbon_column_it *column = jak_carbon_array_it_column_value(it);
                                jak_carbon_printer_print_column(column, printer, builder);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_OBJECT: {
                                jak_carbon_object_it *object = jak_carbon_array_it_object_value(it);
                                jak_carbon_printer_print_object(object, printer, builder);
                                jak_carbon_object_it_drop(object);
                        }
                                break;
                        default:
                                jak_carbon_printer_array_end(printer, builder);
                                JAK_ERROR(&it->err, JAK_ERR_CORRUPTED);
                                return false;
                }
                first_entry = false;
        }

        if (has_entries) {
                if (is_single_entry_array && is_record_container) {
                        jak_carbon_printer_unit_array_end(printer, builder);
                } else {
                        jak_carbon_printer_array_end(printer, builder);
                }
        } else {
                if (is_record_container) {
                        jak_carbon_printer_empty_record(printer, builder);
                } else {
                        jak_carbon_printer_array_begin(printer, builder);
                        jak_carbon_printer_array_end(printer, builder);
                }
        }

        return true;
}

bool jak_carbon_printer_print_column(jak_carbon_column_it *it, jak_carbon_printer *printer, jak_string *builder)
{
        JAK_ERROR_IF_NULL(it)
        JAK_ERROR_IF_NULL(printer)
        JAK_ERROR_IF_NULL(builder)

        jak_carbon_field_type_e type;
        jak_u32 nvalues;
        const void *values = jak_carbon_column_it_values(&type, &nvalues, it);

        jak_carbon_printer_array_begin(printer, builder);
        for (jak_u32 i = 0; i < nvalues; i++) {
                switch (type) {
                        case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN: {
                                jak_u8 value = ((jak_u8 *) values)[i];
                                if (JAK_IS_NULL_BOOLEAN(value)) {
                                        jak_carbon_printer_null(printer, builder);
                                } else if (value == JAK_CARBON_BOOLEAN_COLUMN_TRUE) {
                                        jak_carbon_printer_true(printer, false, builder);
                                } else {
                                        jak_carbon_printer_false(printer, false, builder);
                                }
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U8: {
                                jak_u64 number = ((jak_u8 *) values)[i];
                                jak_carbon_printer_unsigned_nonull(printer, builder, JAK_IS_NULL_U8(number) ? NULL : &number);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U16: {
                                jak_u64 number = ((jak_u16 *) values)[i];
                                jak_carbon_printer_unsigned_nonull(printer, builder, JAK_IS_NULL_U16(number) ? NULL : &number);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U32: {
                                jak_u64 number = ((jak_u32 *) values)[i];
                                jak_carbon_printer_unsigned_nonull(printer, builder, JAK_IS_NULL_U32(number) ? NULL : &number);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_U64: {
                                jak_u64 number = ((jak_u64 *) values)[i];
                                jak_carbon_printer_unsigned_nonull(printer, builder, JAK_IS_NULL_U64(number) ? NULL : &number);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I8: {
                                jak_i64 number = ((jak_i8 *) values)[i];
                                jak_carbon_printer_signed_nonull(printer, builder, JAK_IS_NULL_I8(number) ? NULL : &number);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I16: {
                                jak_i64 number = ((jak_i16 *) values)[i];
                                jak_carbon_printer_signed_nonull(printer, builder, JAK_IS_NULL_I16(number) ? NULL : &number);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I32: {
                                jak_i64 number = ((jak_i32 *) values)[i];
                                jak_carbon_printer_signed_nonull(printer, builder, JAK_IS_NULL_I32(number) ? NULL : &number);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_I64: {
                                jak_i64 number = ((jak_i64 *) values)[i];
                                jak_carbon_printer_signed_nonull(printer, builder, JAK_IS_NULL_I64(number) ? NULL : &number);
                        }
                                break;
                        case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT: {
                                float number = ((float *) values)[i];
                                jak_carbon_printer_float(printer, builder, JAK_IS_NULL_FLOAT(number) ? NULL : &number);
                        }
                                break;
                        default:
                                jak_carbon_printer_array_end(printer, builder);
                                JAK_ERROR(&it->err, JAK_ERR_CORRUPTED);
                                return false;
                }
                if (i + 1 < nvalues) {
                        jak_carbon_printer_comma(printer, builder);
                }
        }
        jak_carbon_printer_array_end(printer, builder);

        return true;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon_prop.h>
#include <jak_carbon_string.h>
#include <jak_carbon_field.h>

jak_u64 jak_carbon_prop_size(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file);
        jak_offset_t prop_start = jak_memfile_save_position(file);
        jak_carbon_jak_string_nomarker_skip(file);
        jak_carbon_field_skip(file);
        jak_offset_t prop_end = jak_memfile_tell(file);
        jak_memfile_restore_position(file);
        return prop_end - prop_start;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon.h>
#include <jak_carbon_revise.h>
#include <jak_carbon_array_it.h>
#include <jak_carbon_int.h>
#include <jak_carbon_dot.h>
#include <jak_carbon_find.h>
#include <jak_carbon_key.h>
#include <jak_carbon_commit.h>
#include <jak_carbon_object_it.h>

static bool internal_jak_pack_array(jak_carbon_array_it *it);

static bool internal_jak_pack_object(jak_carbon_object_it *it);

static bool internal_jak_pack_column(jak_carbon_column_it *it);

static bool internal_commit_update(jak_carbon *doc);

static bool carbon_header_rev_inc(jak_carbon *doc);

// ---------------------------------------------------------------------------------------------------------------------

bool jak_carbon_revise_try_begin(jak_carbon_revise *context, jak_carbon *revised_doc, jak_carbon *doc)
{
        JAK_ERROR_IF_NULL(context)
        JAK_ERROR_IF_NULL(doc)
        if (!doc->versioning.commit_lock) {
                return jak_carbon_revise_begin(context, revised_doc, doc);
        } else {
                return false;
        }
}

bool jak_carbon_revise_begin(jak_carbon_revise *context, jak_carbon *revised_doc, jak_carbon *original)
{
        JAK_ERROR_IF_NULL(context)
        JAK_ERROR_IF_NULL(original)

        if (JAK_LIKELY(original->versioning.is_latest)) {
                jak_spinlock_acquire(&original->versioning.write_lock);
                original->versioning.commit_lock = true;
                context->original = original;
                context->revised_doc = revised_doc;
                jak_error_init(&context->err);
                jak_carbon_clone(context->revised_doc, context->original);
                return true;
        } else {
                JAK_ERROR(&original->err, JAK_ERR_OUTDATED)
                return false;
        }
}


static void key_unsigned_set(jak_carbon *doc, jak_u64 key)
{
        JAK_ASSERT(doc);
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);

        jak_carbon_key_write_unsigned(&doc->memfile, key);

        jak_memfile_restore_position(&doc->memfile);
}

static void key_signed_set(jak_carbon *doc, jak_i64 key)
{
        JAK_ASSERT(doc);
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);

        jak_carbon_key_write_signed(&doc->memfile, key);

        jak_memfile_restore_position(&doc->memfile);
}

static void key_jak_string_set(jak_carbon *doc, const char *key)
{
        JAK_ASSERT(doc);
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);

        jak_carbon_key_update_string(&doc->memfile, key);

        jak_memfile_restore_position(&doc->memfile);
}

bool jak_carbon_revise_key_generate(jak_uid_t *out, jak_carbon_revise *context)
{
        JAK_ERROR_IF_NULL(context);
        jak_carbon_key_e key_type;
        jak_carbon_key_type(&key_type, context->revised_doc);
        if (key_type == JAK_CARBON_KEY_AUTOKEY) {
                jak_uid_t oid;
                jak_unique_id_create(&oid);
                key_unsigned_set(context->revised_doc, oid);
                JAK_OPTIONAL_SET(out, oid);
                return true;
        } else {
                JAK_ERROR(&context->err, JAK_ERR_TYPEMISMATCH)
                return false;
        }
}

bool jak_carbon_revise_key_set_unsigned(jak_carbon_revise *context, jak_u64 key_value)
{
        JAK_ERROR_IF_NULL(context);
        jak_carbon_key_e key_type;
        jak_carbon_key_type(&key_type, context->revised_doc);
        if (key_type == JAK_CARBON_KEY_UKEY) {
                key_unsigned_set(context->revised_doc, key_value);
                return true;
        } else {
                JAK_ERROR(&context->err, JAK_ERR_TYPEMISMATCH)
                return false;
        }
}

bool jak_carbon_revise_key_set_signed(jak_carbon_revise *context, jak_i64 key_value)
{
        JAK_ERROR_IF_NULL(context);
        jak_carbon_key_e key_type;
        jak_carbon_key_type(&key_type, context->revised_doc);
        if (key_type == JAK_CARBON_KEY_IKEY) {
                key_signed_set(context->revised_doc, key_value);
                return true;
        } else {
                JAK_ERROR(&context->err, JAK_ERR_TYPEMISMATCH)
                return false;
        }
}

bool jak_carbon_revise_key_set_string(jak_carbon_revise *context, const char *key_value)
{
        JAK_ERROR_IF_NULL(context);
        jak_carbon_key_e key_type;
        jak_carbon_key_type(&key_type, context->revised_doc);
        if (key_type == JAK_CARBON_KEY_SKEY) {
                key_jak_string_set(context->revised_doc, key_value);
                return true;
        } else {
                JAK_ERROR(&context->err, JAK_ERR_TYPEMISMATCH)
                return false;
        }
}

bool jak_carbon_revise_iterator_open(jak_carbon_array_it *it, jak_carbon_revise *context)
{
        JAK_ERROR_IF_NULL(it);
        JAK_ERROR_IF_NULL(context);
        jak_offset_t payload_start = jak_carbon_int_payload_after_header(context->revised_doc);
        JAK_ERROR_IF(context->revised_doc->memfile.mode != JAK_READ_WRITE, &context->original->err, JAK_ERR_INTERNALERR)
        return jak_carbon_array_it_create(it, &context->revised_doc->memfile, &context->original->err, payload_start);
}

bool jak_carbon_revise_iterator_close(jak_carbon_array_it *it)
{
        JAK_ERROR_IF_NULL(it);
        return jak_carbon_array_it_drop(it);
}

bool jak_carbon_revise_find_open(jak_carbon_find *out, const char *dot_path, jak_carbon_revise *context)
{
        JAK_ERROR_IF_NULL(out)
        JAK_ERROR_IF_NULL(dot_path)
        JAK_ERROR_IF_NULL(context)
        jak_carbon_dot_path path;
        jak_carbon_dot_path_from_string(&path, dot_path);
        bool status = jak_carbon_find_create(out, &path, context->revised_doc);
        jak_carbon_dot_path_drop(&path);
        return status;
}

bool jak_carbon_revise_find_close(jak_carbon_find *find)
{
        JAK_ERROR_IF_NULL(find)
        return jak_carbon_find_drop(find);
}

bool jak_carbon_revise_remove_one(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc)
{
        jak_carbon_revise revise;
        jak_carbon_revise_begin(&revise, rev_doc, doc);
        bool status = jak_carbon_revise_remove(dot_path, &revise);
        jak_carbon_revise_end(&revise);
        return status;
}

bool jak_carbon_revise_remove(const char *dot_path, jak_carbon_revise *context)
{
        JAK_ERROR_IF_NULL(dot_path)
        JAK_ERROR_IF_NULL(context)

        jak_carbon_dot_path dot;
        jak_carbon_path_evaluator eval;
        bool result;

        if (jak_carbon_dot_path_from_string(&dot, dot_path)) {
                jak_carbon_path_evaluator_begin_mutable(&eval, &dot, context);

                if (eval.status != JAK_CARBON_PATH_RESOLVED) {
                        result = false;
                } else {
                        switch (eval.result.container_type) {
                                case JAK_CARBON_ARRAY: {
                                        jak_carbon_array_it *it = &eval.result.containers.array.it;
                                        result = jak_carbon_array_it_remove(it);
                                }
                                        break;
                                case JAK_CARBON_COLUMN: {
                                        jak_carbon_column_it *it = &eval.result.containers.column.it;
                                        jak_u32 elem_pos = eval.result.containers.column.elem_pos;
                                        result = jak_carbon_column_it_remove(it, elem_pos);
                                }
                                        break;
                                default: JAK_ERROR(&context->original->err, JAK_ERR_INTERNALERR);
                                        result = false;
                        }
                }
                jak_carbon_path_evaluator_end(&eval);
                return result;
        } else {
                JAK_ERROR(&context->original->err, JAK_ERR_DOT_PATH_PARSERR);
                return false;
        }
}

bool jak_carbon_revise_pack(jak_carbon_revise *context)
{
        JAK_ERROR_IF_NULL(context);
        jak_carbon_array_it it;
        jak_carbon_revise_iterator_open(&it, context);
        internal_jak_pack_array(&it);
        jak_carbon_revise_iterator_close(&it);
        return true;
}

bool jak_carbon_revise_shrink(jak_carbon_revise *context)
{
        jak_carbon_array_it it;
        jak_carbon_revise_iterator_open(&it, context);
        jak_carbon_array_it_fast_forward(&it);
        if (jak_memfile_remain_size(&it.memfile) > 0) {
                jak_offset_t first_empty_slot = jak_memfile_tell(&it.memfile);
                JAK_ASSERT(jak_memfile_size(&it.memfile) > first_empty_slot);
                jak_offset_t shrink_size = jak_memfile_size(&it.memfile) - first_empty_slot;
                jak_memfile_cut(&it.memfile, shrink_size);
        }

        jak_offset_t size;
        jak_memblock_size(&size, it.memfile.memblock);
        jak_carbon_revise_iterator_close(&it);
        return true;
}

const jak_carbon *jak_carbon_revise_end(jak_carbon_revise *context)
{
        if (JAK_LIKELY(context != NULL)) {
                internal_commit_update(context->revised_doc);

                context->original->versioning.is_latest = false;
                context->original->versioning.commit_lock = false;

                jak_spinlock_release(&context->original->versioning.write_lock);

                return context->revised_doc;
        } else {
                JAK_ERROR_PRINT(JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool jak_carbon_revise_abort(jak_carbon_revise *context)
{
        JAK_ERROR_IF_NULL(context)

        jak_carbon_drop(context->revised_doc);
        context->original->versioning.is_latest = true;
        context->original->versioning.commit_lock = false;
        jak_spinlock_release(&context->original->versioning.write_lock);

        return true;
}

static bool internal_jak_pack_array(jak_carbon_array_it *it)
{
        JAK_ASSERT(it);

        /* shrink this array */
        {
                jak_carbon_array_it this_array_it;
                bool is_empty_slot, is_array_end;

                jak_carbon_array_it_copy(&this_array_it, it);
                jak_carbon_int_array_skip_contents(&is_empty_slot, &is_array_end, &this_array_it);

                if (!is_array_end) {

                        JAK_ERROR_IF(!is_empty_slot, &it->err, JAK_ERR_CORRUPTED);
                        jak_offset_t first_empty_slot_offset = jak_memfile_tell(&this_array_it.memfile);
                        char final;
                        while ((final = *jak_memfile_read(&this_array_it.memfile, sizeof(char))) == 0) {}
                        JAK_ASSERT(final == JAK_CARBON_MARKER_ARRAY_END);
                        jak_offset_t last_empty_slot_offset = jak_memfile_tell(&this_array_it.memfile) - sizeof(char);
                        jak_memfile_seek(&this_array_it.memfile, first_empty_slot_offset);
                        JAK_ASSERT(last_empty_slot_offset > first_empty_slot_offset);

                        jak_memfile_inplace_remove(&this_array_it.memfile,
                                               last_empty_slot_offset - first_empty_slot_offset);

                        final = *jak_memfile_read(&this_array_it.memfile, sizeof(char));
                        JAK_ASSERT(final == JAK_CARBON_MARKER_ARRAY_END);
                }

                jak_carbon_array_it_drop(&this_array_it);
        }

        /* shrink contained containers */
        {
                while (jak_carbon_array_it_next(it)) {
                        jak_carbon_field_type_e type;
                        jak_carbon_array_it_field_type(&type, it);
                        switch (type) {
                                case JAK_CARBON_FIELD_TYPE_NULL:
                                case JAK_CARBON_FIELD_TYPE_TRUE:
                                case JAK_CARBON_FIELD_TYPE_FALSE:
                                case JAK_CARBON_FIELD_TYPE_STRING:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                                case JAK_CARBON_FIELD_TYPE_BINARY:
                                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                                        /* nothing to shrink, because there are no padded zeros here */
                                        break;
                                case JAK_CARBON_FIELD_TYPE_ARRAY: {
                                        jak_carbon_array_it nested_array_it;
                                        jak_carbon_array_it_create(&nested_array_it, &it->memfile, &it->err,
                                                               it->field_access.nested_array_it->payload_start -
                                                               sizeof(jak_u8));
                                        internal_jak_pack_array(&nested_array_it);
                                        JAK_ASSERT(*jak_memfile_peek(&nested_array_it.memfile, sizeof(char)) ==
                                                   JAK_CARBON_MARKER_ARRAY_END);
                                        jak_memfile_skip(&nested_array_it.memfile, sizeof(char));
                                        jak_memfile_seek(&it->memfile, jak_memfile_tell(&nested_array_it.memfile));
                                        jak_carbon_array_it_drop(&nested_array_it);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                                        jak_carbon_column_it_rewind(it->field_access.nested_column_it);
                                        internal_jak_pack_column(it->field_access.nested_column_it);
                                        jak_memfile_seek(&it->memfile,
                                                     jak_memfile_tell(&it->field_access.nested_column_it->memfile));
                                        break;
                                case JAK_CARBON_FIELD_TYPE_OBJECT: {
                                        jak_carbon_object_it nested_object_it;
                                        jak_carbon_object_it_create(&nested_object_it, &it->memfile, &it->err,
                                                                it->field_access.nested_object_it->object_contents_off -
                                                                sizeof(jak_u8));
                                        internal_jak_pack_object(&nested_object_it);
                                        JAK_ASSERT(*jak_memfile_peek(&nested_object_it.memfile, sizeof(char)) ==
                                                   JAK_CARBON_MARKER_OBJECT_END);
                                        jak_memfile_skip(&nested_object_it.memfile, sizeof(char));
                                        jak_memfile_seek(&it->memfile, jak_memfile_tell(&nested_object_it.memfile));
                                        jak_carbon_object_it_drop(&nested_object_it);
                                }
                                        break;
                                default: JAK_ERROR(&it->err, JAK_ERR_INTERNALERR);
                                        return false;
                        }
                }
        }

        JAK_ASSERT(*jak_memfile_peek(&it->memfile, sizeof(char)) == JAK_CARBON_MARKER_ARRAY_END);

        return true;
}

static bool internal_jak_pack_object(jak_carbon_object_it *it)
{
        JAK_ASSERT(it);

        /* shrink this object */
        {
                jak_carbon_object_it this_object_it;
                bool is_empty_slot, is_object_end;

                jak_carbon_object_it_copy(&this_object_it, it);
                jak_carbon_int_object_skip_contents(&is_empty_slot, &is_object_end, &this_object_it);

                if (!is_object_end) {

                        JAK_ERROR_IF(!is_empty_slot, &it->err, JAK_ERR_CORRUPTED);
                        jak_offset_t first_empty_slot_offset = jak_memfile_tell(&this_object_it.memfile);
                        char final;
                        while ((final = *jak_memfile_read(&this_object_it.memfile, sizeof(char))) == 0) {}
                        JAK_ASSERT(final == JAK_CARBON_MARKER_OBJECT_END);
                        jak_offset_t last_empty_slot_offset = jak_memfile_tell(&this_object_it.memfile) - sizeof(char);
                        jak_memfile_seek(&this_object_it.memfile, first_empty_slot_offset);
                        JAK_ASSERT(last_empty_slot_offset > first_empty_slot_offset);

                        jak_memfile_inplace_remove(&this_object_it.memfile,
                                               last_empty_slot_offset - first_empty_slot_offset);

                        final = *jak_memfile_read(&this_object_it.memfile, sizeof(char));
                        JAK_ASSERT(final == JAK_CARBON_MARKER_OBJECT_END);
                }

                jak_carbon_object_it_drop(&this_object_it);
        }

        /* shrink contained containers */
        {
                while (jak_carbon_object_it_next(it)) {
                        jak_carbon_field_type_e type;
                        jak_carbon_object_it_prop_type(&type, it);
                        switch (type) {
                                case JAK_CARBON_FIELD_TYPE_NULL:
                                case JAK_CARBON_FIELD_TYPE_TRUE:
                                case JAK_CARBON_FIELD_TYPE_FALSE:
                                case JAK_CARBON_FIELD_TYPE_STRING:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_U8:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_U16:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_U32:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_U64:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_I8:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_I16:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_I32:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_I64:
                                case JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT:
                                case JAK_CARBON_FIELD_TYPE_BINARY:
                                case JAK_CARBON_FIELD_TYPE_BINARY_CUSTOM:
                                        /* nothing to shrink, because there are no padded zeros here */
                                        break;
                                case JAK_CARBON_FIELD_TYPE_ARRAY: {
                                        jak_carbon_array_it nested_array_it;
                                        jak_carbon_array_it_create(&nested_array_it, &it->memfile, &it->err,
                                                               it->field.value.data.nested_array_it->payload_start -
                                                               sizeof(jak_u8));
                                        internal_jak_pack_array(&nested_array_it);
                                        JAK_ASSERT(*jak_memfile_peek(&nested_array_it.memfile, sizeof(char)) ==
                                                   JAK_CARBON_MARKER_ARRAY_END);
                                        jak_memfile_skip(&nested_array_it.memfile, sizeof(char));
                                        jak_memfile_seek(&it->memfile, jak_memfile_tell(&nested_array_it.memfile));
                                        jak_carbon_array_it_drop(&nested_array_it);
                                }
                                        break;
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U8:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U16:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U32:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_U64:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I8:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I16:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I32:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_I64:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_FLOAT:
                                case JAK_CARBON_FIELD_TYPE_COLUMN_BOOLEAN:
                                        jak_carbon_column_it_rewind(it->field.value.data.nested_column_it);
                                        internal_jak_pack_column(it->field.value.data.nested_column_it);
                                        jak_memfile_seek(&it->memfile,
                                                     jak_memfile_tell(&it->field.value.data.nested_column_it->memfile));
                                        break;
                                case JAK_CARBON_FIELD_TYPE_OBJECT: {
                                        jak_carbon_object_it nested_object_it;
                                        jak_carbon_object_it_create(&nested_object_it, &it->memfile, &it->err,
                                                                it->field.value.data.nested_object_it->object_contents_off -
                                                                sizeof(jak_u8));
                                        internal_jak_pack_object(&nested_object_it);
                                        JAK_ASSERT(*jak_memfile_peek(&nested_object_it.memfile, sizeof(char)) ==
                                                   JAK_CARBON_MARKER_OBJECT_END);
                                        jak_memfile_skip(&nested_object_it.memfile, sizeof(char));
                                        jak_memfile_seek(&it->memfile, jak_memfile_tell(&nested_object_it.memfile));
                                        jak_carbon_object_it_drop(&nested_object_it);
                                }
                                        break;
                                default: JAK_ERROR(&it->err, JAK_ERR_INTERNALERR);
                                        return false;
                        }
                }
        }

        JAK_ASSERT(*jak_memfile_peek(&it->memfile, sizeof(char)) == JAK_CARBON_MARKER_OBJECT_END);

        return true;
}

static bool internal_jak_pack_column(jak_carbon_column_it *it)
{
        JAK_ASSERT(it);

        jak_u32 free_space = (it->column_capacity - it->column_num_elements) * jak_carbon_int_get_type_value_size(it->type);
        jak_offset_t payload_start = jak_carbon_int_column_get_payload_off(it);
        jak_u64 payload_size = it->column_num_elements * jak_carbon_int_get_type_value_size(it->type);
        jak_memfile_seek(&it->memfile, payload_start);
        jak_memfile_skip(&it->memfile, payload_size);

        if (free_space > 0) {
                jak_memfile_inplace_remove(&it->memfile, free_space);

                jak_memfile_seek(&it->memfile, it->num_and_capacity_start_offset);
                jak_memfile_skip_uintvar_stream(&it->memfile); // skip num of elements counter
                jak_memfile_update_uintvar_stream(&it->memfile,
                                              it->column_num_elements); // update capacity counter to num elems

                jak_memfile_skip(&it->memfile, payload_size);

                return true;
        } else {
                return false;
        }
}

static bool internal_commit_update(jak_carbon *doc)
{
        JAK_ASSERT(doc);
        return carbon_header_rev_inc(doc);
}

static bool carbon_header_rev_inc(jak_carbon *doc)
{
        JAK_ASSERT(doc);

        jak_carbon_key_e key_type;
        jak_memfile_save_position(&doc->memfile);
        jak_memfile_seek(&doc->memfile, 0);
        jak_carbon_key_read(NULL, &key_type, &doc->memfile);
        if (jak_carbon_has_key(key_type)) {
                jak_u64 raw_data_len = 0;
                const void *raw_data = jak_carbon_raw_data(&raw_data_len, doc);
                jak_carbon_commit_hash_update(&doc->memfile, raw_data, raw_data_len);
        }
        jak_memfile_restore_position(&doc->memfile);

        return true;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_uintvar_stream.h>
#include <jak_carbon_media.h>
#include <jak_carbon_field.h>
#include <jak_carbon_string.h>

static void write_payload(jak_memfile *file, const char *string, size_t str_len)
{
        jak_memfile_write_uintvar_stream(NULL, file, str_len);
        jak_memfile_ensure_space(file, str_len);
        jak_memfile_write(file, string, str_len);
}

bool jak_carbon_jak_string_nomarker_write(jak_memfile *file, const char *string)
{
        return jak_carbon_jak_string_nomarker_nchar_write(file, string, strlen(string));
}

bool jak_carbon_jak_string_nomarker_nchar_write(jak_memfile *file, const char *string, jak_u64 str_len)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(string)
        write_payload(file, string, str_len);

        return true;
}

bool jak_carbon_jak_string_nomarker_remove(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file);
        jak_u8 len_nbytes;
        jak_u64 str_len = jak_memfile_read_uintvar_stream(&len_nbytes, file);
        jak_memfile_skip(file, -len_nbytes);
        jak_memfile_inplace_remove(file, len_nbytes + str_len);
        return true;
}

bool jak_carbon_jak_string_remove(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file);
        jak_u8 marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);
        if (JAK_LIKELY(marker == JAK_CARBON_FIELD_TYPE_STRING)) {
                jak_memfile_inplace_remove(file, sizeof(jak_u8));
                return jak_carbon_jak_string_nomarker_remove(file);
        } else {
                JAK_ERROR(&file->err, JAK_ERR_MARKERMAPPING)
                return false;
        }
}

bool jak_carbon_jak_string_write(jak_memfile *file, const char *string)
{
        return jak_carbon_jak_string_nchar_write(file, string, strlen(string));
}

bool jak_carbon_jak_string_nchar_write(jak_memfile *file, const char *string, jak_u64 str_len)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(string)

        jak_memfile_ensure_space(file, sizeof(jak_media_type));
        jak_carbon_media_write(file, JAK_CARBON_FIELD_TYPE_STRING);
        jak_carbon_jak_string_nomarker_nchar_write(file, string, str_len);

        return true;
}

bool jak_carbon_jak_string_update(jak_memfile *file, const char *string)
{
        return jak_carbon_jak_string_update_wnchar(file, string, strlen(string));
}

bool jak_carbon_jak_string_update_wnchar(jak_memfile *file, const char *string, size_t str_len)
{
        jak_u8 marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);
        if (JAK_LIKELY(marker == JAK_CARBON_FIELD_TYPE_STRING)) {
                jak_offset_t payload_start = jak_memfile_tell(file);
                jak_u32 old_len = jak_memfile_read_uintvar_stream(NULL, file);
                jak_memfile_skip(file, old_len);
                jak_offset_t diff = jak_memfile_tell(file) - payload_start;
                jak_memfile_seek(file, payload_start);
                jak_memfile_inplace_remove(file, diff);

                write_payload(file, string, str_len);
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_MARKERMAPPING)
                return false;
        }
}

bool jak_carbon_jak_string_skip(jak_memfile *file)
{
        return jak_carbon_jak_string_read(NULL, file);
}

bool jak_carbon_jak_string_nomarker_skip(jak_memfile *file)
{
        return jak_carbon_jak_string_nomarker_read(NULL, file);
}

const char *jak_carbon_jak_string_read(jak_u64 *len, jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)
        jak_u8 marker = *JAK_MEMFILE_READ_TYPE(file, jak_u8);
        if (JAK_LIKELY(marker == JAK_CARBON_FIELD_TYPE_STRING)) {
                return jak_carbon_jak_string_nomarker_read(len, file);
        } else {
                JAK_ERROR(&file->err, JAK_ERR_MARKERMAPPING)
                return false;
        }
}

const char *jak_carbon_jak_string_nomarker_read(jak_u64 *len, jak_memfile *file)
{
        jak_u64 str_len = jak_memfile_read_uintvar_stream(NULL, file);
        const char *result = jak_memfile_read(file, str_len);
        JAK_OPTIONAL_SET(len, str_len);
        return result;
}/**
 * Columnar Binary JSON -- Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_carbon_path.h>
#include <jak_carbon_path.h>
#include <jak_carbon_update.h>
#include <jak_carbon_insert.h>
#include <jak_carbon_revise.h>
#include <jak_utils_numbers.h>

#define try_array_update(type_match, in_place_update_fn, insert_fn)                                                    \
({                                                                                                                     \
        jak_carbon_field_type_e type_is = 0;                                                                            \
        jak_carbon_array_it_field_type(&type_is, it);                                                                      \
        bool status = false;                                                                                           \
        switch (type_is) {                                                                                             \
                case type_match:                                                                                       \
                        status = in_place_update_fn(it, value);                                                        \
                break;                                                                                                 \
                default: {                                                                                             \
                        jak_carbon_insert inserter;                                                                 \
                        jak_carbon_array_it_remove(it);                                                                    \
                        jak_carbon_array_it_next(it);                                                                      \
                        jak_carbon_array_it_insert_begin(&inserter, it);                                                   \
                        status = insert_fn(&inserter, value);                                                          \
                        jak_carbon_array_it_insert_end(&inserter);                                                         \
                break;                                                                                                 \
                }                                                                                                      \
        }                                                                                                              \
        status;                                                                                                        \
})

#define DEFINE_ARRAY_UPDATE_FUNCTION(type_name, type_match, in_place_update_fn, insert_fn)                             \
static bool array_update_##type_name(jak_carbon_array_it *it, jak_##type_name value)                                       \
{                                                                                                                      \
        return try_array_update(type_match, in_place_update_fn, insert_fn);                                            \
}

DEFINE_ARRAY_UPDATE_FUNCTION(u8, JAK_CARBON_FIELD_TYPE_NUMBER_U8, jak_carbon_array_it_update_in_place_u8, jak_carbon_insert_u8)

DEFINE_ARRAY_UPDATE_FUNCTION(u16, JAK_CARBON_FIELD_TYPE_NUMBER_U16, jak_carbon_array_it_update_in_place_u16,
                             jak_carbon_insert_u16)

DEFINE_ARRAY_UPDATE_FUNCTION(u32, JAK_CARBON_FIELD_TYPE_NUMBER_U32, jak_carbon_array_it_update_in_place_u32,
                             jak_carbon_insert_u32)

DEFINE_ARRAY_UPDATE_FUNCTION(u64, JAK_CARBON_FIELD_TYPE_NUMBER_U64, jak_carbon_array_it_update_in_place_u64,
                             jak_carbon_insert_u64)

DEFINE_ARRAY_UPDATE_FUNCTION(i8, JAK_CARBON_FIELD_TYPE_NUMBER_I8, jak_carbon_array_it_update_in_place_i8, jak_carbon_insert_i8)

DEFINE_ARRAY_UPDATE_FUNCTION(i16, JAK_CARBON_FIELD_TYPE_NUMBER_I16, jak_carbon_array_it_update_in_place_i16,
                             jak_carbon_insert_i16)

DEFINE_ARRAY_UPDATE_FUNCTION(i32, JAK_CARBON_FIELD_TYPE_NUMBER_I32, jak_carbon_array_it_update_in_place_i32,
                             jak_carbon_insert_i32)

DEFINE_ARRAY_UPDATE_FUNCTION(i64, JAK_CARBON_FIELD_TYPE_NUMBER_I64, jak_carbon_array_it_update_in_place_i64,
                             jak_carbon_insert_i64)

DEFINE_ARRAY_UPDATE_FUNCTION(float, JAK_CARBON_FIELD_TYPE_NUMBER_FLOAT, jak_carbon_array_it_update_in_place_float,
                             jak_carbon_insert_float)

#define try_update_generic(context, path, array_exec, column_exec)                                                     \
({                                                                                                                     \
        JAK_ERROR_IF_NULL(context)                                                                                         \
        JAK_ERROR_IF_NULL(path)                                                                                            \
        bool status = false;                                                                                           \
        jak_carbon_update updater;                                                                                   \
        if (create(&updater, context, path)) {                                                                         \
                if (resolve_path(&updater) && path_resolved(&updater)) {                                               \
                                                                                                                       \
                        switch (updater.path_evaluater.result.container_type) {                                        \
                        case JAK_CARBON_ARRAY:                                                                              \
                                array_exec;                                                                            \
                                status = true;                                                                         \
                                break;                                                                                 \
                        case JAK_CARBON_COLUMN: {                                                                           \
                                jak_u32 elem_pos;                                                                          \
                                jak_carbon_column_it *it = column_iterator(&elem_pos, &updater);                     \
                                column_exec;                                                                           \
                                status = true;                                                                         \
                        } break;                                                                                       \
                        default:                                                                                       \
                        JAK_ERROR(&context->original->err, JAK_ERR_INTERNALERR)                                            \
                        }                                                                                              \
                }                                                                                                      \
                jak_carbon_path_evaluator_end(&updater.path_evaluater);                                                    \
                }                                                                                                              \
        status;                                                                                                        \
})

#define try_update_value(context, path, value, array_update_fn, column_update_fn)                                      \
        try_update_generic(context, path, (array_update_fn(array_iterator(&updater), value)),                          \
                           (column_update_fn(it, elem_pos, value)) )

#define try_update(context, path, array_update_fn, column_update_fn)                                                   \
        try_update_generic(context, path, (array_update_fn(array_iterator(&updater))), (column_update_fn(it, elem_pos)))


static bool
create(jak_carbon_update *updater, jak_carbon_revise *context, const jak_carbon_dot_path *path)
{
        JAK_ERROR_IF_NULL(updater)
        JAK_ERROR_IF_NULL(context)
        JAK_ERROR_IF_NULL(path)

        jak_error_init(&updater->err);
        updater->context = context;
        updater->path = path;

        return true;
}

static bool compile_path(jak_carbon_dot_path *out, const char *in)
{
        return jak_carbon_dot_path_from_string(out, in);
}

static bool resolve_path(jak_carbon_update *updater)
{
        return jak_carbon_path_evaluator_begin_mutable(&updater->path_evaluater, updater->path, updater->context);
}

static bool path_resolved(jak_carbon_update *updater)
{
        return jak_carbon_path_evaluator_has_result(&updater->path_evaluater);
}

static bool column_update_u8(jak_carbon_column_it *it, jak_u32 pos, jak_u8 value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}

static bool column_update_u16(jak_carbon_column_it *it, jak_u32 pos, jak_u16 value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}

static bool column_update_u32(jak_carbon_column_it *it, jak_u32 pos, jak_u32 value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}

static bool column_update_u64(jak_carbon_column_it *it, jak_u32 pos, jak_u64 value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}

static bool column_update_i8(jak_carbon_column_it *it, jak_u32 pos, jak_i8 value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}

static bool column_update_i16(jak_carbon_column_it *it, jak_u32 pos, jak_i16 value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}

static bool column_update_i32(jak_carbon_column_it *it, jak_u32 pos, jak_i32 value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}

static bool column_update_i64(jak_carbon_column_it *it, jak_u32 pos, jak_i64 value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}

static bool column_update_float(jak_carbon_column_it *it, jak_u32 pos, float value)
{
        JAK_UNUSED(it);
        JAK_UNUSED(pos);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED);    // TODO: Implement
        return false;
}


static inline jak_carbon_array_it *array_iterator(jak_carbon_update *updater)
{
        return &updater->path_evaluater.result.containers.array.it;
}

static inline jak_carbon_column_it *column_iterator(jak_u32 *elem_pos, jak_carbon_update *updater)
{
        *elem_pos = updater->path_evaluater.result.containers.column.elem_pos;
        return &updater->path_evaluater.result.containers.column.it;
}

#define compile_path_and_delegate(context, path, func)                                                                 \
({                                                                                                                     \
        JAK_ERROR_IF_NULL(context)                                                                                         \
        JAK_ERROR_IF_NULL(path)                                                                                            \
                                                                                                                       \
        jak_carbon_dot_path compiled_path;                                                                           \
        bool status;                                                                                                   \
        if (compile_path(&compiled_path, path)) {                                                                      \
                status = func(context, &compiled_path);                                                                \
                jak_carbon_dot_path_drop(&compiled_path);                                                                   \
        } else {                                                                                                       \
                JAK_ERROR(&context->err, JAK_ERR_DOT_PATH_PARSERR)                                                         \
                status = false;                                                                                        \
        }                                                                                                              \
        status;                                                                                                        \
})

#define compile_path_and_delegate_wargs(context, path, func, ...)                                                      \
({                                                                                                                     \
        JAK_ERROR_IF_NULL(context)                                                                                         \
        JAK_ERROR_IF_NULL(path)                                                                                            \
                                                                                                                       \
        jak_carbon_dot_path compiled_path;                                                                           \
        bool status;                                                                                                   \
        if (compile_path(&compiled_path, path)) {                                                                      \
                status = func(context, &compiled_path, __VA_ARGS__);                                                   \
                jak_carbon_dot_path_drop(&compiled_path);                                                                   \
        } else {                                                                                                       \
                JAK_ERROR(&context->err, JAK_ERR_DOT_PATH_PARSERR)                                                         \
                status = false;                                                                                        \
        }                                                                                                              \
        status;                                                                                                        \
})


bool jak_carbon_update_set_null(jak_carbon_revise *context, const char *path)
{
        return compile_path_and_delegate(context, path, jak_carbon_update_set_null_compiled);
}

bool jak_carbon_update_set_true(jak_carbon_revise *context, const char *path)
{
        return compile_path_and_delegate(context, path, jak_carbon_update_set_true_compiled);
}

bool jak_carbon_update_set_false(jak_carbon_revise *context, const char *path)
{
        return compile_path_and_delegate(context, path, jak_carbon_update_set_false_compiled);
}

bool jak_carbon_update_set_u8(jak_carbon_revise *context, const char *path, jak_u8 value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_u8_compiled, value);
}

bool jak_carbon_update_set_u16(jak_carbon_revise *context, const char *path, jak_u16 value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_u16_compiled, value);
}

bool jak_carbon_update_set_u32(jak_carbon_revise *context, const char *path, jak_u32 value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_u32_compiled, value);
}

bool jak_carbon_update_set_u64(jak_carbon_revise *context, const char *path, jak_u64 value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_u64_compiled, value);
}

bool jak_carbon_update_set_i8(jak_carbon_revise *context, const char *path, jak_i8 value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_i8_compiled, value);
}

bool jak_carbon_update_set_i16(jak_carbon_revise *context, const char *path, jak_i16 value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_i16_compiled, value);
}

bool jak_carbon_update_set_i32(jak_carbon_revise *context, const char *path, jak_i32 value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_i32_compiled, value);
}

bool jak_carbon_update_set_i64(jak_carbon_revise *context, const char *path, jak_i64 value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_i64_compiled, value);
}

bool jak_carbon_update_set_float(jak_carbon_revise *context, const char *path, float value)
{
        return compile_path_and_delegate_wargs(context, path, jak_carbon_update_set_float_compiled, value);
}

bool jak_carbon_update_set_unsigned(jak_carbon_revise *context, const char *path, jak_u64 value)
{
        switch (jak_number_min_type_unsigned(value)) {
                case JAK_NUMBER_U8:
                        return jak_carbon_update_set_u8(context, path, (jak_u8) value);
                case JAK_NUMBER_U16:
                        return jak_carbon_update_set_u16(context, path, (jak_u16) value);
                case JAK_NUMBER_U32:
                        return jak_carbon_update_set_u32(context, path, (jak_u32) value);
                case JAK_NUMBER_U64:
                        return jak_carbon_update_set_u64(context, path, (jak_u64) value);
                default: JAK_ERROR(&context->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_update_set_signed(jak_carbon_revise *context, const char *path, jak_i64 value)
{
        switch (jak_number_min_type_signed(value)) {
                case JAK_NUMBER_I8:
                        return jak_carbon_update_set_i8(context, path, (jak_i8) value);
                case JAK_NUMBER_I16:
                        return jak_carbon_update_set_i16(context, path, (jak_i16) value);
                case JAK_NUMBER_I32:
                        return jak_carbon_update_set_i32(context, path, (jak_i32) value);
                case JAK_NUMBER_I64:
                        return jak_carbon_update_set_i64(context, path, (jak_i64) value);
                default: JAK_ERROR(&context->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_update_set_string(jak_carbon_revise *context, const char *path, const char *value)
{
        // TODO: Implement
        JAK_UNUSED(context);
        JAK_UNUSED(path);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

bool jak_carbon_update_set_binary(jak_carbon_revise *context, const char *path, const void *value, size_t nbytes,
                              const char *file_ext, const char *user_type)
{
        // TODO: Implement
        JAK_UNUSED(context);
        JAK_UNUSED(value);
        JAK_UNUSED(nbytes);
        JAK_UNUSED(file_ext);
        JAK_UNUSED(user_type);
        JAK_UNUSED(path);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

jak_carbon_insert *jak_carbon_update_set_array_begin(jak_carbon_revise *context, const char *path,
                                                        jak_carbon_insert_array_state *state_out,
                                                        jak_u64 array_capacity)
{
        // TODO: Implement
        JAK_UNUSED(context);
        JAK_UNUSED(state_out);
        JAK_UNUSED(array_capacity);
        JAK_UNUSED(path);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

bool jak_carbon_update_set_array_end(jak_carbon_insert_array_state *state_in)
{
        // TODO: Implement
        JAK_UNUSED(state_in);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

jak_carbon_insert *jak_carbon_update_set_column_begin(jak_carbon_revise *context, const char *path,
                                                         jak_carbon_insert_column_state *state_out,
                                                         jak_carbon_field_type_e type, jak_u64 column_capacity)
{
        // TODO: Implement
        JAK_UNUSED(state_out);
        JAK_UNUSED(context);
        JAK_UNUSED(type);
        JAK_UNUSED(column_capacity);
        JAK_UNUSED(path);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

bool jak_carbon_update_set_column_end(jak_carbon_insert_column_state *state_in)
{
        // TODO: Implement
        JAK_UNUSED(state_in);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

// ---------------------------------------------------------------------------------------------------------------------

bool jak_carbon_update_set_null_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path)
{
        return try_update(context, path, jak_carbon_array_it_update_in_place_null, jak_carbon_column_it_update_set_null);
}

bool jak_carbon_update_set_true_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path)
{
        return try_update(context, path, jak_carbon_array_it_update_in_place_true, jak_carbon_column_it_update_set_true);
}

bool jak_carbon_update_set_false_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path)
{
        return try_update(context, path, jak_carbon_array_it_update_in_place_false, jak_carbon_column_it_update_set_false);
}

bool jak_carbon_update_set_u8_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                   jak_u8 value)
{
        return try_update_value(context, path, value, array_update_u8, column_update_u8);
}

bool jak_carbon_update_set_u16_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                    jak_u16 value)
{
        return try_update_value(context, path, value, array_update_u16, column_update_u16);
}

bool jak_carbon_update_set_u32_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                    jak_u32 value)
{
        return try_update_value(context, path, value, array_update_u32, column_update_u32);
}

bool jak_carbon_update_set_u64_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                    jak_u64 value)
{
        return try_update_value(context, path, value, array_update_u64, column_update_u64);
}

bool jak_carbon_update_set_i8_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                   jak_i8 value)
{
        return try_update_value(context, path, value, array_update_i8, column_update_i8);
}

bool jak_carbon_update_set_i16_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                    jak_i16 value)
{
        return try_update_value(context, path, value, array_update_i16, column_update_i16);
}

bool jak_carbon_update_set_i32_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                    jak_i32 value)
{
        return try_update_value(context, path, value, array_update_i32, column_update_i32);
}

bool jak_carbon_update_set_i64_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                    jak_i64 value)
{
        return try_update_value(context, path, value, array_update_i64, column_update_i64);
}

bool jak_carbon_update_set_float_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                      float value)
{
        return try_update_value(context, path, value, array_update_float, column_update_float);
}

bool jak_carbon_update_set_unsigned_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                         jak_u64 value)
{
        switch (jak_number_min_type_unsigned(value)) {
                case JAK_NUMBER_U8:
                        return jak_carbon_update_set_u8_compiled(context, path, (jak_u8) value);
                case JAK_NUMBER_U16:
                        return jak_carbon_update_set_u16_compiled(context, path, (jak_u16) value);
                case JAK_NUMBER_U32:
                        return jak_carbon_update_set_u32_compiled(context, path, (jak_u32) value);
                case JAK_NUMBER_U64:
                        return jak_carbon_update_set_u64_compiled(context, path, (jak_u64) value);
                default: JAK_ERROR(&context->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_update_set_signed_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                       jak_i64 value)
{
        switch (jak_number_min_type_signed(value)) {
                case JAK_NUMBER_I8:
                        return jak_carbon_update_set_i8_compiled(context, path, (jak_i8) value);
                case JAK_NUMBER_I16:
                        return jak_carbon_update_set_i16_compiled(context, path, (jak_i16) value);
                case JAK_NUMBER_I32:
                        return jak_carbon_update_set_i32_compiled(context, path, (jak_i32) value);
                case JAK_NUMBER_I64:
                        return jak_carbon_update_set_i64_compiled(context, path, (jak_i64) value);
                default: JAK_ERROR(&context->err, JAK_ERR_INTERNALERR);
                        return false;
        }
}

bool jak_carbon_update_set_jak_string_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                       const char *value)
{
        // TODO: Implement
        JAK_UNUSED(context);
        JAK_UNUSED(path);
        JAK_UNUSED(value);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

bool jak_carbon_update_set_binary_compiled(jak_carbon_revise *context, const jak_carbon_dot_path *path,
                                       const void *value, size_t nbytes, const char *file_ext, const char *user_type)
{
        // TODO: Implement
        JAK_UNUSED(context);
        JAK_UNUSED(value);
        JAK_UNUSED(nbytes);
        JAK_UNUSED(file_ext);
        JAK_UNUSED(user_type);
        JAK_UNUSED(path);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

jak_carbon_insert *jak_carbon_update_set_array_begin_compiled(jak_carbon_revise *context,
                                                                 const jak_carbon_dot_path *path,
                                                                 jak_carbon_insert_array_state *state_out,
                                                                 jak_u64 array_capacity)
{
        // TODO: Implement
        JAK_UNUSED(context);
        JAK_UNUSED(state_out);
        JAK_UNUSED(array_capacity);
        JAK_UNUSED(path);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

bool jak_carbon_update_set_array_end_compiled(jak_carbon_insert_array_state *state_in)
{
        // TODO: Implement
        JAK_UNUSED(state_in);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

jak_carbon_insert *jak_carbon_update_set_column_begin_compiled(jak_carbon_revise *context,
                                                                  const jak_carbon_dot_path *path,
                                                                  jak_carbon_insert_column_state *state_out,
                                                                  jak_carbon_field_type_e type,
                                                                  jak_u64 column_capacity)
{
        // TODO: Implement
        JAK_UNUSED(state_out);
        JAK_UNUSED(context);
        JAK_UNUSED(type);
        JAK_UNUSED(column_capacity);
        JAK_UNUSED(path);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

bool jak_carbon_update_set_column_end_compiled(jak_carbon_insert_column_state *state_in)
{
        // TODO: Implement
        JAK_UNUSED(state_in);
        JAK_ERROR_PRINT(JAK_ERR_NOTIMPLEMENTED)
        return false;
}

// ---------------------------------------------------------------------------------------------------------------------

#define revision_context_delegate_func(rev_doc, doc, func, ...)                                                        \
({                                                                                                                     \
        jak_carbon_revise revise;                                                                                    \
        jak_carbon_revise_begin(&revise, rev_doc, doc);                                                                     \
        bool status = func(&revise, __VA_ARGS__);                                                                      \
        jak_carbon_revise_end(&revise);                                                                                     \
        status;                                                                                                        \
})

bool carbon_update_one_set_null(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_null, dot_path);
}

bool carbon_update_one_set_true(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_true, dot_path);
}

bool carbon_update_one_set_false(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_false, dot_path);
}

bool carbon_update_one_set_u8(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_u8 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_u8, dot_path, value);
}

bool carbon_update_one_set_u16(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_u16 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_u16, dot_path, value);
}

bool carbon_update_one_set_u32(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_u32 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_u32, dot_path, value);
}

bool carbon_update_one_set_u64(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_u64 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_u64, dot_path, value);
}

bool carbon_update_one_set_i8(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_i8 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_i8, dot_path, value);
}

bool carbon_update_one_set_i16(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_i16 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_i16, dot_path, value);
}

bool carbon_update_one_set_i32(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_i32 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_i32, dot_path, value);
}

bool carbon_update_one_set_i64(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_i64 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_i64, dot_path, value);
}

bool carbon_update_one_set_float(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc,
                                 float value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_float, dot_path, value);
}

bool carbon_update_one_set_unsigned(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc,
                                    jak_u64 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_unsigned, dot_path, value);
}

bool
carbon_update_one_set_signed(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc, jak_i64 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_signed, dot_path, value);
}

bool carbon_update_one_set_string(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc,
                                  const char *value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_string, dot_path, value);
}

bool carbon_update_one_set_binary(const char *dot_path, jak_carbon *rev_doc, jak_carbon *doc,
                                  const void *value, size_t nbytes, const char *file_ext, const char *user_type)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_binary, dot_path, value, nbytes,
                                              file_ext, user_type);
}

jak_carbon_insert *carbon_update_one_set_array_begin(jak_carbon_insert_array_state *state_out,
                                                            const char *dot_path, jak_carbon *rev_doc,
                                                            jak_carbon *doc, jak_u64 array_capacity)
{
        jak_carbon_revise revise;
        jak_carbon_revise_begin(&revise, rev_doc, doc);
        jak_carbon_insert *result = jak_carbon_update_set_array_begin(&revise, dot_path, state_out, array_capacity);
        // ... TODO: add revision to context
        return result;
}

bool carbon_update_one_set_array_end(jak_carbon_insert_array_state *state_in)
{
        bool status = jak_carbon_update_set_array_end(state_in);
        // ... TODO: drop revision from context
        return status;
}

jak_carbon_insert *carbon_update_one_set_column_begin(jak_carbon_insert_column_state *state_out,
                                                             const char *dot_path, jak_carbon *rev_doc,
                                                             jak_carbon *doc, jak_carbon_field_type_e type,
                                                             jak_u64 column_capacity)
{
        jak_carbon_revise revise;
        jak_carbon_revise_begin(&revise, rev_doc, doc);
        jak_carbon_insert *result = jak_carbon_update_set_column_begin(&revise, dot_path, state_out, type,
                                                                          column_capacity);
        // ... TODO: add revision to context
        return result;
}

bool carbon_update_one_set_column_end(jak_carbon_insert_column_state *state_in)
{
        bool status = jak_carbon_update_set_column_end(state_in);
        // ... TODO: drop revision from context
        return status;
}

// ---------------------------------------------------------------------------------------------------------------------

bool carbon_update_one_set_null_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                         jak_carbon *doc)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_null_compiled, path);
}

bool carbon_update_one_set_true_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                         jak_carbon *doc)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_true_compiled, path);
}

bool carbon_update_one_set_false_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                          jak_carbon *doc)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_false_compiled, path);
}

bool carbon_update_one_set_u8_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                       jak_carbon *doc, jak_u8 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_u8_compiled, path, value);
}

bool carbon_update_one_set_u16_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                        jak_carbon *doc, jak_u16 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_u16_compiled, path, value);
}

bool carbon_update_one_set_u32_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                        jak_carbon *doc, jak_u32 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_u32_compiled, path, value);
}

bool carbon_update_one_set_u64_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                        jak_carbon *doc, jak_u64 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_u64_compiled, path, value);
}

bool carbon_update_one_set_i8_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                       jak_carbon *doc, jak_i8 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_i8_compiled, path, value);
}

bool carbon_update_one_set_i16_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                        jak_carbon *doc, jak_i16 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_i16_compiled, path, value);
}

bool carbon_update_one_set_i32_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                        jak_carbon *doc, jak_i32 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_i32_compiled, path, value);
}

bool carbon_update_one_set_i64_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                        jak_carbon *doc, jak_i64 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_i64_compiled, path, value);
}

bool carbon_update_one_set_float_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                          jak_carbon *doc, float value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_float_compiled, path, value);
}

bool carbon_update_one_set_unsigned_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                             jak_carbon *doc, jak_u64 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_unsigned_compiled, path, value);
}

bool carbon_update_one_set_signed_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                           jak_carbon *doc, jak_i64 value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_signed_compiled, path, value);
}

bool carbon_update_one_set_jak_string_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                           jak_carbon *doc, const char *value)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_jak_string_compiled, path, value);
}

bool carbon_update_one_set_binary_compiled(const jak_carbon_dot_path *path, jak_carbon *rev_doc,
                                           jak_carbon *doc, const void *value, size_t nbytes,
                                           const char *file_ext,
                                           const char *user_type)
{
        return revision_context_delegate_func(rev_doc, doc, jak_carbon_update_set_binary_compiled, path, value, nbytes,
                                              file_ext, user_type);
}

jak_carbon_insert *carbon_update_one_set_array_begin_compiled(jak_carbon_insert_array_state *state_out,
                                                                     const jak_carbon_dot_path *path,
                                                                     jak_carbon *rev_doc, jak_carbon *doc,
                                                                     jak_u64 array_capacity)
{
        jak_carbon_revise revise;
        jak_carbon_revise_begin(&revise, rev_doc, doc);
        jak_carbon_insert *result = jak_carbon_update_set_array_begin_compiled(&revise, path, state_out,
                                                                                  array_capacity);
        // ... TODO: add revision to context
        return result;
}

bool carbon_update_one_set_array_end_compiled(jak_carbon_insert_array_state *state_in)
{
        bool status = jak_carbon_update_set_array_end_compiled(state_in);
        // ... TODO: drop revision from context
        return status;
}

jak_carbon_insert *carbon_update_one_set_column_begin_compiled(
        jak_carbon_insert_column_state *state_out, const jak_carbon_dot_path *path,
        jak_carbon *rev_doc,
        jak_carbon *doc, jak_carbon_field_type_e type, jak_u64 column_capacity)
{
        jak_carbon_revise revise;
        jak_carbon_revise_begin(&revise, rev_doc, doc);
        jak_carbon_insert *result = jak_carbon_update_set_column_begin_compiled(&revise, path, state_out, type,
                                                                                   column_capacity);
        // ... TODO: add revision to context
        return result;
}

bool carbon_update_one_set_column_end_compiled(jak_carbon_insert_column_state *state_in)
{
        bool status = jak_carbon_update_set_column_end_compiled(state_in);
        // ... TODO: drop revision from context
        return status;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>
#include <inttypes.h>

#include <jak_column_doc.h>
#include <jak_doc.h>

static void
setup_object(jak_column_doc_obj *model, jak_column_doc *parent, jak_archive_field_sid_t key, size_t idx);

static bool object_put(jak_column_doc_obj *model, jak_error *err, const jak_doc_entries *entry,
                       jak_string_dict *dic);

static bool import_object(jak_column_doc_obj *dst, jak_error *err, const jak_doc_obj *doc,
                          jak_string_dict *dic);

static bool
_jak_column_doc_print_object(FILE *file, jak_error *err, const jak_column_doc_obj *object, jak_string_dict *dic);

static const char *get_type_name(jak_error *err, jak_archive_field_e type);

static void object_array_key_columns_create(jak_vector ofType(jak_column_doc_group) *columns);

static jak_column_doc_column *object_array_key_columns_find_or_new(
        jak_vector ofType(jak_column_doc_group) *columns, jak_archive_field_sid_t array_key,
        jak_archive_field_sid_t nested_object_entry_key, jak_archive_field_e nested_object_entry_type);

static bool object_array_key_column_push(jak_column_doc_column *col, jak_error *err,
                                         const jak_doc_entries *entry,
                                         jak_u32 array_idx, jak_string_dict *dic,
                                         jak_column_doc_obj *model);

bool jak_columndoc_create(jak_column_doc *columndoc, jak_error *err, const jak_doc *doc,
                      const jak_doc_bulk *bulk,
                      const jak_doc_entries *entries, jak_string_dict *dic)
{
        JAK_ERROR_IF_NULL(columndoc)
        JAK_ERROR_IF_NULL(doc)
        JAK_ERROR_IF_NULL(dic)
        JAK_ERROR_IF_NULL(bulk)

        columndoc->dic = dic;
        columndoc->doc = doc;
        columndoc->bulk = bulk;
        jak_error_init(&columndoc->err);

        const char *root_string = "/";
        jak_archive_field_sid_t *rootId;

        jak_string_dict_insert(dic, &rootId, (char *const *) &root_string, 1, 0);

        setup_object(&columndoc->columndoc, columndoc, *rootId, 0);

        jak_string_dict_free(dic, rootId);

        const jak_doc_obj *root = jak_doc_entries_get_root(entries);
        if (!import_object(&columndoc->columndoc, err, root, dic)) {
                return false;
        }

        return true;
}

static void object_array_key_columns_drop(jak_vector ofType(jak_column_doc_group) *columns);

static void object_meta_model_free(jak_column_doc_obj *columndoc)
{
        jak_vector_drop(&columndoc->bool_prop_keys);
        jak_vector_drop(&columndoc->int8_prop_keys);
        jak_vector_drop(&columndoc->int16_prop_keys);
        jak_vector_drop(&columndoc->int32_prop_keys);
        jak_vector_drop(&columndoc->int64_prop_keys);
        jak_vector_drop(&columndoc->uint8_prop_keys);
        jak_vector_drop(&columndoc->uint16_prop_keys);
        jak_vector_drop(&columndoc->uin32_prop_keys);
        jak_vector_drop(&columndoc->uint64_prop_keys);
        jak_vector_drop(&columndoc->jak_string_prop_keys);
        jak_vector_drop(&columndoc->float_prop_keys);
        jak_vector_drop(&columndoc->null_prop_keys);
        jak_vector_drop(&columndoc->obj_prop_keys);

        jak_vector_drop(&columndoc->bool_array_prop_keys);
        jak_vector_drop(&columndoc->int8_array_prop_keys);
        jak_vector_drop(&columndoc->int16_array_prop_keys);
        jak_vector_drop(&columndoc->int32_array_prop_keys);
        jak_vector_drop(&columndoc->int64_array_prop_keys);
        jak_vector_drop(&columndoc->uint8_array_prop_keys);
        jak_vector_drop(&columndoc->uint16_array_prop_keys);
        jak_vector_drop(&columndoc->uint32_array_prop_keys);
        jak_vector_drop(&columndoc->uint64_array_prop_keys);
        jak_vector_drop(&columndoc->jak_string_array_prop_keys);
        jak_vector_drop(&columndoc->float_array_prop_keys);
        jak_vector_drop(&columndoc->null_array_prop_keys);

        jak_vector_drop(&columndoc->bool_prop_vals);
        jak_vector_drop(&columndoc->int8_prop_vals);
        jak_vector_drop(&columndoc->int16_prop_vals);
        jak_vector_drop(&columndoc->int32_prop_vals);
        jak_vector_drop(&columndoc->int64_prop_vals);
        jak_vector_drop(&columndoc->uint8_prop_vals);
        jak_vector_drop(&columndoc->uint16_prop_vals);
        jak_vector_drop(&columndoc->uint32_prop_vals);
        jak_vector_drop(&columndoc->uint64_prop_vals);
        jak_vector_drop(&columndoc->float_prop_vals);
        jak_vector_drop(&columndoc->jak_string_prop_vals);

        for (size_t i = 0; i < columndoc->bool_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->bool_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->bool_array_prop_vals);

        for (size_t i = 0; i < columndoc->int8_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->int8_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->int8_array_prop_vals);

        for (size_t i = 0; i < columndoc->int16_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->int16_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->int16_array_prop_vals);

        for (size_t i = 0; i < columndoc->int32_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->int32_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->int32_array_prop_vals);

        for (size_t i = 0; i < columndoc->int64_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->int64_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->int64_array_prop_vals);

        for (size_t i = 0; i < columndoc->uint8_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->uint8_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->uint8_array_prop_vals);

        for (size_t i = 0; i < columndoc->uint16_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->uint16_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->uint16_array_prop_vals);

        for (size_t i = 0; i < columndoc->uint32_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->uint32_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->uint32_array_prop_vals);

        for (size_t i = 0; i < columndoc->ui64_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->ui64_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->ui64_array_prop_vals);

        for (size_t i = 0; i < columndoc->float_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->float_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->float_array_prop_vals);

        for (size_t i = 0; i < columndoc->jak_string_array_prop_vals.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->jak_string_array_prop_vals, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->jak_string_array_prop_vals);

        jak_vector_drop(&columndoc->null_array_prop_vals);

        jak_vector_drop(&columndoc->bool_val_idxs);
        jak_vector_drop(&columndoc->int8_val_idxs);
        jak_vector_drop(&columndoc->int16_val_idxs);
        jak_vector_drop(&columndoc->int32_val_idxs);
        jak_vector_drop(&columndoc->int64_val_idxs);
        jak_vector_drop(&columndoc->uint8_val_idxs);
        jak_vector_drop(&columndoc->uint16_val_idxs);
        jak_vector_drop(&columndoc->uint32_val_idxs);
        jak_vector_drop(&columndoc->uint64_val_idxs);
        jak_vector_drop(&columndoc->float_val_idxs);
        jak_vector_drop(&columndoc->jak_string_val_idxs);

        for (size_t i = 0; i < columndoc->bool_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->bool_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->bool_array_idxs);

        for (size_t i = 0; i < columndoc->int8_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->int8_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->int8_array_idxs);

        for (size_t i = 0; i < columndoc->int16_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->int16_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->int16_array_idxs);

        for (size_t i = 0; i < columndoc->int32_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->int32_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->int32_array_idxs);

        for (size_t i = 0; i < columndoc->int64_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->int64_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->int64_array_idxs);

        for (size_t i = 0; i < columndoc->uint8_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->uint8_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->uint8_array_idxs);

        for (size_t i = 0; i < columndoc->uint16_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->uint16_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->uint16_array_idxs);

        for (size_t i = 0; i < columndoc->uint32_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->uint32_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->uint32_array_idxs);

        for (size_t i = 0; i < columndoc->uint64_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->uint64_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->uint64_array_idxs);

        for (size_t i = 0; i < columndoc->float_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->float_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->float_array_idxs);

        for (size_t i = 0; i < columndoc->jak_string_array_idxs.num_elems; i++) {
                jak_vector *vec = JAK_VECTOR_GET(&columndoc->jak_string_array_idxs, i, jak_vector);
                jak_vector_drop(vec);
        }
        jak_vector_drop(&columndoc->jak_string_array_idxs);

        for (size_t i = 0; i < columndoc->obj_prop_vals.num_elems; i++) {
                jak_column_doc_obj *object = JAK_VECTOR_GET(&columndoc->obj_prop_vals, i, jak_column_doc_obj);
                object_meta_model_free(object);
        }
        jak_vector_drop(&columndoc->obj_prop_vals);

        object_array_key_columns_drop(&columndoc->obj_array_props);
}

bool jak_columndoc_free(jak_column_doc *doc)
{
        JAK_ERROR_IF_NULL(doc);
        object_meta_model_free(&doc->columndoc);
        return true;
}

#define PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, suffix)                                             \
{                                                                                                                      \
    fprintf(file, "\"%s\": { ", type_name);                                                                            \
    if(!jak_vector_is_empty((key_vector))) {                                                                           \
        fprintf(file, "\"Keys\": [ ");                                                                                 \
        for (size_t i = 0; i < (key_vector)->num_elems; i++) {                                                         \
            jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((key_vector), i, jak_archive_field_sid_t);                    \
            fprintf(file, "%"PRIu64"%s", jak_string_id, i + 1 < (key_vector)->num_elems ? ", " : "");                      \
        }                                                                                                              \
        fprintf(file, "], ");                                                                                          \
        fprintf(file, "\"Keys Decoded\": [ ");                                                                         \
        for (size_t i = 0; i < (key_vector)->num_elems; i++) {                                                         \
            jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((key_vector), i, jak_archive_field_sid_t);                    \
            char **encString = jak_string_dict_extract(dic, &jak_string_id, 1);                                              \
            fprintf(file, "\"%s\"%s", encString[0], i + 1 < (key_vector)->num_elems ? ", " : "");                      \
            jak_string_dict_free(dic, encString);                                                                        \
        }                                                                                                              \
        fprintf(file, "]%s", suffix);                                                                                  \
    }                                                                                                                  \
}                                                                                                                      \

#define PRINT_PRIMITIVE_COLUMN(file, type_name, key_vector, value_vector, keyIndicesVector, dic, TYPE, FORMAT_STR)     \
{                                                                                                                      \
    PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, ", ")                                                   \
    if(!jak_vector_is_empty((key_vector))) {                                                                           \
        fprintf(file, "\"Values\": [ ");                                                                               \
        for (size_t i = 0; i < (value_vector)->num_elems; i++) {                                                       \
            TYPE value = *JAK_VECTOR_GET(value_vector, i, TYPE);                                                    \
            fprintf(file, FORMAT_STR "%s", value, i + 1 < (value_vector)->num_elems ? ", " : "");                      \
        }                                                                                                              \
        fprintf(file, "] ");                                                                                           \
    }                                                                                                                  \
    fprintf(file, "}, ");                                                                                              \
}

#define PRINT_PRIMITIVE_BOOLEAN_COLUMN(file, type_name, key_vector, value_vector, dic)                                 \
{                                                                                                                      \
    PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, ", ")                                                   \
    if(!jak_vector_is_empty((key_vector))) {                                                                           \
        fprintf(file, "\"Values\": [ ");                                                                               \
        for (size_t i = 0; i < (value_vector)->num_elems; i++) {                                                       \
            jak_archive_field_boolean_t value = *JAK_VECTOR_GET(value_vector, i, jak_archive_field_boolean_t);                                  \
            fprintf(file, "%s%s", value == 0 ? "false" : "true", i + 1 < (value_vector)->num_elems ? ", " : "");       \
        }                                                                                                              \
        fprintf(file, "]");                                                                                            \
    }                                                                                                                  \
    fprintf(file, "}, ");                                                                                              \
}

static void print_primitive_null(FILE *file, const char *type_name,
                                 const jak_vector ofType(jak_archive_field_sid_t) *key_vector,
                                 jak_string_dict *dic)
{
        PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, "")
        fprintf(file, "}, ");
}

static bool print_primitive_objects(FILE *file, jak_error *err, const char *type_name,
                                    const jak_vector ofType(jak_archive_field_sid_t) *key_vector,
                                    const jak_vector ofType(jak_column_doc_obj) *value_vector,
                                    jak_string_dict *dic)
{
        PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, ", ")
        if (!jak_vector_is_empty((key_vector))) {
                fprintf(file, "\"Values\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        const jak_column_doc_obj *object = JAK_VECTOR_GET(value_vector, i, jak_column_doc_obj);
                        if (!_jak_column_doc_print_object(file, err, object, dic)) {
                                return false;
                        }
                        fprintf(file, "%s", i + 1 < (value_vector)->num_elems ? ", " : "");
                }
                fprintf(file, "]");
        }
        fprintf(file, "}");
        return true;
}

#define PRINT_ARRAY(file, type_name, key_vector, value_vector, TYPE, TYPE_FORMAT, nonnull_expr)                        \
{                                                                                                                      \
    fprintf(file, "\"%s\": { ", type_name);                                                                            \
    if(!jak_vector_is_empty((&key_vector))) {                                                                          \
        fprintf(file, "\"Keys\": [ ");                                                                                 \
        for (size_t i = 0; i < (&key_vector)->num_elems; i++) {                                                        \
            jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((&key_vector), i, jak_archive_field_sid_t);                   \
            fprintf(file, "%"PRIu64"%s", jak_string_id, i + 1 < (&key_vector)->num_elems ? ", " : "");                     \
        }                                                                                                              \
        fprintf(file, "], ");                                                                                          \
        fprintf(file, "\"Keys Decoded\": [ ");                                                                         \
        for (size_t i = 0; i < (&key_vector)->num_elems; i++) {                                                        \
            jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((&key_vector), i, jak_archive_field_sid_t);                   \
            char **encString = jak_string_dict_extract(dic, &jak_string_id, 1);                                              \
            fprintf(file, "\"%s\"%s", encString[0], i + 1 < (&key_vector)->num_elems ? ", " : "");                     \
            jak_string_dict_free(dic, encString);                                                                        \
        }                                                                                                              \
        fprintf(file, "],");                                                                                           \
        fprintf(file, "\"Values\": [ ");                                                                               \
        for (size_t i = 0; i < (&value_vector)->num_elems; i++) {                                                      \
            const jak_vector ofType(TYPE) *values = JAK_VECTOR_GET(&value_vector, i, jak_vector);               \
            fprintf(file, "[ ");                                                                                       \
            for (size_t j = 0; j < values->num_elems; j++) {                                                           \
                TYPE value = *JAK_VECTOR_GET(values, j, TYPE);                                                      \
                if (nonnull_expr) {                                                                                    \
                    fprintf(file, "" TYPE_FORMAT "%s", value, j + 1 < values->num_elems ? ", " : "");                  \
                } else {                                                                                               \
                    fprintf(file, JAK_NULL_TEXT "%s", j + 1 < values->num_elems ? ", " : "");                       \
                }                                                                                                      \
            }                                                                                                          \
            fprintf(file, "]%s ", i + 1 < (&value_vector)->num_elems ? "," : "");                                      \
        }                                                                                                              \
        fprintf(file, "]");                                                                                            \
    }                                                                                                                  \
    fprintf(file, "}, ");                                                                                              \
}

#define PRINT_BOOLEAN_ARRAY(file, type_name, key_vector, value_vector)                                                 \
{                                                                                                                      \
    fprintf(file, "\"%s\": { ", "Boolean");                                                                            \
    if(!jak_vector_is_empty((&key_vector))) {                                                                          \
        fprintf(file, "\"Keys\": [ ");                                                                                 \
        for (size_t i = 0; i < (&key_vector)->num_elems; i++) {                                                        \
            jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((&key_vector), i, jak_archive_field_sid_t);                   \
            fprintf(file, "%"PRIu64"%s", jak_string_id, i + 1 < (&key_vector)->num_elems ? ", " : "");                     \
        }                                                                                                              \
        fprintf(file, "], ");                                                                                          \
        fprintf(file, "\"Keys Decoded\": [ ");                                                                         \
        for (size_t i = 0; i < (&key_vector)->num_elems; i++) {                                                        \
            jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((&key_vector), i, jak_archive_field_sid_t);                   \
            char **encString = jak_string_dict_extract(dic, &jak_string_id, 1);                                              \
            fprintf(file, "\"%s\"%s", encString[0], i + 1 < (&key_vector)->num_elems ? ", " : "");                     \
            jak_string_dict_free(dic, encString);                                                                        \
        }                                                                                                              \
        fprintf(file, "],");                                                                                           \
        fprintf(file, "\"Values\": [ ");                                                                               \
        for (size_t i = 0; i < (&value_vector)->num_elems; i++) {                                                      \
            const jak_vector ofType(jak_archive_field_boolean_t) *values = JAK_VECTOR_GET(&value_vector, i, jak_vector);      \
            fprintf(file, "[ ");                                                                                       \
            for (size_t j = 0; j < values->num_elems; j++) {                                                           \
                jak_archive_field_boolean_t value = *JAK_VECTOR_GET(values, j, jak_archive_field_boolean_t);                                    \
                fprintf(file, "%s%s", value == 0 ? "false" : "true", j + 1 < values->num_elems ? ", " : "");           \
            }                                                                                                          \
            fprintf(file, "]%s ", i + 1 < (&value_vector)->num_elems ? "," : "");                                      \
        }                                                                                                              \
        fprintf(file, "]");                                                                                            \
    }                                                                                                                  \
    fprintf(file, "}, ");                                                                                              \
}

static void
print_array_null(FILE *file, const char *type_name, const jak_vector ofType(jak_archive_field_sid_t) *key_vector,
                 const jak_vector ofType(jak_u16) *value_vector, jak_string_dict *dic)
{
        fprintf(file, "\"%s\": { ", type_name);
        if (!jak_vector_is_empty((key_vector))) {
                fprintf(file, "\"Keys\": [ ");
                for (size_t i = 0; i < (key_vector)->num_elems; i++) {
                        jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((key_vector), i, jak_archive_field_sid_t);
                        fprintf(file, "%"PRIu64"%s", jak_string_id, i + 1 < (key_vector)->num_elems ? ", " : "");
                }
                fprintf(file, "], ");
                fprintf(file, "\"Keys Decoded\": [ ");
                for (size_t i = 0; i < (key_vector)->num_elems; i++) {
                        jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((key_vector), i, jak_archive_field_sid_t);
                        char **encString = jak_string_dict_extract(dic, &jak_string_id, 1);
                        fprintf(file, "\"%s\"%s", encString[0], i + 1 < (key_vector)->num_elems ? ", " : "");
                        jak_string_dict_free(dic, encString);
                }
                fprintf(file, "],");
                fprintf(file, "\"Values\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        jak_u16 amount = *JAK_VECTOR_GET(value_vector, i, jak_u16);
                        fprintf(file, "%d%s", amount, i + 1 < value_vector->num_elems ? ", " : "");
                }
                fprintf(file, "]");
        }
        fprintf(file, "}, ");
}

static void print_array_strings(FILE *file, const char *type_name,
                                const jak_vector ofType(jak_archive_field_sid_t) *key_vector,
                                const jak_vector ofType(Vector
                                                                       ofType(jak_archive_field_sid_t)) *value_vector,
                                jak_string_dict *dic)
{
        fprintf(file, "\"%s\": { ", type_name);
        if (!jak_vector_is_empty((key_vector))) {
                fprintf(file, "\"Keys\": [ ");
                for (size_t i = 0; i < (key_vector)->num_elems; i++) {
                        jak_archive_field_sid_t jak_string_id = *JAK_VECTOR_GET((key_vector), i, jak_archive_field_sid_t);
                        fprintf(file, "%"PRIu64"%s", jak_string_id, i + 1 < (key_vector)->num_elems ? ", " : "");
                }
                fprintf(file, "], ");
                fprintf(file, "\"Keys Decoded\": [ ");
                for (size_t i = 0; i < (key_vector)->num_elems; i++) {
                        jak_archive_field_sid_t jak_string_id_t = *JAK_VECTOR_GET((key_vector), i, jak_archive_field_sid_t);
                        char **encString = jak_string_dict_extract(dic, &jak_string_id_t, 1);
                        fprintf(file, "\"%s\"%s", encString[0], i + 1 < (key_vector)->num_elems ? ", " : "");
                        jak_string_dict_free(dic, encString);
                }
                fprintf(file, "],");
                fprintf(file, "\"Values\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        const jak_vector ofType(jak_archive_field_sid_t) *values = JAK_VECTOR_GET(value_vector, i,
                                                                                                  jak_vector);
                        fprintf(file, "[");
                        for (size_t j = 0; j < values->num_elems; j++) {
                                jak_archive_field_sid_t value = *JAK_VECTOR_GET(values, j, jak_archive_field_sid_t);
                                fprintf(file, "%"PRIu64"%s", value, j + 1 < values->num_elems ? ", " : "");
                        }
                        fprintf(file, "]%s", i + 1 < (value_vector)->num_elems ? ", " : "");

                }
                fprintf(file, "], ");
                fprintf(file, "\"Values Decoded\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        const jak_vector ofType(jak_archive_field_sid_t) *values = JAK_VECTOR_GET(value_vector, i,
                                                                                                  jak_vector);
                        fprintf(file, "[");
                        for (size_t j = 0; j < values->num_elems; j++) {
                                jak_archive_field_sid_t value = *JAK_VECTOR_GET(values, j, jak_archive_field_sid_t);

                                if (JAK_LIKELY(value != JAK_NULL_ENCODED_STRING)) {
                                        char **decoded = jak_string_dict_extract(dic, &value, 1);
                                        fprintf(file, "\"%s\"%s", *decoded, j + 1 < values->num_elems ? ", " : "");
                                        jak_string_dict_free(dic, decoded);
                                } else {
                                        fprintf(file, "null%s", j + 1 < values->num_elems ? ", " : "");
                                }

                        }
                        fprintf(file, "]%s", i + 1 < (value_vector)->num_elems ? ", " : "");

                }
                fprintf(file, "]");
        }
        fprintf(file, "}, ");
}

static void print_primitive_strings(FILE *file, const char *type_name,
                                    const jak_vector ofType(jak_archive_field_sid_t) *key_vector,
                                    const jak_vector ofType(jak_archive_field_sid_t) *value_vector,
                                    jak_string_dict *dic)
{
        PRINT_PRIMITIVE_KEY_PART(file, type_name, key_vector, dic, ", ")
        if (!jak_vector_is_empty((key_vector))) {
                fprintf(file, "\"Values\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        jak_archive_field_sid_t jak_string_id_t = *JAK_VECTOR_GET(value_vector, i, jak_archive_field_sid_t);
                        fprintf(file, "%"PRIu64"%s", jak_string_id_t, i + 1 < (value_vector)->num_elems ? ", " : "");
                }
                fprintf(file, "], ");
                fprintf(file, "\"Values Decoded\": [ ");
                for (size_t i = 0; i < (value_vector)->num_elems; i++) {
                        jak_archive_field_sid_t jak_string_id_t = *JAK_VECTOR_GET(value_vector, i, jak_archive_field_sid_t);
                        char **values = jak_string_dict_extract(dic, &jak_string_id_t, 1);
                        fprintf(file, "\"%s\"%s", *values, i + 1 < (value_vector)->num_elems ? ", " : "");
                        jak_string_dict_free(dic, values);
                }
                fprintf(file, "]");
        }
        fprintf(file, "}, ");

}

#define PRINT_COLUMN(file, columnTable, array_idx, type, format_string)                                                \
{                                                                                                                      \
    const jak_vector *column = JAK_VECTOR_GET(&columnTable->values, array_idx, jak_vector);                     \
    fprintf(file, "%s", column->num_elems > 1 ? "[" : "");                                                             \
    for (size_t i = 0; i < column->num_elems; i++) {                                                                   \
        fprintf(file, format_string, *JAK_VECTOR_GET(column, i, type));                                             \
        fprintf(file, "%s", i + 1 < column->num_elems ? ", " : "");                                                    \
    }                                                                                                                  \
    fprintf(file, "%s", column->num_elems > 1 ? "]" : "");                                                             \
}

static bool print_array_objects(FILE *file, jak_error *err, const char *type_name,
                                const jak_vector ofType(jak_column_doc_group) *key_columns,
                                jak_string_dict *dic)
{
        fprintf(file, "\"%s\": {", type_name);
        fprintf(file, "\"Keys\": [");
        for (size_t array_key_idx = 0; array_key_idx < key_columns->num_elems; array_key_idx++) {
                const jak_column_doc_group
                        *arrayKeyColumns = JAK_VECTOR_GET(key_columns, array_key_idx, jak_column_doc_group);
                fprintf(file,
                        "%"PRIu64"%s",
                        arrayKeyColumns->key,
                        array_key_idx + 1 < key_columns->num_elems ? ", " : "");
        }
        fprintf(file, "], \"Keys Decoded\": [");
        for (size_t array_key_idx = 0; array_key_idx < key_columns->num_elems; array_key_idx++) {
                const jak_column_doc_group
                        *arrayKeyColumns = JAK_VECTOR_GET(key_columns, array_key_idx, jak_column_doc_group);
                jak_archive_field_sid_t encKeyName = arrayKeyColumns->key;
                char **decKeyName = jak_string_dict_extract(dic, &encKeyName, 1);
                fprintf(file, "\"%s\"%s", *decKeyName, array_key_idx + 1 < key_columns->num_elems ? ", " : "");
                jak_string_dict_free(dic, decKeyName);
        }
        fprintf(file, "], ");
        fprintf(file, "\"Tables\": [");
        for (size_t array_key_idx = 0; array_key_idx < key_columns->num_elems; array_key_idx++) {
                fprintf(file, "[");
                const jak_column_doc_group
                        *arrayKeyColumns = JAK_VECTOR_GET(key_columns, array_key_idx, jak_column_doc_group);
                for (size_t columnIdx = 0; columnIdx < arrayKeyColumns->columns.num_elems; columnIdx++) {
                        fprintf(file, "{");
                        const jak_column_doc_column
                                *columnTable = JAK_VECTOR_GET(&arrayKeyColumns->columns, columnIdx,
                                                       jak_column_doc_column);
                        char **decColumnKeyName = jak_string_dict_extract(dic, &columnTable->key_name, 1);

                        const char *column_type_name = get_type_name(err, columnTable->type);
                        if (!column_type_name) {
                                return false;
                        }

                        fprintf(file,
                                "\"Column Name\": %"PRIu64", "
                                "\"Column Name Decoded\": \"%s\", "
                                "\"Unique Column Name Decoded\": \"{'%s'}$%s\", "
                                "\"Type\": \"%s\",",
                                columnTable->key_name,
                                *decColumnKeyName,
                                *decColumnKeyName,
                                column_type_name,
                                column_type_name);

                        fprintf(file, "\"Values\": [");
                        for (size_t array_idx = 0; array_idx < columnTable->values.num_elems; array_idx++) {
                                switch (columnTable->type) {
                                        case JAK_FIELD_NULL: {
                                                const jak_vector
                                                        *column = JAK_VECTOR_GET(&columnTable->values, array_idx,
                                                                          jak_vector);
                                                fprintf(file, "%s", column->num_elems > 1 ? "[" : "");
                                                for (size_t i = 0; i < column->num_elems; i++) {
                                                        fprintf(file, "null");
                                                        fprintf(file, "%s", i + 1 < column->num_elems ? ", " : "");
                                                }
                                                fprintf(file, "%s", column->num_elems > 1 ? "]" : "");
                                        }
                                                break;
                                        case JAK_FIELD_INT8: PRINT_COLUMN(file, columnTable, array_idx,
                                                                          jak_archive_field_i8_t, "%d")
                                                break;
                                        case JAK_FIELD_INT16: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           jak_archive_field_i16_t, "%d")
                                                break;
                                        case JAK_FIELD_INT32: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           jak_archive_field_i32_t, "%d")
                                                break;
                                        case JAK_FIELD_INT64: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           jak_archive_field_i64_t, "%"
                                                                                   PRIi64)
                                                break;
                                        case JAK_FIELD_UINT8: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           jak_archive_field_u8_t, "%d")
                                                break;
                                        case JAK_FIELD_UINT16: PRINT_COLUMN(file, columnTable, array_idx,
                                                                            jak_archive_field_u16_t, "%d")
                                                break;
                                        case JAK_FIELD_UINT32: PRINT_COLUMN(file, columnTable, array_idx,
                                                                            jak_archive_field_u32_t, "%d")
                                                break;
                                        case JAK_FIELD_UINT64: PRINT_COLUMN(file, columnTable, array_idx,
                                                                            jak_archive_field_u64_t, "%"
                                                                                    PRIu64)
                                                break;
                                        case JAK_FIELD_FLOAT: PRINT_COLUMN(file, columnTable, array_idx,
                                                                           jak_archive_field_number_t,
                                                                           "%f")
                                                break;
                                        case JAK_FIELD_STRING: {
                                                const jak_vector
                                                        *column = JAK_VECTOR_GET(&columnTable->values, array_idx,
                                                                          jak_vector);
                                                fprintf(file, "%s", column->num_elems > 1 ? "[" : "");
                                                for (size_t i = 0; i < column->num_elems; i++) {
                                                        jak_archive_field_sid_t encodedString = *JAK_VECTOR_GET(column, i,
                                                                                                         jak_archive_field_sid_t);
                                                        char **decodedString = jak_string_dict_extract(dic, &encodedString, 1);
                                                        fprintf(file,
                                                                "{\"Encoded\": %"PRIu64", \"Decoded\": \"%s\"}",
                                                                encodedString,
                                                                *decodedString);
                                                        fprintf(file, "%s", i + 1 < column->num_elems ? ", " : "");
                                                        jak_string_dict_free(dic, decodedString);
                                                }
                                                fprintf(file, "%s", column->num_elems > 1 ? "]" : "");
                                        }
                                                break;
                                        case JAK_FIELD_OBJECT: {
                                                // jak_column_doc_obj *doc = JAK_VECTOR_GET(&column->values, valueIdx, jak_column_doc_obj);
                                                //  _jak_column_doc_print_object(file, doc, encode);
                                                const jak_vector
                                                        *column = JAK_VECTOR_GET(&columnTable->values, array_idx,
                                                                          jak_vector);
                                                fprintf(file, "%s", column->num_elems > 1 ? "[" : "");
                                                for (size_t i = 0; i < column->num_elems; i++) {
                                                        const jak_column_doc_obj
                                                                *object = JAK_VECTOR_GET(column, i, jak_column_doc_obj);
                                                        if (!_jak_column_doc_print_object(file, err, object, dic)) {
                                                                return false;
                                                        }
                                                        fprintf(file, "%s", i + 1 < column->num_elems ? ", " : "");
                                                }
                                                fprintf(file, "%s", column->num_elems > 1 ? "]" : "");
                                        }
                                                break;
                                        default: JAK_ERROR(err, JAK_ERR_NOTYPE)
                                                return false;
                                }
                                fprintf(file, array_idx + 1 < columnTable->values.num_elems ? ", " : "");
                        }
                        fprintf(file, "],");
                        fprintf(file, "\"Positions\": [");
                        for (size_t positionIdx = 0; positionIdx < columnTable->array_positions.num_elems;
                             positionIdx++) {
                                fprintf(file,
                                        "%d%s",
                                        *JAK_VECTOR_GET(&columnTable->array_positions, positionIdx, jak_i16),
                                        (positionIdx + 1 < columnTable->array_positions.num_elems ? ", " : ""));
                        }
                        fprintf(file, "]");
                        jak_string_dict_free(dic, decColumnKeyName);
                        fprintf(file, "}%s", columnIdx + 1 < arrayKeyColumns->columns.num_elems ? ", " : "");
                }
                fprintf(file, "]%s", array_key_idx + 1 < key_columns->num_elems ? ", " : "");
        }
        fprintf(file, "]");

        fprintf(file, "}");
        return true;
}

static bool
_jak_column_doc_print_object(FILE *file, jak_error *err, const jak_column_doc_obj *object, jak_string_dict *dic)
{
        char **parentKey = jak_string_dict_extract(dic, &object->parent_key, 1);
        fprintf(file, "{ ");
        fprintf(file,
                "\"Parent\": { \"Key\": %"PRIu64", \"Key Decoded\": \"%s\", \"Index\": %zu }, ",
                object->parent_key,
                parentKey[0],
                object->index);
        fprintf(file, "\"Pairs\": { ");
        fprintf(file, "\"Primitives\": { ");
        PRINT_PRIMITIVE_BOOLEAN_COLUMN(file, "Boolean", &object->bool_prop_keys, &object->bool_prop_vals, dic)
        PRINT_PRIMITIVE_COLUMN(file,
                               "UInt8",
                               &object->uint8_prop_keys,
                               &object->uint8_prop_vals,
                               &object->uint8_val_idxs,
                               dic,
                               jak_archive_field_u8_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "UInt16",
                               &object->uint16_prop_keys,
                               &object->uint16_prop_vals,
                               &object->uint16_val_idxs,
                               dic,
                               jak_archive_field_u16_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "UInt32",
                               &object->uin32_prop_keys,
                               &object->uint32_prop_vals,
                               &object->uint32_val_idxs,
                               dic,
                               jak_archive_field_u32_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "UInt64",
                               &object->uint64_prop_keys,
                               &object->uint64_prop_vals,
                               &object->uint64_val_idxs,
                               dic,
                               jak_archive_field_u64_t,
                               "%"
                                       PRIu64)
        PRINT_PRIMITIVE_COLUMN(file,
                               "Int8",
                               &object->int8_prop_keys,
                               &object->int8_prop_vals,
                               &object->int8_val_idxs,
                               dic,
                               jak_archive_field_i8_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "Int16",
                               &object->int16_prop_keys,
                               &object->int16_prop_vals,
                               &object->int16_val_idxs,
                               dic,
                               jak_archive_field_i16_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "Int32",
                               &object->int32_prop_keys,
                               &object->int32_prop_vals,
                               &object->int32_val_idxs,
                               dic,
                               jak_archive_field_i32_t,
                               "%d")
        PRINT_PRIMITIVE_COLUMN(file,
                               "Int64",
                               &object->int64_prop_keys,
                               &object->int64_prop_vals,
                               &object->int64_val_idxs,
                               dic,
                               jak_archive_field_i64_t,
                               "%"
                                       PRIi64)
        PRINT_PRIMITIVE_COLUMN(file,
                               "Real",
                               &object->float_prop_keys,
                               &object->float_prop_vals,
                               &object->float_val_idxs,
                               dic,
                               jak_archive_field_number_t,
                               "%f")
        print_primitive_strings(file, "Strings", &object->jak_string_prop_keys, &object->jak_string_prop_vals, dic);
        print_primitive_null(file, "Null", &object->null_prop_keys, dic);
        if (print_primitive_objects(file, err, "Objects", &object->obj_prop_keys, &object->obj_prop_vals, dic)) {
                return false;
        }
        fprintf(file, "}, ");
        fprintf(file, "\"Arrays\": { ");
        PRINT_BOOLEAN_ARRAY(file, "Boolean", object->bool_array_prop_keys, object->bool_array_prop_vals);
        PRINT_ARRAY(file,
                    "UInt8",
                    object->uint8_array_prop_keys,
                    object->uint8_array_prop_vals,
                    jak_archive_field_u8_t,
                    "%d",
                    (value != JAK_NULL_UINT8));
        PRINT_ARRAY(file,
                    "UInt16",
                    object->uint16_array_prop_keys,
                    object->uint16_array_prop_vals,
                    jak_archive_field_u16_t,
                    "%d",
                    (value != JAK_NULL_UINT16));
        PRINT_ARRAY(file,
                    "UInt32",
                    object->uint32_array_prop_keys,
                    object->uint32_array_prop_vals,
                    jak_archive_field_u32_t,
                    "%d",
                    (value != JAK_NULL_UINT32));
        PRINT_ARRAY(file, "UInt64", object->uint64_array_prop_keys, object->ui64_array_prop_vals,
                    jak_archive_field_u64_t, "%"
                            PRIu64, (value != JAK_NULL_UINT64));
        PRINT_ARRAY(file,
                    "Int8",
                    object->int8_array_prop_keys,
                    object->int8_array_prop_vals,
                    jak_archive_field_i8_t,
                    "%d",
                    (value != JAK_NULL_INT8));
        PRINT_ARRAY(file,
                    "Int16",
                    object->int16_array_prop_keys,
                    object->int16_array_prop_vals,
                    jak_archive_field_i16_t,
                    "%d",
                    (value != JAK_NULL_INT16));
        PRINT_ARRAY(file,
                    "Int32",
                    object->int32_array_prop_keys,
                    object->int32_array_prop_vals,
                    jak_archive_field_i32_t,
                    "%d",
                    (value != JAK_NULL_INT32));
        PRINT_ARRAY(file, "Int64", object->int64_array_prop_keys, object->int64_array_prop_vals,
                    jak_archive_field_i64_t, "%"
                            PRIi64, (value != JAK_NULL_INT64));
        PRINT_ARRAY(file,
                    "Real",
                    object->float_array_prop_keys,
                    object->float_array_prop_vals,
                    jak_archive_field_number_t,
                    "%f",
                    (!isnan(value)));
        print_array_strings(file, "Strings", &object->jak_string_array_prop_keys, &object->jak_string_array_prop_vals, dic);
        print_array_null(file, "Null", &object->null_array_prop_keys, &object->null_array_prop_vals, dic);
        if (!print_array_objects(file, err, "Objects", &object->obj_array_props, dic)) {
                return false;
        }
        fprintf(file, "} ");
        fprintf(file, " }");
        fprintf(file, " }");
        jak_string_dict_free(dic, parentKey);
        return true;
}

bool jak_columndoc_print(FILE *file, jak_column_doc *doc)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(doc)
        return _jak_column_doc_print_object(file, &doc->err, &doc->columndoc, doc->dic);
}

bool jak_columndoc_drop(jak_column_doc *doc)
{
        JAK_UNUSED(doc);
        JAK_NOT_IMPLEMENTED
}

static void object_array_key_columns_create(jak_vector ofType(jak_column_doc_group) *columns)
{
        jak_vector_create(columns, NULL, sizeof(jak_column_doc_group), 20000);
}

static void object_array_key_columns_drop(jak_vector ofType(jak_column_doc_group) *columns)
{
        for (size_t i = 0; i < columns->num_elems; i++) {
                jak_column_doc_group *array_columns = JAK_VECTOR_GET(columns, i, jak_column_doc_group);
                for (size_t j = 0; j < array_columns->columns.num_elems; j++) {

                        jak_column_doc_column *column = JAK_VECTOR_GET(&array_columns->columns, j,
                                                                       jak_column_doc_column);

                        jak_vector ofType(jak_u32) *array_indices = &column->array_positions;
                        jak_vector ofType(jak_vector ofType(<T>)) *values_for_indicies = &column->values;

                        JAK_ASSERT (array_indices->num_elems == values_for_indicies->num_elems);

                        for (size_t k = 0; k < array_indices->num_elems; k++) {

                                jak_vector ofType(<T>)
                                        *values_for_index = JAK_VECTOR_GET(values_for_indicies, k, jak_vector);
                                if (column->type == JAK_FIELD_OBJECT) {
                                        for (size_t l = 0; l < values_for_index->num_elems; l++) {
                                                jak_column_doc_obj *nested_object =
                                                        JAK_VECTOR_GET(values_for_index, l, jak_column_doc_obj);
                                                object_meta_model_free(nested_object);
                                        }
                                }
                                jak_vector_drop(values_for_index);
                        }

                        jak_vector_drop(array_indices);
                        jak_vector_drop(values_for_indicies);
                }
                jak_vector_drop(&array_columns->columns);
        }
        jak_vector_drop(columns);
}

static const char *get_type_name(jak_error *err, jak_archive_field_e type)
{
        switch (type) {
                case JAK_FIELD_NULL:
                        return "Null";
                case JAK_FIELD_INT8:
                        return "Int8";
                case JAK_FIELD_INT16:
                        return "Int16";
                case JAK_FIELD_INT32:
                        return "Int32";
                case JAK_FIELD_INT64:
                        return "Int64";
                case JAK_FIELD_UINT8:
                        return "UInt8";
                case JAK_FIELD_UINT16:
                        return "UInt16";
                case JAK_FIELD_UINT32:
                        return "UInt32";
                case JAK_FIELD_UINT64:
                        return "UInt64";
                case JAK_FIELD_FLOAT:
                        return "Real";
                case JAK_FIELD_STRING:
                        return "String";
                case JAK_FIELD_OBJECT:
                        return "Object";
                default: {
                        JAK_ERROR(err, JAK_ERR_NOTYPE);
                        return NULL;
                }
        }
}

static jak_column_doc_column *object_array_key_columns_find_or_new(
        jak_vector ofType(jak_column_doc_group) *columns, jak_archive_field_sid_t array_key,
        jak_archive_field_sid_t nested_object_entry_key, jak_archive_field_e nested_object_entry_type)
{
        jak_column_doc_group *key_columns;
        jak_column_doc_column *key_column, *new_column;

        for (size_t i = 0; i < columns->num_elems; i++) {
                /** Find object array pair having the key `key` */
                key_columns = JAK_VECTOR_GET(columns, i, jak_column_doc_group);
                if (key_columns->key == array_key) {
                        /** In case such a pair is found, find column that matches the desired type */
                        for (size_t j = 0; j < key_columns->columns.num_elems; j++) {
                                key_column = JAK_VECTOR_GET(&key_columns->columns, j, jak_column_doc_column);
                                if (key_column->key_name == nested_object_entry_key
                                    && key_column->type == nested_object_entry_type) {
                                        /** Column for the object array with the desired key, the nested object entry with the desired key
                                         * and a matching type is found */
                                        return key_column;
                                }
                        }
                        /** In this case, the requested array_key is found, but the nested object entry does not match, hence
                         * create a new one */
                        goto objectArrayKeyColumnsNewColumn;
                }
        }
        /** In this case, the array key is also not known. Create a new one array entry with the fitting key column and
         * return that newly created column */
        key_columns = JAK_VECTOR_NEW_AND_GET(columns, jak_column_doc_group);
        key_columns->key = array_key;
        jak_vector_create(&key_columns->columns, NULL, sizeof(jak_column_doc_column), 10);

        objectArrayKeyColumnsNewColumn:
        new_column = JAK_VECTOR_NEW_AND_GET(&key_columns->columns, jak_column_doc_column);
        new_column->key_name = nested_object_entry_key;
        new_column->type = nested_object_entry_type;
        jak_vector_create(&new_column->values, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&new_column->array_positions, NULL, sizeof(jak_u32), 10);

        return new_column;
}

static bool object_array_key_column_push(jak_column_doc_column *col, jak_error *err,
                                         const jak_doc_entries *entry,
                                         jak_u32 array_idx, jak_string_dict *dic,
                                         jak_column_doc_obj *model)
{
        JAK_ASSERT(col->type == entry->type);

        jak_u32 *entry_array_idx = JAK_VECTOR_NEW_AND_GET(&col->array_positions, jak_u32);
        *entry_array_idx = array_idx;

        jak_vector ofType(<T>) *values_for_entry = JAK_VECTOR_NEW_AND_GET(&col->values, jak_vector);
        jak_vector_create(values_for_entry, NULL, GET_TYPE_SIZE(entry->type), entry->values.num_elems);

        bool is_null_by_def = entry->values.num_elems == 0;
        jak_u32 num_elements = (jak_u32) entry->values.num_elems;

        jak_archive_field_e entryType = is_null_by_def ? JAK_FIELD_NULL : entry->type;
        num_elements = is_null_by_def ? 1 : num_elements;

        switch (entryType) {
                case JAK_FIELD_NULL: {
                        jak_vector_push(values_for_entry, &num_elements, 1);
                }
                        break;
                case JAK_FIELD_BOOLEAN:
                case JAK_FIELD_INT8:
                case JAK_FIELD_INT16:
                case JAK_FIELD_INT32:
                case JAK_FIELD_INT64:
                case JAK_FIELD_UINT8:
                case JAK_FIELD_UINT16:
                case JAK_FIELD_UINT32:
                case JAK_FIELD_UINT64:
                case JAK_FIELD_FLOAT:
                        JAK_ASSERT(!is_null_by_def);
                        jak_vector_push(values_for_entry, entry->values.base, num_elements);
                        break;
                case JAK_FIELD_STRING: {
                        JAK_ASSERT(!is_null_by_def);
                        char **strings = JAK_VECTOR_ALL(&entry->values, char *);
                        jak_archive_field_sid_t *jak_string_ids;
                        jak_string_dict_locate_fast(&jak_string_ids, dic, (char *const *) strings, num_elements);
                        jak_vector_push(values_for_entry, jak_string_ids, num_elements);
                        jak_string_dict_free(dic, jak_string_ids);
                        //jak_string_dict_free(encode, strings);
                }
                        break;
                case JAK_FIELD_OBJECT:
                        JAK_ASSERT(!is_null_by_def);

                        jak_archive_field_sid_t *array_key;
                        jak_string_dict_locate_fast(&array_key, dic, (char *const *) &entry->key, 1);

                        for (size_t array_idx = 0; array_idx < num_elements; array_idx++) {
                                jak_column_doc_obj
                                        *nested_object = JAK_VECTOR_NEW_AND_GET(values_for_entry, jak_column_doc_obj);
                                setup_object(nested_object, model->parent, *array_key, array_idx);
                                if (!import_object(nested_object,
                                                   err,
                                                   JAK_VECTOR_GET(&entry->values, array_idx, jak_doc_obj),
                                                   dic)) {
                                        return false;
                                }
                        }
                        jak_string_dict_free(dic, array_key);
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOTYPE);
                        return false;
        }
        return true;
}

static void
setup_object(jak_column_doc_obj *model, jak_column_doc *parent, jak_archive_field_sid_t key, size_t idx)
{
        model->parent = parent;
        model->parent_key = key;
        model->index = idx;

        jak_vector_create(&model->bool_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->int8_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->int16_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->int32_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->int64_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->uint8_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->uint16_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->uin32_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->uint64_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->jak_string_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 50);
        jak_vector_create(&model->float_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->null_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->obj_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);

        jak_vector_create(&model->bool_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->int8_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->int16_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->int32_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->int64_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->uint8_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->uint16_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->uint32_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->uint64_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->jak_string_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 50);
        jak_vector_create(&model->float_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);
        jak_vector_create(&model->null_array_prop_keys, NULL, sizeof(jak_archive_field_sid_t), 10);

        jak_vector_create(&model->bool_prop_vals, NULL, sizeof(jak_archive_field_boolean_t), 10);
        jak_vector_create(&model->int8_prop_vals, NULL, sizeof(jak_archive_field_i8_t), 10);
        jak_vector_create(&model->int16_prop_vals, NULL, sizeof(jak_archive_field_i16_t), 10);
        jak_vector_create(&model->int32_prop_vals, NULL, sizeof(jak_archive_field_i32_t), 10);
        jak_vector_create(&model->int64_prop_vals, NULL, sizeof(jak_archive_field_i64_t), 10);
        jak_vector_create(&model->uint8_prop_vals, NULL, sizeof(jak_archive_field_u8_t), 10);
        jak_vector_create(&model->uint16_prop_vals, NULL, sizeof(jak_archive_field_u16_t), 10);
        jak_vector_create(&model->uint32_prop_vals, NULL, sizeof(jak_archive_field_u32_t), 10);
        jak_vector_create(&model->uint64_prop_vals, NULL, sizeof(jak_archive_field_u64_t), 10);
        jak_vector_create(&model->float_prop_vals, NULL, sizeof(jak_archive_field_number_t), 10);
        jak_vector_create(&model->jak_string_prop_vals, NULL, sizeof(jak_archive_field_sid_t), 50);

        jak_vector_create(&model->bool_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->int8_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->int16_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->int32_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->int64_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->uint8_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->uint16_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->uint32_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->ui64_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->float_array_prop_vals, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->jak_string_array_prop_vals, NULL, sizeof(jak_vector), 50);
        jak_vector_create(&model->null_array_prop_vals, NULL, sizeof(jak_u16), 10);

        jak_vector_create(&model->bool_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->int8_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->int16_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->int32_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->int64_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->uint8_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->uint16_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->uint32_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->uint64_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->float_val_idxs, NULL, sizeof(jak_u32), 10);
        jak_vector_create(&model->jak_string_val_idxs, NULL, sizeof(jak_u32), 50);

        jak_vector_create(&model->bool_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->int8_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->int16_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->int32_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->int64_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->uint8_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->uint16_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->uint32_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->uint64_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->float_array_idxs, NULL, sizeof(jak_vector), 10);
        jak_vector_create(&model->jak_string_array_idxs, NULL, sizeof(jak_vector), 50);

        jak_vector_create(&model->obj_prop_vals, NULL, sizeof(jak_column_doc_obj), 10);

        object_array_key_columns_create(&model->obj_array_props);
}

static bool
object_put_primitive(jak_column_doc_obj *columndoc, jak_error *err, const jak_doc_entries *entry,
                     jak_string_dict *dic, const jak_archive_field_sid_t *key_id)
{
        switch (entry->type) {
                case JAK_FIELD_NULL:
                        jak_vector_push(&columndoc->null_prop_keys, key_id, 1);
                        break;
                case JAK_FIELD_BOOLEAN:
                        jak_vector_push(&columndoc->bool_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->bool_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_INT8:
                        jak_vector_push(&columndoc->int8_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->int8_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_INT16:
                        jak_vector_push(&columndoc->int16_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->int16_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_INT32:
                        jak_vector_push(&columndoc->int32_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->int32_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_INT64:
                        jak_vector_push(&columndoc->int64_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->int64_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_UINT8:
                        jak_vector_push(&columndoc->uint8_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->uint8_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_UINT16:
                        jak_vector_push(&columndoc->uint16_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->uint16_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_UINT32:
                        jak_vector_push(&columndoc->uin32_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->uint32_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_UINT64:
                        jak_vector_push(&columndoc->uint64_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->uint64_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_FLOAT:
                        jak_vector_push(&columndoc->float_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->float_prop_vals, entry->values.base, 1);
                        break;
                case JAK_FIELD_STRING: {
                        jak_archive_field_sid_t *value;
                        jak_string_dict_locate_fast(&value, dic, (char *const *) entry->values.base, 1);
                        jak_vector_push(&columndoc->jak_string_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->jak_string_prop_vals, value, 1);
                        jak_string_dict_free(dic, value);
                }
                        break;
                case JAK_FIELD_OBJECT: {
                        jak_column_doc_obj template, *nested_object;
                        size_t position = jak_vector_length(&columndoc->obj_prop_keys);
                        jak_vector_push(&columndoc->obj_prop_keys, key_id, 1);
                        jak_vector_push(&columndoc->obj_prop_vals, &template, 1);
                        nested_object = JAK_VECTOR_GET(&columndoc->obj_prop_vals, position, jak_column_doc_obj);
                        setup_object(nested_object, columndoc->parent, *key_id, 0);
                        if (!import_object(nested_object, err, JAK_VECTOR_GET(&entry->values, 0, jak_doc_obj), dic)) {
                                return false;
                        }
                }
                        break;
                        JAK_ERROR(err, JAK_ERR_NOTYPE)
                        return false;
        }
        return true;
}

static void object_push_array(jak_vector ofType(Vector
                                                               ofType( < T >)) *values, size_t TSize,
                              jak_u32 num_elements,
                              const void *data, jak_archive_field_sid_t key_id,
                              jak_vector ofType(jak_archive_field_sid_t) *key_vector)
{
        jak_vector ofType(<T>) template, *vector;
        size_t idx = jak_vector_length(values);
        jak_vector_push(values, &template, 1);
        vector = JAK_VECTOR_GET(values, idx, jak_vector);
        jak_vector_create(vector, NULL, TSize, num_elements);
        jak_vector_push(vector, data, num_elements);
        jak_vector_push(key_vector, &key_id, 1);
}

static bool
object_put_array(jak_column_doc_obj *model, jak_error *err, const jak_doc_entries *entry,
                 jak_string_dict *dic, const jak_archive_field_sid_t *key_id)
{
        JAK_UNUSED(dic);
        jak_u32 num_elements = (jak_u32) jak_vector_length(&entry->values);

        switch (entry->type) {
                case JAK_FIELD_NULL: {
                        jak_vector_push(&model->null_array_prop_vals, &num_elements, 1);
                        jak_vector_push(&model->null_array_prop_keys, key_id, 1);
                }
                        break;
                case JAK_FIELD_BOOLEAN:
                        object_push_array(&model->bool_array_prop_vals,
                                          sizeof(jak_archive_field_boolean_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->bool_array_prop_keys);
                        break;
                case JAK_FIELD_INT8:
                        object_push_array(&model->int8_array_prop_vals,
                                          sizeof(jak_archive_field_i8_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->int8_array_prop_keys);
                        break;
                case JAK_FIELD_INT16:
                        object_push_array(&model->int16_array_prop_vals,
                                          sizeof(jak_archive_field_i16_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->int16_array_prop_keys);
                        break;
                case JAK_FIELD_INT32:
                        object_push_array(&model->int32_array_prop_vals,
                                          sizeof(jak_archive_field_i32_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->int32_array_prop_keys);
                        break;
                case JAK_FIELD_INT64:
                        object_push_array(&model->int64_array_prop_vals,
                                          sizeof(jak_archive_field_i64_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->int64_array_prop_keys);
                        break;
                case JAK_FIELD_UINT8:
                        object_push_array(&model->uint8_array_prop_vals,
                                          sizeof(jak_archive_field_u8_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->uint8_array_prop_keys);
                        break;
                case JAK_FIELD_UINT16:
                        object_push_array(&model->uint16_array_prop_vals,
                                          sizeof(jak_archive_field_u16_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->uint16_array_prop_keys);
                        break;
                case JAK_FIELD_UINT32:
                        object_push_array(&model->uint32_array_prop_vals,
                                          sizeof(jak_archive_field_u32_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->uint32_array_prop_keys);
                        break;
                case JAK_FIELD_UINT64:
                        object_push_array(&model->ui64_array_prop_vals,
                                          sizeof(jak_archive_field_u64_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->uint64_array_prop_keys);
                        break;
                case JAK_FIELD_FLOAT:
                        object_push_array(&model->float_array_prop_vals,
                                          sizeof(jak_archive_field_number_t),
                                          num_elements,
                                          entry->values.base,
                                          *key_id,
                                          &model->float_array_prop_keys);
                        break;
                case JAK_FIELD_STRING: {
                        const char **strings = JAK_VECTOR_ALL(&entry->values, const char *);
                        jak_archive_field_sid_t *jak_string_ids;
                        jak_string_dict_locate_fast(&jak_string_ids, dic, (char *const *) strings, num_elements);
                        object_push_array(&model->jak_string_array_prop_vals,
                                          sizeof(jak_archive_field_sid_t),
                                          num_elements,
                                          jak_string_ids,
                                          *key_id,
                                          &model->jak_string_array_prop_keys);
                        jak_string_dict_free(dic, jak_string_ids);
                }
                        break;
                case JAK_FIELD_OBJECT: {
                        jak_archive_field_sid_t *nested_object_key_name;
                        for (jak_u32 array_idx = 0; array_idx < num_elements; array_idx++) {
                                const jak_doc_obj *object = JAK_VECTOR_GET(&entry->values, array_idx,
                                                                           jak_doc_obj);
                                for (size_t pair_idx = 0; pair_idx < object->entries.num_elems; pair_idx++) {
                                        const jak_doc_entries
                                                *pair = JAK_VECTOR_GET(&object->entries, pair_idx, jak_doc_entries);
                                        jak_string_dict_locate_fast(&nested_object_key_name, dic, (char *const *) &pair->key, 1);
                                        jak_column_doc_column *key_column =
                                                object_array_key_columns_find_or_new(&model->obj_array_props,
                                                                                     *key_id,
                                                                                     *nested_object_key_name,
                                                                                     pair->type);
                                        if (!object_array_key_column_push(key_column, err, pair, array_idx, dic,
                                                                          model)) {
                                                return false;
                                        }
                                        jak_string_dict_free(dic, nested_object_key_name);
                                }
                        }
                }
                        break;
                default: {
                        JAK_ERROR(err, JAK_ERR_NOTYPE)
                        return false;
                }
                        break;
        }
        return true;
}

static bool object_put(jak_column_doc_obj *model, jak_error *err, const jak_doc_entries *entry,
                       jak_string_dict *dic)
{
        jak_archive_field_sid_t *key_id;
        enum EntryType {
                ENTRY_TYPE_NULL, ENTRY_TYPE_PRIMITIVE, ENTRY_TYPE_ARRAY
        } entryType;

        jak_string_dict_locate_fast(&key_id, dic, (char *const *) &entry->key, 1);
        entryType =
                entry->values.num_elems == 0 ? ENTRY_TYPE_NULL : (entry->values.num_elems == 1 ? ENTRY_TYPE_PRIMITIVE
                                                                                               : ENTRY_TYPE_ARRAY);

        switch (entryType) {
                case ENTRY_TYPE_NULL:
                        /** For a key which does not jak_async_map_exec to any value, the value is defined as 'null'  */
                        jak_vector_push(&model->null_prop_keys, key_id, 1);
                        break;
                case ENTRY_TYPE_PRIMITIVE:
                        if (!object_put_primitive(model, err, entry, dic, key_id)) {
                                return false;
                        }
                        break;
                case ENTRY_TYPE_ARRAY:
                        if (!object_put_array(model, err, entry, dic, key_id)) {
                                return false;
                        }
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOTYPE)
                        return false;
        }

        jak_string_dict_free(dic, key_id);
        return true;
}

static bool import_object(jak_column_doc_obj *dst, jak_error *err, const jak_doc_obj *doc,
                          jak_string_dict *dic)
{
        const jak_vector ofType(jak_doc_entries) *objectEntries = jak_doc_get_entries(doc);
        const jak_doc_entries *entries = JAK_VECTOR_ALL(objectEntries, jak_doc_entries);
        for (size_t i = 0; i < objectEntries->num_elems; i++) {
                const jak_doc_entries *entry = entries + i;
                if (!object_put(dst, err, entry, dic)) {
                        return false;
                }
        }
        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>
#include <inttypes.h>
#include <jak_json.h>
#include <jak_doc.h>
#include <jak_column_doc.h>
#include <jak_json.h>
#include <jak_utils_sort.h>

char VALUE_NULL = '\0';

static void create_doc(jak_doc_obj *model, jak_doc *doc);

static void create_typed_vector(jak_doc_entries *entry);

static void entries_drop(jak_doc_entries *entry);

static bool print_value(FILE *file, jak_archive_field_e type, const jak_vector ofType(<T>) *values);

static void _jak_doc_print_object(FILE *file, const jak_doc_obj *model);

static bool
import_json_object(jak_doc_obj *target, jak_error *err, const jak_json_object *json_obj);

static void sort_jak_columndoc_entries(jak_column_doc_obj *columndoc);

bool jak_doc_bulk_create(jak_doc_bulk *bulk, jak_string_dict *dic)
{
        JAK_ERROR_IF_NULL(bulk)
        JAK_ERROR_IF_NULL(dic)
        bulk->dic = dic;
        jak_vector_create(&bulk->keys, NULL, sizeof(char *), 500);
        jak_vector_create(&bulk->values, NULL, sizeof(char *), 1000);
        jak_vector_create(&bulk->models, NULL, sizeof(jak_doc), 50);
        return true;
}

jak_doc_obj *jak_doc_bulk_new_obj(jak_doc *model)
{
        if (!model) {
                return NULL;
        } else {
                jak_doc_obj *retval = JAK_VECTOR_NEW_AND_GET(&model->obj_model, jak_doc_obj);
                create_doc(retval, model);
                return retval;
        }
}

bool jak_doc_bulk_get_dic_contents(jak_vector ofType (const char *) **strings,
                               jak_vector ofType(jak_archive_field_sid_t) **jak_string_ids,
                               const jak_doc_bulk *context)
{
        JAK_ERROR_IF_NULL(context)

        size_t num_distinct_values;
        jak_string_dict_num_distinct(&num_distinct_values, context->dic);
        jak_vector ofType (const char *) *result_strings = JAK_MALLOC(sizeof(jak_vector));
        jak_vector ofType (jak_archive_field_sid_t) *resultjak_string_id_ts = JAK_MALLOC(sizeof(jak_vector));
        jak_vector_create(result_strings, NULL, sizeof(const char *), num_distinct_values);
        jak_vector_create(resultjak_string_id_ts, NULL, sizeof(jak_archive_field_sid_t), num_distinct_values);

        int status = jak_string_dict_get_contents(result_strings, resultjak_string_id_ts, context->dic);
        JAK_CHECK_SUCCESS(status);
        *strings = result_strings;
        *jak_string_ids = resultjak_string_id_ts;

        return status;
}

jak_doc *jak_doc_bulk_new_doc(jak_doc_bulk *context, jak_archive_field_e type)
{
        if (!context) {
                return NULL;
        }

        jak_doc template, *model;
        size_t idx = jak_vector_length(&context->models);
        jak_vector_push(&context->models, &template, 1);
        model = JAK_VECTOR_GET(&context->models, idx, jak_doc);
        model->context = context;
        model->type = type;

        jak_vector_create(&model->obj_model, NULL, sizeof(jak_doc_obj), 500);

        return model;
}

bool jak_doc_bulk_drop(jak_doc_bulk *bulk)
{
        JAK_ERROR_IF_NULL(bulk)
        for (size_t i = 0; i < bulk->keys.num_elems; i++) {
                char *string = *JAK_VECTOR_GET(&bulk->keys, i, char *);
                free(string);
        }
        for (size_t i = 0; i < bulk->values.num_elems; i++) {
                char *string = *JAK_VECTOR_GET(&bulk->values, i, char *);
                free(string);
        }
        for (size_t i = 0; i < bulk->models.num_elems; i++) {
                jak_doc *model = JAK_VECTOR_GET(&bulk->models, i, jak_doc);
                for (size_t j = 0; j < model->obj_model.num_elems; j++) {
                        jak_doc_obj *doc = JAK_VECTOR_GET(&model->obj_model, j, jak_doc_obj);
                        jak_doc_drop(doc);
                }
                jak_vector_drop(&model->obj_model);
        }

        jak_vector_drop(&bulk->keys);
        jak_vector_drop(&bulk->values);
        jak_vector_drop(&bulk->models);
        return true;
}

bool jak_doc_bulk_shrink(jak_doc_bulk *bulk)
{
        JAK_ERROR_IF_NULL(bulk)
        jak_vector_shrink(&bulk->keys);
        jak_vector_shrink(&bulk->values);
        return true;
}

bool jak_doc_bulk_print(FILE *file, jak_doc_bulk *bulk)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(bulk)

        fprintf(file, "{");
        char **key_strings = JAK_VECTOR_ALL(&bulk->keys, char *);
        fprintf(file, "\"Key Strings\": [");
        for (size_t i = 0; i < bulk->keys.num_elems; i++) {
                fprintf(file, "\"%s\"%s", key_strings[i], i + 1 < bulk->keys.num_elems ? ", " : "");
        }
        fprintf(file, "], ");

        char **valueStrings = JAK_VECTOR_ALL(&bulk->values, char *);
        fprintf(file, "\"Value Strings\": [");
        for (size_t i = 0; i < bulk->values.num_elems; i++) {
                fprintf(file, "\"%s\"%s", valueStrings[i], i + 1 < bulk->values.num_elems ? ", " : "");
        }
        fprintf(file, "]}");

        return true;
}

bool jak_doc_print(FILE *file, const jak_doc *doc)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(doc)

        if (doc->obj_model.num_elems == 0) {
                fprintf(file, "{ }");
        }

        if (doc->obj_model.num_elems > 1) {
                fprintf(file, "[");
        }

        for (size_t num_entries = 0; num_entries < doc->obj_model.num_elems; num_entries++) {
                jak_doc_obj *object = JAK_VECTOR_GET(&doc->obj_model, num_entries, jak_doc_obj);
                _jak_doc_print_object(file, object);
                fprintf(file, "%s", num_entries + 1 < doc->obj_model.num_elems ? ", " : "");
        }

        if (doc->obj_model.num_elems > 1) {
                fprintf(file, "]");
        }

        return true;
}

const jak_vector ofType(jak_doc_entries) *jak_doc_get_entries(const jak_doc_obj *model)
{
        return &model->entries;
}

void jak_doc_print_entries(FILE *file, const jak_doc_entries *entries)
{
        fprintf(file, "{\"Key\": \"%s\"", entries->key);
}

void jak_doc_drop(jak_doc_obj *model)
{
        for (size_t i = 0; i < model->entries.num_elems; i++) {
                jak_doc_entries *entry = JAK_VECTOR_GET(&model->entries, i, jak_doc_entries);
                entries_drop(entry);
        }
        jak_vector_drop(&model->entries);
}

bool jak_doc_obj_add_key(jak_doc_entries **out, jak_doc_obj *obj, const char *key, jak_archive_field_e type)
{
        JAK_ERROR_IF_NULL(out)
        JAK_ERROR_IF_NULL(obj)
        JAK_ERROR_IF_NULL(key)

        size_t entry_idx;
        char *key_dup = strdup(key);

        jak_doc_entries entry_model = {.type = type, .key = key_dup, .context = obj};

        create_typed_vector(&entry_model);
        jak_vector_push(&obj->doc->context->keys, &key_dup, 1);

        entry_idx = jak_vector_length(&obj->entries);
        jak_vector_push(&obj->entries, &entry_model, 1);

        *out = JAK_VECTOR_GET(&obj->entries, entry_idx, jak_doc_entries);

        return true;
}

bool jak_doc_obj_push_primtive(jak_doc_entries *entry, const void *value)
{
        JAK_ERROR_IF_NULL(entry)
        JAK_ERROR_IF_NULL((entry->type == JAK_FIELD_NULL) || (value != NULL))

        switch (entry->type) {
                case JAK_FIELD_NULL:
                        jak_vector_push(&entry->values, &VALUE_NULL, 1);
                        break;
                case JAK_FIELD_STRING: {
                        char *string = value ? strdup((char *) value) : NULL;
                        jak_vector_push(&entry->context->doc->context->values, &string, 1);
                        jak_vector_push(&entry->values, &string, 1);
                }
                        break;
                default:
                        jak_vector_push(&entry->values, value, 1);
                        break;
        }
        return true;
}

bool jak_doc_obj_push_object(jak_doc_obj **out, jak_doc_entries *entry)
{
        JAK_ERROR_IF_NULL(out);
        JAK_ERROR_IF_NULL(entry);

        JAK_ASSERT(entry->type == JAK_FIELD_OBJECT);

        jak_doc_obj objectModel;

        create_doc(&objectModel, entry->context->doc);
        size_t length = jak_vector_length(&entry->values);
        jak_vector_push(&entry->values, &objectModel, 1);

        *out = JAK_VECTOR_GET(&entry->values, length, jak_doc_obj);

        return true;
}

static jak_archive_field_e
value_type_for_json_number(bool *success, jak_error *err, const jak_json_number *number)
{
        *success = true;
        switch (number->value_type) {
                case JAK_JSON_NUMBER_FLOAT:
                        return JAK_FIELD_FLOAT;
                case JAK_JSON_NUMBER_UNSIGNED: {
                        jak_u64 test = number->value.unsigned_integer;
                        if (test <= JAK_LIMITS_UINT8_MAX) {
                                return JAK_FIELD_UINT8;
                        } else if (test <= JAK_LIMITS_UINT16_MAX) {
                                return JAK_FIELD_UINT16;
                        } else if (test <= JAK_LIMITS_UINT32_MAX) {
                                return JAK_FIELD_UINT32;
                        } else {
                                return JAK_FIELD_UINT64;
                        }
                }
                case JAK_JSON_NUMBER_SIGNED: {
                        jak_i64 test = number->value.signed_integer;
                        if (test >= JAK_LIMITS_INT8_MIN && test <= JAK_LIMITS_INT8_MAX) {
                                return JAK_FIELD_INT8;
                        } else if (test >= JAK_LIMITS_INT16_MIN && test <= JAK_LIMITS_INT16_MAX) {
                                return JAK_FIELD_INT16;
                        } else if (test >= JAK_LIMITS_INT32_MIN && test <= JAK_LIMITS_INT32_MAX) {
                                return JAK_FIELD_INT32;
                        } else {
                                return JAK_FIELD_INT64;
                        }
                }
                default: JAK_ERROR(err, JAK_ERR_NOJSONNUMBERT);
                        *success = false;
                        return JAK_FIELD_INT8;
        }
}

static void
import_json_object_jak_string_prop(jak_doc_obj *target, const char *key, const jak_json_string *string)
{
        jak_doc_entries *entry;
        jak_doc_obj_add_key(&entry, target, key, JAK_FIELD_STRING);
        jak_doc_obj_push_primtive(entry, string->value);
}

static bool import_json_object_number_prop(jak_doc_obj *target, jak_error *err, const char *key,
                                           const jak_json_number *number)
{
        jak_doc_entries *entry;
        bool success;
        jak_archive_field_e number_type = value_type_for_json_number(&success, err, number);
        if (!success) {
                return false;
        }
        jak_doc_obj_add_key(&entry, target, key, number_type);
        jak_doc_obj_push_primtive(entry, &number->value);
        return true;
}

static void import_json_object_bool_prop(jak_doc_obj *target, const char *key, jak_archive_field_boolean_t value)
{
        jak_doc_entries *entry;
        jak_doc_obj_add_key(&entry, target, key, JAK_FIELD_BOOLEAN);
        jak_doc_obj_push_primtive(entry, &value);
}

static void import_json_object_null_prop(jak_doc_obj *target, const char *key)
{
        jak_doc_entries *entry;
        jak_doc_obj_add_key(&entry, target, key, JAK_FIELD_NULL);
        jak_doc_obj_push_primtive(entry, NULL);
}

static bool import_json_object_object_prop(jak_doc_obj *target, jak_error *err, const char *key,
                                           const jak_json_object *object)
{
        jak_doc_entries *entry;
        jak_doc_obj *nested_object = NULL;
        jak_doc_obj_add_key(&entry, target, key, JAK_FIELD_OBJECT);
        jak_doc_obj_push_object(&nested_object, entry);
        return import_json_object(nested_object, err, object);
}

static bool import_json_object_array_prop(jak_doc_obj *target, jak_error *err, const char *key,
                                          const jak_json_array *array)
{
        jak_doc_entries *entry;

        if (!jak_vector_is_empty(&array->elements.elements)) {
                size_t num_elements = array->elements.elements.num_elems;

                /** Find first type that is not null unless the entire array is of type null */
                jak_json_value_type_e array_data_type = JAK_JSON_VALUE_NULL;
                jak_archive_field_e field_type;

                for (size_t i = 0; i < num_elements && array_data_type == JAK_JSON_VALUE_NULL; i++) {
                        const jak_json_element *element = JAK_VECTOR_GET(&array->elements.elements, i,
                                                                         jak_json_element);
                        array_data_type = element->value.value_type;
                }

                switch (array_data_type) {
                        case JAK_JSON_VALUE_OBJECT:
                                field_type = JAK_FIELD_OBJECT;
                                break;
                        case JAK_JSON_VALUE_STRING:
                                field_type = JAK_FIELD_STRING;
                                break;
                        case JAK_JSON_VALUE_NUMBER: {
                                /** find smallest fitting physical number type */
                                jak_archive_field_e array_number_type = JAK_FIELD_NULL;
                                for (size_t i = 0; i < num_elements; i++) {
                                        const jak_json_element
                                                *element = JAK_VECTOR_GET(&array->elements.elements, i,
                                                                   jak_json_element);
                                        if (JAK_UNLIKELY(element->value.value_type == JAK_JSON_VALUE_NULL)) {
                                                continue;
                                        } else {
                                                bool success;
                                                jak_archive_field_e element_number_type =
                                                        value_type_for_json_number(&success, err,
                                                                                   element->value.value.number);
                                                if (!success) {
                                                        return false;
                                                }
                                                JAK_ASSERT(element_number_type == JAK_FIELD_INT8 ||
                                                           element_number_type == JAK_FIELD_INT16
                                                           || element_number_type == JAK_FIELD_INT32
                                                           || element_number_type == JAK_FIELD_INT64
                                                           || element_number_type == JAK_FIELD_UINT8
                                                           || element_number_type == JAK_FIELD_UINT16
                                                           || element_number_type == JAK_FIELD_UINT32
                                                           || element_number_type == JAK_FIELD_UINT64
                                                           || element_number_type == JAK_FIELD_FLOAT);
                                                if (JAK_UNLIKELY(array_number_type == JAK_FIELD_NULL)) {
                                                        array_number_type = element_number_type;
                                                } else {
                                                        if (array_number_type == JAK_FIELD_INT8) {
                                                                array_number_type = element_number_type;
                                                        } else if (array_number_type == JAK_FIELD_INT16) {
                                                                if (element_number_type != JAK_FIELD_INT8) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == JAK_FIELD_INT32) {
                                                                if (element_number_type != JAK_FIELD_INT8
                                                                    && element_number_type != JAK_FIELD_INT16) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == JAK_FIELD_INT64) {
                                                                if (element_number_type != JAK_FIELD_INT8
                                                                    && element_number_type != JAK_FIELD_INT16
                                                                    && element_number_type != JAK_FIELD_INT32) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == JAK_FIELD_UINT8) {
                                                                array_number_type = element_number_type;
                                                        } else if (array_number_type == JAK_FIELD_UINT16) {
                                                                if (element_number_type != JAK_FIELD_UINT16) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == JAK_FIELD_UINT32) {
                                                                if (element_number_type != JAK_FIELD_UINT8
                                                                    && element_number_type != JAK_FIELD_UINT16) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == JAK_FIELD_UINT64) {
                                                                if (element_number_type != JAK_FIELD_UINT8
                                                                    && element_number_type != JAK_FIELD_UINT16
                                                                    && element_number_type != JAK_FIELD_UINT32) {
                                                                        array_number_type = element_number_type;
                                                                }
                                                        } else if (array_number_type == JAK_FIELD_FLOAT) {
                                                                break;
                                                        }
                                                }
                                        }
                                }
                                JAK_ASSERT(array_number_type != JAK_FIELD_NULL);
                                field_type = array_number_type;
                        }
                                break;
                        case JAK_JSON_VALUE_FALSE:
                        case JAK_JSON_VALUE_TRUE:
                                field_type = JAK_FIELD_BOOLEAN;
                                break;
                        case JAK_JSON_VALUE_NULL:
                                field_type = JAK_FIELD_NULL;
                                break;
                        case JAK_JSON_VALUE_ARRAY: JAK_ERROR(err, JAK_ERR_ERRINTERNAL) /** array type is illegal here */
                                return false;
                        default: JAK_ERROR(err, JAK_ERR_NOTYPE)
                                return false;
                }

                jak_doc_obj_add_key(&entry, target, key, field_type);

                for (size_t i = 0; i < num_elements; i++) {
                        const jak_json_element *element = JAK_VECTOR_GET(&array->elements.elements, i,
                                                                         jak_json_element);
                        jak_json_value_type_e ast_node_data_type = element->value.value_type;

                        switch (field_type) {
                                case JAK_FIELD_OBJECT: {
                                        jak_doc_obj *nested_object = NULL;
                                        jak_doc_obj_push_object(&nested_object, entry);
                                        if (ast_node_data_type != JAK_JSON_VALUE_NULL) {
                                                /** the object is null by definition, if no entries are contained */
                                                if (!import_json_object(nested_object, err,
                                                                        element->value.value.object)) {
                                                        return false;
                                                }
                                        }
                                }
                                        break;
                                case JAK_FIELD_STRING: {
                                        JAK_ASSERT(ast_node_data_type == array_data_type ||
                                                   ast_node_data_type == JAK_JSON_VALUE_NULL);
                                        jak_doc_obj_push_primtive(entry,
                                                              ast_node_data_type == JAK_JSON_VALUE_NULL
                                                              ? JAK_NULL_ENCODED_STRING : element->value
                                                                      .value.string->value);
                                }
                                        break;
                                case JAK_FIELD_INT8:
                                case JAK_FIELD_INT16:
                                case JAK_FIELD_INT32:
                                case JAK_FIELD_INT64:
                                case JAK_FIELD_UINT8:
                                case JAK_FIELD_UINT16:
                                case JAK_FIELD_UINT32:
                                case JAK_FIELD_UINT64:
                                case JAK_FIELD_FLOAT: {
                                        JAK_ASSERT(ast_node_data_type == array_data_type ||
                                                   ast_node_data_type == JAK_JSON_VALUE_NULL);
                                        switch (field_type) {
                                                case JAK_FIELD_INT8: {
                                                        jak_archive_field_i8_t value =
                                                                ast_node_data_type == JAK_JSON_VALUE_NULL ? JAK_NULL_INT8
                                                                                                      : (jak_archive_field_i8_t) element
                                                                        ->value.value.number->value.signed_integer;
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case JAK_FIELD_INT16: {
                                                        jak_archive_field_i16_t value =
                                                                ast_node_data_type == JAK_JSON_VALUE_NULL ? JAK_NULL_INT16
                                                                                                      : (jak_archive_field_i16_t) element
                                                                        ->value.value.number->value.signed_integer;
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case JAK_FIELD_INT32: {
                                                        jak_archive_field_i32_t value =
                                                                ast_node_data_type == JAK_JSON_VALUE_NULL ? JAK_NULL_INT32
                                                                                                      : (jak_archive_field_i32_t) element
                                                                        ->value.value.number->value.signed_integer;
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case JAK_FIELD_INT64: {
                                                        jak_archive_field_i64_t value =
                                                                ast_node_data_type == JAK_JSON_VALUE_NULL ? JAK_NULL_INT64
                                                                                                      : (jak_archive_field_i64_t) element
                                                                        ->value.value.number->value.signed_integer;
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case JAK_FIELD_UINT8: {
                                                        jak_archive_field_u8_t value =
                                                                ast_node_data_type == JAK_JSON_VALUE_NULL ? JAK_NULL_UINT8
                                                                                                      : (jak_archive_field_u8_t) element
                                                                        ->value.value.number->value.unsigned_integer;
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case JAK_FIELD_UINT16: {
                                                        jak_archive_field_u16_t value =
                                                                ast_node_data_type == JAK_JSON_VALUE_NULL ? JAK_NULL_UINT16
                                                                                                      : (jak_archive_field_u16_t) element
                                                                        ->value.value.number->value.unsigned_integer;
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case JAK_FIELD_UINT32: {
                                                        jak_archive_field_u32_t value =
                                                                ast_node_data_type == JAK_JSON_VALUE_NULL ? JAK_NULL_UINT32
                                                                                                      : (jak_archive_field_u32_t) element
                                                                        ->value.value.number->value.unsigned_integer;
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case JAK_FIELD_UINT64: {
                                                        jak_archive_field_u64_t value =
                                                                ast_node_data_type == JAK_JSON_VALUE_NULL ? JAK_NULL_UINT64
                                                                                                      : (jak_archive_field_u64_t) element
                                                                        ->value.value.number->value.unsigned_integer;
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                case JAK_FIELD_FLOAT: {
                                                        jak_archive_field_number_t value = JAK_NULL_FLOAT;
                                                        if (ast_node_data_type != JAK_JSON_VALUE_NULL) {
                                                                json_number_type_e
                                                                        element_number_type = element->value.value.number->value_type;
                                                                if (element_number_type == JAK_JSON_NUMBER_FLOAT) {
                                                                        value = element->value.value.number->value.float_number;
                                                                } else if (element_number_type ==
                                                                           JAK_JSON_NUMBER_UNSIGNED) {
                                                                        value = element->value.value.number->value.unsigned_integer;
                                                                } else if (element_number_type == JAK_JSON_NUMBER_SIGNED) {
                                                                        value = element->value.value.number->value.signed_integer;
                                                                } else {
                                                                        JAK_ERROR_PRINT_AND_DIE(
                                                                                JAK_ERR_INTERNALERR) /** type mismatch */
                                                                        return false;
                                                                }
                                                        }
                                                        jak_doc_obj_push_primtive(entry, &value);
                                                }
                                                        break;
                                                default: JAK_ERROR_PRINT_AND_DIE(
                                                        JAK_ERR_INTERNALERR) /** not a number type  */
                                                        return false;
                                        }
                                }
                                        break;
                                case JAK_FIELD_BOOLEAN:
                                        if (JAK_LIKELY(ast_node_data_type == JAK_JSON_VALUE_TRUE
                                                       || ast_node_data_type == JAK_JSON_VALUE_FALSE)) {
                                                jak_archive_field_boolean_t value =
                                                        ast_node_data_type == JAK_JSON_VALUE_TRUE ? JAK_BOOLEAN_TRUE
                                                                                              : JAK_BOOLEAN_FALSE;
                                                jak_doc_obj_push_primtive(entry, &value);
                                        } else {
                                                JAK_ASSERT(ast_node_data_type == JAK_JSON_VALUE_NULL);
                                                jak_archive_field_boolean_t value = JAK_NULL_BOOLEAN;
                                                jak_doc_obj_push_primtive(entry, &value);
                                        }
                                        break;
                                case JAK_FIELD_NULL:
                                        JAK_ASSERT(ast_node_data_type == array_data_type);
                                        jak_doc_obj_push_primtive(entry, NULL);
                                        break;
                                default: JAK_ERROR(err, JAK_ERR_NOTYPE)
                                        return false;
                        }
                }
        } else {
                import_json_object_null_prop(target, key);
        }
        return true;
}

static bool
import_json_object(jak_doc_obj *target, jak_error *err, const jak_json_object *json_obj)
{
        for (size_t i = 0; i < json_obj->value->members.num_elems; i++) {
                jak_json_prop *member = JAK_VECTOR_GET(&json_obj->value->members, i, jak_json_prop);
                jak_json_value_type_e value_type = member->value.value.value_type;
                switch (value_type) {
                        case JAK_JSON_VALUE_STRING:
                                import_json_object_jak_string_prop(target, member->key.value,
                                                               member->value.value.value.string);
                                break;
                        case JAK_JSON_VALUE_NUMBER:
                                if (!import_json_object_number_prop(target,
                                                                    err,
                                                                    member->key.value,
                                                                    member->value.value.value.number)) {
                                        return false;
                                }
                                break;
                        case JAK_JSON_VALUE_TRUE:
                        case JAK_JSON_VALUE_FALSE: {
                                jak_archive_field_boolean_t value =
                                        value_type == JAK_JSON_VALUE_TRUE ? JAK_BOOLEAN_TRUE : JAK_BOOLEAN_FALSE;
                                import_json_object_bool_prop(target, member->key.value, value);
                        }
                                break;
                        case JAK_JSON_VALUE_NULL:
                                import_json_object_null_prop(target, member->key.value);
                                break;
                        case JAK_JSON_VALUE_OBJECT:
                                if (!import_json_object_object_prop(target,
                                                                    err,
                                                                    member->key.value,
                                                                    member->value.value.value.object)) {
                                        return false;
                                }
                                break;
                        case JAK_JSON_VALUE_ARRAY:
                                if (!import_json_object_array_prop(target,
                                                                   err,
                                                                   member->key.value,
                                                                   member->value.value.value.array)) {
                                        return false;
                                }
                                break;
                        default: JAK_ERROR(err, JAK_ERR_NOTYPE);
                                return false;
                }
        }
        return true;
}

static bool
import_json(jak_doc_obj *target, jak_error *err, const jak_json *jak_json,
            jak_doc_entries *partition)
{
        jak_json_value_type_e value_type = jak_json->element->value.value_type;
        switch (value_type) {
                case JAK_JSON_VALUE_OBJECT:
                        if (!import_json_object(target, err, jak_json->element->value.value.object)) {
                                return false;
                        }
                        break;
                case JAK_JSON_VALUE_ARRAY: {
                        const jak_vector ofType(jak_json_element)
                                *arrayContent = &jak_json->element->value.value.array->elements.elements;
                        if (!jak_vector_is_empty(arrayContent)) {
                                const jak_json_element *first = JAK_VECTOR_GET(arrayContent, 0,
                                                                               jak_json_element);
                                switch (first->value.value_type) {
                                        case JAK_JSON_VALUE_OBJECT:
                                                if (!import_json_object(target, err, first->value.value.object)) {
                                                        return false;
                                                }
                                                for (size_t i = 1; i < arrayContent->num_elems; i++) {
                                                        const jak_json_element
                                                                *element = JAK_VECTOR_GET(arrayContent, i,
                                                                                   jak_json_element);
                                                        jak_doc_obj *nested;
                                                        jak_doc_obj_push_object(&nested, partition);
                                                        if (!import_json_object(nested, err,
                                                                                element->value.value.object)) {
                                                                return false;
                                                        }
                                                }
                                                break;
                                        case JAK_JSON_VALUE_ARRAY:
                                        case JAK_JSON_VALUE_STRING:
                                        case JAK_JSON_VALUE_NUMBER:
                                        case JAK_JSON_VALUE_TRUE:
                                        case JAK_JSON_VALUE_FALSE:
                                        case JAK_JSON_VALUE_NULL:
                                        default: JAK_ERROR_PRINT_AND_DIE(
                                                JAK_ERR_INTERNALERR) /** Unsupported operation in arrays */
                                                break;
                                }
                        }
                }
                        break;
                case JAK_JSON_VALUE_STRING:
                case JAK_JSON_VALUE_NUMBER:
                case JAK_JSON_VALUE_TRUE:
                case JAK_JSON_VALUE_FALSE:
                case JAK_JSON_VALUE_NULL:
                default: JAK_ERROR(err, JAK_ERR_JSONTYPE);
                        return false;
        }
        return true;
}

jak_doc_obj *jak_doc_bulk_add_json(jak_doc_entries *partition, jak_json *jak_json)
{
        if (!partition || !jak_json) {
                return NULL;
        }

        jak_doc_obj *converted_json;
        jak_doc_obj_push_object(&converted_json, partition);
        if (!import_json(converted_json, &jak_json->err, jak_json, partition)) {
                return NULL;
        }

        return converted_json;
}

jak_doc_obj *jak_doc_entries_get_root(const jak_doc_entries *partition)
{
        return partition ? partition->context : NULL;
}

jak_doc_entries *jak_doc_bulk_new_entries(jak_doc_bulk *dst)
{
        jak_doc_entries *partition = NULL;
        jak_doc *model = jak_doc_bulk_new_doc(dst, JAK_FIELD_OBJECT);
        jak_doc_obj *object = jak_doc_bulk_new_obj(model);
        jak_doc_obj_add_key(&partition, object, "/", JAK_FIELD_OBJECT);
        return partition;
}

#define JAK_DEFINE_TYPE_LQ_FUNC(type)                                                                               \
static bool compare_##type##_leq(const void *lhs, const void *rhs)                                                \
{                                                                                                                      \
    jak_archive_##type a = *(jak_archive_##type *) lhs;                                                                                            \
    jak_archive_##type b = *(jak_archive_##type *) rhs;                                                                                            \
    return (a <= b);                                                                                                   \
}

JAK_DEFINE_TYPE_LQ_FUNC(field_boolean_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_number_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_i8_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_i16_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_i32_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_i64_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_u8_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_u16_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_u32_t)

JAK_DEFINE_TYPE_LQ_FUNC(field_u64_t)

static bool compare_encoded_jak_string_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        jak_string_dict *dic = (jak_string_dict *) args;
        jak_archive_field_sid_t *a = (jak_archive_field_sid_t *) lhs;
        jak_archive_field_sid_t *b = (jak_archive_field_sid_t *) rhs;
        char **a_string = jak_string_dict_extract(dic, a, 1);
        char **b_string = jak_string_dict_extract(dic, b, 1);
        bool lq = strcmp(*a_string, *b_string) <= 0;
        jak_string_dict_free(dic, a_string);
        jak_string_dict_free(dic, b_string);
        return lq;
}

static void sort_nested_primitive_object(jak_column_doc_obj *columndoc)
{
        if (columndoc->parent->read_optimized) {
                for (size_t i = 0; i < columndoc->obj_prop_vals.num_elems; i++) {
                        jak_column_doc_obj *nestedModel = JAK_VECTOR_GET(&columndoc->obj_prop_vals, i,
                                                                         jak_column_doc_obj);
                        sort_jak_columndoc_entries(nestedModel);
                }
        }
}

#define JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(type)                                                                         \
static bool compare_##type##_array_leq(const void *lhs, const void *rhs)                                           \
{                                                                                                                      \
    jak_vector ofType(jak_archive_##type) *a = (jak_vector *) lhs;                                                               \
    jak_vector ofType(jak_archive_##type) *b = (jak_vector *) rhs;                                                               \
    const jak_archive_##type *aValues = JAK_VECTOR_ALL(a, jak_archive_##type);                                                                  \
    const jak_archive_##type *bValues = JAK_VECTOR_ALL(b, jak_archive_##type);                                                                  \
    size_t max_compare_idx = a->num_elems < b->num_elems ? a->num_elems : b->num_elems;                                \
    for (size_t i = 0; i < max_compare_idx; i++) {                                                                     \
        if (aValues[i] > bValues[i]) {                                                                                 \
            return false;                                                                                              \
        }                                                                                                              \
    }                                                                                                                  \
    return true;                                                                                                       \
}

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_boolean_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_i8_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_i16_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_i32_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_i64_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_u8_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_u16_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_u32_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_u64_t)

JAK_DEFINE_ARRAY_TYPE_LQ_FUNC(field_number_t)

static bool compare_encoded_jak_string_array_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        jak_string_dict *dic = (jak_string_dict *) args;
        jak_vector ofType(jak_archive_field_sid_t) *a = (jak_vector *) lhs;
        jak_vector ofType(jak_archive_field_sid_t) *b = (jak_vector *) rhs;
        const jak_archive_field_sid_t *aValues = JAK_VECTOR_ALL(a, jak_archive_field_sid_t);
        const jak_archive_field_sid_t *bValues = JAK_VECTOR_ALL(b, jak_archive_field_sid_t);
        size_t max_compare_idx = a->num_elems < b->num_elems ? a->num_elems : b->num_elems;
        for (size_t i = 0; i < max_compare_idx; i++) {
                char **aString = jak_string_dict_extract(dic, aValues + i, 1);
                char **bString = jak_string_dict_extract(dic, bValues + i, 1);
                bool greater = strcmp(*aString, *bString) > 0;
                jak_string_dict_free(dic, aString);
                jak_string_dict_free(dic, bString);
                if (greater) {
                        return false;
                }
        }
        return true;
}

static void sorted_nested_array_objects(jak_column_doc_obj *columndoc)
{
        if (columndoc->parent->read_optimized) {
                for (size_t i = 0; i < columndoc->obj_array_props.num_elems; i++) {
                        jak_column_doc_group
                                *array_columns = JAK_VECTOR_GET(&columndoc->obj_array_props, i, jak_column_doc_group);
                        for (size_t j = 0; j < array_columns->columns.num_elems; j++) {
                                jak_column_doc_column
                                        *column = JAK_VECTOR_GET(&array_columns->columns, j, jak_column_doc_column);
                                jak_vector ofType(jak_u32) *array_indices = &column->array_positions;
                                jak_vector ofType(
                                        jak_vector ofType(<T>)) *values_for_indicies = &column->values;
                                JAK_ASSERT (array_indices->num_elems == values_for_indicies->num_elems);

                                for (size_t k = 0; k < array_indices->num_elems; k++) {
                                        jak_vector ofType(<T>)
                                                *values_for_index = JAK_VECTOR_GET(values_for_indicies, k, jak_vector);
                                        if (column->type == JAK_FIELD_OBJECT) {
                                                for (size_t l = 0; l < values_for_index->num_elems; l++) {
                                                        jak_column_doc_obj *nested_object =
                                                                JAK_VECTOR_GET(values_for_index, l, jak_column_doc_obj);
                                                        sort_jak_columndoc_entries(nested_object);
                                                }
                                        }
                                }
                        }
                }
        }
}

#define SORT_META_MODEL_VALUES(key_vector, value_vector, value_type, compareValueFunc)                                 \
{                                                                                                                      \
    size_t num_elements = jak_vector_length(&key_vector);                                                              \
                                                                                                                       \
    if (num_elements > 0) {                                                                                            \
        size_t *value_indicies = JAK_MALLOC(sizeof(size_t) * num_elements);                                                \
        for (size_t i = 0; i < num_elements; i++) {                                                                    \
            value_indicies[i] = i;                                                                                     \
        }                                                                                                              \
                                                                                                                       \
        jak_vector ofType(jak_archive_field_sid_t) key_cpy;                                                               \
        jak_vector ofType(value_type) value_cpy;                                                                     \
                                                                                                                       \
        jak_vector_cpy(&key_cpy, &key_vector);                                                                         \
        jak_vector_cpy(&value_cpy, &value_vector);                                                                     \
                                                                                                                       \
        value_type *values = JAK_VECTOR_ALL(&value_cpy, value_type);                                                \
                                                                                                                       \
        jak_sort_qsort_indicies(value_indicies, values, sizeof(value_type), compareValueFunc, num_elements,         \
                      key_vector.allocator);                                                                           \
                                                                                                                       \
        for (size_t i = 0; i < num_elements; i++) {                                                                    \
            jak_vector_set(&key_vector, i, JAK_VECTOR_GET(&key_cpy, value_indicies[i], jak_archive_field_sid_t));        \
            jak_vector_set(&value_vector, i, JAK_VECTOR_GET(&value_cpy, value_indicies[i], value_type));            \
        }                                                                                                              \
                                                                                                                       \
                                                                                                                       \
        free(value_indicies);                                                                                          \
        jak_vector_drop(&key_cpy);                                                                                     \
        jak_vector_drop(&value_cpy);                                                                                   \
    }                                                                                                                  \
}

static void sort_meta_model_jak_string_values(jak_vector ofType(jak_archive_field_sid_t) *key_vector,
                                          jak_vector ofType(jak_archive_field_sid_t) *value_vector,
                                          jak_string_dict *dic)
{
        size_t num_elements = jak_vector_length(key_vector);

        if (num_elements > 0) {
                size_t *value_indicies = JAK_MALLOC(sizeof(size_t) * num_elements);
                for (size_t i = 0; i < num_elements; i++) {
                        value_indicies[i] = i;
                }

                jak_vector ofType(jak_archive_field_sid_t) key_cpy;
                jak_vector ofType(jak_archive_field_sid_t) value_cpy;

                jak_vector_cpy(&key_cpy, key_vector);
                jak_vector_cpy(&value_cpy, value_vector);

                jak_archive_field_sid_t *values = JAK_VECTOR_ALL(&value_cpy, jak_archive_field_sid_t);

                jak_sort_qsort_indicies_wargs(value_indicies,
                                          values,
                                          sizeof(jak_archive_field_sid_t),
                                          compare_encoded_jak_string_less_eq_func,
                                          num_elements,
                                          key_vector->allocator,
                                          dic);

                for (size_t i = 0; i < num_elements; i++) {
                        jak_vector_set(key_vector, i, JAK_VECTOR_GET(&key_cpy, value_indicies[i], jak_archive_field_sid_t));
                        jak_vector_set(value_vector, i, JAK_VECTOR_GET(&value_cpy, value_indicies[i], jak_archive_field_sid_t));
                }

                free(value_indicies);
                jak_vector_drop(&key_cpy);
                jak_vector_drop(&value_cpy);
        }
}

#define SORT_META_MODEL_ARRAYS(key_vector, value_array_vector, compare_func)                                           \
{                                                                                                                      \
    size_t num_elements = jak_vector_length(&key_vector);                                                              \
                                                                                                                       \
    if (num_elements > 0) {                                                                                            \
        size_t *value_indicies = JAK_MALLOC(sizeof(size_t) * num_elements);                                                \
        for (size_t i = 0; i < num_elements; i++) {                                                                    \
            value_indicies[i] = i;                                                                                     \
        }                                                                                                              \
                                                                                                                       \
        jak_vector ofType(jak_archive_field_sid_t) key_cpy;                                                               \
        jak_vector ofType(jak_vector) value_cpy;                                                                   \
                                                                                                                       \
        jak_vector_cpy(&key_cpy, &key_vector);                                                                         \
        jak_vector_cpy(&value_cpy, &value_array_vector);                                                               \
                                                                                                                       \
        const jak_vector *values = JAK_VECTOR_ALL(&value_array_vector, jak_vector);                             \
                                                                                                                       \
        jak_sort_qsort_indicies(value_indicies, values, sizeof(jak_vector), compare_func, num_elements,           \
                      key_vector.allocator);                                                                           \
                                                                                                                       \
        for (size_t i = 0; i < num_elements; i++) {                                                                    \
            jak_vector_set(&key_vector, i, JAK_VECTOR_GET(&key_cpy, value_indicies[i], jak_archive_field_sid_t));        \
            jak_vector_set(&value_array_vector, i, JAK_VECTOR_GET(&value_cpy, value_indicies[i], jak_vector));    \
        }                                                                                                              \
                                                                                                                       \
        free(value_indicies);                                                                                          \
        jak_vector_drop(&key_cpy);                                                                                     \
        jak_vector_drop(&value_cpy);                                                                                   \
    }                                                                                                                  \
}

static void sort_jak_columndoc_strings_arrays(jak_vector ofType(jak_archive_field_sid_t) *key_vector,
                                          jak_vector ofType(jak_archive_field_sid_t) *value_array_vector,
                                          jak_string_dict *dic)
{
        size_t num_elements = jak_vector_length(key_vector);

        if (num_elements > 0) {
                size_t *value_indicies = JAK_MALLOC(sizeof(size_t) * num_elements);
                for (size_t i = 0; i < num_elements; i++) {
                        value_indicies[i] = i;
                }

                jak_vector ofType(jak_archive_field_sid_t) key_cpy;
                jak_vector ofType(jak_vector) value_cpy;

                jak_vector_cpy(&key_cpy, key_vector);
                jak_vector_cpy(&value_cpy, value_array_vector);

                const jak_vector *values = JAK_VECTOR_ALL(value_array_vector, jak_vector);

                jak_sort_qsort_indicies_wargs(value_indicies,
                                          values,
                                          sizeof(jak_vector),
                                          compare_encoded_jak_string_array_less_eq_func,
                                          num_elements,
                                          key_vector->allocator,
                                          dic);

                for (size_t i = 0; i < num_elements; i++) {
                        jak_vector_set(key_vector, i, JAK_VECTOR_GET(&key_cpy, value_indicies[i], jak_archive_field_sid_t));
                        jak_vector_set(value_array_vector, i, JAK_VECTOR_GET(&value_cpy, value_indicies[i], jak_vector));
                }

                free(value_indicies);
                jak_vector_drop(&key_cpy);
                jak_vector_drop(&value_cpy);
        }
}

static bool compare_object_array_key_columns_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        jak_string_dict *dic = (jak_string_dict *) args;
        jak_column_doc_group *a = (jak_column_doc_group *) lhs;
        jak_column_doc_group *b = (jak_column_doc_group *) rhs;
        char **a_column_name = jak_string_dict_extract(dic, &a->key, 1);
        char **b_column_name = jak_string_dict_extract(dic, &b->key, 1);
        bool column_name_leq = strcmp(*a_column_name, *b_column_name) <= 0;
        jak_string_dict_free(dic, a_column_name);
        jak_string_dict_free(dic, b_column_name);
        return column_name_leq;
}

static bool compare_object_array_key_column_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        jak_string_dict *dic = (jak_string_dict *) args;
        jak_column_doc_column *a = (jak_column_doc_column *) lhs;
        jak_column_doc_column *b = (jak_column_doc_column *) rhs;
        char **a_column_name = jak_string_dict_extract(dic, &a->key_name, 1);
        char **b_column_name = jak_string_dict_extract(dic, &b->key_name, 1);
        int cmpResult = strcmp(*a_column_name, *b_column_name);
        bool column_name_leq = cmpResult < 0 ? true : (cmpResult == 0 ? (a->type <= b->type) : false);
        jak_string_dict_free(dic, a_column_name);
        jak_string_dict_free(dic, b_column_name);
        return column_name_leq;
}

struct com_column_leq_arg {
        jak_string_dict *dic;
        jak_archive_field_e value_type;
};

#define ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, type, valueVectorAPtr, valueVectorBPtr)                                 \
{                                                                                                                      \
    for (size_t i = 0; i < max_num_elem; i++) {                                                                        \
        type o1 = *JAK_VECTOR_GET(valueVectorAPtr, i, type);                                                        \
        type o2 = *JAK_VECTOR_GET(valueVectorBPtr, i, type);                                                        \
        if (o1 > o2) {                                                                                                 \
            return false;                                                                                              \
        }                                                                                                              \
    }                                                                                                                  \
    return true;                                                                                                       \
}

static bool compare_column_less_eq_func(const void *lhs, const void *rhs, void *args)
{
        jak_vector ofType(<T>) *a = (jak_vector *) lhs;
        jak_vector ofType(<T>) *b = (jak_vector *) rhs;
        struct com_column_leq_arg *func_arg = (struct com_column_leq_arg *) args;

        size_t max_num_elem = JAK_MIN(a->num_elems, b->num_elems);

        switch (func_arg->value_type) {
                case JAK_FIELD_NULL:
                        return (a->num_elems <= b->num_elems);
                        break;
                case JAK_FIELD_BOOLEAN: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_boolean_t, a, b);
                        break;
                case JAK_FIELD_INT8: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_i8_t, a, b);
                        break;
                case JAK_FIELD_INT16: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_i16_t, a, b);
                        break;
                case JAK_FIELD_INT32: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_i32_t, a, b);
                        break;
                case JAK_FIELD_INT64: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_i64_t, a, b);
                        break;
                case JAK_FIELD_UINT8: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_u8_t, a, b);
                        break;
                case JAK_FIELD_UINT16: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_u16_t, a, b);
                        break;
                case JAK_FIELD_UINT32: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_u32_t, a, b);
                        break;
                case JAK_FIELD_UINT64: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_u64_t, a, b);
                        break;
                case JAK_FIELD_FLOAT: ARRAY_LEQ_PRIMITIVE_FUNC(max_num_elem, jak_archive_field_number_t, a, b);
                        break;
                case JAK_FIELD_STRING:
                        for (size_t i = 0; i < max_num_elem; i++) {
                                jak_archive_field_sid_t o1 = *JAK_VECTOR_GET(a, i, jak_archive_field_sid_t);
                                jak_archive_field_sid_t o2 = *JAK_VECTOR_GET(b, i, jak_archive_field_sid_t);
                                char **o1_string = jak_string_dict_extract(func_arg->dic, &o1, 1);
                                char **o2_string = jak_string_dict_extract(func_arg->dic, &o2, 1);
                                bool greater = strcmp(*o1_string, *o2_string) > 0;
                                jak_string_dict_free(func_arg->dic, o1_string);
                                jak_string_dict_free(func_arg->dic, o2_string);
                                if (greater) {
                                        return false;
                                }
                        }
                        return true;
                case JAK_FIELD_OBJECT:
                        return true;
                        break;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_NOTYPE)
                        return false;
        }
}

static void sort_jak_columndoc_column(jak_column_doc_column *column, jak_string_dict *dic)
{
        /** Sort column by its value, and re-arrange the array position list according this new order */
        jak_vector ofType(jak_u32) array_position_cpy;
        jak_vector ofType(jak_vector ofType(<T>)) values_cpy;

        jak_vector_cpy(&array_position_cpy, &column->array_positions);
        jak_vector_cpy(&values_cpy, &column->values);

        JAK_ASSERT(column->array_positions.num_elems == column->values.num_elems);
        JAK_ASSERT(array_position_cpy.num_elems == values_cpy.num_elems);
        JAK_ASSERT(values_cpy.num_elems == column->array_positions.num_elems);

        size_t *indices = JAK_MALLOC(values_cpy.num_elems * sizeof(size_t));
        for (size_t i = 0; i < values_cpy.num_elems; i++) {
                indices[i] = i;
        }

        struct com_column_leq_arg func_arg = {.dic = dic, .value_type = column->type};

        jak_sort_qsort_indicies_wargs(indices,
                                  values_cpy.base,
                                  values_cpy.elem_size,
                                  compare_column_less_eq_func,
                                  values_cpy.num_elems,
                                  values_cpy.allocator,
                                  &func_arg);

        for (size_t i = 0; i < values_cpy.num_elems; i++) {
                jak_vector_set(&column->values, i, jak_vector_at(&values_cpy, indices[i]));
                jak_vector_set(&column->array_positions, i, jak_vector_at(&array_position_cpy, indices[i]));
        }

        free(indices);
        jak_vector_drop(&array_position_cpy);
        jak_vector_drop(&values_cpy);
}

static void sort_jak_columndoc_column_arrays(jak_column_doc_obj *columndoc)
{
        jak_vector ofType(jak_column_doc_group) cpy;
        jak_vector_cpy(&cpy, &columndoc->obj_array_props);
        size_t *indices = JAK_MALLOC(cpy.num_elems * sizeof(size_t));
        for (size_t i = 0; i < cpy.num_elems; i++) {
                indices[i] = i;
        }
        jak_sort_qsort_indicies_wargs(indices,
                                  cpy.base,
                                  sizeof(jak_column_doc_group),
                                  compare_object_array_key_columns_less_eq_func,
                                  cpy.num_elems,
                                  cpy.allocator,
                                  columndoc->parent->dic);
        for (size_t i = 0; i < cpy.num_elems; i++) {
                jak_vector_set(&columndoc->obj_array_props, i, JAK_VECTOR_GET(&cpy, indices[i], jak_column_doc_group));
        }
        free(indices);

        for (size_t i = 0; i < cpy.num_elems; i++) {
                jak_column_doc_group *key_columns = JAK_VECTOR_GET(&columndoc->obj_array_props, i,
                                                                   jak_column_doc_group);
                size_t *columnIndices = JAK_MALLOC(key_columns->columns.num_elems * sizeof(size_t));
                jak_vector ofType(jak_column_doc_column) columnCpy;
                jak_vector_cpy(&columnCpy, &key_columns->columns);
                for (size_t i = 0; i < key_columns->columns.num_elems; i++) {
                        columnIndices[i] = i;
                }

                /** First, sort by column name; Then, sort by columns with same name by type */
                jak_sort_qsort_indicies_wargs(columnIndices,
                                          columnCpy.base,
                                          sizeof(jak_column_doc_column),
                                          compare_object_array_key_column_less_eq_func,
                                          key_columns->columns.num_elems,
                                          key_columns->columns.allocator,
                                          columndoc->parent->dic);
                for (size_t i = 0; i < key_columns->columns.num_elems; i++) {
                        jak_vector_set(&key_columns->columns,
                                i,
                                JAK_VECTOR_GET(&columnCpy, columnIndices[i], jak_column_doc_column));
                        jak_column_doc_column *column = JAK_VECTOR_GET(&key_columns->columns, i,
                                                                       jak_column_doc_column);
                        sort_jak_columndoc_column(column, columndoc->parent->dic);
                }

                jak_vector_drop(&columnCpy);
                free(columnIndices);
        }
        jak_vector_drop(&cpy);
}

static void sort_jak_columndoc_values(jak_column_doc_obj *columndoc)
{
        if (columndoc->parent->read_optimized) {
                SORT_META_MODEL_VALUES(columndoc->bool_prop_keys,
                                       columndoc->bool_prop_vals,
                                       jak_archive_field_boolean_t,
                                       compare_field_boolean_t_leq);
                SORT_META_MODEL_VALUES(columndoc->int8_prop_keys,
                                       columndoc->int8_prop_vals,
                                       jak_archive_field_i8_t,
                                       compare_field_i8_t_leq);
                SORT_META_MODEL_VALUES(columndoc->int16_prop_keys,
                                       columndoc->int16_prop_vals,
                                       jak_archive_field_i16_t,
                                       compare_field_i16_t_leq);
                SORT_META_MODEL_VALUES(columndoc->int32_prop_keys,
                                       columndoc->int32_prop_vals,
                                       jak_archive_field_i32_t,
                                       compare_field_i32_t_leq);
                SORT_META_MODEL_VALUES(columndoc->int64_prop_keys,
                                       columndoc->int64_prop_vals,
                                       jak_archive_field_i64_t,
                                       compare_field_i64_t_leq);
                SORT_META_MODEL_VALUES(columndoc->uint8_prop_keys,
                                       columndoc->uint8_prop_vals,
                                       jak_archive_field_u8_t,
                                       compare_field_u8_t_leq);
                SORT_META_MODEL_VALUES(columndoc->uint16_prop_keys,
                                       columndoc->uint16_prop_vals,
                                       jak_archive_field_u16_t,
                                       compare_field_u16_t_leq);
                SORT_META_MODEL_VALUES(columndoc->uin32_prop_keys,
                                       columndoc->uint32_prop_vals,
                                       jak_archive_field_u32_t,
                                       compare_field_u32_t_leq);
                SORT_META_MODEL_VALUES(columndoc->uint64_prop_keys,
                                       columndoc->uint64_prop_vals,
                                       jak_archive_field_u64_t,
                                       compare_field_u64_t_leq);
                SORT_META_MODEL_VALUES(columndoc->float_prop_keys,
                                       columndoc->float_prop_vals,
                                       jak_archive_field_number_t,
                                       compare_field_number_t_leq);
                sort_meta_model_jak_string_values(&columndoc->jak_string_prop_keys,
                                              &columndoc->jak_string_prop_vals,
                                              columndoc->parent->dic);

                SORT_META_MODEL_ARRAYS(columndoc->bool_array_prop_keys,
                                       columndoc->bool_array_prop_vals,
                                       compare_field_boolean_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->int8_array_prop_keys,
                                       columndoc->int8_array_prop_vals,
                                       compare_field_i8_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->int16_array_prop_keys,
                                       columndoc->int16_array_prop_vals,
                                       compare_field_i16_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->int32_array_prop_keys,
                                       columndoc->int32_array_prop_vals,
                                       compare_field_i32_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->int64_array_prop_keys,
                                       columndoc->int64_array_prop_vals,
                                       compare_field_i64_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->uint8_array_prop_keys,
                                       columndoc->uint8_array_prop_vals,
                                       compare_field_u8_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->uint16_array_prop_keys,
                                       columndoc->uint16_array_prop_vals,
                                       compare_field_u16_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->uint32_array_prop_keys,
                                       columndoc->uint32_array_prop_vals,
                                       compare_field_u32_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->uint64_array_prop_keys,
                                       columndoc->ui64_array_prop_vals,
                                       compare_field_u64_t_array_leq);
                SORT_META_MODEL_ARRAYS(columndoc->float_array_prop_keys,
                                       columndoc->float_array_prop_vals,
                                       compare_field_number_t_array_leq);
                sort_jak_columndoc_strings_arrays(&columndoc->jak_string_array_prop_keys,
                                              &columndoc->jak_string_array_prop_vals,
                                              columndoc->parent->dic);

                sort_jak_columndoc_column_arrays(columndoc);
        }
}

static void sort_jak_columndoc_entries(jak_column_doc_obj *columndoc)
{
        if (columndoc->parent->read_optimized) {
                sort_jak_columndoc_values(columndoc);
                sort_nested_primitive_object(columndoc);
                sorted_nested_array_objects(columndoc);
        }
}

jak_column_doc *jak_doc_entries_columndoc(const jak_doc_bulk *bulk, const jak_doc_entries *partition,
                                             bool read_optimized)
{
        if (!bulk || !partition) {
                return NULL;
        }

        // Step 1: encode all strings at once in a bulk
        char *const *key_strings = JAK_VECTOR_ALL(&bulk->keys, char *);
        char *const *valueStrings = JAK_VECTOR_ALL(&bulk->values, char *);
        jak_string_dict_insert(bulk->dic, NULL, key_strings, jak_vector_length(&bulk->keys), 0);
        jak_string_dict_insert(bulk->dic, NULL, valueStrings, jak_vector_length(&bulk->values), 0);

        // Step 2: for each document doc, create a meta doc, and construct a binary compressed document
        const jak_doc *models = JAK_VECTOR_ALL(&bulk->models, jak_doc);
        JAK_ASSERT (bulk->models.num_elems == 1);

        const jak_doc *model = models;

        jak_column_doc *columndoc = JAK_MALLOC(sizeof(jak_column_doc));
        columndoc->read_optimized = read_optimized;
        jak_error err;
        if (!jak_columndoc_create(columndoc, &err, model, bulk, partition, bulk->dic)) {
                jak_error_print_and_abort(&err);
        }

        if (columndoc->read_optimized) {
                sort_jak_columndoc_entries(&columndoc->columndoc);
        }

        return columndoc;
}

bool jak_doc_entries_drop(jak_doc_entries *partition)
{
        JAK_UNUSED(partition);
        return true;
}

static void create_doc(jak_doc_obj *model, jak_doc *doc)
{
        jak_vector_create(&model->entries, NULL, sizeof(jak_doc_entries), 50);
        model->doc = doc;
}

static void create_typed_vector(jak_doc_entries *entry)
{
        size_t size;
        switch (entry->type) {
                case JAK_FIELD_NULL:
                        size = sizeof(field_null_t);
                        break;
                case JAK_FIELD_BOOLEAN:
                        size = sizeof(jak_archive_field_boolean_t);
                        break;
                case JAK_FIELD_INT8:
                        size = sizeof(jak_archive_field_i8_t);
                        break;
                case JAK_FIELD_INT16:
                        size = sizeof(jak_archive_field_i16_t);
                        break;
                case JAK_FIELD_INT32:
                        size = sizeof(jak_archive_field_i32_t);
                        break;
                case JAK_FIELD_INT64:
                        size = sizeof(jak_archive_field_i64_t);
                        break;
                case JAK_FIELD_UINT8:
                        size = sizeof(jak_archive_field_u8_t);
                        break;
                case JAK_FIELD_UINT16:
                        size = sizeof(jak_archive_field_u16_t);
                        break;
                case JAK_FIELD_UINT32:
                        size = sizeof(jak_archive_field_u32_t);
                        break;
                case JAK_FIELD_UINT64:
                        size = sizeof(jak_archive_field_u64_t);
                        break;
                case JAK_FIELD_FLOAT:
                        size = sizeof(jak_archive_field_number_t);
                        break;
                case JAK_FIELD_STRING:
                        size = sizeof(field_jak_string_t);
                        break;
                case JAK_FIELD_OBJECT:
                        size = sizeof(jak_doc_obj);
                        break;
                default: JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR) /** unknown type */
                        return;
        }
        jak_vector_create(&entry->values, NULL, size, 50);
}

static void entries_drop(jak_doc_entries *entry)
{
        if (entry->type == JAK_FIELD_OBJECT) {
                for (size_t i = 0; i < entry->values.num_elems; i++) {
                        jak_doc_obj *model = JAK_VECTOR_GET(&entry->values, i, jak_doc_obj);
                        jak_doc_drop(model);
                }
        }
        jak_vector_drop(&entry->values);
}

static bool print_value(FILE *file, jak_archive_field_e type, const jak_vector ofType(<T>) *values)
{
        size_t num_values = values->num_elems;
        if (num_values == 0) {
                fprintf(file, "null");
                return true;
        }
        if (num_values > 1) {
                fprintf(file, "[");
        }
        switch (type) {
                case JAK_FIELD_NULL: {
                        for (size_t i = 0; i < num_values; i++) {
                                fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                        }
                }
                        break;
                case JAK_FIELD_BOOLEAN: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_boolean_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_boolean_t));
                                if (value != JAK_NULL_BOOLEAN) {
                                        fprintf(file, "%s%s", value == 0 ? "false" : "true",
                                                i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_INT8: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_i8_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_i8_t));
                                if (value != JAK_NULL_INT8) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_INT16: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_i16_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_i16_t));
                                if (value != JAK_NULL_INT16) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_INT32: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_i32_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_i32_t));
                                if (value != JAK_NULL_INT32) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_INT64: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_i64_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_i64_t));
                                if (value != JAK_NULL_INT64) {
                                        fprintf(file, "%" PRIi64 "%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_UINT8: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_u8_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_u8_t));
                                if (value != JAK_NULL_UINT8) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_UINT16: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_u16_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_u16_t));
                                if (value != JAK_NULL_UINT16) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_UINT32: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_u32_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_u32_t));
                                if (value != JAK_NULL_UINT32) {
                                        fprintf(file, "%d%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_UINT64: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_u64_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_u64_t));
                                if (value != JAK_NULL_UINT64) {
                                        fprintf(file, "%" PRIu64 "%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_FLOAT: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_archive_field_number_t value = *(JAK_VECTOR_GET(values, i, jak_archive_field_number_t));
                                if (!isnan(value)) {
                                        fprintf(file, "%f%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_STRING: {
                        for (size_t i = 0; i < num_values; i++) {
                                field_jak_string_t value = *(JAK_VECTOR_GET(values, i, field_jak_string_t));
                                if (value) {
                                        fprintf(file, "\"%s\"%s", value, i + 1 < num_values ? ", " : "");
                                } else {
                                        fprintf(file, "null%s", i + 1 < num_values ? ", " : "");
                                }
                        }
                }
                        break;
                case JAK_FIELD_OBJECT: {
                        for (size_t i = 0; i < num_values; i++) {
                                jak_doc_obj *obj = JAK_VECTOR_GET(values, i, jak_doc_obj);
                                if (!JAK_NULL_OBJECT_MODEL(obj)) {
                                        _jak_doc_print_object(file, obj);
                                } else {
                                        fprintf(file, "null");
                                }
                                fprintf(file, "%s", i + 1 < num_values ? ", " : "");
                        }
                }
                        break;
                default: JAK_NOT_IMPLEMENTED;
        }
        if (num_values > 1) {
                fprintf(file, "]");
        }
        return true;
}

static void _jak_doc_print_object(FILE *file, const jak_doc_obj *model)
{
        fprintf(file, "{");
        for (size_t i = 0; i < model->entries.num_elems; i++) {
                jak_doc_entries *entry = JAK_VECTOR_GET(&model->entries, i, jak_doc_entries);
                fprintf(file, "\"%s\": ", entry->key);
                print_value(file, entry->type, &entry->values);
                fprintf(file, "%s", i + 1 < model->entries.num_elems ? ", " : "");
        }
        fprintf(file, "}");
}

/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_alloc.h>
#include <jak_vector.h>
#include <jak_encode_sync.h>
#include <jak_encode_async.h>
#include <jak_spinlock.h>
#include <jak_str_hash.h>
#include <jak_time.h>
#include <jak_async.h>
#include <jak_slicelist.h>
#include <jak_hash.h>

#define STRING_DIC_ASYNC_TAG "jak_string_dict_async"

#define HASH_FUNCTION                  JAK_HASH_SAX

struct carrier {
        jak_string_dict local_dictionary;
        pthread_t thread;
        size_t id;
};

struct async_extra {
        jak_vector ofType(carrier) carriers;
        jak_vector ofType(struct carrier *) carrier_mapping;
        jak_spinlock lock;
};

struct parallel_insert_arg {
        jak_vector ofType(char *) strings;
        jak_archive_field_sid_t *out;
        struct carrier *carrier;
        bool enable_write_out;
        bool did_work;
        uint_fast16_t insert_num_threads;
};

struct parallel_remove_arg {
        jak_vector ofType(jak_archive_field_sid_t) *local_ids;
        struct carrier *carrier;
        int result;
        bool did_work;
};

struct parallel_locate_arg {
        struct carrier *carrier;
        jak_archive_field_sid_t *ids_out;
        bool *found_mask_out;
        size_t num_not_found_out;
        jak_vector ofType(char *) keys_in;
        int result;
        bool did_work;
};

struct parallel_extract_arg {
        jak_vector ofType(jak_archive_field_sid_t) local_ids_in;
        char **strings_out;
        struct carrier *carrier;
        bool did_work;
};

#define _JAK_ENCODE_ASYNC_HASHCODE_OF(string)                                                                                            \
    HASH_FUNCTION(strlen(string), string)

#define MAKE_GLOBAL(thread_id, localjak_string_id_t)                                                                \
    ((thread_id << 54) | localjak_string_id_t)

#define GET_OWNER(globalId)                                                                                            \
    (globalId >> 54)

#define GET_jak_string_id_t(globalId)                                                                               \
    ((~((jak_archive_field_sid_t) 0)) >> 10 & global_jak_string_id);

static bool _jak_encode_async_drop(jak_string_dict *self);

static bool
_jak_encode_async_insert(jak_string_dict *self, jak_archive_field_sid_t **out, char *const *strings, size_t num_strings,
            size_t __num_threads);

static bool _jak_encode_async_remove(jak_string_dict *self, jak_archive_field_sid_t *strings, size_t num_strings);

static bool
_jak_encode_async_locate_safe(jak_string_dict *self, jak_archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
                 char *const *keys, size_t num_keys);

static bool
_jak_encode_async_locate_fast(jak_string_dict *self, jak_archive_field_sid_t **out, char *const *keys, size_t num_keys);

static char **_jak_encode_async_locate_extract(jak_string_dict *self, const jak_archive_field_sid_t *ids, size_t num_ids);

static bool _jak_encode_async_free(jak_string_dict *self, void *ptr);

static bool _jak_encode_async_num_distinct(jak_string_dict *self, size_t *num);

static bool _jak_encode_async_get_contents(jak_string_dict *self, jak_vector ofType (char *) *strings,
                              jak_vector ofType(jak_archive_field_sid_t) *jak_string_ids);

static bool _jak_encode_async_reset_counters(jak_string_dict *self);

static bool _jak_encode_async_counters(jak_string_dict *self, jak_str_hash_counters *counters);

static bool this_lock(jak_string_dict *self);

static bool this_unlock(jak_string_dict *self);

static bool _jak_encode_async_create_extra(jak_string_dict *self, size_t capacity, size_t num_index_buckets,
                              size_t approx_num_unique_str, size_t num_threads);

static bool this_setup_carriers(jak_string_dict *self, size_t capacity, size_t num_index_buckets,
                                size_t approx_num_unique_str, size_t num_threads);

#define THIS_EXTRAS(self)                                                                                              \
({                                                                                                                     \
    JAK_CHECK_TAG(self->tag, JAK_ASYNC);                                                             \
    (struct async_extra *) self->extra;                                                                                       \
})

int jak_encode_async_create(jak_string_dict *dic, size_t capacity, size_t num_index_buckets,
                        size_t approx_num_unique_strs, size_t num_threads, const jak_allocator *alloc)
{
        JAK_CHECK_SUCCESS(jak_alloc_this_or_std(&dic->alloc, alloc));

        dic->tag = JAK_ASYNC;
        dic->drop = _jak_encode_async_drop;
        dic->insert = _jak_encode_async_insert;
        dic->remove = _jak_encode_async_remove;
        dic->locate_safe = _jak_encode_async_locate_safe;
        dic->locate_fast = _jak_encode_async_locate_fast;
        dic->extract = _jak_encode_async_locate_extract;
        dic->free = _jak_encode_async_free;
        dic->resetCounters = _jak_encode_async_reset_counters;
        dic->counters = _jak_encode_async_counters;
        dic->num_distinct = _jak_encode_async_num_distinct;
        dic->get_contents = _jak_encode_async_get_contents;

        JAK_CHECK_SUCCESS(_jak_encode_async_create_extra(dic, capacity, num_index_buckets, approx_num_unique_strs, num_threads));
        return true;
}

static bool _jak_encode_async_create_extra(jak_string_dict *self, size_t capacity, size_t num_index_buckets,
                              size_t approx_num_unique_str, size_t num_threads)
{
        JAK_ASSERT(self);

        self->extra = jak_alloc_malloc(&self->alloc, sizeof(struct async_extra));
        struct async_extra *extra = THIS_EXTRAS(self);
        jak_spinlock_init(&extra->lock);
        jak_vector_create(&extra->carriers, &self->alloc, sizeof(struct carrier), num_threads);
        this_setup_carriers(self, capacity, num_index_buckets, approx_num_unique_str, num_threads);
        jak_vector_create(&extra->carrier_mapping, &self->alloc, sizeof(struct carrier *), capacity);

        return true;
}

static bool _jak_encode_async_drop(jak_string_dict *self)
{
        JAK_CHECK_TAG(self->tag, JAK_ASYNC);
        struct async_extra *extra = THIS_EXTRAS(self);
        for (size_t i = 0; i < extra->carriers.num_elems; i++) {
                struct carrier *carrier = JAK_VECTOR_GET(&extra->carriers, i, struct carrier);
                jak_string_dict_drop(&carrier->local_dictionary);
        }
        JAK_CHECK_SUCCESS(jak_vector_drop(&extra->carriers));
        JAK_CHECK_SUCCESS(jak_vector_drop(&extra->carrier_mapping));
        JAK_CHECK_SUCCESS(jak_alloc_free(&self->alloc, extra));
        return true;
}

void *parallel_remove_function(void *args)
{
        struct parallel_remove_arg *carrier_arg = (struct parallel_remove_arg *) args;
        jak_archive_field_sid_t len = jak_vector_length(carrier_arg->local_ids);
        carrier_arg->did_work = len > 0;

        JAK_DEBUG(STRING_DIC_ASYNC_TAG,
                  "thread %zu spawned for remove task (%zu elements)",
                  carrier_arg->carrier->id,
                  jak_vector_length(carrier_arg->local_ids));
        if (len > 0) {
                jak_string_dict *dic = &carrier_arg->carrier->local_dictionary;
                jak_archive_field_sid_t *ids = JAK_VECTOR_ALL(carrier_arg->local_ids, jak_archive_field_sid_t);
                carrier_arg->result = jak_string_dict_remove(dic, ids, len);
                JAK_DEBUG(STRING_DIC_ASYNC_TAG, "thread %zu task done", carrier_arg->carrier->id);
        } else {
                carrier_arg->result = true;
                JAK_WARN(STRING_DIC_ASYNC_TAG, "thread %zu had nothing to do", carrier_arg->carrier->id);
        }

        return NULL;
}

void *parallel_insert_function(void *args)
{
        struct parallel_insert_arg *restrict this_args = (struct parallel_insert_arg *restrict) args;
        this_args->did_work = this_args->strings.num_elems > 0;

        JAK_TRACE(STRING_DIC_ASYNC_TAG, "thread-local insert function started (thread %zu)", this_args->carrier->id);
        JAK_DEBUG(STRING_DIC_ASYNC_TAG,
                  "thread %zu spawned for insert task (%zu elements)",
                  this_args->carrier->id,
                  jak_vector_length(&this_args->strings));

        if (this_args->did_work) {
                JAK_TRACE(STRING_DIC_ASYNC_TAG,
                          "thread %zu starts insertion of %zu strings",
                          this_args->carrier->id,
                          jak_vector_length(&this_args->strings));
                char **data = (char **) jak_vector_data(&this_args->strings);

                int status = jak_string_dict_insert(&this_args->carrier->local_dictionary,
                                           this_args->enable_write_out ? &this_args->out : NULL,
                                           data,
                                           jak_vector_length(&this_args->strings),
                                           this_args->insert_num_threads);

                /** internal JAK_ERROR during thread-local string dictionary building process */
                JAK_ERROR_PRINT_AND_DIE_IF(status != true, JAK_ERR_INTERNALERR);
                JAK_DEBUG(STRING_DIC_ASYNC_TAG, "thread %zu done", this_args->carrier->id);
        } else {
                JAK_WARN(STRING_DIC_ASYNC_TAG, "thread %zu had nothing to do", this_args->carrier->id);
        }

        return NULL;
}

void *parallel_locate_safe_function(void *args)
{
        struct parallel_locate_arg *restrict this_args = (struct parallel_locate_arg *restrict) args;
        this_args->did_work = jak_vector_length(&this_args->keys_in) > 0;

        JAK_TRACE(STRING_DIC_ASYNC_TAG,
                  "thread-local 'locate' function invoked for thread %zu...",
                  this_args->carrier->id)

        JAK_DEBUG(STRING_DIC_ASYNC_TAG,
                  "thread %zu spawned for locate (safe) task (%zu elements)",
                  this_args->carrier->id,
                  jak_vector_length(&this_args->keys_in));

        if (this_args->did_work) {
                this_args->result = jak_string_dict_locate_safe(&this_args->ids_out,
                                                       &this_args->found_mask_out,
                                                       &this_args->num_not_found_out,
                                                       &this_args->carrier->local_dictionary,
                                                       JAK_VECTOR_ALL(&this_args->keys_in, char *),
                                                       jak_vector_length(&this_args->keys_in));

                JAK_DEBUG(STRING_DIC_ASYNC_TAG, "thread %zu done", this_args->carrier->id);
        } else {
                JAK_WARN(STRING_DIC_ASYNC_TAG, "thread %zu had nothing to do", this_args->carrier->id);
        }

        return NULL;
}

void *parallel_extract_function(void *args)
{
        struct parallel_extract_arg *restrict this_args = (struct parallel_extract_arg *restrict) args;
        this_args->did_work = jak_vector_length(&this_args->local_ids_in) > 0;

        JAK_DEBUG(STRING_DIC_ASYNC_TAG,
                  "thread %zu spawned for extract task (%zu elements)",
                  this_args->carrier->id,
                  jak_vector_length(&this_args->local_ids_in));

        if (this_args->did_work) {
                this_args->strings_out = jak_string_dict_extract(&this_args->carrier->local_dictionary,
                                                        JAK_VECTOR_ALL(&this_args->local_ids_in, jak_archive_field_sid_t),
                                                        jak_vector_length(&this_args->local_ids_in));
                JAK_DEBUG(STRING_DIC_ASYNC_TAG, "thread %zu done", this_args->carrier->id);
        } else {
                JAK_WARN(STRING_DIC_ASYNC_TAG, "thread %zu had nothing to do", this_args->carrier->id);
        }

        return NULL;
}

static void synchronize(jak_vector ofType(carrier) *carriers, size_t num_threads)
{
        JAK_DEBUG(STRING_DIC_ASYNC_TAG, "barrier installed for %d threads", num_threads);

        jak_timestamp begin = jak_wallclock();
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                volatile struct carrier *carrier = JAK_VECTOR_GET(carriers, thread_id, struct carrier);
                pthread_join(carrier->thread, NULL);
                JAK_DEBUG(STRING_DIC_ASYNC_TAG, "thread %d joined", carrier->id);
        }
        jak_timestamp end = jak_wallclock();
        jak_timestamp duration = (end - begin);
        JAK_UNUSED(duration);

        JAK_DEBUG(STRING_DIC_ASYNC_TAG,
                  "barrier passed for %d threads after %f seconds",
                  num_threads,
                  duration / 1000.0f);
}

static void create_thread_assignment(atomic_uint_fast16_t **str_carrier_mapping, atomic_size_t **carrier_num_strings,
                                     size_t **str_carrier_idx_mapping, jak_allocator *alloc, size_t num_strings,
                                     size_t num_threads)
{
        /** jak_async_map_exec string depending on hash values to a particular carrier */
        *str_carrier_mapping = jak_alloc_malloc(alloc, num_strings * sizeof(atomic_uint_fast16_t));
        memset(*str_carrier_mapping, 0, num_strings * sizeof(atomic_uint_fast16_t));

        /** counters to compute how many strings go to a particular carrier */
        *carrier_num_strings = jak_alloc_malloc(alloc, num_threads * sizeof(atomic_size_t));
        memset(*carrier_num_strings, 0, num_threads * sizeof(atomic_size_t));

        /** an inverted index that contains the i-th position for string k that was assigned to carrier m.
         * With this, given a (global) string and and its carrier, one can have directly the position of the
         * string in the carriers "thread-local locate" args */
        *str_carrier_idx_mapping = jak_alloc_malloc(alloc, num_strings * sizeof(size_t));
}

static void drop_thread_assignment(jak_allocator *alloc, atomic_uint_fast16_t *str_carrier_mapping,
                                   atomic_size_t *carrier_num_strings, size_t *str_carrier_idx_mapping)
{
        jak_alloc_free(alloc, carrier_num_strings);
        jak_alloc_free(alloc, str_carrier_mapping);
        jak_alloc_free(alloc, str_carrier_idx_mapping);
}

struct thread_assign_arg {
        atomic_uint_fast16_t *str_carrier_mapping;
        size_t num_threads;
        atomic_size_t *carrier_num_strings;
        char *const *base_strings;
};

static void parallel_compute_thread_assignment_function(const void *restrict start, size_t width, size_t len,
                                                        void *restrict args, jak_thread_id_t tid)
{
        JAK_UNUSED(tid);
        JAK_UNUSED(width);

        char *const *strings = (char *const *) start;

        struct thread_assign_arg *func_args = (struct thread_assign_arg *) args;

        while (len--) {
                size_t i = strings - func_args->base_strings;
                const char *key = *strings;
                /** re-using this hashcode for the thread-local dictionary is more costly than to compute it fresh
                 * (due to more I/O with the RAM) */
                size_t thread_id = _JAK_ENCODE_ASYNC_HASHCODE_OF(key) % func_args->num_threads;
                atomic_fetch_add(&func_args->str_carrier_mapping[i], thread_id);
                atomic_fetch_add(&func_args->carrier_num_strings[thread_id], 1);
                strings++;
        }
}

static void compute_thread_assignment(atomic_uint_fast16_t *str_carrier_mapping, atomic_size_t *carrier_num_strings,
                                      char *const *strings, size_t num_strings, size_t num_threads)
{
        struct thread_assign_arg args =
                {.base_strings = strings, .carrier_num_strings = carrier_num_strings, .num_threads = num_threads, .str_carrier_mapping = str_carrier_mapping};
        jak_for(strings,
                sizeof(char *const *),
                num_strings,
                parallel_compute_thread_assignment_function,
                &args,
                JAK_THREADING_HINT_MULTI,
                num_threads);

}

static bool
_jak_encode_async_insert(jak_string_dict *self, jak_archive_field_sid_t **out, char *const *strings, size_t num_strings,
            size_t __num_threads)
{
        jak_timestamp begin = jak_wallclock();
        JAK_INFO(STRING_DIC_ASYNC_TAG, "insert operation invoked: %zu strings in total", num_strings)

        JAK_CHECK_TAG(self->tag, JAK_ASYNC);
        /** parameter 'num_threads' must be set to 0 for async dictionary */
        JAK_ERROR_PRINT_AND_DIE_IF(__num_threads != 0, JAK_ERR_INTERNALERR);

        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        uint_fast16_t num_threads = jak_vector_length(&extra->carriers);

        atomic_uint_fast16_t *str_carrier_mapping;
        size_t *str_carrier_idx_mapping;
        atomic_size_t *carrier_num_strings;

        create_thread_assignment(&str_carrier_mapping,
                                 &carrier_num_strings,
                                 &str_carrier_idx_mapping,
                                 &self->alloc,
                                 num_strings,
                                 num_threads);

        jak_vector ofType(struct parallel_insert_arg *) carrier_args;
        jak_vector_create(&carrier_args, &self->alloc, sizeof(struct parallel_insert_arg *), num_threads);

        /** compute which carrier is responsible for which string */
        compute_thread_assignment(str_carrier_mapping, carrier_num_strings, strings, num_strings, num_threads);

        /** prepare to move string subsets to carriers */
        for (uint_fast16_t i = 0; i < num_threads; i++) {
                struct parallel_insert_arg *entry = jak_alloc_malloc(&self->alloc, sizeof(struct parallel_insert_arg));
                entry->carrier = JAK_VECTOR_GET(&extra->carriers, i, struct carrier);
                entry->insert_num_threads = num_threads;

                jak_vector_create(&entry->strings, &self->alloc, sizeof(char *), JAK_MAX(1, carrier_num_strings[i]));
                jak_vector_push(&carrier_args, &entry, 1);
                JAK_ASSERT (entry->strings.base != NULL);

                struct parallel_insert_arg *carrier_arg = *JAK_VECTOR_GET(&carrier_args, i, struct parallel_insert_arg *);
                carrier_arg->out = NULL;
        }

        /** create per-carrier string subset */
        /** parallizing this makes no sense but waste of resources and energy */
        for (size_t i = 0; i < num_strings; i++) {
                uint_fast16_t thread_id = str_carrier_mapping[i];
                struct parallel_insert_arg
                        *carrier_arg = *JAK_VECTOR_GET(&carrier_args, thread_id, struct parallel_insert_arg *);
                carrier_arg->enable_write_out = out != NULL;

                /** store local index of string i inside the thread */
                str_carrier_idx_mapping[i] = jak_vector_length(&carrier_arg->strings);

                jak_vector_push(&carrier_arg->strings, &strings[i], 1);
        }


        /** schedule insert operation per carrier */
        JAK_TRACE(STRING_DIC_ASYNC_TAG, "schedule insert operation to %zu threads", num_threads)
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_insert_arg
                        *carrier_arg = *JAK_VECTOR_GET(&carrier_args, thread_id, struct parallel_insert_arg *);
                struct carrier *carrier = JAK_VECTOR_GET(&extra->carriers, thread_id, struct carrier);
                JAK_TRACE(STRING_DIC_ASYNC_TAG, "create thread %zu...", thread_id)
                pthread_create(&carrier->thread, NULL, parallel_insert_function, carrier_arg);
                JAK_TRACE(STRING_DIC_ASYNC_TAG, "thread %zu created", thread_id)
        }
        JAK_TRACE(STRING_DIC_ASYNC_TAG, "scheduling done for %zu threads", num_threads)

        /** synchronize */
        JAK_TRACE(STRING_DIC_ASYNC_TAG, "start synchronizing %zu threads", num_threads)
        synchronize(&extra->carriers, num_threads);
        JAK_TRACE(STRING_DIC_ASYNC_TAG, "%zu threads in sync", num_threads)

        /** compute string ids; the string id produced by this implementation is a compound identifier encoding
         * both the owning thread id and the thread-local string id. For this, the returned (global) string identifier
         * is split into 10bits encoded the thread (given a maximum of 1024 threads that can be handled by this
         * implementation), and 54bits used to encode the thread-local string id
         *
         * TECHNICAL LIMIT: 1024 threads
         */

        /** optionally, return the created string ids. In case 'out' is NULL, nothing has to be done (especially
         * none of the carrier threads allocated thread-local 'out's which mean that no cleanup must be done */

        /** parallelizing the following block makes no sense but waste of compute power and energy */
        if (JAK_LIKELY(out != NULL)) {
                jak_archive_field_sid_t *total_out = jak_alloc_malloc(&self->alloc,
                                                                      num_strings * sizeof(jak_archive_field_sid_t));
                size_t currentOut = 0;

                for (size_t jak_string_idx = 0; jak_string_idx < num_strings; jak_string_idx++) {
                        uint_fast16_t thread_id = str_carrier_mapping[jak_string_idx];
                        size_t localIdx = str_carrier_idx_mapping[jak_string_idx];
                        struct parallel_insert_arg
                                *carrier_arg = *JAK_VECTOR_GET(&carrier_args, thread_id, struct parallel_insert_arg *);
                        jak_archive_field_sid_t global_jak_string_owner_id = thread_id;
                        jak_archive_field_sid_t global_jak_string_local_id = carrier_arg->out[localIdx];
                        jak_archive_field_sid_t global_jak_string_id = MAKE_GLOBAL(global_jak_string_owner_id,
                                                                               global_jak_string_local_id);
                        total_out[currentOut++] = global_jak_string_id;
                }

                *out = total_out;
        }

        /** cleanup */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_insert_arg
                        *carrier_arg = *JAK_VECTOR_GET(&carrier_args, thread_id, struct parallel_insert_arg *);
                if (carrier_arg->did_work) {
                        jak_string_dict_free(&carrier_arg->carrier->local_dictionary, carrier_arg->out);
                }
                jak_vector_drop(&carrier_arg->strings);
                jak_alloc_free(&self->alloc, carrier_arg);
        }

        /** cleanup */
        drop_thread_assignment(&self->alloc, str_carrier_mapping, carrier_num_strings, str_carrier_idx_mapping);
        jak_vector_drop(&carrier_args);

        this_unlock(self);

        jak_timestamp end = jak_wallclock();
        JAK_UNUSED(begin);
        JAK_UNUSED(end);
        JAK_INFO(STRING_DIC_ASYNC_TAG, "insertion operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;
}

static bool _jak_encode_async_remove(jak_string_dict *self, jak_archive_field_sid_t *strings, size_t num_strings)
{
        jak_timestamp begin = jak_wallclock();
        JAK_INFO(STRING_DIC_ASYNC_TAG, "remove operation started: %zu strings to remove", num_strings);

        JAK_CHECK_TAG(self->tag, JAK_ASYNC);

        this_lock(self);

        struct parallel_remove_arg empty;
        struct async_extra *extra = THIS_EXTRAS(self);
        uint_fast16_t num_threads = jak_vector_length(&extra->carriers);
        size_t approx_num_strings_per_thread = JAK_MAX(1, num_strings / num_threads);
        jak_vector ofType(jak_archive_field_sid_t) *jak_string_map = jak_alloc_malloc(&self->alloc, num_threads *
                                                                                                       sizeof(jak_vector));

        jak_vector ofType(struct parallel_remove_arg) carrier_args;
        jak_vector_create(&carrier_args, &self->alloc, sizeof(struct parallel_remove_arg), num_threads);

        /** prepare thread-local subset of string ids */
        jak_vector_repeated_push(&carrier_args, &empty, num_threads);
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                jak_vector_create(jak_string_map + thread_id, &self->alloc, sizeof(jak_archive_field_sid_t),
                           approx_num_strings_per_thread);
        }

        /** compute subset of string ids per thread  */
        for (size_t i = 0; i < num_strings; i++) {
                jak_archive_field_sid_t global_jak_string_id = strings[i];
                uint_fast16_t owning_thread_id = GET_OWNER(global_jak_string_id);
                jak_archive_field_sid_t localjak_string_id_t = GET_jak_string_id_t(global_jak_string_id);
                JAK_ASSERT(owning_thread_id < num_threads);

                jak_vector_push(jak_string_map + owning_thread_id, &localjak_string_id_t, 1);
        }

        /** schedule remove operation per carrier */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = JAK_VECTOR_GET(&extra->carriers, thread_id, struct carrier);
                struct parallel_remove_arg *carrier_arg = JAK_VECTOR_GET(&carrier_args, thread_id, struct parallel_remove_arg);
                carrier_arg->carrier = carrier;
                carrier_arg->local_ids = jak_string_map + thread_id;

                pthread_create(&carrier->thread, NULL, parallel_remove_function, carrier_arg);
        }

        /** synchronize */
        synchronize(&extra->carriers, num_threads);

        /** cleanup */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                jak_vector_drop(jak_string_map + thread_id);
        }

        jak_alloc_free(&self->alloc, jak_string_map);
        jak_vector_data(&carrier_args);

        this_unlock(self);

        jak_timestamp end = jak_wallclock();
        JAK_UNUSED(begin);
        JAK_UNUSED(end);
        JAK_INFO(STRING_DIC_ASYNC_TAG, "remove operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;
}

static bool
_jak_encode_async_locate_safe(jak_string_dict *self, jak_archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
                 char *const *keys, size_t num_keys)
{
        jak_timestamp begin = jak_wallclock();
        JAK_INFO(STRING_DIC_ASYNC_TAG, "locate (safe) operation started: %zu strings to locate", num_keys)

        JAK_CHECK_TAG(self->tag, JAK_ASYNC);

        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        uint_fast16_t num_threads = jak_vector_length(&extra->carriers);

        /** global result output */
        JAK_ALLOC_MALLOC(jak_archive_field_sid_t, global_out, num_keys, &self->alloc);
        JAK_ALLOC_MALLOC(bool, global_found_mask, num_keys, &self->alloc);

        size_t global_num_not_found = 0;

        atomic_uint_fast16_t *str_carrier_mapping;
        size_t *str_carrier_idx_mapping;
        atomic_size_t *carrier_num_strings;

        struct parallel_locate_arg carrier_args[num_threads];

        create_thread_assignment(&str_carrier_mapping,
                                 &carrier_num_strings,
                                 &str_carrier_idx_mapping,
                                 &self->alloc,
                                 num_keys,
                                 num_threads);

        /** compute which carrier is responsible for which string */
        compute_thread_assignment(str_carrier_mapping, carrier_num_strings, keys, num_keys, num_threads);

        /** prepare to move string subsets to carriers */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_locate_arg *arg = carrier_args + thread_id;
                jak_vector_create(&arg->keys_in, &self->alloc, sizeof(char *), carrier_num_strings[thread_id]);
                JAK_ASSERT (&arg->keys_in.base != NULL);
        }

        JAK_TRACE(STRING_DIC_ASYNC_TAG, "computing per-thread string subset for %zu strings", num_keys)
        /** create per-carrier string subset */
        for (size_t i = 0; i < num_keys; i++) {
                /** get thread responsible for this particular string */
                uint_fast16_t thread_id = str_carrier_mapping[i];

                /** get the thread-local argument list for the thread that is responsible for this particular string */
                struct parallel_locate_arg *arg = carrier_args + thread_id;

                /** store local index of string i inside the thread */
                str_carrier_idx_mapping[i] = jak_vector_length(&arg->keys_in);

                /** push that string into the thread-local vector */
                jak_vector_push(&arg->keys_in, &keys[i], 1);
        }

        JAK_TRACE(STRING_DIC_ASYNC_TAG, "schedule operation to threads to %zu threads...", num_threads)
        /** schedule operation to threads */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = JAK_VECTOR_GET(&extra->carriers, thread_id, struct carrier);
                struct parallel_locate_arg *arg = carrier_args + thread_id;
                carrier_args[thread_id].carrier = carrier;
                pthread_create(&carrier->thread, NULL, parallel_locate_safe_function, arg);
        }

        /** synchronize */
        JAK_TRACE(STRING_DIC_ASYNC_TAG, "start syncing %zu threads...", num_threads)
        synchronize(&extra->carriers, num_threads);
        JAK_TRACE(STRING_DIC_ASYNC_TAG, "%zu threads in sync.", num_threads)

        /** collect and merge results */
        JAK_TRACE(STRING_DIC_ASYNC_TAG, "merging results of %zu threads", num_threads)
        for (size_t i = 0; i < num_keys; i++) {
                /** get thread responsible for this particular string, and local position of that string inside the
                 * thread storage */
                uint_fast16_t thread_id = str_carrier_mapping[i];
                size_t local_thread_idx = str_carrier_idx_mapping[i];

                /** get the thread-local argument list for the thread that is responsible for this particular string */
                struct parallel_locate_arg *arg = carrier_args + thread_id;

                /** merge into global result */
                jak_archive_field_sid_t jak_string_id_owner = thread_id;
                jak_archive_field_sid_t jak_string_id_local_idx = arg->ids_out[local_thread_idx];
                jak_archive_field_sid_t global_jak_string_id = MAKE_GLOBAL(jak_string_id_owner, jak_string_id_local_idx);
                global_out[i] = global_jak_string_id;
                global_found_mask[i] = arg->found_mask_out[local_thread_idx];
        }
        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                /** compute total number of not-found elements */
                struct parallel_locate_arg *arg = carrier_args + thread_id;
                global_num_not_found += arg->num_not_found_out;

                /** cleanup */
                if (JAK_LIKELY(arg->did_work)) {
                        jak_string_dict_free(&arg->carrier->local_dictionary, arg->found_mask_out);
                        jak_string_dict_free(&arg->carrier->local_dictionary, arg->ids_out);
                }
        }

        JAK_TRACE(STRING_DIC_ASYNC_TAG, "cleanup%s", "...")

        /** cleanup */
        drop_thread_assignment(&self->alloc, str_carrier_mapping, carrier_num_strings, str_carrier_idx_mapping);

        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_locate_arg *arg = carrier_args + thread_id;
                jak_vector_drop(&arg->keys_in);
        }

        /** return results */
        *out = global_out;
        *found_mask = global_found_mask;
        *num_not_found = global_num_not_found;

        this_unlock(self);

        jak_timestamp end = jak_wallclock();
        JAK_UNUSED(begin);
        JAK_UNUSED(end);
        JAK_INFO(STRING_DIC_ASYNC_TAG, "locate (safe) operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;
}

static bool
_jak_encode_async_locate_fast(jak_string_dict *self, jak_archive_field_sid_t **out, char *const *keys, size_t num_keys)
{
        JAK_CHECK_TAG(self->tag, JAK_ASYNC);

        this_lock(self);

        bool *found_mask;
        size_t num_not_found;
        int result;

        /** use safer but in principle more slower implementation */
        result = _jak_encode_async_locate_safe(self, out, &found_mask, &num_not_found, keys, num_keys);

        /** cleanup */
        _jak_encode_async_free(self, found_mask);

        this_unlock(self);

        return result;
}

static char **_jak_encode_async_locate_extract(jak_string_dict *self, const jak_archive_field_sid_t *ids, size_t num_ids)
{
        jak_timestamp begin = jak_wallclock();
        JAK_INFO(STRING_DIC_ASYNC_TAG, "extract (safe) operation started: %zu strings to extract", num_ids)

        if (self->tag != JAK_ASYNC) {
                return NULL;
        }

        this_lock(self);

        JAK_ALLOC_MALLOC(char *, globalResult, num_ids, &self->alloc);

        struct async_extra *extra = (struct async_extra *) self->extra;
        uint_fast16_t num_threads = jak_vector_length(&extra->carriers);
        size_t approx_num_strings_per_thread = JAK_MAX(1, num_ids / num_threads);

        JAK_ALLOC_MALLOC(size_t, local_thread_idx, num_ids, &self->alloc);
        JAK_ALLOC_MALLOC(uint_fast16_t, owning_thread_ids, num_ids, &self->alloc);
        JAK_ALLOC_MALLOC(struct parallel_extract_arg, thread_args, num_threads, &self->alloc);

        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_extract_arg *arg = thread_args + thread_id;
                jak_vector_create(&arg->local_ids_in, &self->alloc, sizeof(jak_archive_field_sid_t),
                           approx_num_strings_per_thread);
        }

        /** compute subset of string ids per thread  */
        for (size_t i = 0; i < num_ids; i++) {
                jak_archive_field_sid_t global_jak_string_id = ids[i];
                owning_thread_ids[i] = GET_OWNER(global_jak_string_id);
                jak_archive_field_sid_t localjak_string_id_t = GET_jak_string_id_t(global_jak_string_id);
                JAK_ASSERT(owning_thread_ids[i] < num_threads);

                struct parallel_extract_arg *arg = thread_args + owning_thread_ids[i];
                local_thread_idx[i] = jak_vector_length(&arg->local_ids_in);
                jak_vector_push(&arg->local_ids_in, &localjak_string_id_t, 1);
        }

        /** schedule remove operation per carrier */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = JAK_VECTOR_GET(&extra->carriers, thread_id, struct carrier);
                struct parallel_extract_arg *carrier_arg = thread_args + thread_id;
                carrier_arg->carrier = carrier;
                pthread_create(&carrier->thread, NULL, parallel_extract_function, carrier_arg);
        }

        /** synchronize */
        synchronize(&extra->carriers, num_threads);

        for (size_t i = 0; i < num_ids; i++) {
                uint_fast16_t owning_thread_id = owning_thread_ids[i];
                size_t localIdx = local_thread_idx[i];
                struct parallel_extract_arg *carrier_arg = thread_args + owning_thread_id;
                char *extractedString = carrier_arg->strings_out[localIdx];
                globalResult[i] = extractedString;
        }

        /** cleanup */
        for (uint_fast16_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct parallel_extract_arg *carrier_arg = thread_args + thread_id;
                jak_vector_drop(&carrier_arg->local_ids_in);
                if (JAK_LIKELY(carrier_arg->did_work)) {
                        jak_string_dict_free(&carrier_arg->carrier->local_dictionary, carrier_arg->strings_out);
                }
        }

        JAK_ALLOC_FREE(local_thread_idx, &self->alloc);
        JAK_ALLOC_FREE(owning_thread_ids, &self->alloc);
        JAK_ALLOC_FREE(thread_args, &self->alloc);

        this_unlock(self);

        jak_timestamp end = jak_wallclock();
        JAK_UNUSED(begin);
        JAK_UNUSED(end);
        JAK_INFO(STRING_DIC_ASYNC_TAG, "extract (safe) operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return globalResult;
}

static bool _jak_encode_async_free(jak_string_dict *self, void *ptr)
{
        JAK_CHECK_TAG(self->tag, JAK_ASYNC);
        jak_alloc_free(&self->alloc, ptr);
        return true;
}

static bool _jak_encode_async_num_distinct(jak_string_dict *self, size_t *num)
{
        JAK_CHECK_TAG(self->tag, JAK_ASYNC);
        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        size_t num_carriers = jak_vector_length(&extra->carriers);
        struct carrier *carriers = JAK_VECTOR_ALL(&extra->carriers, struct carrier);
        size_t num_distinct = 0;
        while (num_carriers--) {
                size_t local_distinct;
                jak_string_dict_num_distinct(&local_distinct, &carriers->local_dictionary);
                num_distinct += local_distinct;
                carriers++;
        }
        *num = num_distinct;
        this_unlock(self);
        return true;
}

static bool _jak_encode_async_get_contents(jak_string_dict *self, jak_vector ofType (char *) *strings,
                              jak_vector ofType(jak_archive_field_sid_t) *jak_string_ids)
{
        JAK_CHECK_TAG(self->tag, JAK_ASYNC);
        this_lock(self);
        struct async_extra *extra = THIS_EXTRAS(self);
        size_t num_carriers = jak_vector_length(&extra->carriers);
        jak_vector ofType (char *) local_jak_string_results;
        jak_vector ofType (jak_archive_field_sid_t) local_jak_string_id_results;
        size_t approx_num_distinct_local_values;
        _jak_encode_async_num_distinct(self, &approx_num_distinct_local_values);
        approx_num_distinct_local_values = JAK_MAX(1, approx_num_distinct_local_values / extra->carriers.num_elems);
        approx_num_distinct_local_values *= 1.2f;

        jak_vector_create(&local_jak_string_results, NULL, sizeof(char *), approx_num_distinct_local_values);
        jak_vector_create(&local_jak_string_id_results, NULL, sizeof(jak_archive_field_sid_t), approx_num_distinct_local_values);

        for (size_t thread_id = 0; thread_id < num_carriers; thread_id++) {
                jak_vector_clear(&local_jak_string_results);
                jak_vector_clear(&local_jak_string_id_results);

                struct carrier *carrier = JAK_VECTOR_GET(&extra->carriers, thread_id, struct carrier);

                jak_string_dict_get_contents(&local_jak_string_results, &local_jak_string_id_results, &carrier->local_dictionary);

                JAK_ASSERT(local_jak_string_id_results.num_elems == local_jak_string_results.num_elems);
                for (size_t k = 0; k < local_jak_string_results.num_elems; k++) {
                        char *string = *JAK_VECTOR_GET(&local_jak_string_results, k, char *);
                        jak_archive_field_sid_t localjak_string_id_t = *JAK_VECTOR_GET(&local_jak_string_id_results, k,
                                                                            jak_archive_field_sid_t);
                        jak_archive_field_sid_t global_jak_string_id = MAKE_GLOBAL(thread_id, localjak_string_id_t);
                        jak_vector_push(strings, &string, 1);
                        jak_vector_push(jak_string_ids, &global_jak_string_id, 1);
                }
        }

        jak_vector_drop(&local_jak_string_results);
        jak_vector_drop(&local_jak_string_id_results);
        this_unlock(self);
        return true;
}

static bool _jak_encode_async_reset_counters(jak_string_dict *self)
{
        JAK_CHECK_TAG(self->tag, JAK_ASYNC);

        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        size_t num_threads = jak_vector_length(&extra->carriers);

        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = JAK_VECTOR_GET(&extra->carriers, thread_id, struct carrier);
                jak_string_dict_reset_counters(&carrier->local_dictionary);
        }

        this_unlock(self);

        return true;
}

static bool _jak_encode_async_counters(jak_string_dict *self, jak_str_hash_counters *counters)
{
        JAK_CHECK_TAG(self->tag, JAK_ASYNC);

        this_lock(self);

        struct async_extra *extra = THIS_EXTRAS(self);
        size_t num_threads = jak_vector_length(&extra->carriers);

        JAK_CHECK_SUCCESS(jak_str_hash_counters_init(counters));

        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                struct carrier *carrier = JAK_VECTOR_GET(&extra->carriers, thread_id, struct carrier);
                jak_str_hash_counters local_counters;
                jak_string_dict_get_counters(&local_counters, &carrier->local_dictionary);
                jak_str_hash_counters_add(counters, &local_counters);
        }

        this_unlock(self);

        return true;
}

struct create_carrier_arg {
        size_t local_capacity;
        size_t local_bucket_num;
        size_t local_bucket_cap;
        const jak_allocator *alloc;
};

static void parallel_create_carrier(const void *restrict start, size_t width, size_t len, void *restrict args,
                                    jak_thread_id_t tid)
{
        JAK_UNUSED(tid);
        JAK_UNUSED(width);

        struct carrier *carrier = (struct carrier *) start;
        const struct create_carrier_arg *createArgs = (const struct create_carrier_arg *) args;
        while (len--) {
                jak_encode_sync_create(&carrier->local_dictionary,
                                   createArgs->local_capacity,
                                   createArgs->local_bucket_num,
                                   createArgs->local_bucket_cap,
                                   0,
                                   createArgs->alloc);
                memset(&carrier->thread, 0, sizeof(pthread_t));
                carrier++;
        }
}

static bool this_setup_carriers(jak_string_dict *self, size_t capacity, size_t num_index_buckets,
                                size_t approx_num_unique_str, size_t num_threads)
{
        struct async_extra *extra = THIS_EXTRAS(self);
        size_t local_bucket_num = JAK_MAX(1, num_index_buckets / num_threads);
        struct carrier new_carrier;

        struct create_carrier_arg createArgs = {.local_capacity = JAK_MAX(1,
                                                                          capacity /
                                                                          num_threads), .local_bucket_num = local_bucket_num, .local_bucket_cap = JAK_MAX(
                1,
                approx_num_unique_str / num_threads / local_bucket_num / SLICE_KEY_COLUMN_MAX_ELEMS), .alloc = &self
                ->alloc};

        for (size_t thread_id = 0; thread_id < num_threads; thread_id++) {
                new_carrier.id = thread_id;
                jak_vector_push(&extra->carriers, &new_carrier, 1);
        }

        jak_for(JAK_VECTOR_ALL(&extra->carriers, struct carrier),
                sizeof(struct carrier),
                num_threads,
                parallel_create_carrier,
                &createArgs,
                JAK_THREADING_HINT_MULTI,
                num_threads);

        return true;
}

static bool this_lock(jak_string_dict *self)
{
        struct async_extra *extra = THIS_EXTRAS(self);
        JAK_CHECK_SUCCESS(jak_spinlock_acquire(&extra->lock));
        return true;
}

static bool this_unlock(jak_string_dict *self)
{
        struct async_extra *extra = THIS_EXTRAS(self);
        JAK_CHECK_SUCCESS(jak_spinlock_release(&extra->lock));
        return true;
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>

#include <jak_encoded_doc.h>

bool jak_encoded_doc_collection_create(jak_encoded_doc_list *collection, jak_error *err,
                                   jak_archive *archive)
{
        JAK_UNUSED(collection);
        JAK_UNUSED(err);
        JAK_UNUSED(archive);

        jak_vector_create(&collection->flat_object_collection, NULL, sizeof(jak_encoded_doc), 5000000);
        jak_hashtable_create(&collection->index, err, sizeof(jak_uid_t), sizeof(jak_u32), 5000000);
        jak_error_init(&collection->err);
        collection->archive = archive;

        return true;
}

bool jak_encoded_doc_collection_drop(jak_encoded_doc_list *collection)
{
        JAK_UNUSED(collection);

        jak_hashtable_drop(&collection->index);
        for (jak_u32 i = 0; i < collection->flat_object_collection.num_elems; i++) {
                jak_encoded_doc *doc = JAK_VECTOR_GET(&collection->flat_object_collection, i, jak_encoded_doc);
                jak_encoded_doc_drop(doc);
        }
        jak_vector_drop(&collection->flat_object_collection);
        return true;
}

static jak_encoded_doc *
doc_create(jak_error *err, jak_uid_t object_id, jak_encoded_doc_list *collection)
{
        if (collection) {
                jak_u32 doc_position = collection->flat_object_collection.num_elems;
                jak_encoded_doc
                        *new_doc = JAK_VECTOR_NEW_AND_GET(&collection->flat_object_collection, jak_encoded_doc);
                new_doc->context = collection;
                new_doc->object_id = object_id;
                jak_vector_create(&new_doc->props, NULL, sizeof(jak_encoded_doc_prop), 20);
                jak_vector_create(&new_doc->props_arrays, NULL, sizeof(jak_encoded_doc_prop_array), 20);
                jak_hashtable_create(&new_doc->prop_array_index, err, sizeof(jak_archive_field_sid_t), sizeof(jak_u32), 20);
                jak_error_init(&new_doc->err);
                jak_hashtable_insert_or_update(&collection->index, &object_id, &doc_position, 1);
                return new_doc;
        } else {
                JAK_ERROR(err, JAK_ERR_ILLEGALARG);
                return NULL;
        }
}

jak_encoded_doc *jak_encoded_doc_collection_get_or_append(jak_encoded_doc_list *collection,
                                                             jak_uid_t id)
{
        JAK_ERROR_IF_NULL(collection);
        const jak_u32 *doc_pos = jak_hashtable_get_value(&collection->index, &id);
        if (doc_pos) {
                jak_encoded_doc *result = JAK_VECTOR_GET(&collection->flat_object_collection, *doc_pos,
                                                         jak_encoded_doc);
                JAK_ERROR_IF(result == NULL, &collection->err, JAK_ERR_INTERNALERR);
                return result;
        } else {
                jak_encoded_doc *result = doc_create(&collection->err, id, collection);
                if (!result) {
                        JAK_ERROR(&collection->err, JAK_ERR_INTERNALERR);
                }
                return result;
        }
}

bool jak_encoded_doc_collection_print(FILE *file, jak_encoded_doc_list *collection)
{
        JAK_UNUSED(file);
        JAK_UNUSED(collection);

        if (collection->flat_object_collection.num_elems > 0) {
                jak_encoded_doc *root = JAK_VECTOR_GET(&collection->flat_object_collection, 0, jak_encoded_doc);
                jak_encoded_doc_print(file, root);
        }

        return false;
}

bool jak_encoded_doc_drop(jak_encoded_doc *doc)
{
        JAK_UNUSED(doc);
        for (jak_u32 i = 0; i < doc->props_arrays.num_elems; i++) {
                jak_encoded_doc_prop_array *array = JAK_VECTOR_GET(&doc->props_arrays, i,
                                                                   jak_encoded_doc_prop_array);
                jak_vector_drop(&array->values);
        }
        for (jak_u32 i = 0; i < doc->props.num_elems; i++) {
                jak_encoded_doc_prop *single = JAK_VECTOR_GET(&doc->props, i, jak_encoded_doc_prop);
                if (single->header.value_type == JAK_VALUE_DECODED_STRING) {
                        free(single->value.string);
                }
        }
        jak_vector_drop(&doc->props);
        jak_vector_drop(&doc->props_arrays);
        jak_hashtable_drop(&doc->prop_array_index);
        return false;
}

#define DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(built_in_type, basic_type, value_name)                               \
bool                                                                                                    \
jak_encoded_doc_add_prop_##value_name(jak_encoded_doc *doc, jak_archive_field_sid_t key, built_in_type value)       \
{                                                                                                                      \
    JAK_ERROR_IF_NULL(doc)                                                                                      \
    jak_encoded_doc_prop *prop = JAK_VECTOR_NEW_AND_GET(&doc->props, jak_encoded_doc_prop);                      \
    prop->header.context = doc;                                                                                        \
    prop->header.key_type = JAK_STRING_ENCODED;                                        \
    prop->header.key.key_id = key;                                                                                     \
    prop->header.value_type = JAK_VALUE_BUILTIN;                                              \
    prop->header.type = basic_type;                                                                                    \
    prop->value.builtin.value_name = value;                                                                            \
    return true;                                                                                                       \
}

#define DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(built_in_type, basic_type, value_name)                       \
bool                                                                                                    \
jak_encoded_doc_add_prop_##value_name##_decoded(jak_encoded_doc *doc, const char *key, built_in_type value)    \
{                                                                                                                      \
    JAK_ERROR_IF_NULL(doc)                                                                                      \
    jak_encoded_doc_prop *prop = JAK_VECTOR_NEW_AND_GET(&doc->props, jak_encoded_doc_prop);                      \
    prop->header.context = doc;                                                                                        \
    prop->header.key_type = JAK_STRING_DECODED;                                        \
    prop->header.key.key_str = strdup(key);                                                                            \
    prop->header.value_type = JAK_VALUE_BUILTIN;                                              \
    prop->header.type = basic_type;                                                                                    \
    prop->value.builtin.value_name = value;                                                                            \
    return true;                                                                                                       \
}

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_i8_t, JAK_FIELD_INT8, int8)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_i16_t, JAK_FIELD_INT16, int16)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_i32_t, JAK_FIELD_INT32, int32)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_i64_t, JAK_FIELD_INT64, int64)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_u8_t, JAK_FIELD_UINT8, uint8)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_u16_t, JAK_FIELD_UINT16, uint16)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_u32_t, JAK_FIELD_UINT32, uint32)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_u64_t, JAK_FIELD_UINT64, uint64)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_number_t, JAK_FIELD_FLOAT, number)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_boolean_t, JAK_FIELD_BOOLEAN, boolean)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC(jak_archive_field_sid_t, JAK_FIELD_STRING, string)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_i8_t, JAK_FIELD_INT8, int8)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_i16_t, JAK_FIELD_INT16, int16)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_i32_t, JAK_FIELD_INT32, int32)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_i64_t, JAK_FIELD_INT64, int64)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_u8_t, JAK_FIELD_UINT8, uint8)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_u16_t, JAK_FIELD_UINT16, uint16)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_u32_t, JAK_FIELD_UINT32, uint32)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_u64_t, JAK_FIELD_UINT64, uint64)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_number_t, JAK_FIELD_FLOAT, number)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_boolean_t, JAK_FIELD_BOOLEAN, boolean)

DECLARE_JAK_ENCODED_DOC_ADD_PROP_BASIC_DECODED(jak_archive_field_sid_t, JAK_FIELD_STRING, string)

bool jak_encoded_doc_add_prop_jak_string_decoded_jak_string_value_decoded(jak_encoded_doc *doc, const char *key,
                                                              const char *value)
{
        JAK_ERROR_IF_NULL(doc)
        jak_encoded_doc_prop *prop = JAK_VECTOR_NEW_AND_GET(&doc->props, jak_encoded_doc_prop);
        prop->header.context = doc;
        prop->header.key_type = JAK_STRING_DECODED;
        prop->header.key.key_str = strdup(key);
        prop->header.type = JAK_FIELD_STRING;
        prop->value.string = strdup(value);
        return true;
}

bool jak_encoded_doc_add_prop_null(jak_encoded_doc *doc, jak_archive_field_sid_t key)
{
        JAK_ERROR_IF_NULL(doc)
        jak_encoded_doc_prop *prop = JAK_VECTOR_NEW_AND_GET(&doc->props, jak_encoded_doc_prop);
        prop->header.context = doc;
        prop->header.key_type = JAK_STRING_ENCODED;
        prop->header.key.key_id = key;
        prop->header.type = JAK_FIELD_NULL;
        prop->value.builtin.null = 1;
        return true;
}

bool jak_encoded_doc_add_prop_null_decoded(jak_encoded_doc *doc, const char *key)
{
        JAK_ERROR_IF_NULL(doc)
        jak_encoded_doc_prop *prop = JAK_VECTOR_NEW_AND_GET(&doc->props, jak_encoded_doc_prop);
        prop->header.context = doc;
        prop->header.key_type = JAK_STRING_DECODED;
        prop->header.key.key_str = strdup(key);
        prop->header.type = JAK_FIELD_NULL;
        prop->value.builtin.null = 1;
        return true;
}

bool
jak_encoded_doc_add_prop_object(jak_encoded_doc *doc, jak_archive_field_sid_t key, jak_encoded_doc *value)
{
        JAK_ERROR_IF_NULL(doc)
        jak_encoded_doc_prop *prop = JAK_VECTOR_NEW_AND_GET(&doc->props, jak_encoded_doc_prop);
        prop->header.context = doc;
        prop->header.key_type = JAK_STRING_ENCODED;
        prop->header.key.key_id = key;
        prop->header.type = JAK_FIELD_OBJECT;
        prop->value.builtin.object = value->object_id;
        return true;
}

bool jak_encoded_doc_add_prop_object_decoded(jak_encoded_doc *doc, const char *key,
                                         jak_encoded_doc *value)
{
        JAK_ERROR_IF_NULL(doc)
        jak_encoded_doc_prop *prop = JAK_VECTOR_NEW_AND_GET(&doc->props, jak_encoded_doc_prop);
        prop->header.context = doc;
        prop->header.key_type = JAK_STRING_DECODED;
        prop->header.key.key_str = strdup(key);
        prop->header.type = JAK_FIELD_OBJECT;
        prop->value.builtin.object = value->object_id;
        return true;
}

#define DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(name, basic_type)                                               \
bool                                                                                                    \
jak_encoded_doc_add_prop_array_##name(jak_encoded_doc *doc,                                                    \
                                       jak_archive_field_sid_t key)                                                         \
{                                                                                                                      \
    JAK_ERROR_IF_NULL(doc)                                                                                      \
    jak_u32 new_array_pos = doc->props_arrays.num_elems;                                                              \
    jak_encoded_doc_prop_array *array = JAK_VECTOR_NEW_AND_GET(&doc->props_arrays, jak_encoded_doc_prop_array);  \
    array->header.key_type = JAK_STRING_ENCODED;                                          \
    array->header.key.key_id = key;                                                                                    \
    array->header.type = basic_type;                                                                                   \
    array->header.context = doc;                                                                                       \
    jak_vector_create(&array->values, NULL, sizeof(jak_encoded_doc_value_u), 10);                                   \
    jak_hashtable_insert_or_update(&doc->prop_array_index, &key, &new_array_pos, 1);                                \
    return true;                                                                                                       \
}

#define DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(name, basic_type)                                       \
bool                                                                                                    \
jak_encoded_doc_add_prop_array_##name##_decoded(jak_encoded_doc *doc,                                          \
                                       const char *key)                                                                \
{                                                                                                                      \
    JAK_ERROR_IF_NULL(doc)                                                                                      \
    jak_encoded_doc_prop_array *array = JAK_VECTOR_NEW_AND_GET(&doc->props_arrays, jak_encoded_doc_prop_array);  \
    array->header.key_type = JAK_STRING_DECODED;                                          \
    array->header.key.key_str = strdup(key);                                                                           \
    array->header.type = basic_type;                                                                                   \
    array->header.context = doc;                                                                                       \
    jak_vector_create(&array->values, NULL, sizeof(jak_encoded_doc_value_u), 10);                                   \
    return true;                                                                                                       \
}

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int8, JAK_FIELD_INT8)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int16, JAK_FIELD_INT16)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int32, JAK_FIELD_INT32)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(int64, JAK_FIELD_INT64)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint8, JAK_FIELD_UINT8)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint16, JAK_FIELD_UINT16)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint32, JAK_FIELD_UINT32)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(uint64, JAK_FIELD_UINT64)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(number, JAK_FIELD_FLOAT)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(boolean, JAK_FIELD_BOOLEAN)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(string, JAK_FIELD_STRING)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(null, JAK_FIELD_NULL)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE(object, JAK_FIELD_OBJECT)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int8, JAK_FIELD_INT8)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int16, JAK_FIELD_INT16)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int32, JAK_FIELD_INT32)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(int64, JAK_FIELD_INT64)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint8, JAK_FIELD_UINT8)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint16, JAK_FIELD_UINT16)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint32, JAK_FIELD_UINT32)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(uint64, JAK_FIELD_UINT64)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(number, JAK_FIELD_FLOAT)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(boolean, JAK_FIELD_BOOLEAN)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(string, JAK_FIELD_STRING)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(null, JAK_FIELD_NULL)

DECALRE_JAK_ENCODED_DOC_ADD_PROP_ARRAY_TYPE_DECODED(object, JAK_FIELD_OBJECT)

#define DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(name, built_in_type, basic_type)                                    \
bool                                                                                                    \
jak_encoded_doc_array_push_##name(jak_encoded_doc *doc, jak_archive_field_sid_t key,                                \
                                     const built_in_type *values, jak_u32 values_length)                              \
{                                                                                                                      \
    JAK_ERROR_IF_NULL(doc)                                                                                      \
    const jak_u32 *prop_pos = jak_hashtable_get_value(&doc->prop_array_index, &key);                               \
    JAK_ERROR_IF(prop_pos == NULL, &doc->err, JAK_ERR_NOTFOUND);                                                 \
    jak_encoded_doc_prop_array *array = JAK_VECTOR_GET(&doc->props_arrays, *prop_pos,                          \
                                                               jak_encoded_doc_prop_array);                       \
    JAK_ERROR_IF(array == NULL, &doc->err, JAK_ERR_INTERNALERR);                                                 \
    JAK_ERROR_IF(array->header.type != basic_type, &doc->err, JAK_ERR_TYPEMISMATCH);                             \
    for (jak_u32 i = 0; i < values_length; i++) {                                                                     \
        jak_encoded_doc_value_u *value = JAK_VECTOR_NEW_AND_GET(&array->values, jak_encoded_doc_value_u);            \
        value->name = values[i];                                                                                       \
    }                                                                                                                  \
                                                                                                                       \
    return true;                                                                                                       \
}

#include <inttypes.h>

#define DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(name, built_in_type, basic_type)                            \
bool                                                                                                    \
jak_encoded_doc_array_push_##name##_decoded(jak_encoded_doc *doc, const char *key,                             \
                                     const built_in_type *values, jak_u32 values_length)                              \
{                                                                                                                      \
    jak_u32 prop_pos = (jak_u32) -1;                                                                                 \
    for (jak_u32 i = 0; i < doc->props_arrays.num_elems; i++)                                                         \
    {                                                                                                                  \
        jak_encoded_doc_prop_array *prop = JAK_VECTOR_GET(&doc->props_arrays, i, jak_encoded_doc_prop_array); \
        if (prop->header.key_type == JAK_STRING_DECODED) {                                \
            if (strcmp(prop->header.key.key_str, key) == 0) {                                                          \
                prop_pos = i;                                                                                          \
                break;                                                                                                 \
            }                                                                                                          \
        }                                                                                                              \
    }                                                                                                                  \
    JAK_ERROR_IF(prop_pos == (jak_u32) -1, &doc->err, JAK_ERR_NOTFOUND);                                        \
    jak_encoded_doc_prop_array *array = JAK_VECTOR_GET(&doc->props_arrays, prop_pos,                           \
                                                                   jak_encoded_doc_prop_array);                   \
    JAK_ERROR_IF(array == NULL, &doc->err, JAK_ERR_INTERNALERR);                                                 \
    JAK_ERROR_IF(array->header.type != basic_type, &doc->err, JAK_ERR_TYPEMISMATCH);                             \
    for (jak_u32 i = 0; i < values_length; i++) {                                                                     \
        jak_encoded_doc_value_u *value = JAK_VECTOR_NEW_AND_GET(&array->values, jak_encoded_doc_value_u);            \
        value->name = values[i];                                                                                       \
    }                                                                                                                  \
                                                                                                                       \
    return true;                                                                                                       \
}

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(int8, jak_archive_field_i8_t, JAK_FIELD_INT8)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(int16, jak_archive_field_i16_t, JAK_FIELD_INT16)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(int32, jak_archive_field_i32_t, JAK_FIELD_INT32)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(int64, jak_archive_field_i64_t, JAK_FIELD_INT64)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(uint8, jak_archive_field_u8_t, JAK_FIELD_UINT8)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(uint16, jak_archive_field_u16_t, JAK_FIELD_UINT16)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(uint32, jak_archive_field_u32_t, JAK_FIELD_UINT32)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(uint64, jak_archive_field_u64_t, JAK_FIELD_UINT64)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(number, jak_archive_field_number_t, JAK_FIELD_FLOAT)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(boolean, jak_archive_field_boolean_t, JAK_FIELD_BOOLEAN)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(string, jak_archive_field_sid_t, JAK_FIELD_STRING)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE(null, jak_archive_field_u32_t, JAK_FIELD_NULL)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int8, jak_archive_field_i8_t, JAK_FIELD_INT8)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int16, jak_archive_field_i16_t, JAK_FIELD_INT16)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int32, jak_archive_field_i32_t, JAK_FIELD_INT32)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(int64, jak_archive_field_i64_t, JAK_FIELD_INT64)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint8, jak_archive_field_u8_t, JAK_FIELD_UINT8)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint16, jak_archive_field_u16_t, JAK_FIELD_UINT16)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint32, jak_archive_field_u32_t, JAK_FIELD_UINT32)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(uint64, jak_archive_field_u64_t, JAK_FIELD_UINT64)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(number, jak_archive_field_number_t, JAK_FIELD_FLOAT)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(boolean, jak_archive_field_boolean_t, JAK_FIELD_BOOLEAN)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(string, jak_archive_field_sid_t, JAK_FIELD_STRING)

DECLARE_JAK_ENCODED_DOC_ARRAY_PUSH_TYPE_DECODED(null, jak_archive_field_u32_t, JAK_FIELD_NULL)
//
//bool
//jak_encoded_doc_array_push_null(jak_encoded_doc *doc, jak_archive_field_sid_t key, jak_u32 how_many)
//{
//    JAK_ERROR_IF_NULL(doc)
//    const jak_u32 *prop_pos = jak_hashtable_get_value(&doc->prop_array_index, &key);
//    JAK_ERROR_IF(prop_pos == NULL, &doc->err, JAK_ERR_NOTFOUND);
//    jak_encoded_doc_prop_array *array = JAK_VECTOR_GET(&doc->props_arrays, *prop_pos,
//                                                               jak_encoded_doc_prop_array);
//    JAK_ERROR_IF(array == NULL, &doc->err, JAK_ERR_INTERNALERR);
//    JAK_ERROR_IF(array->header.type != JAK_FIELD_NULL, &doc->err, JAK_ERR_TYPEMISMATCH);
//    jak_encoded_doc_value_u *value = JAK_VECTOR_NEW_AND_GET(&array->values, jak_encoded_doc_value_u);
//    value->num_nulls = how_many;
//    return true;
//}


#include <inttypes.h>
#include <jak_archive_query.h>

bool jak_encoded_doc_array_push_object(jak_encoded_doc *doc, jak_archive_field_sid_t key, jak_uid_t id)
{
        JAK_UNUSED(doc);
        JAK_UNUSED(key);
        JAK_UNUSED(id);

        JAK_ERROR_IF_NULL(doc)
        const jak_u32 *prop_pos = jak_hashtable_get_value(&doc->prop_array_index, &key);
        JAK_ERROR_IF(prop_pos == NULL, &doc->err, JAK_ERR_NOTFOUND);
        jak_encoded_doc_prop_array *array = JAK_VECTOR_GET(&doc->props_arrays, *prop_pos,
                                                           jak_encoded_doc_prop_array);
        JAK_ERROR_IF(array == NULL, &doc->err, JAK_ERR_INTERNALERR);
        JAK_ERROR_IF(array->header.type != JAK_FIELD_OBJECT, &doc->err, JAK_ERR_TYPEMISMATCH);
        jak_encoded_doc_value_u *value = JAK_VECTOR_NEW_AND_GET(&array->values, jak_encoded_doc_value_u);
        value->object = id;
        return true;
}

bool jak_encoded_doc_array_push_object_decoded(jak_encoded_doc *doc, const char *key, jak_uid_t id)
{
        JAK_UNUSED(doc);
        JAK_UNUSED(key);
        JAK_UNUSED(id);

        JAK_ERROR_IF_NULL(doc)
        jak_u32 prop_pos = (jak_u32) -1;
        for (jak_u32 i = 0; i < doc->props_arrays.num_elems; i++) {
                jak_encoded_doc_prop_array *prop = JAK_VECTOR_GET(&doc->props_arrays, i,
                                                                  jak_encoded_doc_prop_array);
                if (prop->header.key_type == JAK_STRING_DECODED) {
                        if (strcmp(prop->header.key.key_str, key) == 0) {
                                prop_pos = i;
                                break;
                        }
                }
        }
        JAK_ERROR_IF(prop_pos == (jak_u32) -1, &doc->err, JAK_ERR_NOTFOUND);
        jak_encoded_doc_prop_array *array = JAK_VECTOR_GET(&doc->props_arrays, prop_pos,
                                                           jak_encoded_doc_prop_array);
        JAK_ERROR_IF(array == NULL, &doc->err, JAK_ERR_INTERNALERR);
        JAK_ERROR_IF(array->header.type != JAK_FIELD_OBJECT, &doc->err, JAK_ERR_TYPEMISMATCH);
        jak_encoded_doc_value_u *value = JAK_VECTOR_NEW_AND_GET(&array->values, jak_encoded_doc_value_u);
        value->object = id;
        return true;
}

static bool doc_print_pretty(FILE *file, jak_encoded_doc *doc, unsigned level)
{
        jak_archive_query query;
        jak_archive_query_run(&query, doc->context->archive);

        fprintf(file, "{\n");

        for (jak_u32 i = 0; i < doc->props.num_elems; i++) {
                jak_encoded_doc_prop *prop = JAK_VECTOR_GET(&doc->props, i, jak_encoded_doc_prop);
                char *key_str = NULL;
                if (prop->header.key_type == JAK_STRING_ENCODED) {
                        key_str = jak_query_fetch_jak_string_by_id(&query, prop->header.key.key_id);
                } else {
                        key_str = strdup(prop->header.key.key_str);
                }

                for (unsigned k = 0; k < level; k++) {
                        fprintf(file, "   ");
                }

                fprintf(file, "\"%s\": ", key_str);
                switch (prop->header.type) {
                        case JAK_FIELD_INT8:
                                fprintf(file, "%" PRIi8, prop->value.builtin.int8);
                                break;
                        case JAK_FIELD_INT16:
                                fprintf(file, "%" PRIi16, prop->value.builtin.int16);
                                break;
                        case JAK_FIELD_INT32:
                                fprintf(file, "%" PRIi32, prop->value.builtin.int32);
                                break;
                        case JAK_FIELD_INT64:
                                fprintf(file, "%" PRIi64, prop->value.builtin.int64);
                                break;
                        case JAK_FIELD_UINT8:
                                fprintf(file, "%" PRIu8, prop->value.builtin.uint8);
                                break;
                        case JAK_FIELD_UINT16:
                                fprintf(file, "%" PRIu16, prop->value.builtin.uint16);
                                break;
                        case JAK_FIELD_UINT32:
                                fprintf(file, "%" PRIu32, prop->value.builtin.uint32);
                                break;
                        case JAK_FIELD_UINT64:
                                fprintf(file, "%" PRIu64, prop->value.builtin.uint64);
                                break;
                        case JAK_FIELD_FLOAT:
                                fprintf(file, "%.2f", ceilf(prop->value.builtin.number * 100) / 100);
                                break;
                        case JAK_FIELD_STRING: {
                                if (prop->header.value_type == JAK_VALUE_BUILTIN) {
                                        char *value_str = jak_query_fetch_jak_string_by_id(&query,
                                                                                       prop->value.builtin.string);
                                        fprintf(file, "\"%s\"", value_str);
                                        free(value_str);
                                } else {
                                        fprintf(file, "\"%s\"", prop->value.string);
                                }
                        }
                                break;
                        case JAK_FIELD_BOOLEAN:
                                fprintf(file, "\"%s\"", prop->value.builtin.boolean ? "true" : "false");
                                break;
                        case JAK_FIELD_NULL:
                                fprintf(file, "null");
                                break;
                        case JAK_FIELD_OBJECT: {
                                jak_encoded_doc *nested =
                                        jak_encoded_doc_collection_get_or_append(doc->context, prop->value.builtin.object);
                                doc_print_pretty(file, nested, level + 1);
                        }
                                break;
                        default: JAK_ERROR(&doc->err, JAK_ERR_INTERNALERR);
                                return false;
                }
                free(key_str);
                fprintf(file, "%s\n", i + 1 < doc->props.num_elems || doc->props_arrays.num_elems > 0 ? ", " : "");
        }

        for (jak_u32 i = 0; i < doc->props_arrays.num_elems; i++) {
                jak_encoded_doc_prop_array *prop = JAK_VECTOR_GET(&doc->props_arrays, i,
                                                                  jak_encoded_doc_prop_array);
                char *key_str = NULL;
                if (prop->header.key_type == JAK_STRING_ENCODED) {
                        key_str = jak_query_fetch_jak_string_by_id(&query, prop->header.key.key_id);
                } else {
                        key_str = strdup(prop->header.key.key_str);
                }

                for (unsigned k = 0; k < level; k++) {
                        fprintf(file, "   ");
                }

                fprintf(file, "\"%s\": ", key_str);

                if (prop->values.num_elems == 0) {
                        fprintf(file, "[ ]\n");
                        continue;
                }

                if (prop->values.num_elems > 1) {
                        fprintf(file, "[");
                }

                switch (prop->header.type) {
                        case JAK_FIELD_INT8:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_i8_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                jak_encoded_doc_value_u))->int8;
                                        if (JAK_IS_NULL_INT8(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIi8 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_INT16:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_i16_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                 jak_encoded_doc_value_u))->int16;
                                        if (JAK_IS_NULL_INT16(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIi16 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_INT32:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_i32_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                 jak_encoded_doc_value_u))->int32;
                                        if (JAK_IS_NULL_INT32(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIi32 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_INT64:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_i64_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                 jak_encoded_doc_value_u))->int64;
                                        if (JAK_IS_NULL_INT64(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIi64 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_UINT8:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_u8_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                jak_encoded_doc_value_u))->uint8;
                                        if (JAK_IS_NULL_UINT8(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIu8 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_UINT16:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_u16_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                 jak_encoded_doc_value_u))->uint16;
                                        if (JAK_IS_NULL_UINT16(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIu16 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_UINT32:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_u32_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                 jak_encoded_doc_value_u))->uint32;
                                        if (JAK_IS_NULL_UINT32(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIu32 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_UINT64:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_u64_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                 jak_encoded_doc_value_u))->uint64;
                                        if (JAK_IS_NULL_UINT64(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%" PRIu64 "%s",
                                                        value,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_FLOAT:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_number_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                    jak_encoded_doc_value_u))->number;
                                        if (JAK_IS_NULL_NUMBER(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%.2f%s",
                                                        ceilf(value * 100) / 100,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_STRING: {
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_sid_t value = (JAK_VECTOR_GET(&prop->values, k,
                                                                                 jak_encoded_doc_value_u))->string;
                                        if (JAK_IS_NULL_STRING(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                char *value_str = jak_query_fetch_jak_string_by_id(&query, value);
                                                fprintf(file,
                                                        "\"%s\"%s",
                                                        value_str,
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                                free(value_str);
                                        }
                                }
                        }
                                break;
                        case JAK_FIELD_BOOLEAN:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_archive_field_boolean_t
                                                value = (JAK_VECTOR_GET(&prop->values, k, jak_encoded_doc_value_u))->boolean;
                                        if (JAK_IS_NULL_BOOL(value)) {
                                                fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                        } else {
                                                fprintf(file,
                                                        "%s%s",
                                                        value ? "true" : "false",
                                                        k + 1 < prop->values.num_elems ? ", " : "");
                                        }
                                }
                                break;
                        case JAK_FIELD_NULL:
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        fprintf(file, "null%s", k + 1 < prop->values.num_elems ? ", " : "");
                                }
                                break;
                        case JAK_FIELD_OBJECT: {
                                for (jak_u32 k = 0; k < prop->values.num_elems; k++) {
                                        jak_uid_t nested_oid = (JAK_VECTOR_GET(&prop->values, k,
                                                                              jak_encoded_doc_value_u))->object;
                                        jak_encoded_doc
                                                *nested_doc = jak_encoded_doc_collection_get_or_append(doc->context,
                                                                                                   nested_oid);
                                        fprintf(file, "\n");
                                        for (unsigned k = 0; k < level + 1; k++) {
                                                fprintf(file, "   ");
                                        }
                                        doc_print_pretty(file, nested_doc, level + 2);
                                        fprintf(file, "%s", k + 1 < prop->values.num_elems ? "," : "");
                                }
                                fprintf(file, "\n");
                                for (unsigned k = 0; k < level; k++) {
                                        fprintf(file, "   ");
                                }
                        }
                                break;
                        default: JAK_ERROR(&doc->err, JAK_ERR_INTERNALERR);
                                return false;
                }
                free(key_str);
                if (prop->values.num_elems > 1) {
                        fprintf(file, "]");
                }
                fprintf(file, "%s\n", i + 1 < doc->props_arrays.num_elems ? ", " : "");
        }

        for (unsigned k = 0; k < level - 1; k++) {
                fprintf(file, "   ");
        }

        fprintf(file, "}");

        jak_query_drop(&query);

        return true;
}

bool jak_encoded_doc_print(FILE *file, jak_encoded_doc *doc)
{
        return doc_print_pretty(file, doc, 1);
}

/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_vector.h>
#include <jak_spinlock.h>
#include <jak_str_hash.h>
#include <jak_encode_sync.h>
#include <jak_str_hash_mem.h>
#include <jak_time.h>
#include <jak_bloom.h>
#include <jak_hash.h>

#define STRING_DIC_SYNC_TAG "string-dic-sync"

struct entry {
        char *str;
        bool in_use;
};

struct sync_extra {
        jak_vector ofType(entry) contents;
        jak_vector ofType(jak_string_id_t_t) freelist;
        jak_str_hash index;
        jak_spinlock _jak_encode_sync_lock;
};

static bool _jak_encode_sync_drop(jak_string_dict *self);

static bool
_jak_encode_sync_insert(jak_string_dict *self, jak_archive_field_sid_t **out, char *const *strings, size_t num_strings,
            size_t num_threads);

static bool _jak_encode_sync_remove(jak_string_dict *self, jak_archive_field_sid_t *strings, size_t num_strings);

static bool
_jak_encode_sync_locate_safe(jak_string_dict *self, jak_archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
                 char *const *keys, size_t num_keys);

static bool
_jak_encode_sync_locate_fast(jak_string_dict *self, jak_archive_field_sid_t **out, char *const *keys, size_t num_keys);

static char **_jak_encode_sync_extract(jak_string_dict *self, const jak_archive_field_sid_t *ids, size_t num_ids);

static bool _jak_encode_sync_free(jak_string_dict *self, void *ptr);

static bool _jak_encode_sync_reset_counters(jak_string_dict *self);

static bool _jak_encode_sync_counters(jak_string_dict *self, jak_str_hash_counters *counters);

static bool _jak_encode_sync_num_distinct(jak_string_dict *self, size_t *num);

static bool _jak_encode_sync_get_contents(jak_string_dict *self, jak_vector ofType (char *) *strings,
                              jak_vector ofType(jak_archive_field_sid_t) *jak_string_ids);

static void _jak_encode_sync_lock(jak_string_dict *self);

static void _jak_encode_sync_unlock(jak_string_dict *self);

static int
create_extra(jak_string_dict *self, size_t capacity, size_t num_index_buckets, size_t num_index_bucket_cap,
             size_t num_threads);

static struct sync_extra *this_extra(jak_string_dict *self);

static int freelist_pop(jak_archive_field_sid_t *out, jak_string_dict *self);

static int freelist_push(jak_string_dict *self, jak_archive_field_sid_t idx);

int
jak_encode_sync_create(jak_string_dict *dic, size_t capacity, size_t num_indx_buckets, size_t num_index_bucket_cap,
                   size_t num_threads, const jak_allocator *alloc)
{
        JAK_ERROR_IF_NULL(dic);

        JAK_CHECK_SUCCESS(jak_alloc_this_or_std(&dic->alloc, alloc));

        dic->tag = JAK_SYNC;
        dic->drop = _jak_encode_sync_drop;
        dic->insert = _jak_encode_sync_insert;
        dic->remove = _jak_encode_sync_remove;
        dic->locate_safe = _jak_encode_sync_locate_safe;
        dic->locate_fast = _jak_encode_sync_locate_fast;
        dic->extract = _jak_encode_sync_extract;
        dic->free = _jak_encode_sync_free;
        dic->resetCounters = _jak_encode_sync_reset_counters;
        dic->counters = _jak_encode_sync_counters;
        dic->num_distinct = _jak_encode_sync_num_distinct;
        dic->get_contents = _jak_encode_sync_get_contents;

        JAK_CHECK_SUCCESS(create_extra(dic, capacity, num_indx_buckets, num_index_bucket_cap, num_threads));
        return true;
}

static void _jak_encode_sync_lock(jak_string_dict *self)
{
        JAK_ASSERT(self->tag == JAK_SYNC);
        struct sync_extra *extra = this_extra(self);
        jak_spinlock_acquire(&extra->_jak_encode_sync_lock);
}

static void _jak_encode_sync_unlock(jak_string_dict *self)
{
        JAK_ASSERT(self->tag == JAK_SYNC);
        struct sync_extra *extra = this_extra(self);
        jak_spinlock_release(&extra->_jak_encode_sync_lock);
}

static int
create_extra(jak_string_dict *self, size_t capacity, size_t num_index_buckets, size_t num_index_bucket_cap,
             size_t num_threads)
{
        self->extra = jak_alloc_malloc(&self->alloc, sizeof(struct sync_extra));
        struct sync_extra *extra = this_extra(self);
        jak_spinlock_init(&extra->_jak_encode_sync_lock);
        JAK_CHECK_SUCCESS(jak_vector_create(&extra->contents, &self->alloc, sizeof(struct entry), capacity));
        JAK_CHECK_SUCCESS(jak_vector_create(&extra->freelist, &self->alloc, sizeof(jak_archive_field_sid_t), capacity));
        struct entry empty = {.str    = NULL, .in_use = false};
        for (size_t i = 0; i < capacity; i++) {
                JAK_CHECK_SUCCESS(jak_vector_push(&extra->contents, &empty, 1));
                freelist_push(self, i);
        }
        JAK_UNUSED(num_threads);

        jak_allocator jak_hashtable_alloc;
#if defined(JAK_CONFIG_TRACE_STRING_DIC_ALLOC) && !defined(NDEBUG)
        CHECK_SUCCESS(allocatorTrace(&jak_hashtable_alloc));
#else
        JAK_CHECK_SUCCESS(jak_alloc_this_or_std(&jak_hashtable_alloc, &self->alloc));
#endif

        JAK_CHECK_SUCCESS(jak_str_hash_create_inmemory(&extra->index,
                                                  &jak_hashtable_alloc,
                                                  num_index_buckets,
                                                  num_index_bucket_cap));
        return true;
}

static struct sync_extra *this_extra(jak_string_dict *self)
{
        JAK_ASSERT (self->tag == JAK_SYNC);
        return (struct sync_extra *) self->extra;
}

static int freelist_pop(jak_archive_field_sid_t *out, jak_string_dict *self)
{
        JAK_ASSERT (self->tag == JAK_SYNC);
        struct sync_extra *extra = this_extra(self);
        if (JAK_UNLIKELY(jak_vector_is_empty(&extra->freelist))) {
                size_t num_new_pos;
                JAK_CHECK_SUCCESS(jak_vector_grow(&num_new_pos, &extra->freelist));
                JAK_CHECK_SUCCESS(jak_vector_grow(NULL, &extra->contents));
                JAK_ASSERT (extra->freelist.cap_elems == extra->contents.cap_elems);
                struct entry empty = {.in_use = false, .str    = NULL};
                while (num_new_pos--) {
                        size_t new_pos = jak_vector_length(&extra->contents);
                        JAK_CHECK_SUCCESS(jak_vector_push(&extra->freelist, &new_pos, 1));
                        JAK_CHECK_SUCCESS(jak_vector_push(&extra->contents, &empty, 1));
                }
        }
        *out = *(jak_archive_field_sid_t *) jak_vector_pop(&extra->freelist);
        return true;
}

static int freelist_push(jak_string_dict *self, jak_archive_field_sid_t idx)
{
        JAK_ASSERT (self->tag == JAK_SYNC);
        struct sync_extra *extra = this_extra(self);
        JAK_CHECK_SUCCESS(jak_vector_push(&extra->freelist, &idx, 1));
        JAK_ASSERT (extra->freelist.cap_elems == extra->contents.cap_elems);
        return true;
}

static bool _jak_encode_sync_drop(jak_string_dict *self)
{
        JAK_CHECK_TAG(self->tag, JAK_SYNC)

        struct sync_extra *extra = this_extra(self);

        struct entry *entries = (struct entry *) extra->contents.base;
        for (size_t i = 0; i < extra->contents.num_elems; i++) {
                struct entry *entry = entries + i;
                if (entry->in_use) {
                        JAK_ASSERT (entry->str);
                        jak_alloc_free(&self->alloc, entry->str);
                        entry->str = NULL;
                }
        }

        jak_vector_drop(&extra->freelist);
        jak_vector_drop(&extra->contents);
        jak_str_hash_drop(&extra->index);
        jak_alloc_free(&self->alloc, self->extra);

        return true;
}

static bool
_jak_encode_sync_insert(jak_string_dict *self, jak_archive_field_sid_t **out, char *const *strings, size_t num_strings,
            size_t num_threads)
{
        JAK_TRACE(STRING_DIC_SYNC_TAG, "local string dictionary insertion invoked for %zu strings", num_strings);
        jak_timestamp begin = jak_wallclock();

        JAK_UNUSED(num_threads);

        JAK_CHECK_TAG(self->tag, JAK_SYNC)
        _jak_encode_sync_lock(self);

        struct sync_extra *extra = this_extra(self);

        jak_allocator jak_hashtable_alloc;
#if defined(JAK_CONFIG_TRACE_STRING_DIC_ALLOC) && !defined(NDEBUG)
        CHECK_SUCCESS(allocatorTrace(&jak_hashtable_alloc));
#else
        JAK_CHECK_SUCCESS(jak_alloc_this_or_std(&jak_hashtable_alloc, &self->alloc));
#endif

        jak_archive_field_sid_t *ids_out = jak_alloc_malloc(&jak_hashtable_alloc,
                                                            num_strings * sizeof(jak_archive_field_sid_t));
        bool *found_mask;
        jak_archive_field_sid_t *values;
        size_t num_not_found;

        /** query index for strings to get a boolean mask which strings are new and which must be added */
        /** This is for the case that the string dictionary is not empty to skip processing of those new elements
         * which are already contained */
        JAK_TRACE(STRING_DIC_SYNC_TAG, "local string dictionary check for new strings in insertion bulk%s", "...");

        /** NOTE: palatalization of the call to this function decreases performance */
        jak_str_hash_get_bulk_safe(&values, &found_mask, &num_not_found, &extra->index, strings, num_strings);

        /** OPTIMIZATION: use a jak_bitmap to check whether a string (which has not appeared in the
         * dictionary before this batch but might occur multiple times in the current batch) was seen
         * before (with a slight prob. of doing too much work) */
        jak_bitmap bitmap;
        jak_bloom_create(&bitmap, 22 * num_not_found);

        /** copy string ids for already known strings to their result position resp. add those which are new */
        for (size_t i = 0; i < num_strings; i++) {

                if (found_mask[i]) {
                        ids_out[i] = values[i];
                } else {
                        /** This path is taken only for strings that are not already contained in the dictionary. However,
                         * since this insertion batch may contain duplicate string, querying for already inserted strings
                         * must be done anyway for each string in the insertion batch that is inserted. */

                        jak_archive_field_sid_t jak_string_id = 0;
                        const char *key = (const char *) (strings[i]);

                        bool found = false;
                        jak_archive_field_sid_t value;

                        /** Query the jak_bitmap if the keys was already seend. If the filter returns "yes", a lookup
                         * is requried since the filter maybe made a mistake. Of the filter returns "no", the
                         * keys is new for sure. In this case, one can skip the lookup into the buckets. */
                        size_t key_length = strlen(key);
                        hash32_t bloom_key = key_length > 0 ? JAK_HASH_FNV(strlen(key), key)
                                                            : 0; /** using a hash of a keys instead of the string keys itself avoids reading the entire string for computing k hashes inside the jak_bitmap */
                        if (JAK_BLOOM_TEST_AND_SET(&bitmap, &bloom_key, sizeof(hash32_t))) {
                                /** ensure that the string really was seen (due to collisions in the bloom filter the keys might not
                                 * been actually seen) */

                                /** query index for strings to get a boolean mask which strings are new and which must be added */
                                /** This is for the case that the string was not already contained in the string dictionary but may have
                                 * duplicates in this insertion batch that are already inserted */
                                jak_str_hash_get_bulk_safe_exact(&value,
                                                            &found,
                                                            &extra->index,
                                                            key);  /** OPTIMIZATION: use specialized function for "exact" query to avoid unnessecary malloc calls to manage set of results if only a single result is needed */
                        }

                        if (found) {
                                ids_out[i] = value;
                        } else {

                                /** register in contents list */
                                bool pop_result = freelist_pop(&jak_string_id, self);
                                JAK_ERROR_PRINT_AND_DIE_IF(!pop_result, JAK_ERR_SLOTBROKEN)
                                struct entry *entries = (struct entry *) jak_vector_data(&extra->contents);
                                struct entry *entry = entries + jak_string_id;
                                JAK_ASSERT (!entry->in_use);
                                entry->in_use = true;
                                entry->str = strdup(strings[i]);
                                ids_out[i] = jak_string_id;

                                /** add for not yet registered pairs to buffer for fast import */
                                jak_str_hash_put_exact_fast(&extra->index, entry->str, jak_string_id);
                        }
                }
        }

        /** set potential non-null out parameters */
        JAK_OPTIONAL_SET_OR_ELSE(out, ids_out, jak_alloc_free(&self->alloc, ids_out));

        /** cleanup */
        jak_alloc_free(&jak_hashtable_alloc, found_mask);
        jak_alloc_free(&jak_hashtable_alloc, values);
        jak_bloom_drop(&bitmap);

        _jak_encode_sync_unlock(self);

        jak_timestamp end = jak_wallclock();
        JAK_UNUSED(begin);
        JAK_UNUSED(end);
        JAK_INFO(STRING_DIC_SYNC_TAG, "insertion operation done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;

}

static bool _jak_encode_sync_remove(jak_string_dict *self, jak_archive_field_sid_t *strings, size_t num_strings)
{
        JAK_ERROR_IF_NULL(self);
        JAK_ERROR_IF_NULL(strings);
        JAK_ERROR_IF_NULL(num_strings);
        JAK_CHECK_TAG(self->tag, JAK_SYNC)
        _jak_encode_sync_lock(self);

        struct sync_extra *extra = this_extra(self);

        size_t num_strings_to_delete = 0;
        char **jak_string_to_delete = jak_alloc_malloc(&self->alloc, num_strings * sizeof(char *));
        jak_archive_field_sid_t *jak_string_ids_to_delete = jak_alloc_malloc(&self->alloc,
                                                                         num_strings * sizeof(jak_archive_field_sid_t));

        /** remove strings from contents JAK_vector, and skip duplicates */
        for (size_t i = 0; i < num_strings; i++) {
                jak_archive_field_sid_t jak_archive_field_sid_t = strings[i];
                struct entry *entry = (struct entry *) jak_vector_data(&extra->contents) + jak_archive_field_sid_t;
                if (JAK_LIKELY(entry->in_use)) {
                        jak_string_to_delete[num_strings_to_delete] = entry->str;
                        jak_string_ids_to_delete[num_strings_to_delete] = strings[i];
                        entry->str = NULL;
                        entry->in_use = false;
                        num_strings_to_delete++;
                        JAK_CHECK_SUCCESS(freelist_push(self, jak_archive_field_sid_t));
                }
        }

        /** remove from index */
        JAK_CHECK_SUCCESS(jak_str_hash_remove(&extra->index, jak_string_to_delete, num_strings_to_delete));

        /** free up resources for strings that should be removed */
        for (size_t i = 0; i < num_strings_to_delete; i++) {
                free(jak_string_to_delete[i]);
        }

        /** cleanup */
        jak_alloc_free(&self->alloc, jak_string_to_delete);
        jak_alloc_free(&self->alloc, jak_string_ids_to_delete);

        _jak_encode_sync_unlock(self);
        return true;
}

static bool
_jak_encode_sync_locate_safe(jak_string_dict *self, jak_archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
                 char *const *keys, size_t num_keys)
{
        jak_timestamp begin = jak_wallclock();
        JAK_TRACE(STRING_DIC_SYNC_TAG, "'locate_safe' function invoked for %zu strings", num_keys)

        JAK_ERROR_IF_NULL(self);
        JAK_ERROR_IF_NULL(out);
        JAK_ERROR_IF_NULL(found_mask);
        JAK_ERROR_IF_NULL(num_not_found);
        JAK_ERROR_IF_NULL(keys);
        JAK_ERROR_IF_NULL(num_keys);
        JAK_CHECK_TAG(self->tag, JAK_SYNC)

        _jak_encode_sync_lock(self);
        struct sync_extra *extra = this_extra(self);
        int status = jak_str_hash_get_bulk_safe(out, found_mask, num_not_found, &extra->index, keys, num_keys);
        _jak_encode_sync_unlock(self);

        jak_timestamp end = jak_wallclock();
        JAK_UNUSED(begin);
        JAK_UNUSED(end);
        JAK_TRACE(STRING_DIC_SYNC_TAG, "'locate_safe' function done: %f seconds spent here", (end - begin) / 1000.0f)

        return status;
}

static bool
_jak_encode_sync_locate_fast(jak_string_dict *self, jak_archive_field_sid_t **out, char *const *keys, size_t num_keys)
{
        JAK_CHECK_TAG(self->tag, JAK_SYNC)

        bool *found_mask;
        size_t num_not_found;

        /** use safer but in principle more slower implementation */
        int result = _jak_encode_sync_locate_safe(self, out, &found_mask, &num_not_found, keys, num_keys);

        /** cleanup */
        _jak_encode_sync_free(self, found_mask);

        return result;
}

static char **_jak_encode_sync_extract(jak_string_dict *self, const jak_archive_field_sid_t *ids, size_t num_ids)
{
        if (JAK_UNLIKELY(!self || !ids || num_ids == 0 || self->tag != JAK_SYNC)) {
                return NULL;
        }

        _jak_encode_sync_lock(self);

        jak_allocator jak_hashtable_alloc;
#if defined(JAK_CONFIG_TRACE_STRING_DIC_ALLOC) && !defined(NDEBUG)
        allocatorTrace(&jak_hashtable_alloc);
#else
        jak_alloc_this_or_std(&jak_hashtable_alloc, &self->alloc);
#endif

        struct sync_extra *extra = this_extra(self);
        char **result = jak_alloc_malloc(&jak_hashtable_alloc, num_ids * sizeof(char *));
        struct entry *entries = (struct entry *) jak_vector_data(&extra->contents);

        /** Optimization: notify the kernel that the content list is accessed randomly (since hash based access)*/
        jak_vector_memadvice(&extra->contents, MADV_RANDOM | MADV_WILLNEED);

        for (size_t i = 0; i < num_ids; i++) {
                jak_archive_field_sid_t jak_archive_field_sid_t = ids[i];
                JAK_ASSERT(jak_archive_field_sid_t < jak_vector_length(&extra->contents));
                JAK_ASSERT(
                        jak_archive_field_sid_t == JAK_NULL_ENCODED_STRING || entries[jak_archive_field_sid_t].in_use);
                result[i] = jak_archive_field_sid_t != JAK_NULL_ENCODED_STRING ? entries[jak_archive_field_sid_t].str
                                                                               : JAK_NULL_TEXT;
        }

        _jak_encode_sync_unlock(self);
        return result;
}

static bool _jak_encode_sync_free(jak_string_dict *self, void *ptr)
{
        JAK_UNUSED(self);

        jak_allocator jak_hashtable_alloc;
#if defined(JAK_CONFIG_TRACE_STRING_DIC_ALLOC) && !defined(NDEBUG)
        CHECK_SUCCESS(allocatorTrace(&jak_hashtable_alloc));
#else
        JAK_CHECK_SUCCESS(jak_alloc_this_or_std(&jak_hashtable_alloc, &self->alloc));
#endif

        return jak_alloc_free(&jak_hashtable_alloc, ptr);
}

static bool _jak_encode_sync_reset_counters(jak_string_dict *self)
{
        JAK_CHECK_TAG(self->tag, JAK_SYNC)
        struct sync_extra *extra = this_extra(self);
        JAK_CHECK_SUCCESS(jak_str_hash_reset_counters(&extra->index));
        return true;
}

static bool _jak_encode_sync_counters(jak_string_dict *self, jak_str_hash_counters *counters)
{
        JAK_CHECK_TAG(self->tag, JAK_SYNC)
        struct sync_extra *extra = this_extra(self);
        JAK_CHECK_SUCCESS(jak_str_hash_get_counters(counters, &extra->index));
        return true;
}

static bool _jak_encode_sync_num_distinct(jak_string_dict *self, size_t *num)
{
        JAK_CHECK_TAG(self->tag, JAK_SYNC)
        struct sync_extra *extra = this_extra(self);
        *num = jak_vector_length(&extra->contents);
        return true;
}

static bool _jak_encode_sync_get_contents(jak_string_dict *self, jak_vector ofType (char *) *strings,
                              jak_vector ofType(jak_archive_field_sid_t) *jak_string_ids)
{
        JAK_CHECK_TAG(self->tag, JAK_SYNC);
        struct sync_extra *extra = this_extra(self);

        for (jak_archive_field_sid_t i = 0; i < extra->contents.num_elems; i++) {
                const struct entry *e = JAK_VECTOR_GET(&extra->contents, i, struct entry);
                if (e->in_use) {
                        jak_vector_push(strings, &e->str, 1);
                        jak_vector_push(jak_string_ids, &i, 1);
                }
        }
        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_error.h>

bool jak_error_init(jak_error *err)
{
        if (err) {
                err->code = JAK_ERR_NOERR;
                err->details = NULL;
                err->file = NULL;
                err->line = 0;
        }
        return (err != NULL);
}

bool jak_error_cpy(jak_error *dst, const jak_error *src)
{
        JAK_ERROR_IF_NULL(dst);
        JAK_ERROR_IF_NULL(src);
        *dst = *src;
        return true;
}

bool jak_error_drop(jak_error *err)
{
        JAK_ERROR_IF_NULL(err);
        if (err->details) {
                free(err->details);
                err->details = NULL;
        }
        return true;
}

bool jak_error_set(jak_error *err, int code, const char *file, jak_u32 line)
{
        return jak_error_set_wdetails(err, code, file, line, NULL);
}

bool jak_error_set_wdetails(jak_error *err, int code, const char *file, jak_u32 line, const char *details)
{
        if (err) {
                err->code = code;
                err->file = file;
                err->line = line;
                err->details = details ? strdup(details) : NULL;
#ifndef NDEBUG
                jak_error_print_and_abort(err);
#endif
        }
        return (err != NULL);
}

bool jak_error_set_no_abort(jak_error *err, int code, const char *file, jak_u32 line)
{
        return jak_error_set_wdetails_no_abort(err, code, file, line, NULL);
}

bool jak_error_set_wdetails_no_abort(jak_error *err, int code, const char *file, jak_u32 line, const char *details)
{
        if (err) {
                err->code = code;
                err->file = file;
                err->line = line;
                err->details = details ? strdup(details) : NULL;
#ifndef NDEBUG
                JAK_ERROR_PRINT(code);
#endif
        }
        return (err != NULL);
}

bool jak_error_str(const char **errstr, const char **file, jak_u32 *line, bool *details, const char **detailsstr,
               const jak_error *err)
{
        if (err) {
                if (err->code >= jak_global_nerr_str) {
                        JAK_OPTIONAL_SET(errstr, JAK_ERRSTR_ILLEGAL_CODE)
                } else {
                        JAK_OPTIONAL_SET(errstr, jak_global_err_str[err->code])
                }
                JAK_OPTIONAL_SET(file, err->file)
                JAK_OPTIONAL_SET(line, err->line)
                JAK_OPTIONAL_SET(details, err->details != NULL);
                JAK_OPTIONAL_SET(detailsstr, err->details)
                return true;
        }
        return false;
}

bool jak_error_print_to_stderr(const jak_error *err)
{
        if (err) {
                const char *errstr;
                const char *file;
                jak_u32 line;
                bool has_details;
                const char *details;
                if (jak_error_str(&errstr, &file, &line, &has_details, &details, err)) {
                        fprintf(stderr, "*** ERROR ***   %s\n", errstr);
                        fprintf(stderr, "                details: %s\n", has_details ? details : "no details");
                        fprintf(stderr, "                source.: %s(%d)\n", file, line);
                } else {
                        fprintf(stderr, "*** ERROR ***   internal JAK_ERROR during JAK_ERROR information fetch");
                }
                fflush(stderr);
        }
        return (err != NULL);
}

bool jak_error_print_and_abort(const jak_error *err)
{
        jak_error_print_to_stderr(err);
        abort();
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_hash.h>
#include <jak_hash_set.h>

#define _JAK_HASH_SET_HASHCODE_OF(size, x) JAK_HASH_BERNSTEIN(size, x)
#define FIX_MAP_AUTO_REHASH_LOADFACTOR 0.9f

bool jak_hashset_create(jak_hashset *map, jak_error *err, size_t key_size, size_t capacity)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ERROR_IF_NULL(key_size)

        int err_code = JAK_ERR_INITFAILED;

        map->size = 0;

        JAK_SUCCESS_OR_JUMP(jak_vector_create(&map->key_data, NULL, key_size, capacity), error_handling);
        JAK_SUCCESS_OR_JUMP(jak_vector_create(&map->table, NULL, sizeof(jak_hashset_bucket), capacity),
                            cleanup_key_data_and_error);
        JAK_SUCCESS_OR_JUMP(jak_vector_enlarge_size_to_capacity(&map->table), cleanup_key_value_table_and_error);
        JAK_SUCCESS_OR_JUMP(jak_vector_zero_memory(&map->table), cleanup_key_value_table_and_error);
        JAK_SUCCESS_OR_JUMP(jak_spinlock_init(&map->lock), cleanup_key_value_table_and_error);
        JAK_SUCCESS_OR_JUMP(jak_error_init(&map->err), cleanup_key_value_table_and_error);

        return true;

        cleanup_key_value_table_and_error:
        if (!jak_vector_drop(&map->table)) {
                err_code = JAK_ERR_DROPFAILED;
        }
        cleanup_key_data_and_error:
        if (!jak_vector_drop(&map->key_data)) {
                err_code = JAK_ERR_DROPFAILED;
        }
        error_handling:
        JAK_ERROR(err, err_code);
        return false;
}

bool jak_hashset_drop(jak_hashset *map)
{
        JAK_ERROR_IF_NULL(map)

        bool status = true;

        status &= jak_vector_drop(&map->table);
        status &= jak_vector_drop(&map->key_data);

        if (!status) {
                JAK_ERROR(&map->err, JAK_ERR_DROPFAILED);
        }

        return status;
}

jak_vector *jak_hashset_keys(jak_hashset *map)
{
        if (map) {
                jak_vector *result = JAK_MALLOC(sizeof(jak_vector));
                jak_vector_create(result, NULL, map->key_data.elem_size, map->key_data.num_elems);
                for (jak_u32 i = 0; i < map->table.num_elems; i++) {
                        jak_hashset_bucket *bucket = JAK_VECTOR_GET(&map->table, i, jak_hashset_bucket);
                        if (bucket->in_use_flag) {
                                const void *data = jak_vector_at(&map->key_data, bucket->key_idx);
                                jak_vector_push(result, data, 1);
                        }
                }
                return result;
        } else {
                return NULL;
        }
}

jak_hashset *jak_hashset_cpy(jak_hashset *src)
{
        if (src) {
                jak_hashset *cpy = JAK_MALLOC(sizeof(jak_hashset));

                jak_hashset_lock(src);

                jak_hashset_create(cpy, &src->err, src->key_data.elem_size, src->table.cap_elems);

                JAK_ASSERT(src->key_data.cap_elems == src->table.cap_elems);
                JAK_ASSERT(src->key_data.num_elems <= src->table.num_elems);

                jak_vector_cpy_to(&cpy->key_data, &src->key_data);
                jak_vector_cpy_to(&cpy->table, &src->table);
                cpy->size = src->size;
                jak_error_cpy(&cpy->err, &src->err);

                JAK_ASSERT(cpy->key_data.cap_elems == cpy->table.cap_elems);
                JAK_ASSERT(cpy->key_data.num_elems <= cpy->table.num_elems);

                jak_hashset_unlock(src);
                return cpy;
        } else {
                JAK_ERROR(&src->err, JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool jak_hashset_clear(jak_hashset *map)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ASSERT(map->key_data.cap_elems == map->table.cap_elems);
        JAK_ASSERT(map->key_data.num_elems <= map->table.num_elems);

        jak_hashset_lock(map);

        bool status = jak_vector_clear(&map->key_data) && jak_vector_zero_memory(&map->table);

        map->size = 0;

        JAK_ASSERT(map->key_data.cap_elems == map->table.cap_elems);
        JAK_ASSERT(map->key_data.num_elems <= map->table.num_elems);

        if (!status) {
                JAK_ERROR(&map->err, JAK_ERR_OPPFAILED);
        }

        jak_hashset_unlock(map);

        return status;
}

bool jak_hashset_avg_displace(float *displace, const jak_hashset *map)
{
        JAK_ERROR_IF_NULL(displace);
        JAK_ERROR_IF_NULL(map);

        size_t sum_dis = 0;
        for (size_t i = 0; i < map->table.num_elems; i++) {
                jak_hashset_bucket *bucket = JAK_VECTOR_GET(&map->table, i, jak_hashset_bucket);
                sum_dis += abs(bucket->displacement);
        }
        *displace = (sum_dis / (float) map->table.num_elems);

        return true;
}

bool jak_hashset_lock(jak_hashset *map)
{
        JAK_ERROR_IF_NULL(map)
        jak_spinlock_acquire(&map->lock);
        return true;
}

bool jak_hashset_unlock(jak_hashset *map)
{
        JAK_ERROR_IF_NULL(map)
        jak_spinlock_release(&map->lock);
        return true;
}

static inline const void *_jak_hash_set_get_bucket_key(const jak_hashset_bucket *bucket, const jak_hashset *map)
{
        return map->key_data.base + bucket->key_idx * map->key_data.elem_size;
}

static void _jak_hash_set_insert(jak_hashset_bucket *bucket, jak_hashset *map, const void *key, jak_i32 displacement)
{
        jak_u64 idx = map->key_data.num_elems;
        void *key_datum = JAK_VECTOR_NEW_AND_GET(&map->key_data, void *);
        memcpy(key_datum, key, map->key_data.elem_size);
        bucket->key_idx = idx;
        bucket->in_use_flag = true;
        bucket->displacement = displacement;
        map->size++;
}

static inline uint_fast32_t _jak_hash_set_insert_or_update(jak_hashset *map, const jak_u32 *bucket_idxs, const void *keys,
                                             uint_fast32_t num_pairs)
{
        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                jak_u32 intended_bucket_idx = bucket_idxs[i];

                jak_u32 bucket_idx = intended_bucket_idx;

                jak_hashset_bucket *bucket = JAK_VECTOR_GET(&map->table, bucket_idx, jak_hashset_bucket);
                if (bucket->in_use_flag && memcmp(_jak_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) != 0) {
                        bool fitting_bucket_found = false;
                        jak_u32 displace_idx;
                        for (displace_idx = bucket_idx + 1; displace_idx < map->table.num_elems; displace_idx++) {
                                jak_hashset_bucket
                                        *bucket = JAK_VECTOR_GET(&map->table, displace_idx, jak_hashset_bucket);
                                fitting_bucket_found = !bucket->in_use_flag || (bucket->in_use_flag
                                                                                &&
                                                                                memcmp(_jak_hash_set_get_bucket_key(bucket, map), key,
                                                                                       map->key_data.elem_size) == 0);
                                if (fitting_bucket_found) {
                                        break;
                                } else {
                                        jak_i32 displacement = displace_idx - bucket_idx;
                                        const void *swap_key = _jak_hash_set_get_bucket_key(bucket, map);

                                        if (bucket->displacement < displacement) {
                                                _jak_hash_set_insert(bucket, map, key, displacement);
                                                _jak_hash_set_insert_or_update(map, &displace_idx, swap_key, 1);
                                                goto next_round;
                                        }
                                }
                        }
                        if (!fitting_bucket_found) {
                                for (displace_idx = 0; displace_idx < bucket_idx - 1; displace_idx++) {
                                        const jak_hashset_bucket
                                                *bucket = JAK_VECTOR_GET(&map->table, displace_idx, jak_hashset_bucket);
                                        fitting_bucket_found = !bucket->in_use_flag || (bucket->in_use_flag
                                                                                        && memcmp(_jak_hash_set_get_bucket_key(bucket,
                                                                                                                 map),
                                                                                                  key,
                                                                                                  map->key_data.elem_size)
                                                                                           == 0);
                                        if (fitting_bucket_found) {
                                                break;
                                        }
                                }
                        }

                        JAK_ASSERT(fitting_bucket_found == true);
                        bucket_idx = displace_idx;
                        bucket = JAK_VECTOR_GET(&map->table, bucket_idx, jak_hashset_bucket);
                }

                bool is_update =
                        bucket->in_use_flag && memcmp(_jak_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                if (!is_update) {
                        jak_i32 displacement = intended_bucket_idx - bucket_idx;
                        _jak_hash_set_insert(bucket, map, key, displacement);
                }

                next_round:
                if (map->size >= FIX_MAP_AUTO_REHASH_LOADFACTOR * map->table.cap_elems) {
                        return i + 1; /* tell the caller that pair i was inserted, but it successors not */
                }

        }
        return 0;
}

bool jak_hashset_insert_or_update(jak_hashset *map, const void *keys, uint_fast32_t num_pairs)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ERROR_IF_NULL(keys)

        JAK_ASSERT(map->key_data.cap_elems == map->table.cap_elems);
        JAK_ASSERT(map->key_data.num_elems <= map->table.num_elems);

        jak_hashset_lock(map);

        jak_u32 *bucket_idxs = JAK_MALLOC(num_pairs * sizeof(jak_u32));
        if (!bucket_idxs) {
                JAK_ERROR(&map->err, JAK_ERR_MALLOCERR);
                return false;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                hash32_t hash = _JAK_HASH_SET_HASHCODE_OF(map->key_data.elem_size, key);
                bucket_idxs[i] = hash % map->table.num_elems;
        }

        uint_fast32_t cont_idx = 0;
        do {
                cont_idx = _jak_hash_set_insert_or_update(map,
                                            bucket_idxs + cont_idx,
                                            keys + cont_idx * map->key_data.elem_size,
                                            num_pairs - cont_idx);
                if (cont_idx != 0) {
                        /* rehashing is required, and [status, num_pairs) are left to be inserted */
                        if (!jak_hashset_rehash(map)) {
                                jak_hashset_unlock(map);
                                return false;
                        }
                }
        } while (cont_idx != 0);

        free(bucket_idxs);
        jak_hashset_unlock(map);

        return true;
}

bool jak_hashset_remove_if_contained(jak_hashset *map, const void *keys, size_t num_pairs)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ERROR_IF_NULL(keys)

        jak_hashset_lock(map);

        jak_u32 *bucket_idxs = JAK_MALLOC(num_pairs * sizeof(jak_u32));
        if (!bucket_idxs) {
                JAK_ERROR(&map->err, JAK_ERR_MALLOCERR);
                jak_hashset_unlock(map);
                return false;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                bucket_idxs[i] = _JAK_HASH_SET_HASHCODE_OF(map->key_data.elem_size, key) % map->table.num_elems;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                jak_u32 bucket_idx = bucket_idxs[i];
                jak_u32 actual_idx = bucket_idx;
                bool bucket_found = false;

                for (jak_u32 k = bucket_idx; !bucket_found && k < map->table.num_elems; k++) {
                        const jak_hashset_bucket *bucket = JAK_VECTOR_GET(&map->table, k, jak_hashset_bucket);
                        bucket_found = bucket->in_use_flag
                                       && memcmp(_jak_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                        actual_idx = k;
                }
                for (jak_u32 k = 0; !bucket_found && k < bucket_idx; k++) {
                        const jak_hashset_bucket *bucket = JAK_VECTOR_GET(&map->table, k, jak_hashset_bucket);
                        bucket_found = bucket->in_use_flag
                                       && memcmp(_jak_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                        actual_idx = k;
                }

                if (bucket_found) {
                        jak_hashset_bucket *bucket = JAK_VECTOR_GET(&map->table, actual_idx, jak_hashset_bucket);
                        bucket->in_use_flag = false;
                        bucket->key_idx = 0;
                }
        }

        free(bucket_idxs);

        jak_hashset_unlock(map);

        return true;
}

bool jak_hashset_contains_key(jak_hashset *map, const void *key)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ERROR_IF_NULL(key)

        bool result = false;

        jak_hashset_lock(map);

        jak_u32 bucket_idx = _JAK_HASH_SET_HASHCODE_OF(map->key_data.elem_size, key) % map->table.num_elems;
        bool bucket_found = false;

        for (jak_u32 k = bucket_idx; !bucket_found && k < map->table.num_elems; k++) {
                const jak_hashset_bucket *bucket = JAK_VECTOR_GET(&map->table, k, jak_hashset_bucket);
                bucket_found =
                        bucket->in_use_flag && memcmp(_jak_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
        }
        for (jak_u32 k = 0; !bucket_found && k < bucket_idx; k++) {
                const jak_hashset_bucket *bucket = JAK_VECTOR_GET(&map->table, k, jak_hashset_bucket);
                bucket_found =
                        bucket->in_use_flag && memcmp(_jak_hash_set_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
        }

        result = bucket_found;
        jak_hashset_unlock(map);

        return result;
}

bool jak_hashset_get_load_factor(float *factor, jak_hashset *map)
{
        JAK_ERROR_IF_NULL(factor)
        JAK_ERROR_IF_NULL(map)

        jak_hashset_lock(map);

        *factor = map->size / (float) map->table.num_elems;

        jak_hashset_unlock(map);

        return true;
}

bool jak_hashset_rehash(jak_hashset *map)
{
        JAK_ERROR_IF_NULL(map)

        jak_hashset_lock(map);

        jak_hashset *cpy = jak_hashset_cpy(map);
        jak_hashset_clear(map);

        size_t new_cap = (cpy->key_data.cap_elems + 1) * 1.7f;

        jak_vector_grow_to(&map->key_data, new_cap);
        jak_vector_grow_to(&map->table, new_cap);
        jak_vector_enlarge_size_to_capacity(&map->table);
        jak_vector_zero_memory(&map->table);

        JAK_ASSERT(map->key_data.cap_elems == map->table.cap_elems);
        JAK_ASSERT(map->key_data.num_elems <= map->table.num_elems);

        for (size_t i = 0; i < cpy->table.num_elems; i++) {
                jak_hashset_bucket *bucket = JAK_VECTOR_GET(&cpy->table, i, jak_hashset_bucket);
                if (bucket->in_use_flag) {
                        const void *old_key = _jak_hash_set_get_bucket_key(bucket, cpy);
                        if (!jak_hashset_insert_or_update(map, old_key, 1)) {
                                JAK_ERROR(&map->err, JAK_ERR_REHASH_NOROLLBACK)
                                jak_hashset_unlock(map);
                                return false;
                        }
                }
        }

        jak_hashset_unlock(map);
        return true;
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_hash.h>
#include <jak_hash_table.h>

#define _JAK_HASH_TABLE_HASHCODE_OF(size, x) JAK_HASH_BERNSTEIN(size, x)
#define FIX_MAP_AUTO_REHASH_LOADFACTOR 0.9f

bool jak_hashtable_create(jak_hashtable *map, jak_error *err, size_t key_size, size_t value_size,
                      size_t capacity)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ERROR_IF_NULL(key_size)
        JAK_ERROR_IF_NULL(value_size)

        int err_code = JAK_ERR_INITFAILED;

        map->size = 0;

        JAK_SUCCESS_OR_JUMP(jak_vector_create(&map->key_data, NULL, key_size, capacity), error_handling);
        JAK_SUCCESS_OR_JUMP(jak_vector_create(&map->value_data, NULL, value_size, capacity), cleanup_key_data_and_error);
        JAK_SUCCESS_OR_JUMP(jak_vector_create(&map->table, NULL, sizeof(jak_hashtable_bucket), capacity),
                            cleanup_value_key_data_and_error);
        JAK_SUCCESS_OR_JUMP(jak_vector_enlarge_size_to_capacity(&map->table), cleanup_key_value_table_and_error);
        JAK_SUCCESS_OR_JUMP(jak_vector_zero_memory(&map->table), cleanup_key_value_table_and_error);
        JAK_SUCCESS_OR_JUMP(jak_spinlock_init(&map->lock), cleanup_key_value_table_and_error);
        JAK_SUCCESS_OR_JUMP(jak_error_init(&map->err), cleanup_key_value_table_and_error);

        return true;

        cleanup_key_value_table_and_error:
        if (!jak_vector_drop(&map->table)) {
                err_code = JAK_ERR_DROPFAILED;
        }
        cleanup_value_key_data_and_error:
        if (!jak_vector_drop(&map->value_data)) {
                err_code = JAK_ERR_DROPFAILED;
        }
        cleanup_key_data_and_error:
        if (!jak_vector_drop(&map->key_data)) {
                err_code = JAK_ERR_DROPFAILED;
        }
        error_handling:
        JAK_ERROR(err, err_code);
        return false;
}

bool jak_hashtable_drop(jak_hashtable *map)
{
        JAK_ERROR_IF_NULL(map)

        bool status = true;

        status &= jak_vector_drop(&map->table);
        status &= jak_vector_drop(&map->value_data);
        status &= jak_vector_drop(&map->key_data);

        if (!status) {
                JAK_ERROR(&map->err, JAK_ERR_DROPFAILED);
        }

        return status;
}

jak_hashtable *jak_hashtable_cpy(jak_hashtable *src)
{
        if (src) {
                jak_hashtable *cpy = JAK_MALLOC(sizeof(jak_hashtable));

                jak_hashtable_lock(src);

                jak_hashtable_create(cpy,
                                 &src->err,
                                 src->key_data.elem_size,
                                 src->value_data.elem_size,
                                 src->table.cap_elems);

                JAK_ASSERT(src->key_data.cap_elems == src->value_data.cap_elems
                           && src->value_data.cap_elems == src->table.cap_elems);
                JAK_ASSERT((src->key_data.num_elems == src->value_data.num_elems)
                           && src->value_data.num_elems <= src->table.num_elems);

                jak_vector_cpy_to(&cpy->key_data, &src->key_data);
                jak_vector_cpy_to(&cpy->value_data, &src->value_data);
                jak_vector_cpy_to(&cpy->table, &src->table);
                cpy->size = src->size;
                jak_error_cpy(&cpy->err, &src->err);

                JAK_ASSERT(cpy->key_data.cap_elems == src->value_data.cap_elems
                           && src->value_data.cap_elems == cpy->table.cap_elems);
                JAK_ASSERT((cpy->key_data.num_elems == src->value_data.num_elems)
                           && src->value_data.num_elems <= cpy->table.num_elems);

                jak_hashtable_unlock(src);
                return cpy;
        } else {
                JAK_ERROR(&src->err, JAK_ERR_NULLPTR);
                return NULL;
        }
}

bool jak_hashtable_clear(jak_hashtable *map)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ASSERT(map->key_data.cap_elems == map->value_data.cap_elems
                   && map->value_data.cap_elems == map->table.cap_elems);
        JAK_ASSERT((map->key_data.num_elems == map->value_data.num_elems)
                   && map->value_data.num_elems <= map->table.num_elems);

        jak_hashtable_lock(map);

        bool status = jak_vector_clear(&map->key_data) && jak_vector_clear(&map->value_data) && jak_vector_zero_memory(&map->table);

        map->size = 0;

        JAK_ASSERT(map->key_data.cap_elems == map->value_data.cap_elems
                   && map->value_data.cap_elems == map->table.cap_elems);
        JAK_ASSERT((map->key_data.num_elems == map->value_data.num_elems)
                   && map->value_data.num_elems <= map->table.num_elems);

        if (!status) {
                JAK_ERROR(&map->err, JAK_ERR_OPPFAILED);
        }

        jak_hashtable_unlock(map);

        return status;
}

bool jak_hashtable_avg_displace(float *displace, const jak_hashtable *map)
{
        JAK_ERROR_IF_NULL(displace);
        JAK_ERROR_IF_NULL(map);

        size_t sum_dis = 0;
        for (size_t i = 0; i < map->table.num_elems; i++) {
                jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&map->table, i, jak_hashtable_bucket);
                sum_dis += abs(bucket->displacement);
        }
        *displace = (sum_dis / (float) map->table.num_elems);

        return true;
}

bool jak_hashtable_lock(jak_hashtable *map)
{
        JAK_ERROR_IF_NULL(map)
        //jak_spinlock_acquire(&map->lock);
        return true;
}

bool jak_hashtable_unlock(jak_hashtable *map)
{
        JAK_ERROR_IF_NULL(map)
        //jak_spinlock_release(&map->lock);
        return true;
}

static inline const void *_jak_hash_table_get_bucket_key(const jak_hashtable_bucket *bucket, const jak_hashtable *map)
{
        return map->key_data.base + bucket->data_idx * map->key_data.elem_size;
}

static inline const void *get_bucket_value(const jak_hashtable_bucket *bucket, const jak_hashtable *map)
{
        return map->value_data.base + bucket->data_idx * map->value_data.elem_size;
}

static void _jak_hash_table_insert(jak_hashtable_bucket *bucket, jak_hashtable *map, const void *key, const void *value,
                   jak_i32 displacement)
{
        JAK_ASSERT(map->key_data.num_elems == map->value_data.num_elems);
        jak_u64 idx = map->key_data.num_elems;
        void *key_datum = JAK_VECTOR_NEW_AND_GET(&map->key_data, void *);
        void *value_datum = JAK_VECTOR_NEW_AND_GET(&map->value_data, void *);
        memcpy(key_datum, key, map->key_data.elem_size);
        memcpy(value_datum, value, map->value_data.elem_size);
        bucket->data_idx = idx;
        bucket->in_use_flag = true;
        bucket->displacement = displacement;
        map->size++;
}

static inline uint_fast32_t _jak_hash_table_insert_or_update(jak_hashtable *map, const jak_u32 *bucket_idxs, const void *keys,
                                             const void *values, uint_fast32_t num_pairs)
{
        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                const void *value = values + i * map->key_data.elem_size;
                jak_u32 intended_bucket_idx = bucket_idxs[i];

                jak_u32 bucket_idx = intended_bucket_idx;

                jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&map->table, bucket_idx, jak_hashtable_bucket);
                if (bucket->in_use_flag && memcmp(_jak_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) != 0) {
                        bool fitting_bucket_found = false;
                        jak_u32 displace_idx;
                        for (displace_idx = bucket_idx + 1; displace_idx < map->table.num_elems; displace_idx++) {
                                jak_hashtable_bucket
                                        *bucket = JAK_VECTOR_GET(&map->table, displace_idx, jak_hashtable_bucket);
                                fitting_bucket_found = !bucket->in_use_flag || (bucket->in_use_flag
                                                                                &&
                                                                                memcmp(_jak_hash_table_get_bucket_key(bucket, map), key,
                                                                                       map->key_data.elem_size) == 0);
                                if (fitting_bucket_found) {
                                        break;
                                } else {
                                        jak_i32 displacement = displace_idx - bucket_idx;
                                        const void *swap_key = _jak_hash_table_get_bucket_key(bucket, map);
                                        const void *swap_value = get_bucket_value(bucket, map);

                                        if (bucket->displacement < displacement) {
                                                _jak_hash_table_insert(bucket, map, key, value, displacement);
                                                _jak_hash_table_insert_or_update(map, &displace_idx, swap_key, swap_value, 1);
                                                goto next_round;
                                        }
                                }
                        }
                        if (!fitting_bucket_found) {
                                for (displace_idx = 0; displace_idx < bucket_idx - 1; displace_idx++) {
                                        const jak_hashtable_bucket
                                                *bucket = JAK_VECTOR_GET(&map->table, displace_idx, jak_hashtable_bucket);
                                        fitting_bucket_found = !bucket->in_use_flag || (bucket->in_use_flag
                                                                                        && memcmp(_jak_hash_table_get_bucket_key(bucket,
                                                                                                                 map),
                                                                                                  key,
                                                                                                  map->key_data.elem_size)
                                                                                           == 0);
                                        if (fitting_bucket_found) {
                                                break;
                                        }
                                }
                        }

                        JAK_ASSERT(fitting_bucket_found == true);
                        bucket_idx = displace_idx;
                        bucket = JAK_VECTOR_GET(&map->table, bucket_idx, jak_hashtable_bucket);
                }

                bool is_update =
                        bucket->in_use_flag && memcmp(_jak_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                if (is_update) {
                        void *bucket_value = (void *) get_bucket_value(bucket, map);
                        memcpy(bucket_value, value, map->value_data.elem_size);
                } else {
                        jak_i32 displacement = intended_bucket_idx - bucket_idx;
                        _jak_hash_table_insert(bucket, map, key, value, displacement);
                }

                next_round:
                if (map->size >= FIX_MAP_AUTO_REHASH_LOADFACTOR * map->table.cap_elems) {
                        return i + 1; /* tell the caller that pair i was inserted, but it successors not */
                }

        }
        return 0;
}

bool jak_hashtable_insert_or_update(jak_hashtable *map, const void *keys, const void *values,
                                uint_fast32_t num_pairs)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ERROR_IF_NULL(keys)
        JAK_ERROR_IF_NULL(values)

        JAK_ASSERT(map->key_data.cap_elems == map->value_data.cap_elems
                   && map->value_data.cap_elems == map->table.cap_elems);
        JAK_ASSERT((map->key_data.num_elems == map->value_data.num_elems)
                   && map->value_data.num_elems <= map->table.num_elems);

        jak_hashtable_lock(map);

        jak_u32 *bucket_idxs = JAK_MALLOC(num_pairs * sizeof(jak_u32));
        if (!bucket_idxs) {
                JAK_ERROR(&map->err, JAK_ERR_MALLOCERR);
                return false;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                hash32_t hash = _JAK_HASH_TABLE_HASHCODE_OF(map->key_data.elem_size, key);
                bucket_idxs[i] = hash % map->table.num_elems;
        }

        uint_fast32_t cont_idx = 0;
        do {
                cont_idx = _jak_hash_table_insert_or_update(map,
                                            bucket_idxs + cont_idx,
                                            keys + cont_idx * map->key_data.elem_size,
                                            values + cont_idx * map->value_data.elem_size,
                                            num_pairs - cont_idx);
                if (cont_idx != 0) {
                        /* rehashing is required, and [status, num_pairs) are left to be inserted */
                        if (!jak_hashtable_rehash(map)) {
                                jak_hashtable_unlock(map);
                                return false;
                        }
                }
        } while (cont_idx != 0);

        free(bucket_idxs);
        jak_hashtable_unlock(map);

        return true;
}

typedef struct jak_hashtable_header {
        char marker;
        jak_offset_t key_data_off;
        jak_offset_t value_data_off;
        jak_offset_t table_off;
        jak_u32 size;
} jak_hashtable_header;

bool jak_hashtable_serialize(FILE *file, jak_hashtable *table)
{
        jak_offset_t header_pos = ftell(file);
        fseek(file, sizeof(jak_hashtable_header), SEEK_CUR);

        jak_offset_t key_data_off = ftell(file);
        if (!jak_vector_serialize(file, &table->key_data)) {
                goto error_handling;
        }

        jak_offset_t value_data_off = ftell(file);
        if (!jak_vector_serialize(file, &table->value_data)) {
                goto error_handling;
        }

        jak_offset_t table_off = ftell(file);
        if (!jak_vector_serialize(file, &table->table)) {
                goto error_handling;
        }

        jak_offset_t end = ftell(file);

        fseek(file, header_pos, SEEK_SET);
        jak_hashtable_header header = {.marker = JAK_MARKER_SYMBOL_HASHTABLE_HEADER, .size = table
                ->size, .key_data_off = key_data_off, .value_data_off = value_data_off, .table_off = table_off};
        int nwrite = fwrite(&header, sizeof(jak_hashtable_header), 1, file);
        JAK_ERROR_IF(nwrite != 1, &table->err, JAK_ERR_FWRITE_FAILED);
        fseek(file, end, SEEK_SET);
        return true;

        error_handling:
        fseek(file, header_pos, SEEK_SET);
        return false;
}

bool jak_hashtable_deserialize(jak_hashtable *table, jak_error *err, FILE *file)
{
        JAK_ERROR_IF_NULL(table)
        JAK_ERROR_IF_NULL(err)
        JAK_ERROR_IF_NULL(file)

        int err_code = JAK_ERR_NOERR;

        jak_hashtable_header header;
        jak_offset_t start = ftell(file);
        int nread = fread(&header, sizeof(jak_hashtable_header), 1, file);
        if (nread != 1) {
                err_code = JAK_ERR_FREAD_FAILED;
                goto error_handling;
        }
        if (header.marker != JAK_MARKER_SYMBOL_HASHTABLE_HEADER) {
                err_code = JAK_ERR_CORRUPTED;
                goto error_handling;
        }

        fseek(file, header.key_data_off, SEEK_SET);
        if (!jak_vector_deserialize(&table->key_data, err, file)) {
                err_code = err->code;
                goto error_handling;
        }

        fseek(file, header.value_data_off, SEEK_SET);
        if (!jak_vector_deserialize(&table->value_data, err, file)) {
                err_code = err->code;
                goto error_handling;
        }

        fseek(file, header.table_off, SEEK_SET);
        if (!jak_vector_deserialize(&table->table, err, file)) {
                err_code = err->code;
                goto error_handling;
        }

        jak_spinlock_init(&table->lock);
        jak_error_init(&table->err);
        return true;

        error_handling:
        fseek(file, start, SEEK_SET);
        JAK_ERROR(err, err_code);
        return false;
}

bool jak_hashtable_remove_if_contained(jak_hashtable *map, const void *keys, size_t num_pairs)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ERROR_IF_NULL(keys)

        jak_hashtable_lock(map);

        jak_u32 *bucket_idxs = JAK_MALLOC(num_pairs * sizeof(jak_u32));
        if (!bucket_idxs) {
                JAK_ERROR(&map->err, JAK_ERR_MALLOCERR);
                jak_hashtable_unlock(map);
                return false;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                bucket_idxs[i] = _JAK_HASH_TABLE_HASHCODE_OF(map->key_data.elem_size, key) % map->table.num_elems;
        }

        for (uint_fast32_t i = 0; i < num_pairs; i++) {
                const void *key = keys + i * map->key_data.elem_size;
                jak_u32 bucket_idx = bucket_idxs[i];
                jak_u32 actual_idx = bucket_idx;
                bool bucket_found = false;

                for (jak_u32 k = bucket_idx; !bucket_found && k < map->table.num_elems; k++) {
                        const jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&map->table, k, jak_hashtable_bucket);
                        bucket_found = bucket->in_use_flag
                                       && memcmp(_jak_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                        actual_idx = k;
                }
                for (jak_u32 k = 0; !bucket_found && k < bucket_idx; k++) {
                        const jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&map->table, k, jak_hashtable_bucket);
                        bucket_found = bucket->in_use_flag
                                       && memcmp(_jak_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                        actual_idx = k;
                }

                if (bucket_found) {
                        jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&map->table, actual_idx, jak_hashtable_bucket);
                        bucket->in_use_flag = false;
                        bucket->data_idx = 0;
                        bucket->num_probs = 0;
                }
        }

        free(bucket_idxs);

        jak_hashtable_unlock(map);

        return true;
}

const void *jak_hashtable_get_value(jak_hashtable *map, const void *key)
{
        JAK_ERROR_IF_NULL(map)
        JAK_ERROR_IF_NULL(key)

        const void *result = NULL;

        jak_hashtable_lock(map);

        jak_u32 bucket_idx = _JAK_HASH_TABLE_HASHCODE_OF(map->key_data.elem_size, key) % map->table.num_elems;
        jak_u32 actual_idx = bucket_idx;
        bool bucket_found = false;

        for (jak_u32 k = bucket_idx; !bucket_found && k < map->table.num_elems; k++) {
                const jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&map->table, k, jak_hashtable_bucket);
                bucket_found =
                        bucket->in_use_flag && memcmp(_jak_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                actual_idx = k;
        }
        for (jak_u32 k = 0; !bucket_found && k < bucket_idx; k++) {
                const jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&map->table, k, jak_hashtable_bucket);
                bucket_found =
                        bucket->in_use_flag && memcmp(_jak_hash_table_get_bucket_key(bucket, map), key, map->key_data.elem_size) == 0;
                actual_idx = k;
        }

        if (bucket_found) {
                jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&map->table, actual_idx, jak_hashtable_bucket);
                result = get_bucket_value(bucket, map);
        }

        jak_hashtable_unlock(map);

        return result;
}

bool jak_hashtable_get_load_factor(float *factor, jak_hashtable *map)
{
        JAK_ERROR_IF_NULL(factor)
        JAK_ERROR_IF_NULL(map)

        jak_hashtable_lock(map);

        *factor = map->size / (float) map->table.num_elems;

        jak_hashtable_unlock(map);

        return true;
}

bool jak_hashtable_rehash(jak_hashtable *map)
{
        JAK_ERROR_IF_NULL(map)

        jak_hashtable_lock(map);

        jak_hashtable *cpy = jak_hashtable_cpy(map);
        jak_hashtable_clear(map);

        size_t new_cap = (cpy->key_data.cap_elems + 1) * 1.7f;

        jak_vector_grow_to(&map->key_data, new_cap);
        jak_vector_grow_to(&map->value_data, new_cap);
        jak_vector_grow_to(&map->table, new_cap);
        jak_vector_enlarge_size_to_capacity(&map->table);
        jak_vector_zero_memory(&map->table);

        JAK_ASSERT(map->key_data.cap_elems == map->value_data.cap_elems
                   && map->value_data.cap_elems == map->table.cap_elems);
        JAK_ASSERT((map->key_data.num_elems == map->value_data.num_elems)
                   && map->value_data.num_elems <= map->table.num_elems);

        for (size_t i = 0; i < cpy->table.num_elems; i++) {
                jak_hashtable_bucket *bucket = JAK_VECTOR_GET(&cpy->table, i, jak_hashtable_bucket);
                if (bucket->in_use_flag) {
                        const void *old_key = _jak_hash_table_get_bucket_key(bucket, cpy);
                        const void *old_value = get_bucket_value(bucket, cpy);
                        if (!jak_hashtable_insert_or_update(map, old_key, old_value, 1)) {
                                JAK_ERROR(&map->err, JAK_ERR_REHASH_NOROLLBACK)
                                jak_hashtable_unlock(map);
                                return false;
                        }
                }
        }

        jak_hashtable_unlock(map);
        return true;
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>

#include <jak_bitmap.h>
#include <jak_pack.h>
#include <jak_huffman.h>

#define  JAK_MARKER_SYMBOL_HUFFMAN_DIC_ENTRY   'd'

bool jak_pack_huffman_init(jak_packer *self)
{
        self->extra = JAK_MALLOC(sizeof(jak_huffman));
        if (self->extra != NULL) {
                jak_huffman *encoder = (jak_huffman *) self->extra;
                jak_coding_huffman_create(encoder);
                return true;
        } else {
                return false;
        }
}

bool jak_pack_jak_coding_huffman_cpy(const jak_packer *self, jak_packer *dst)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_HUFFMAN);

        *dst = *self;
        dst->extra = JAK_MALLOC(sizeof(jak_huffman));
        if (dst->extra != NULL) {
                jak_huffman *self_encoder = (jak_huffman *) self->extra;
                jak_huffman *dst_encoder = (jak_huffman *) dst->extra;
                return jak_coding_huffman_cpy(dst_encoder, self_encoder);
        } else {
                return false;
        }
}

bool jak_pack_jak_coding_huffman_drop(jak_packer *self)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_HUFFMAN);

        jak_huffman *encoder = (jak_huffman *) self->extra;
        jak_coding_huffman_drop(encoder);

        return true;
}

bool huffman_dump_dictionary(FILE *file, jak_memfile *memfile)
{
        jak_pack_huffman_info entry_info;
        jak_offset_t offset;

        while ((*JAK_MEMFILE_PEEK(memfile, char)) == JAK_MARKER_SYMBOL_HUFFMAN_DIC_ENTRY) {
                jak_memfile_get_offset(&offset, memfile);
                jak_coding_huffman_read_entry(&entry_info, memfile, JAK_MARKER_SYMBOL_HUFFMAN_DIC_ENTRY);

                fprintf(file, "0x%04x ", (unsigned) offset);
                fprintf(file,
                        "[marker: %c] [letter: '%c'] [nbytes_prefix: %d] [code: ",
                        JAK_MARKER_SYMBOL_HUFFMAN_DIC_ENTRY,
                        entry_info.letter,
                        entry_info.nbytes_prefix);

                if (entry_info.nbytes_prefix > 0) {
                        for (jak_u16 i = 0; i < entry_info.nbytes_prefix; i++) {
                                jak_bitmap_print_bits_in_char(file, entry_info.prefix_code[i]);
                                fprintf(file, "%s", i + 1 < entry_info.nbytes_prefix ? ", " : "");
                        }
                } else {
                        fprintf(file, "0b00000000");
                }

                fprintf(file, "]\n");
        }
        return true;
}

bool huffman_dump_jak_string_table_entry(FILE *file, jak_memfile *memfile)
{
        JAK_UNUSED(file);
        JAK_UNUSED(memfile);

        jak_pack_huffman_str_info info;

        jak_coding_huffman_read_string(&info, memfile);

        fprintf(file, "[[nbytes_encoded: %d] [bytes: ", info.nbytes_encoded);
        for (size_t i = 0; i < info.nbytes_encoded; i++) {
                char byte = info.encoded_bytes[i];
                jak_bitmap_print_bits_in_char(file, byte);
                fprintf(file, "%s", i + 1 < info.nbytes_encoded ? "," : "");
        }
        fprintf(file, "]\n");

        return true;
}

bool jak_pack_huffman_write_extra(jak_packer *self, jak_memfile *dst,
                              const jak_vector ofType (const char *) *strings)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_HUFFMAN);

        jak_huffman *encoder = (jak_huffman *) self->extra;

        jak_coding_huffman_build(encoder, strings);
        jak_coding_huffman_serialize(dst, encoder, JAK_MARKER_SYMBOL_HUFFMAN_DIC_ENTRY);

        return true;
}

bool jak_pack_huffman_read_extra(jak_packer *self, FILE *src, size_t nbytes)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_HUFFMAN);

        JAK_UNUSED(self);
        JAK_UNUSED(src);
        JAK_UNUSED(nbytes);

        abort(); /* not implemented */
        return false;
}

bool jak_pack_huffman_print_extra(jak_packer *self, FILE *file, jak_memfile *src)
{
        JAK_UNUSED(self);

        huffman_dump_dictionary(file, src);

        return true;
}

bool jak_pack_huffman_print_encoded(jak_packer *self, FILE *file, jak_memfile *src,
                                jak_u32 decompressed_strlen)
{
        JAK_UNUSED(self);
        JAK_UNUSED(file);
        JAK_UNUSED(src);
        JAK_UNUSED(decompressed_strlen);

        huffman_dump_jak_string_table_entry(file, src);

        return true;
}

bool
jak_pack_huffman_encode_string(jak_packer *self, jak_memfile *dst, jak_error *err, const char *string)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_HUFFMAN);

        jak_huffman *encoder = (jak_huffman *) self->extra;
        bool status = jak_coding_huffman_encode(dst, encoder, string);
        jak_error_cpy(err, &encoder->err);

        return status;
}

bool jak_pack_huffman_decode_string(jak_packer *self, char *dst, size_t strlen, FILE *src)
{
        JAK_UNUSED(self);
        JAK_UNUSED(dst);
        JAK_UNUSED(strlen);
        JAK_UNUSED(src);
        abort(); /* not implemented */
        return false;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>
#include <ctype.h>
#include <locale.h>
#include <jak_json.h>
#include <jak_doc.h>
#include <jak_utils_convert.h>
#include <jak_utils_numbers.h>
#include "jak_json.h"

static struct {
        jak_json_token_e token;
        const char *string;
} JAK_JSON_TOKEN_STRINGS[] = {{.token = JAK_OBJECT_OPEN, .string = "JAK_OBJECT_OPEN"},
                              {.token = JAK_OBJECT_CLOSE, .string = "JAK_OBJECT_CLOSE"},
                              {.token = JAK_LITERAL_STRING, .string = "JSON_TOKEN_STRING"},
                              {.token = JAK_LITERAL_INT, .string = "JAK_LITERAL_INT"},
                              {.token = JAK_LITERAL_FLOAT, .string = "JAK_LITERAL_FLOAT"},
                              {.token = JAK_LITERAL_TRUE, .string = "JAK_LITERAL_TRUE"},
                              {.token = JAK_LITERAL_FALSE, .string = "JAK_LITERAL_FALSE"},
                              {.token = JAK_LITERAL_NULL, .string = "JAK_LITERAL_NULL"},
                              {.token = JAK_COMMA, .string = "JAK_COMMA"},
                              {.token = JAK_ASSIGN, .string = "JSON_TOKEN_ASSIGMENT"},
                              {.token = JAK_ARRAY_OPEN, .string = "JAK_ARRAY_OPEN"},
                              {.token = JAK_ARRAY_CLOSE, .string = "JAK_ARRAY_CLOSE"},
                              {.token = JAK_JSON_UNKNOWN, .string = "JAK_JSON_UNKNOWN"}};

struct token_memory {
        jak_json_token_e type;
        bool init;
};

static int process_token(jak_error *err, jak_json_err *error_desc, const jak_json_token *token,
                         jak_vector ofType(jak_json_token_e) *brackets, struct token_memory *token_mem);

static int set_error(jak_json_err *error_desc, const jak_json_token *token, const char *msg);

bool jak_json_tokenizer_init(jak_json_tokenizer *tokenizer, const char *input)
{
        JAK_ERROR_IF_NULL(tokenizer)
        JAK_ERROR_IF_NULL(input)
        tokenizer->cursor = input;
        tokenizer->token =
                (jak_json_token) {.type = JAK_JSON_UNKNOWN, .length = 0, .column = 0, .line = 1, .string = NULL};
        jak_error_init(&tokenizer->err);
        return true;
}

static void
parse_jak_string_token(jak_json_tokenizer *tokenizer, char c, char delimiter, char delimiter2, char delimiter3,
                   bool include_start, bool include_end)
{
        bool escapeQuote = false;
        tokenizer->token.type = JAK_LITERAL_STRING;
        if (!include_start) {
                tokenizer->token.string++;
        }
        tokenizer->token.column++;
        char last_1_c = '\0', last_2_c = '\0', last_3_c = '\0', last_4_c = '\0';
        c = *(++tokenizer->cursor);
        while ((escapeQuote || (c != delimiter && c != delimiter2 && c != delimiter3)) && c != '\r' && c != '\n') {
                next_char:
                tokenizer->token.length++;
                last_4_c = last_3_c;
                last_3_c = last_2_c;
                last_2_c = last_1_c;
                last_1_c = c;
                c = *(++tokenizer->cursor);
                if (JAK_UNLIKELY(c == '\\' && last_1_c == '\\')) {
                        goto next_char;
                }
                escapeQuote = c == '"' && last_1_c == '\\'
                              && ((last_2_c == '\\' && last_3_c == '\\' && last_4_c != '\\')
                                  || (last_2_c != '\\' && last_3_c == '\\')
                                  || (last_2_c != '\\' && last_3_c != '\\'));
        }

        if (include_end) {
                tokenizer->token.length++;
        } else {
                tokenizer->cursor++;
        }

        tokenizer->cursor += (c == '\r' || c == '\n') ? 1 : 0;
}

const jak_json_token *json_tokenizer_next(jak_json_tokenizer *tokenizer)
{
        if (JAK_LIKELY(*tokenizer->cursor != '\0')) {
                char c = *tokenizer->cursor;
                tokenizer->token.string = tokenizer->cursor;
                tokenizer->token.column += tokenizer->token.length;
                tokenizer->token.length = 0;
                if (c == '\n' || c == '\r') {
                        tokenizer->token.line += c == '\n' ? 1 : 0;
                        tokenizer->token.column = c == '\n' ? 0 : tokenizer->token.column;
                        tokenizer->cursor++;
                        return json_tokenizer_next(tokenizer);
                } else if (isspace(c)) {
                        do {
                                tokenizer->cursor++;
                                tokenizer->token.column++;
                        } while (isspace(c = *tokenizer->cursor) && c != '\n');
                        return json_tokenizer_next(tokenizer);
                } else if (c == '{' || c == '}' || c == '[' || c == ']' || c == ':' || c == ',') {
                        tokenizer->token.type =
                                c == '{' ? JAK_OBJECT_OPEN : c == '}' ? JAK_OBJECT_CLOSE : c == '[' ? JAK_ARRAY_OPEN : c == ']'
                                                                                                           ? JAK_ARRAY_CLOSE
                                                                                                           : c == ':'
                                                                                                             ? JAK_ASSIGN
                                                                                                             : JAK_COMMA;
                        tokenizer->token.column++;
                        tokenizer->token.length = 1;
                        tokenizer->cursor++;
                } else if (c != '"' && (isalpha(c) || c == '_') &&
                           (strlen(tokenizer->cursor) >= 4 && (strncmp(tokenizer->cursor, "null", 4) != 0 &&
                                                               strncmp(tokenizer->cursor, "true", 4) != 0)) &&
                           (strlen(tokenizer->cursor) >= 5 && strncmp(tokenizer->cursor, "false", 5) != 0)) {
                        parse_jak_string_token(tokenizer, c, ' ', ':', ',', true, true);
                } else if (c == '"') {
                        parse_jak_string_token(tokenizer, c, '"', '"', '"', false, false);
                } else if (c == 't' || c == 'f' || c == 'n') {
                        const unsigned lenTrueNull = 4;
                        const unsigned lenFalse = 5;
                        const unsigned cursorLen = strlen(tokenizer->cursor);
                        if (cursorLen >= lenTrueNull && strncmp(tokenizer->cursor, "true", lenTrueNull) == 0) {
                                tokenizer->token.type = JAK_LITERAL_TRUE;
                                tokenizer->token.length = lenTrueNull;
                        } else if (cursorLen >= lenFalse && strncmp(tokenizer->cursor, "false", lenFalse) == 0) {
                                tokenizer->token.type = JAK_LITERAL_FALSE;
                                tokenizer->token.length = lenFalse;
                        } else if (cursorLen >= lenTrueNull && strncmp(tokenizer->cursor, "null", lenTrueNull) == 0) {
                                tokenizer->token.type = JAK_LITERAL_NULL;
                                tokenizer->token.length = lenTrueNull;
                        } else {
                                goto caseTokenUnknown;
                        }
                        tokenizer->token.column++;
                        tokenizer->cursor += tokenizer->token.length;
                } else if (c == '-' || isdigit(c)) {
                        unsigned fracFound = 0, expFound = 0, plusMinusFound = 0;
                        bool plusMinusAllowed = false;
                        bool onlyDigitsAllowed = false;
                        do {
                                onlyDigitsAllowed |= plusMinusAllowed;
                                plusMinusAllowed = (expFound == 1);
                                c = *(++tokenizer->cursor);
                                fracFound += c == '.';
                                expFound += (c == 'e') || (c == 'E');
                                plusMinusFound += plusMinusAllowed && ((c == '+') || (c == '-')) ? 1 : 0;
                                tokenizer->token.length++;
                        } while ((((isdigit(c)) || (c == '.' && fracFound <= 1)
                                   || (plusMinusAllowed && (plusMinusFound <= 1) && ((c == '+') || (c == '-')))
                                   || ((c == 'e' || c == 'E') && expFound <= 1))) && c != '\n' && c != '\r');

                        if (!isdigit(*(tokenizer->cursor - 1))) {
                                tokenizer->token.column -= tokenizer->token.length;
                                goto caseTokenUnknown;
                        }
                        tokenizer->cursor += (c == '\r' || c == '\n') ? 1 : 0;
                        tokenizer->token.type = fracFound ? JAK_LITERAL_FLOAT : JAK_LITERAL_INT;
                } else {
                        caseTokenUnknown:
                        tokenizer->token.type = JAK_JSON_UNKNOWN;
                        tokenizer->token.column++;
                        tokenizer->token.length = strlen(tokenizer->cursor);
                        tokenizer->cursor += tokenizer->token.length;
                }
                return &tokenizer->token;
        } else {
                return NULL;
        }
}

void jak_json_token_dup(jak_json_token *dst, const jak_json_token *src)
{
        JAK_ASSERT(dst);
        JAK_ASSERT(src);
        memcpy(dst, src, sizeof(jak_json_token));
}

void jak_json_token_print(FILE *file, const jak_json_token *token)
{
        char *string = JAK_MALLOC(token->length + 1);
        strncpy(string, token->string, token->length);
        string[token->length] = '\0';
        fprintf(file,
                "{\"type\": \"%s\", \"line\": %d, \"column\": %d, \"length\": %d, \"text\": \"%s\"}",
                JAK_JSON_TOKEN_STRINGS[token->type].string,
                token->line,
                token->column,
                token->length,
                string);
        free(string);
}

static bool parse_object(jak_json_object *object, jak_error *err,
                         jak_vector ofType(jak_json_token) *token_stream, size_t *token_idx);

static bool parse_array(jak_json_array *array, jak_error *err,
                        jak_vector ofType(jak_json_token) *token_stream, size_t *token_idx);

static void parse_string(jak_json_string *string, jak_vector ofType(jak_json_token) *token_stream,
                         size_t *token_idx);

static void parse_number(jak_json_number *number, jak_vector ofType(jak_json_token) *token_stream,
                         size_t *token_idx);

static bool parse_element(jak_json_element *element, jak_error *err,
                          jak_vector ofType(jak_json_token) *token_stream, size_t *token_idx);

static bool parse_elements(jak_json_elements *elements, jak_error *err,
                           jak_vector ofType(jak_json_token) *token_stream, size_t *token_idx);

static bool parse_token_stream(jak_json *jak_json, jak_error *err,
                               jak_vector ofType(jak_json_token) *token_stream);

static jak_json_token get_token(jak_vector ofType(jak_json_token) *token_stream, size_t token_idx);

static void connect_child_and_parents_member(jak_json_prop *member);

static void connect_child_and_parents_object(jak_json_object *object);

static void connect_child_and_parents_array(jak_json_array *array);

static void connect_child_and_parents_value(jak_json_node_value *value);

static void connect_child_and_parents_element(jak_json_element *element);

static void connect_child_and_parents(jak_json *jak_json);

static bool json_ast_node_member_print(FILE *file, jak_error *err, jak_json_prop *member);

static bool json_ast_node_object_print(FILE *file, jak_error *err, jak_json_object *object);

static bool json_ast_node_array_print(FILE *file, jak_error *err, jak_json_array *array);

static void json_ast_node_jak_string_print(FILE *file, jak_json_string *string);

static bool json_ast_node_number_print(FILE *file, jak_error *err, jak_json_number *number);

static bool json_ast_node_value_print(FILE *file, jak_error *err, jak_json_node_value *value);

static bool json_ast_node_element_print(FILE *file, jak_error *err, jak_json_element *element);

#define NEXT_TOKEN(x) { *x = *x + 1; }
#define PREV_TOKEN(x) { *x = *x - 1; }

bool jak_json_parser_create(jak_json_parser *parser)
{
        JAK_ERROR_IF_NULL(parser)

        jak_error_init(&parser->err);

        return true;
}

bool
jak_json_parse(jak_json *json, jak_json_err *error_desc, jak_json_parser *parser, const char *input)
{
        JAK_ERROR_IF_NULL(parser)
        JAK_ERROR_IF_NULL(input)

        jak_vector ofType(jak_json_token_e) brackets;
        jak_vector ofType(jak_json_token) token_stream;

        jak_json retval;
        JAK_ZERO_MEMORY(&retval, sizeof(jak_json))
        retval.element = JAK_MALLOC(sizeof(jak_json_element));
        jak_error_init(&retval.err);
        const jak_json_token *token;
        int status;

        jak_json_tokenizer_init(&parser->tokenizer, input);
        jak_vector_create(&brackets, NULL, sizeof(jak_json_token_e), 15);
        jak_vector_create(&token_stream, NULL, sizeof(jak_json_token), 200);

        struct token_memory token_mem = {.init = true, .type = JAK_JSON_UNKNOWN};

        while ((token = json_tokenizer_next(&parser->tokenizer))) {
                if (JAK_LIKELY(
                        (status = process_token(&parser->err, error_desc, token, &brackets, &token_mem)) == true)) {
                        jak_json_token *newToken = JAK_VECTOR_NEW_AND_GET(&token_stream, jak_json_token);
                        jak_json_token_dup(newToken, token);
                } else {
                        goto cleanup;
                }
        }
        if (!jak_vector_is_empty(&brackets)) {
                jak_json_token_e type = *JAK_VECTOR_PEEK(&brackets, jak_json_token_e);
                char buffer[1024];
                sprintf(&buffer[0],
                        "Unexpected end of file: missing '%s' to match unclosed '%s' (if any)",
                        type == JAK_OBJECT_OPEN ? "}" : "]",
                        type == JAK_OBJECT_OPEN ? "{" : "[");
                status = set_error(error_desc, token, &buffer[0]);
                goto cleanup;
        }

        if (!parse_token_stream(&retval, &parser->err, &token_stream)) {
                return false;
        }

        JAK_OPTIONAL_SET_OR_ELSE(json, retval, jak_json_drop(json));
        status = true;

        cleanup:
        jak_vector_drop(&brackets);
        jak_vector_drop(&token_stream);
        return status;
}

bool test_condition_value(jak_error *err, jak_json_node_value *value)
{
        switch (value->value_type) {
                case JAK_JSON_VALUE_OBJECT:
                        for (size_t i = 0; i < value->value.object->value->members.num_elems; i++) {
                                jak_json_prop *member = JAK_VECTOR_GET(&value->value.object->value->members, i,
                                                                       jak_json_prop);
                                if (!test_condition_value(err, &member->value.value)) {
                                        return false;
                                }
                        }
                        break;
                case JAK_JSON_VALUE_ARRAY: {
                        jak_json_elements *elements = &value->value.array->elements;
                        jak_json_value_type_e value_type = JAK_JSON_VALUE_NULL;

                        for (size_t i = 0; i < elements->elements.num_elems; i++) {
                                jak_json_element *element = JAK_VECTOR_GET(&elements->elements, i,
                                                                           jak_json_element);
                                value_type =
                                        ((i == 0 || value_type == JAK_JSON_VALUE_NULL) ? element->value.value_type
                                                                                   : value_type);

                                /** Test "All elements in array of same type" condition */
                                if ((element->value.value_type != JAK_JSON_VALUE_NULL) && (value_type == JAK_JSON_VALUE_TRUE
                                                                                       && (element->value.value_type !=
                                                                                           JAK_JSON_VALUE_TRUE
                                                                                           ||
                                                                                           element->value.value_type !=
                                                                                           JAK_JSON_VALUE_FALSE))
                                    && (value_type == JAK_JSON_VALUE_FALSE && (element->value.value_type != JAK_JSON_VALUE_TRUE
                                                                           || element->value.value_type !=
                                                                              JAK_JSON_VALUE_FALSE))
                                    && ((value_type != JAK_JSON_VALUE_TRUE && value_type != JAK_JSON_VALUE_FALSE)
                                        && value_type != element->value.value_type)) {
                                        char message[] = "JSON file constraint broken: arrays of mixed types detected";
                                        char *result = JAK_MALLOC(strlen(message) + 1);
                                        strcpy(result, &message[0]);
                                        JAK_ERROR_WDETAILS(err, JAK_ERR_ARRAYOFMIXEDTYPES, result);
                                        free(result);
                                        return false;
                                }

                                switch (element->value.value_type) {
                                        case JAK_JSON_VALUE_OBJECT: {
                                                jak_json_object *object = element->value.value.object;
                                                for (size_t i = 0; i < object->value->members.num_elems; i++) {
                                                        jak_json_prop
                                                                *member = JAK_VECTOR_GET(&object->value->members, i,
                                                                                  jak_json_prop);
                                                        if (!test_condition_value(err, &member->value.value)) {
                                                                return false;
                                                        }
                                                }
                                        }
                                                break;
                                        case JAK_JSON_VALUE_ARRAY: {/** Test "No Array of Arrays" condition */
                                                char message[] = "JSON file constraint broken: arrays of arrays detected";
                                                char *result = JAK_MALLOC(strlen(message) + 1);
                                                strcpy(result, &message[0]);
                                                JAK_ERROR_WDETAILS(err, JAK_ERR_ARRAYOFARRAYS, result);
                                                free(result);
                                                return false;
                                        }
                                        default:
                                                break;
                                }
                        }
                }
                        break;
                default:
                        break;
        }
        return true;
}

bool jak_json_test(jak_error *err, jak_json *jak_json)
{
        return (test_condition_value(err, &jak_json->element->value));
}

static jak_json_token get_token(jak_vector ofType(jak_json_token) *token_stream, size_t token_idx)
{
        return *(jak_json_token *) jak_vector_at(token_stream, token_idx);
}

bool parse_members(jak_error *err, jak_json_members *members,
                   jak_vector ofType(jak_json_token) *token_stream,
                   size_t *token_idx)
{
        jak_vector_create(&members->members, NULL, sizeof(jak_json_prop), 20);
        jak_json_token delimiter_token;

        do {
                jak_json_prop *member = JAK_VECTOR_NEW_AND_GET(&members->members, jak_json_prop);
                jak_json_token keyNameToken = get_token(token_stream, *token_idx);

                member->key.value = JAK_MALLOC(keyNameToken.length + 1);
                strncpy(member->key.value, keyNameToken.string, keyNameToken.length);
                member->key.value[keyNameToken.length] = '\0';

                NEXT_TOKEN(token_idx); /** skip assignment token */
                NEXT_TOKEN(token_idx);
                jak_json_token valueToken = get_token(token_stream, *token_idx);

                switch (valueToken.type) {
                        case JAK_OBJECT_OPEN:
                                member->value.value.value_type = JAK_JSON_VALUE_OBJECT;
                                member->value.value.value.object = JAK_MALLOC(sizeof(jak_json_object));
                                if (!parse_object(member->value.value.value.object, err, token_stream, token_idx)) {
                                        return false;
                                }
                                break;
                        case JAK_ARRAY_OPEN:
                                member->value.value.value_type = JAK_JSON_VALUE_ARRAY;
                                member->value.value.value.array = JAK_MALLOC(sizeof(jak_json_array));
                                if (!parse_array(member->value.value.value.array, err, token_stream, token_idx)) {
                                        return false;
                                }
                                break;
                        case JAK_LITERAL_STRING:
                                member->value.value.value_type = JAK_JSON_VALUE_STRING;
                                member->value.value.value.string = JAK_MALLOC(sizeof(jak_json_string));
                                parse_string(member->value.value.value.string, token_stream, token_idx);
                                break;
                        case JAK_LITERAL_INT:
                        case JAK_LITERAL_FLOAT:
                                member->value.value.value_type = JAK_JSON_VALUE_NUMBER;
                                member->value.value.value.number = JAK_MALLOC(sizeof(jak_json_number));
                                parse_number(member->value.value.value.number, token_stream, token_idx);
                                break;
                        case JAK_LITERAL_TRUE:
                                member->value.value.value_type = JAK_JSON_VALUE_TRUE;
                                NEXT_TOKEN(token_idx);
                                break;
                        case JAK_LITERAL_FALSE:
                                member->value.value.value_type = JAK_JSON_VALUE_FALSE;
                                NEXT_TOKEN(token_idx);
                                break;
                        case JAK_LITERAL_NULL:
                                member->value.value.value_type = JAK_JSON_VALUE_NULL;
                                NEXT_TOKEN(token_idx);
                                break;
                        default: JAK_ERROR(err, JAK_ERR_PARSETYPE)
                                return false;
                }

                delimiter_token = get_token(token_stream, *token_idx);
                NEXT_TOKEN(token_idx);
        } while (delimiter_token.type == JAK_COMMA);
        PREV_TOKEN(token_idx);
        return true;
}

static bool parse_object(jak_json_object *object, jak_error *err,
                         jak_vector ofType(jak_json_token) *token_stream, size_t *token_idx)
{
        JAK_ASSERT(get_token(token_stream, *token_idx).type == JAK_OBJECT_OPEN);
        NEXT_TOKEN(token_idx);  /** Skip '{' */
        object->value = JAK_MALLOC(sizeof(jak_json_members));

        /** test whether this is an empty object */
        jak_json_token token = get_token(token_stream, *token_idx);

        if (token.type != JAK_OBJECT_CLOSE) {
                if (!parse_members(err, object->value, token_stream, token_idx)) {
                        return false;
                }
        } else {
                jak_vector_create(&object->value->members, NULL, sizeof(jak_json_prop), 20);
        }

        NEXT_TOKEN(token_idx);  /** Skip '}' */
        return true;
}

static bool parse_array(jak_json_array *array, jak_error *err,
                        jak_vector ofType(jak_json_token) *token_stream, size_t *token_idx)
{
        jak_json_token token = get_token(token_stream, *token_idx);
        JAK_UNUSED(token);
        JAK_ASSERT(token.type == JAK_ARRAY_OPEN);
        NEXT_TOKEN(token_idx); /** Skip '[' */

        jak_vector_create(&array->elements.elements, NULL, sizeof(jak_json_element), 250);
        if (!parse_elements(&array->elements, err, token_stream, token_idx)) {
                return false;
        }

        NEXT_TOKEN(token_idx); /** Skip ']' */
        return true;
}

static void parse_string(jak_json_string *string, jak_vector ofType(jak_json_token) *token_stream,
                         size_t *token_idx)
{
        jak_json_token token = get_token(token_stream, *token_idx);
        JAK_ASSERT(token.type == JAK_LITERAL_STRING);

        string->value = JAK_MALLOC(token.length + 1);
        if (JAK_LIKELY(token.length > 0)) {
                strncpy(string->value, token.string, token.length);
        }
        string->value[token.length] = '\0';
        NEXT_TOKEN(token_idx);
}

static void parse_number(jak_json_number *number, jak_vector ofType(jak_json_token) *token_stream,
                         size_t *token_idx)
{
        jak_json_token token = get_token(token_stream, *token_idx);
        JAK_ASSERT(token.type == JAK_LITERAL_FLOAT || token.type == JAK_LITERAL_INT);

        char *value = JAK_MALLOC(token.length + 1);
        strncpy(value, token.string, token.length);
        value[token.length] = '\0';

        if (token.type == JAK_LITERAL_INT) {
                jak_i64 assumeSigned = jak_convert_atoi64(value);
                if (value[0] == '-') {
                        number->value_type = JAK_JSON_NUMBER_SIGNED;
                        number->value.signed_integer = assumeSigned;
                } else {
                        jak_u64 assumeUnsigned = jak_convert_atoiu64(value);
                        if (assumeUnsigned >= (jak_u64) assumeSigned) {
                                number->value_type = JAK_JSON_NUMBER_UNSIGNED;
                                number->value.unsigned_integer = assumeUnsigned;
                        } else {
                                number->value_type = JAK_JSON_NUMBER_SIGNED;
                                number->value.signed_integer = assumeSigned;
                        }
                }
        } else {
                number->value_type = JAK_JSON_NUMBER_FLOAT;
                setlocale(LC_ALL | ~LC_NUMERIC, "");
                number->value.float_number = strtof(value, NULL);
        }

        free(value);
        NEXT_TOKEN(token_idx);
}

static bool parse_element(jak_json_element *element, jak_error *err,
                          jak_vector ofType(jak_json_token) *token_stream, size_t *token_idx)
{
        jak_json_token token = get_token(token_stream, *token_idx);

        if (token.type == JAK_OBJECT_OPEN) { /** Parse object */
                element->value.value_type = JAK_JSON_VALUE_OBJECT;
                element->value.value.object = JAK_MALLOC(sizeof(jak_json_object));
                if (!parse_object(element->value.value.object, err, token_stream, token_idx)) {
                        return false;
                }
        } else if (token.type == JAK_ARRAY_OPEN) { /** Parse array */
                element->value.value_type = JAK_JSON_VALUE_ARRAY;
                element->value.value.array = JAK_MALLOC(sizeof(jak_json_array));
                if (!parse_array(element->value.value.array, err, token_stream, token_idx)) {
                        return false;
                }
        } else if (token.type == JAK_LITERAL_STRING) { /** Parse string */
                element->value.value_type = JAK_JSON_VALUE_STRING;
                element->value.value.string = JAK_MALLOC(sizeof(jak_json_string));
                parse_string(element->value.value.string, token_stream, token_idx);
        } else if (token.type == JAK_LITERAL_FLOAT || token.type == JAK_LITERAL_INT) { /** Parse number */
                element->value.value_type = JAK_JSON_VALUE_NUMBER;
                element->value.value.number = JAK_MALLOC(sizeof(jak_json_number));
                parse_number(element->value.value.number, token_stream, token_idx);
        } else if (token.type == JAK_LITERAL_TRUE) {
                element->value.value_type = JAK_JSON_VALUE_TRUE;
                NEXT_TOKEN(token_idx);
        } else if (token.type == JAK_LITERAL_FALSE) {
                element->value.value_type = JAK_JSON_VALUE_FALSE;
                NEXT_TOKEN(token_idx);
        } else if (token.type == JAK_LITERAL_NULL) {
                element->value.value_type = JAK_JSON_VALUE_NULL;
                NEXT_TOKEN(token_idx);
        } else {
                element->value.value_type = JAK_JSON_VALUE_NULL;
        }
        return true;
}

static bool parse_elements(jak_json_elements *elements, jak_error *err,
                           jak_vector ofType(jak_json_token) *token_stream, size_t *token_idx)
{
        jak_json_token delimiter;
        do {
                jak_json_token current = get_token(token_stream, *token_idx);
                if (current.type != JAK_ARRAY_CLOSE && current.type != JAK_OBJECT_CLOSE) {
                        if (!parse_element(JAK_VECTOR_NEW_AND_GET(&elements->elements, jak_json_element),
                                           err,
                                           token_stream,
                                           token_idx)) {
                                return false;
                        }
                }
                delimiter = get_token(token_stream, *token_idx);
                NEXT_TOKEN(token_idx);
        } while (delimiter.type == JAK_COMMA);
        PREV_TOKEN(token_idx);
        return true;
}

static bool parse_token_stream(jak_json *jak_json, jak_error *err,
                               jak_vector ofType(jak_json_token) *token_stream)
{
        size_t token_idx = 0;
        if (!parse_element(jak_json->element, err, token_stream, &token_idx)) {
                return false;
        }
        connect_child_and_parents(jak_json);
        return true;
}

static void connect_child_and_parents_member(jak_json_prop *member)
{
        connect_child_and_parents_element(&member->value);
}

static void connect_child_and_parents_object(jak_json_object *object)
{
        object->value->parent = object;
        for (size_t i = 0; i < object->value->members.num_elems; i++) {
                jak_json_prop *member = JAK_VECTOR_GET(&object->value->members, i, jak_json_prop);
                member->parent = object->value;

                member->key.parent = member;

                member->value.parent_type = JAK_JSON_PARENT_MEMBER;
                member->value.parent.member = member;

                connect_child_and_parents_member(member);
        }
}

static void connect_child_and_parents_array(jak_json_array *array)
{
        array->elements.parent = array;
        for (size_t i = 0; i < array->elements.elements.num_elems; i++) {
                jak_json_element *element = JAK_VECTOR_GET(&array->elements.elements, i, jak_json_element);
                element->parent_type = JAK_JSON_PARENT_ELEMENTS;
                element->parent.elements = &array->elements;
                connect_child_and_parents_element(element);
        }
}

static void connect_child_and_parents_value(jak_json_node_value *value)
{
        switch (value->value_type) {
                case JAK_JSON_VALUE_OBJECT:
                        connect_child_and_parents_object(value->value.object);
                        break;
                case JAK_JSON_VALUE_ARRAY:
                        connect_child_and_parents_array(value->value.array);
                        break;
                default:
                        break;
        }
}

static void connect_child_and_parents_element(jak_json_element *element)
{
        element->value.parent = element;
        connect_child_and_parents_value(&element->value);
}

static void connect_child_and_parents(jak_json *jak_json)
{
        jak_json->element->parent_type = JAK_JSON_PARENT_OBJECT;
        jak_json->element->parent.jak_json = jak_json;
        connect_child_and_parents_element(jak_json->element);
}

static bool isValue(jak_json_token_e token)
{
        return (token == JAK_LITERAL_STRING || token == JAK_LITERAL_FLOAT || token == JAK_LITERAL_INT || token == JAK_LITERAL_TRUE
                || token == JAK_LITERAL_FALSE || token == JAK_LITERAL_NULL);
}

static int process_token(jak_error *err, jak_json_err *error_desc, const jak_json_token *token,
                         jak_vector ofType(jak_json_token_e) *brackets, struct token_memory *token_mem)
{
        switch (token->type) {
                case JAK_OBJECT_OPEN:
                case JAK_ARRAY_OPEN:
                        jak_vector_push(brackets, &token->type, 1);
                        break;
                case JAK_OBJECT_CLOSE:
                case JAK_ARRAY_CLOSE: {
                        if (!jak_vector_is_empty(brackets)) {
                                jak_json_token_e bracket = *JAK_VECTOR_PEEK(brackets, jak_json_token_e);
                                if ((token->type == JAK_ARRAY_CLOSE && bracket == JAK_ARRAY_OPEN)
                                    || (token->type == JAK_OBJECT_CLOSE && bracket == JAK_OBJECT_OPEN)) {
                                        jak_vector_pop(brackets);
                                } else {
                                        goto pushEntry;
                                }
                        } else {
                                pushEntry:
                                jak_vector_push(brackets, &token->type, 1);
                        }
                }
                        break;
                default:
                        break;
        }

        switch (token_mem->type) {
                case JAK_OBJECT_OPEN:
                        switch (token->type) {
                                case JAK_LITERAL_STRING:
                                case JAK_OBJECT_CLOSE:
                                        break;
                                default:
                                        return set_error(error_desc, token, "Expected key name or '}'");
                        }
                        break;
                case JAK_LITERAL_STRING:
                        switch (token->type) {
                                case JAK_ASSIGN:
                                case JAK_COMMA:
                                case JAK_ARRAY_CLOSE:
                                case JAK_OBJECT_CLOSE:
                                        break;
                                default:
                                        return set_error(error_desc, token,
                                                         "Expected key name (missing ':'), enumeration (','), "
                                                         "end of enumeration (']'), or end of object ('}')");
                        }
                        break;
                case JAK_OBJECT_CLOSE:
                case JAK_LITERAL_INT:
                case JAK_LITERAL_FLOAT:
                case JAK_LITERAL_TRUE:
                case JAK_LITERAL_FALSE:
                case JAK_LITERAL_NULL:
                        switch (token->type) {
                                case JAK_COMMA:
                                case JAK_ARRAY_CLOSE:
                                case JAK_OBJECT_CLOSE:
                                        break;
                                default:
                                        return set_error(error_desc, token,
                                                         "Expected enumeration (','), end of enumeration (']'), "
                                                         "or end of object ('})");
                        }
                        break;
                case JAK_ASSIGN:
                case JAK_COMMA:
                        switch (token->type) {
                                case JAK_LITERAL_STRING:
                                case JAK_LITERAL_FLOAT:
                                case JAK_LITERAL_INT:
                                case JAK_OBJECT_OPEN:
                                case JAK_ARRAY_OPEN:
                                case JAK_LITERAL_TRUE:
                                case JAK_LITERAL_FALSE:
                                case JAK_LITERAL_NULL:
                                        break;
                                default:
                                        return set_error(error_desc,
                                                         token,
                                                         "Expected key name, or value (string, number, object, enumeration, true, "
                                                         "false, or null).");
                        }
                        break;
                case JAK_ARRAY_OPEN:
                        switch (token->type) {
                                case JAK_ARRAY_CLOSE:
                                case JAK_LITERAL_STRING:
                                case JAK_LITERAL_FLOAT:
                                case JAK_LITERAL_INT:
                                case JAK_OBJECT_OPEN:
                                case JAK_ARRAY_OPEN:
                                case JAK_LITERAL_TRUE:
                                case JAK_LITERAL_FALSE:
                                case JAK_LITERAL_NULL:
                                        break;
                                default:
                                        return set_error(error_desc, token,
                                                         "End of enumeration (']'), enumeration (','), or "
                                                         "end of enumeration (']')");
                        }
                        break;
                case JAK_ARRAY_CLOSE:
                        switch (token->type) {
                                case JAK_COMMA:
                                case JAK_ARRAY_CLOSE:
                                case JAK_OBJECT_CLOSE:
                                        break;
                                default:
                                        return set_error(error_desc, token,
                                                         "End of enumeration (']'), enumeration (','), or "
                                                         "end of object ('}')");
                        }
                        break;
                case JAK_JSON_UNKNOWN:
                        if (token_mem->init) {
                                if (token->type != JAK_OBJECT_OPEN && token->type != JAK_ARRAY_OPEN && !isValue(token->type)) {
                                        return set_error(error_desc, token,
                                                         "Expected JSON document: missing '{' or '['");
                                }
                                token_mem->init = false;
                        } else {
                                return set_error(error_desc, token, "Unexpected token");
                        }
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOJSONTOKEN)
                        return false;
        }

        token_mem->type = token->type;
        return true;
}

static int set_error(jak_json_err *error_desc, const jak_json_token *token, const char *msg)
{
        if (error_desc) {
                error_desc->token = token;
                error_desc->token_type_str = token ? JAK_JSON_TOKEN_STRINGS[token->type].string : "(no token)";
                error_desc->msg = msg;
        }
        return false;
}

static bool json_ast_node_member_print(FILE *file, jak_error *err, jak_json_prop *member)
{
        fprintf(file, "\"%s\": ", member->key.value);
        return json_ast_node_value_print(file, err, &member->value.value);
}

static bool json_ast_node_object_print(FILE *file, jak_error *err, jak_json_object *object)
{
        fprintf(file, "{");
        for (size_t i = 0; i < object->value->members.num_elems; i++) {
                jak_json_prop *member = JAK_VECTOR_GET(&object->value->members, i, jak_json_prop);
                if (!json_ast_node_member_print(file, err, member)) {
                        return false;
                }
                fprintf(file, "%s", i + 1 < object->value->members.num_elems ? ", " : "");
        }
        fprintf(file, "}");
        return true;
}

static bool json_ast_node_array_print(FILE *file, jak_error *err, jak_json_array *array)
{
        fprintf(file, "[");
        for (size_t i = 0; i < array->elements.elements.num_elems; i++) {
                jak_json_element *element = JAK_VECTOR_GET(&array->elements.elements, i, jak_json_element);
                if (!json_ast_node_element_print(file, err, element)) {
                        return false;
                }
                fprintf(file, "%s", i + 1 < array->elements.elements.num_elems ? ", " : "");
        }
        fprintf(file, "]");
        return true;
}

static void json_ast_node_jak_string_print(FILE *file, jak_json_string *string)
{
        fprintf(file, "\"%s\"", string->value);
}

static bool json_ast_node_number_print(FILE *file, jak_error *err, jak_json_number *number)
{
        switch (number->value_type) {
                case JAK_JSON_NUMBER_FLOAT:
                        fprintf(file, "%f", number->value.float_number);
                        break;
                case JAK_JSON_NUMBER_UNSIGNED:
                        fprintf(file, "%" PRIu64, number->value.unsigned_integer);
                        break;
                case JAK_JSON_NUMBER_SIGNED:
                        fprintf(file, "%" PRIi64, number->value.signed_integer);
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOJSONNUMBERT);
                        return false;
        }
        return true;
}

static bool json_ast_node_value_print(FILE *file, jak_error *err, jak_json_node_value *value)
{
        switch (value->value_type) {
                case JAK_JSON_VALUE_OBJECT:
                        if (!json_ast_node_object_print(file, err, value->value.object)) {
                                return false;
                        }
                        break;
                case JAK_JSON_VALUE_ARRAY:
                        if (!json_ast_node_array_print(file, err, value->value.array)) {
                                return false;
                        }
                        break;
                case JAK_JSON_VALUE_STRING:
                        json_ast_node_jak_string_print(file, value->value.string);
                        break;
                case JAK_JSON_VALUE_NUMBER:
                        if (!json_ast_node_number_print(file, err, value->value.number)) {
                                return false;
                        }
                        break;
                case JAK_JSON_VALUE_TRUE:
                        fprintf(file, "true");
                        break;
                case JAK_JSON_VALUE_FALSE:
                        fprintf(file, "false");
                        break;
                case JAK_JSON_VALUE_NULL:
                        fprintf(file, "null");
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOTYPE);
                        return false;
        }
        return true;
}

static bool json_ast_node_element_print(FILE *file, jak_error *err, jak_json_element *element)
{
        return json_ast_node_value_print(file, err, &element->value);
}

static bool json_ast_node_value_drop(jak_json_node_value *value, jak_error *err);

static bool json_ast_node_element_drop(jak_json_element *element, jak_error *err)
{
        return json_ast_node_value_drop(&element->value, err);
}

static bool json_ast_node_member_drop(jak_json_prop *member, jak_error *err)
{
        free(member->key.value);
        return json_ast_node_element_drop(&member->value, err);
}

static bool json_ast_node_members_drop(jak_json_members *members, jak_error *err)
{
        for (size_t i = 0; i < members->members.num_elems; i++) {
                jak_json_prop *member = JAK_VECTOR_GET(&members->members, i, jak_json_prop);
                if (!json_ast_node_member_drop(member, err)) {
                        return false;
                }
        }
        jak_vector_drop(&members->members);
        return true;
}

static bool json_ast_node_elements_drop(jak_json_elements *elements, jak_error *err)
{
        for (size_t i = 0; i < elements->elements.num_elems; i++) {
                jak_json_element *element = JAK_VECTOR_GET(&elements->elements, i, jak_json_element);
                if (!json_ast_node_element_drop(element, err)) {
                        return false;
                }
        }
        jak_vector_drop(&elements->elements);
        return true;
}

static bool json_ast_node_object_drop(jak_json_object *object, jak_error *err)
{
        if (!json_ast_node_members_drop(object->value, err)) {
                return false;
        } else {
                free(object->value);
                return true;
        }
}

static bool json_ast_node_array_drop(jak_json_array *array, jak_error *err)
{
        return json_ast_node_elements_drop(&array->elements, err);
}

static void json_ast_node_jak_string_drop(jak_json_string *string)
{
        free(string->value);
}

static void json_ast_node_number_drop(jak_json_number *number)
{
        JAK_UNUSED(number);
}

static bool json_ast_node_value_drop(jak_json_node_value *value, jak_error *err)
{
        switch (value->value_type) {
                case JAK_JSON_VALUE_OBJECT:
                        if (!json_ast_node_object_drop(value->value.object, err)) {
                                return false;
                        } else {
                                free(value->value.object);
                        }
                        break;
                case JAK_JSON_VALUE_ARRAY:
                        if (!json_ast_node_array_drop(value->value.array, err)) {
                                return false;
                        } else {
                                free(value->value.array);
                        }
                        break;
                case JAK_JSON_VALUE_STRING:
                        json_ast_node_jak_string_drop(value->value.string);
                        free(value->value.string);
                        break;
                case JAK_JSON_VALUE_NUMBER:
                        json_ast_node_number_drop(value->value.number);
                        free(value->value.number);
                        break;
                case JAK_JSON_VALUE_TRUE:
                case JAK_JSON_VALUE_FALSE:
                case JAK_JSON_VALUE_NULL:
                        break;
                default: JAK_ERROR(err, JAK_ERR_NOTYPE)
                        return false;

        }
        return true;
}

bool jak_json_drop(jak_json *jak_json)
{
        jak_json_element *element = jak_json->element;
        if (!json_ast_node_value_drop(&element->value, &jak_json->err)) {
                return false;
        } else {
                free(jak_json->element);
                return true;
        }
}

bool jak_json_print(FILE *file, jak_json *jak_json)
{
        return json_ast_node_element_print(file, &jak_json->err, jak_json->element);
}

bool jak_json_list_is_empty(const jak_json_elements *elements)
{
        return elements->elements.num_elems == 0;
}

bool jak_json_list_length(jak_u32 *len, const jak_json_elements *elements)
{
        JAK_ERROR_IF_NULL(len)
        JAK_ERROR_IF_NULL(elements)
        *len = elements->elements.num_elems;
        return true;
}

jak_json_list_type_e jak_json_fitting_type(jak_json_list_type_e current, jak_json_list_type_e to_add)
{
        if (current == JAK_JSON_LIST_VARIABLE_OR_NESTED || to_add == JAK_JSON_LIST_VARIABLE_OR_NESTED) {
                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
        }
        if (current == JAK_JSON_LIST_EMPTY || current == JAK_JSON_LIST_FIXED_BOOLEAN ||
            to_add == JAK_JSON_LIST_EMPTY || to_add == JAK_JSON_LIST_FIXED_BOOLEAN) {
                if (current == to_add) {
                        return current;
                } else {
                        if ((to_add == JAK_JSON_LIST_FIXED_BOOLEAN && current == JAK_JSON_LIST_FIXED_NULL) ||
                            (to_add == JAK_JSON_LIST_FIXED_NULL && current == JAK_JSON_LIST_FIXED_BOOLEAN)) {
                                return JAK_JSON_LIST_FIXED_BOOLEAN;
                        } else {
                                if (to_add == JAK_JSON_LIST_EMPTY) {
                                        return current;
                                } else if (current == JAK_JSON_LIST_EMPTY) {
                                        return to_add;
                                } else {

                                        return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        }
                }
        } else {
                switch (current) {
                        case JAK_JSON_LIST_FIXED_NULL:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                        case JAK_JSON_LIST_FIXED_FLOAT:
                                        case JAK_JSON_LIST_FIXED_BOOLEAN:
                                        case JAK_JSON_LIST_FIXED_U8:
                                        case JAK_JSON_LIST_FIXED_U16:
                                        case JAK_JSON_LIST_FIXED_U32:
                                        case JAK_JSON_LIST_FIXED_U64:
                                        case JAK_JSON_LIST_FIXED_I8:
                                        case JAK_JSON_LIST_FIXED_I16:
                                        case JAK_JSON_LIST_FIXED_I32:
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return to_add;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_FLOAT:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                        case JAK_JSON_LIST_FIXED_FLOAT:
                                        case JAK_JSON_LIST_FIXED_U8:
                                        case JAK_JSON_LIST_FIXED_U16:
                                        case JAK_JSON_LIST_FIXED_U32:
                                        case JAK_JSON_LIST_FIXED_U64:
                                        case JAK_JSON_LIST_FIXED_I8:
                                        case JAK_JSON_LIST_FIXED_I16:
                                        case JAK_JSON_LIST_FIXED_I32:
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_FIXED_FLOAT;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_U8:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                                return JAK_JSON_LIST_FIXED_U8;
                                        case JAK_JSON_LIST_FIXED_U8:
                                                return JAK_JSON_LIST_FIXED_U8;
                                        case JAK_JSON_LIST_FIXED_U16:
                                                return JAK_JSON_LIST_FIXED_U16;
                                        case JAK_JSON_LIST_FIXED_U32:
                                                return JAK_JSON_LIST_FIXED_U32;
                                        case JAK_JSON_LIST_FIXED_U64:
                                                return JAK_JSON_LIST_FIXED_U64;
                                        case JAK_JSON_LIST_FIXED_I8:
                                                return JAK_JSON_LIST_FIXED_I16;
                                        case JAK_JSON_LIST_FIXED_I16:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_I32:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_U16:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                                return JAK_JSON_LIST_FIXED_U16;
                                        case JAK_JSON_LIST_FIXED_U8:
                                        case JAK_JSON_LIST_FIXED_U16:
                                                return JAK_JSON_LIST_FIXED_U16;
                                        case JAK_JSON_LIST_FIXED_U32:
                                                return JAK_JSON_LIST_FIXED_U32;
                                        case JAK_JSON_LIST_FIXED_U64:
                                                return JAK_JSON_LIST_FIXED_U64;
                                        case JAK_JSON_LIST_FIXED_I8:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_I16:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_I32:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_U32:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                                return JAK_JSON_LIST_FIXED_U32;
                                        case JAK_JSON_LIST_FIXED_U8:
                                        case JAK_JSON_LIST_FIXED_U16:
                                        case JAK_JSON_LIST_FIXED_U32:
                                                return JAK_JSON_LIST_FIXED_U32;
                                        case JAK_JSON_LIST_FIXED_U64:
                                                return JAK_JSON_LIST_FIXED_U64;
                                        case JAK_JSON_LIST_FIXED_I8:
                                        case JAK_JSON_LIST_FIXED_I16:
                                        case JAK_JSON_LIST_FIXED_I32:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_U64:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                                return JAK_JSON_LIST_FIXED_U64;
                                        case JAK_JSON_LIST_FIXED_U8:
                                        case JAK_JSON_LIST_FIXED_U16:
                                        case JAK_JSON_LIST_FIXED_U32:
                                        case JAK_JSON_LIST_FIXED_U64:
                                                return JAK_JSON_LIST_FIXED_U64;
                                        case JAK_JSON_LIST_FIXED_I8:
                                        case JAK_JSON_LIST_FIXED_I16:
                                        case JAK_JSON_LIST_FIXED_I32:
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_I8:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                                return JAK_JSON_LIST_FIXED_I8;
                                        case JAK_JSON_LIST_FIXED_U8:
                                                return JAK_JSON_LIST_FIXED_I16;
                                        case JAK_JSON_LIST_FIXED_U16:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_U32:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        case JAK_JSON_LIST_FIXED_U64:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                        case JAK_JSON_LIST_FIXED_I8:
                                                return JAK_JSON_LIST_FIXED_I8;
                                        case JAK_JSON_LIST_FIXED_I16:
                                                return JAK_JSON_LIST_FIXED_I16;
                                        case JAK_JSON_LIST_FIXED_I32:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_I16:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                                return JAK_JSON_LIST_FIXED_I16;
                                        case JAK_JSON_LIST_FIXED_U8:
                                        case JAK_JSON_LIST_FIXED_U16:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_U32:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        case JAK_JSON_LIST_FIXED_U64:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                        case JAK_JSON_LIST_FIXED_I8:
                                        case JAK_JSON_LIST_FIXED_I16:
                                                return JAK_JSON_LIST_FIXED_I16;
                                        case JAK_JSON_LIST_FIXED_I32:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_I32:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_U8:
                                        case JAK_JSON_LIST_FIXED_U16:
                                        case JAK_JSON_LIST_FIXED_U32:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        case JAK_JSON_LIST_FIXED_U64:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                        case JAK_JSON_LIST_FIXED_I8:
                                        case JAK_JSON_LIST_FIXED_I16:
                                        case JAK_JSON_LIST_FIXED_I32:
                                                return JAK_JSON_LIST_FIXED_I32;
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        case JAK_JSON_LIST_FIXED_I64:
                                switch (to_add) {
                                        case JAK_JSON_LIST_FIXED_NULL:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        case JAK_JSON_LIST_FIXED_U8:
                                        case JAK_JSON_LIST_FIXED_U16:
                                        case JAK_JSON_LIST_FIXED_U32:
                                        case JAK_JSON_LIST_FIXED_U64:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                        case JAK_JSON_LIST_FIXED_I8:
                                        case JAK_JSON_LIST_FIXED_I16:
                                        case JAK_JSON_LIST_FIXED_I32:
                                        case JAK_JSON_LIST_FIXED_I64:
                                                return JAK_JSON_LIST_FIXED_I64;
                                        default:
                                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                }
                        default:
                                return JAK_JSON_LIST_VARIABLE_OR_NESTED;
                }
        }
}

static jak_json_list_type_e number_type_to_list_type(jak_number_min_type_e type)
{
        switch (type) {
                case JAK_NUMBER_U8:
                        return JAK_JSON_LIST_FIXED_U8;
                case JAK_NUMBER_U16:
                        return JAK_JSON_LIST_FIXED_U16;
                case JAK_NUMBER_U32:
                        return JAK_JSON_LIST_FIXED_U32;
                case JAK_NUMBER_U64:
                        return JAK_JSON_LIST_FIXED_U64;
                case JAK_NUMBER_I8:
                        return JAK_JSON_LIST_FIXED_I8;
                case JAK_NUMBER_I16:
                        return JAK_JSON_LIST_FIXED_I16;
                case JAK_NUMBER_I32:
                        return JAK_JSON_LIST_FIXED_I32;
                case JAK_NUMBER_I64:
                        return JAK_JSON_LIST_FIXED_I64;
                default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE)
                        return JAK_JSON_LIST_EMPTY;

        }
}

bool jak_json_array_get_type(jak_json_list_type_e *type, const jak_json_array *array)
{
        JAK_ERROR_IF_NULL(type)
        JAK_ERROR_IF_NULL(array)
        jak_json_list_type_e list_type = JAK_JSON_LIST_EMPTY;
        for (jak_u32 i = 0; i < array->elements.elements.num_elems; i++) {
                const jak_json_element *elem = JAK_VECTOR_GET(&array->elements.elements, i, jak_json_element);
                switch (elem->value.value_type) {
                        case JAK_JSON_VALUE_OBJECT:
                        case JAK_JSON_VALUE_ARRAY:
                        case JAK_JSON_VALUE_STRING:
                                list_type = JAK_JSON_LIST_VARIABLE_OR_NESTED;
                                goto return_result;
                        case JAK_JSON_VALUE_NUMBER: {
                                jak_json_list_type_e elem_type;
                                switch (elem->value.value.number->value_type) {
                                        case JAK_JSON_NUMBER_FLOAT:
                                                elem_type = JAK_JSON_LIST_FIXED_FLOAT;
                                                break;
                                        case JAK_JSON_NUMBER_UNSIGNED:
                                                elem_type = number_type_to_list_type(jak_number_min_type_unsigned(
                                                        elem->value.value.number->value.unsigned_integer));
                                                break;
                                        case JAK_JSON_NUMBER_SIGNED:
                                                elem_type = number_type_to_list_type(jak_number_min_type_signed(
                                                        elem->value.value.number->value.signed_integer));
                                                break;
                                        default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE);
                                                continue;
                                }

                                list_type = jak_json_fitting_type(list_type, elem_type);
                                if (list_type == JAK_JSON_LIST_VARIABLE_OR_NESTED) {
                                        goto return_result;
                                }
                                break;
                        }
                        case JAK_JSON_VALUE_TRUE:
                        case JAK_JSON_VALUE_FALSE:
                                list_type = jak_json_fitting_type(list_type, JAK_JSON_LIST_FIXED_BOOLEAN);
                                if (list_type == JAK_JSON_LIST_VARIABLE_OR_NESTED) {
                                        goto return_result;
                                }
                                break;
                        case JAK_JSON_VALUE_NULL:
                                list_type = jak_json_fitting_type(list_type, JAK_JSON_LIST_FIXED_NULL);
                                if (list_type == JAK_JSON_LIST_VARIABLE_OR_NESTED) {
                                        goto return_result;
                                }
                                break;
                        default: JAK_ERROR_PRINT(JAK_ERR_UNSUPPORTEDTYPE);
                                break;
                }
        }
        return_result:
        *type = list_type;
        return true;

}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------

#include <libs/libb64/libb64.h>
#include <jak_json_printer_extended.h>
#include <jak_carbon_array_it.h>

// ---------------------------------------------------------------------------------------------------------------------

#define INIT_BUFFER_LEN 1024
#define NULL_STR "null"

// ---------------------------------------------------------------------------------------------------------------------

struct extra {
        char *buffer;
        size_t buffer_size;
};

// ---------------------------------------------------------------------------------------------------------------------

#define INIT_BUFFER_LEN 1024
#define NULL_STR "null"

// ---------------------------------------------------------------------------------------------------------------------

struct jak_json_compact_extra {
        char *buffer;
        size_t buffer_size;
};

// ---------------------------------------------------------------------------------------------------------------------

static void _jak_json_printer_compact_nop(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self)
        JAK_UNUSED(builder)
}

static void _jak_json_printer_compact_drop(jak_carbon_printer *self)
{
        struct jak_json_compact_extra *extra = (struct jak_json_compact_extra *) self->extra;
        free(extra->buffer);
        free(self->extra);
}

static void _jak_json_printer_compact_obj_begin(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "{");
}

static void _jak_json_printer_compact_obj_end(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "}");
}

static void meta_data_nop(jak_carbon_printer *self, jak_string *builder, int key_type, const void *key,
                          jak_u64 key_length, jak_u64 rev)
{
        JAK_UNUSED(self)
        JAK_UNUSED(builder)
        JAK_UNUSED(key_type)
        JAK_UNUSED(key)
        JAK_UNUSED(key_length)
        JAK_UNUSED(rev)
}

static void _jak_json_printer_compact_empty_record(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "{}");
}

static void _jak_json_printer_compact_array_begin(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);

        jak_string_add(builder, "[");
}

static void _jak_json_printer_compact_array_end(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "]");
}

static void _jak_json_printer_compact_const_null(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "null");
}

static void _jak_json_printer_compact_const_true(jak_carbon_printer *self, bool is_null, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, is_null ? "null" : "true");
}

static void _jak_json_printer_compact_const_false(jak_carbon_printer *self, bool is_null, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, is_null ? "null" : "false");
}

static void _jak_json_printer_compact_val_signed(jak_carbon_printer *self, jak_string *builder, const jak_i64 *value)
{
        JAK_UNUSED(self);
        if (JAK_LIKELY(value != NULL)) {
                jak_string_add_i64(builder, *value);
        } else {
                jak_string_add(builder, NULL_STR);
        }

}

static void _jak_json_printer_compact_val_unsigned(jak_carbon_printer *self, jak_string *builder, const jak_u64 *value)
{
        JAK_UNUSED(self);
        if (JAK_LIKELY(value != NULL)) {
                jak_string_add_u64(builder, *value);
        } else {
                jak_string_add(builder, NULL_STR);
        }
}

static void _jak_json_printer_compact_val_float(jak_carbon_printer *self, jak_string *builder, const float *value)
{
        JAK_UNUSED(self);
        if (JAK_LIKELY(value != NULL)) {
                jak_string_add_float(builder, *value);
        } else {
                jak_string_add(builder, NULL_STR);
        }
}

static void _jak_json_printer_compact_val_string(jak_carbon_printer *self, jak_string *builder, const char *value, jak_u64 strlen)
{
        JAK_UNUSED(self);
        jak_string_add_char(builder, '"');
        jak_string_add_nchar(builder, value, strlen);
        jak_string_add_char(builder, '"');
}

#define code_of(x, data_len)      (x + data_len + 2)
#define data_of(x)      (x)

static void _jak_json_printer_compact_print_binary(jak_carbon_printer *self, jak_string *builder, const jak_carbon_binary *binary)
{
        /* base64 code will be written into the extra's buffer after a null-terminated copy of the binary data */
        struct jak_json_compact_extra *extra = (struct jak_json_compact_extra *) self->extra;
        /* buffer of at least 2x data length for base64 code + 1x data length to hold the null-terminated value */
        size_t required_buff_size = 3 * (binary->blob_len + 1);
        /* increase buffer capacity if needed */
        if (extra->buffer_size < required_buff_size) {
                extra->buffer_size = required_buff_size * 1.7f;
                extra->buffer = realloc(extra->buffer, extra->buffer_size);
                JAK_ERROR_PRINT_IF(!extra->buffer, JAK_ERR_REALLOCERR);
        }
        /* decrease buffer capacity if needed */
        if (extra->buffer_size * 0.3f > required_buff_size) {
                extra->buffer_size = required_buff_size;
                extra->buffer = realloc(extra->buffer, extra->buffer_size);
                JAK_ERROR_PRINT_IF(!extra->buffer, JAK_ERR_REALLOCERR);
        }

        JAK_ASSERT(extra->buffer_size >= required_buff_size);
        JAK_ZERO_MEMORY(extra->buffer, extra->buffer_size);
        /* copy binary data into buffer, and leave one (zero'd) byte free; null-termination is required by libb64 */
        memcpy(data_of(extra->buffer), binary->blob, binary->blob_len);

        jak_string_add(builder, "{ ");
        jak_string_add(builder, "\"type\": \"");
        jak_string_add_nchar(builder, binary->mime_type, binary->mime_type_strlen);
        jak_string_add(builder, "\", \"encoding\": \"base64\", \"binary-string\": \"");

        base64_encodestate state;
        base64_init_encodestate(&state);

        jak_u64 code_len = base64_encode_block(data_of(extra->buffer), binary->blob_len + 2,
                                               code_of(extra->buffer, binary->blob_len), &state);
        base64_encode_blockend(code_of(extra->buffer, binary->blob_len), &state);
        jak_string_add_nchar(builder, code_of(extra->buffer, binary->blob_len), code_len);


        jak_string_add(builder, "\" }");
}

static void _jak_json_printer_compact_val_binary(jak_carbon_printer *self, jak_string *builder, const jak_carbon_binary *binary)
{
        _jak_json_printer_compact_print_binary(self, builder, binary);
}

static void _jak_json_printer_compact_comma(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, ", ");
}

static void print_key(jak_string *builder, const char *key_name, jak_u64 key_len)
{
        jak_string_add_char(builder, '"');
        jak_string_add_nchar(builder, key_name, key_len);
        jak_string_add(builder, "\": ");
}

static void _jak_json_printer_compact_prop_null(jak_carbon_printer *self, jak_string *builder,
                      const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self);
        print_key(builder, key_name, key_len);
        jak_string_add(builder, "null");
}

static void _jak_json_printer_compact_prop_true(jak_carbon_printer *self, jak_string *builder,
                      const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self);
        print_key(builder, key_name, key_len);
        jak_string_add(builder, "true");
}

static void _jak_json_printer_compact_prop_false(jak_carbon_printer *self, jak_string *builder,
                       const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self);
        print_key(builder, key_name, key_len);
        jak_string_add(builder, "false");
}

static void _jak_json_printer_compact_prop_signed(jak_carbon_printer *self, jak_string *builder,
                        const char *key_name, jak_u64 key_len, const jak_i64 *value)
{
        JAK_UNUSED(self);
        print_key(builder, key_name, key_len);
        jak_string_add_i64(builder, *value);
}

static void _jak_json_printer_compact_prop_unsigned(jak_carbon_printer *self, jak_string *builder,
                          const char *key_name, jak_u64 key_len, const jak_u64 *value)
{
        JAK_UNUSED(self);
        print_key(builder, key_name, key_len);
        jak_string_add_u64(builder, *value);
}

static void _jak_json_printer_compact_prop_float(jak_carbon_printer *self, jak_string *builder,
                       const char *key_name, jak_u64 key_len, const float *value)
{
        JAK_UNUSED(self);
        print_key(builder, key_name, key_len);
        jak_string_add_float(builder, *value);
}

static void _jak_json_printer_compact_prop_string(jak_carbon_printer *self, jak_string *builder,
                        const char *key_name, jak_u64 key_len, const char *value, jak_u64 strlen)
{
        JAK_UNUSED(self);
        print_key(builder, key_name, key_len);
        jak_string_add_char(builder, '"');
        jak_string_add_nchar(builder, value, strlen);
        jak_string_add_char(builder, '"');
}

static void _jak_json_printer_compact_prop_binary(jak_carbon_printer *self, jak_string *builder,
                        const char *key_name, jak_u64 key_len, const jak_carbon_binary *binary)
{
        print_key(builder, key_name, key_len);
        _jak_json_printer_compact_print_binary(self, builder, binary);
}

static void _jak_json_printer_compact_array_prop_name(jak_carbon_printer *self, jak_string *builder,
                            const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self)
        print_key(builder, key_name, key_len);
}

static void _jak_json_printer_compact_obj_prop_name(jak_carbon_printer *self, jak_string *builder,
                          const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self)
        print_key(builder, key_name, key_len);
}

// ---------------------------------------------------------------------------------------------------------------------

bool jak_json_compact_printer_create(jak_carbon_printer *printer)
{
        JAK_ERROR_IF_NULL(printer);
        printer->drop = _jak_json_printer_compact_drop;

        printer->record_begin = _jak_json_printer_compact_nop;
        printer->record_end = _jak_json_printer_compact_nop;

        printer->meta_begin = _jak_json_printer_compact_nop;
        printer->meta_data = meta_data_nop;
        printer->meta_end = _jak_json_printer_compact_nop;

        printer->doc_begin = _jak_json_printer_compact_nop;
        printer->doc_end = _jak_json_printer_compact_nop;

        printer->empty_record = _jak_json_printer_compact_empty_record;

        printer->unit_array_begin = _jak_json_printer_compact_nop;
        printer->unit_array_end = _jak_json_printer_compact_nop;

        printer->array_begin = _jak_json_printer_compact_array_begin;
        printer->array_end = _jak_json_printer_compact_array_end;

        printer->const_null = _jak_json_printer_compact_const_null;
        printer->const_true = _jak_json_printer_compact_const_true;
        printer->const_false = _jak_json_printer_compact_const_false;

        printer->val_signed = _jak_json_printer_compact_val_signed;
        printer->val_unsigned = _jak_json_printer_compact_val_unsigned;
        printer->val_float = _jak_json_printer_compact_val_float;
        printer->val_string = _jak_json_printer_compact_val_string;
        printer->val_binary = _jak_json_printer_compact_val_binary;

        printer->comma = _jak_json_printer_compact_comma;

        printer->prop_null = _jak_json_printer_compact_prop_null;
        printer->prop_true = _jak_json_printer_compact_prop_true;
        printer->prop_false = _jak_json_printer_compact_prop_false;
        printer->prop_signed = _jak_json_printer_compact_prop_signed;
        printer->prop_unsigned = _jak_json_printer_compact_prop_unsigned;
        printer->prop_float = _jak_json_printer_compact_prop_float;
        printer->prop_string = _jak_json_printer_compact_prop_string;
        printer->prop_binary = _jak_json_printer_compact_prop_binary;
        printer->array_prop_name = _jak_json_printer_compact_array_prop_name;
        printer->column_prop_name = _jak_json_printer_compact_array_prop_name;
        printer->obj_prop_name = _jak_json_printer_compact_obj_prop_name;
        printer->obj_begin = _jak_json_printer_compact_obj_begin;
        printer->obj_end = _jak_json_printer_compact_obj_end;

        printer->extra = JAK_MALLOC(sizeof(struct jak_json_compact_extra));
        struct jak_json_compact_extra *extra = (struct jak_json_compact_extra *) printer->extra;
        *extra = (struct jak_json_compact_extra) {
                .buffer_size = INIT_BUFFER_LEN,
                .buffer = JAK_MALLOC(INIT_BUFFER_LEN)
        };
        JAK_ZERO_MEMORY(extra->buffer, extra->buffer_size);

        return true;
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// ---------------------------------------------------------------------------------------------------------------------

#include <libs/libb64/libb64.h>
#include <jak_carbon.h>
#include <jak_json_printer_extended.h>
#include <jak_carbon_commit.h>

// ---------------------------------------------------------------------------------------------------------------------

#define INIT_BUFFER_LEN 1024
#define NULL_STR "null"

// ---------------------------------------------------------------------------------------------------------------------

struct jak_json_extended_extra {
        char *buffer;
        size_t buffer_size;
};

// ---------------------------------------------------------------------------------------------------------------------

static void _jak_json_printer_extended_drop(jak_carbon_printer *self)
{
        struct jak_json_extended_extra *extra = (struct jak_json_extended_extra *) self->extra;
        free(extra->buffer);
        free(self->extra);
}

static void _jak_json_printer_extended_obj_begin(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "{");
}

static void _jak_json_printer_extended_obj_end(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "}");
}

static void _jak_json_printer_extended_meta_begin(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "\"meta\": {");
}

static void meta_data(jak_carbon_printer *self, jak_string *builder,
                      int key_type, const void *key,
                      jak_u64 key_length, jak_u64 commit_hash)
{
        JAK_UNUSED(self)

        jak_string_add(builder, "\"key\": {");

        switch (key_type) {
                case JAK_CARBON_KEY_NOKEY:
                        jak_string_add(builder, "\"type\": \"nokey\", \"value\": null");
                        break;
                case JAK_CARBON_KEY_AUTOKEY:
                        jak_string_add(builder, "\"type\": \"autokey\", \"value\": ");
                        jak_string_add_u64(builder, *(jak_u64 *) key);
                        break;
                case JAK_CARBON_KEY_UKEY:
                        jak_string_add(builder, "\"type\": \"ukey\", \"value\": ");
                        jak_string_add_u64(builder, *(jak_u64 *) key);
                        break;
                case JAK_CARBON_KEY_IKEY:
                        jak_string_add(builder, "\"type\": \"ikey\", \"value\": ");
                        jak_string_add_u64(builder, *(jak_i64 *) key);
                        break;
                case JAK_CARBON_KEY_SKEY:
                        jak_string_add(builder, "\"type\": \"skey\", \"value\": ");
                        if (key_length > 0) {
                                jak_string_add(builder, "\"");
                                jak_string_add_nchar(builder, key, key_length);
                                jak_string_add(builder, "\"");
                        } else {
                                jak_string_add(builder, "null");
                        }

                        break;
                default: JAK_ERROR_PRINT(JAK_ERR_INTERNALERR);
        }
        jak_string_add(builder, "}, \"commit\": ");
        if (commit_hash) {
                jak_string_add(builder, "\"");
                jak_carbon_commit_hash_append_to_str(builder, commit_hash);
                jak_string_add(builder, "\"");
        } else {
                jak_string_add(builder, "null");
        }
}

static void _jak_json_printer_extended_meta_end(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "}, ");
}

static void _jak_json_printer_extended_doc_begin(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self)

        jak_string_add(builder, "\"doc\": ");
}

static void _jak_json_printer_extended_doc_end(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        JAK_UNUSED(builder);
}

static void _jak_json_printer_extended_empty_record(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "[]");
}

static void _jak_json_printer_extended_array_begin(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "[");
}

static void _jak_json_printer_extended_array_end(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "]");
}

static void _jak_json_printer_extended_const_null(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, "null");
}

static void _jak_json_printer_extended_const_true(jak_carbon_printer *self, bool is_null, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, is_null ? "null" : "true");
}

static void _jak_json_printer_extended_const_false(jak_carbon_printer *self, bool is_null, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, is_null ? "null" : "false");
}

static void _jak_json_printer_extended_val_signed(jak_carbon_printer *self, jak_string *builder, const jak_i64 *value)
{
        JAK_UNUSED(self);
        if (JAK_LIKELY(value != NULL)) {
                jak_string_add_i64(builder, *value);
        } else {
                jak_string_add(builder, NULL_STR);
        }

}

static void _jak_json_printer_extended_val_unsigned(jak_carbon_printer *self, jak_string *builder, const jak_u64 *value)
{
        JAK_UNUSED(self);
        if (JAK_LIKELY(value != NULL)) {
                jak_string_add_u64(builder, *value);
        } else {
                jak_string_add(builder, NULL_STR);
        }
}

static void _jak_json_printer_extended_val_float(jak_carbon_printer *self, jak_string *builder, const float *value)
{
        JAK_UNUSED(self);
        if (JAK_LIKELY(value != NULL)) {
                jak_string_add_float(builder, *value);
        } else {
                jak_string_add(builder, NULL_STR);
        }
}

static void _jak_json_printer_extended_val_string(jak_carbon_printer *self, jak_string *builder, const char *value, jak_u64 strlen)
{
        JAK_UNUSED(self);
        jak_string_add_char(builder, '"');
        jak_string_add_nchar(builder, value, strlen);
        jak_string_add_char(builder, '"');
}

#define code_of(x, data_len)      (x + data_len + 2)
#define data_of(x)      (x)

static void _jak_json_printer_extended_print_binary(jak_carbon_printer *self, jak_string *builder, const jak_carbon_binary *binary)
{
        /* base64 code will be written into the extra's buffer after a null-terminated copy of the binary data */
        struct jak_json_extended_extra *extra = (struct jak_json_extended_extra *) self->extra;
        /* buffer of at least 2x data length for base64 code + 1x data length to hold the null-terminated value */
        size_t required_buff_size = 3 * (binary->blob_len + 1);
        /* increase buffer capacity if needed */
        if (extra->buffer_size < required_buff_size) {
                extra->buffer_size = required_buff_size * 1.7f;
                extra->buffer = realloc(extra->buffer, extra->buffer_size);
                JAK_ERROR_PRINT_IF(!extra->buffer, JAK_ERR_REALLOCERR);
        }
        /* decrease buffer capacity if needed */
        if (extra->buffer_size * 0.3f > required_buff_size) {
                extra->buffer_size = required_buff_size;
                extra->buffer = realloc(extra->buffer, extra->buffer_size);
                JAK_ERROR_PRINT_IF(!extra->buffer, JAK_ERR_REALLOCERR);
        }

        JAK_ASSERT(extra->buffer_size >= required_buff_size);
        JAK_ZERO_MEMORY(extra->buffer, extra->buffer_size);
        /* copy binary data into buffer, and leave one (zero'd) byte free; null-termination is required by libb64 */
        memcpy(data_of(extra->buffer), binary->blob, binary->blob_len);

        jak_string_add(builder, "{ ");
        jak_string_add(builder, "\"type\": \"");
        jak_string_add_nchar(builder, binary->mime_type, binary->mime_type_strlen);
        jak_string_add(builder, "\", \"encoding\": \"base64\", \"binary-string\": \"");

        base64_encodestate state;
        base64_init_encodestate(&state);

        jak_u64 code_len = base64_encode_block(data_of(extra->buffer), binary->blob_len + 2,
                                               code_of(extra->buffer, binary->blob_len), &state);
        base64_encode_blockend(code_of(extra->buffer, binary->blob_len), &state);
        jak_string_add_nchar(builder, code_of(extra->buffer, binary->blob_len), code_len);


        jak_string_add(builder, "\" }");
}

static void _jak_json_printer_extended_val_binary(jak_carbon_printer *self, jak_string *builder, const jak_carbon_binary *binary)
{
        _jak_json_printer_extended_print_binary(self, builder, binary);
}

static void _jak_json_printer_extended_comma(jak_carbon_printer *self, jak_string *builder)
{
        JAK_UNUSED(self);
        jak_string_add(builder, ", ");
}

static void _jak_json_printer_extended_print_key(jak_string *builder, const char *key_name, jak_u64 key_len)
{
        jak_string_add_char(builder, '"');
        jak_string_add_nchar(builder, key_name, key_len);
        jak_string_add(builder, "\": ");
}

static void _jak_json_printer_extended_prop_null(jak_carbon_printer *self, jak_string *builder,
                      const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self);
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
        jak_string_add(builder, "null");
}

static void _jak_json_printer_extended_prop_true(jak_carbon_printer *self, jak_string *builder,
                      const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self);
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
        jak_string_add(builder, "true");
}

static void _jak_json_printer_extended_prop_false(jak_carbon_printer *self, jak_string *builder,
                       const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self);
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
        jak_string_add(builder, "false");
}

static void _jak_json_printer_extended_prop_signed(jak_carbon_printer *self, jak_string *builder,
                        const char *key_name, jak_u64 key_len, const jak_i64 *value)
{
        JAK_UNUSED(self);
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
        jak_string_add_i64(builder, *value);
}

static void _jak_json_printer_extended_prop_unsigned(jak_carbon_printer *self, jak_string *builder,
                          const char *key_name, jak_u64 key_len, const jak_u64 *value)
{
        JAK_UNUSED(self);
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
        jak_string_add_u64(builder, *value);
}

static void _jak_json_printer_extended_prop_float(jak_carbon_printer *self, jak_string *builder,
                       const char *key_name, jak_u64 key_len, const float *value)
{
        JAK_UNUSED(self);
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
        jak_string_add_float(builder, *value);
}

static void _jak_json_printer_extended_prop_string(jak_carbon_printer *self, jak_string *builder,
                        const char *key_name, jak_u64 key_len, const char *value, jak_u64 strlen)
{
        JAK_UNUSED(self);
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
        jak_string_add_char(builder, '"');
        jak_string_add_nchar(builder, value, strlen);
        jak_string_add_char(builder, '"');
}

static void _jak_json_printer_extended_prop_binary(jak_carbon_printer *self, jak_string *builder,
                        const char *key_name, jak_u64 key_len, const jak_carbon_binary *binary)
{
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
        _jak_json_printer_extended_print_binary(self, builder, binary);
}

static void _jak_json_printer_extended_array_prop_name(jak_carbon_printer *self, jak_string *builder,
                            const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self)
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
}

static void _jak_json_printer_extended_obj_prop_name(jak_carbon_printer *self, jak_string *builder,
                          const char *key_name, jak_u64 key_len)
{
        JAK_UNUSED(self)
        _jak_json_printer_extended_print_key(builder, key_name, key_len);
}

// ---------------------------------------------------------------------------------------------------------------------

bool jak_json_extended_printer_create(jak_carbon_printer *printer)
{
        JAK_ERROR_IF_NULL(printer);
        printer->drop = _jak_json_printer_extended_drop;

        printer->record_begin = _jak_json_printer_extended_obj_begin;
        printer->record_end = _jak_json_printer_extended_obj_end;

        printer->meta_begin = _jak_json_printer_extended_meta_begin;
        printer->meta_data = meta_data;
        printer->meta_end = _jak_json_printer_extended_meta_end;

        printer->doc_begin = _jak_json_printer_extended_doc_begin;
        printer->doc_end = _jak_json_printer_extended_doc_end;

        printer->empty_record = _jak_json_printer_extended_empty_record;

        printer->unit_array_begin = _jak_json_printer_extended_array_begin;
        printer->unit_array_end = _jak_json_printer_extended_array_end;

        printer->array_begin = _jak_json_printer_extended_array_begin;
        printer->array_end = _jak_json_printer_extended_array_end;

        printer->const_null = _jak_json_printer_extended_const_null;
        printer->const_true = _jak_json_printer_extended_const_true;
        printer->const_false = _jak_json_printer_extended_const_false;

        printer->val_signed = _jak_json_printer_extended_val_signed;
        printer->val_unsigned = _jak_json_printer_extended_val_unsigned;
        printer->val_float = _jak_json_printer_extended_val_float;
        printer->val_string = _jak_json_printer_extended_val_string;
        printer->val_binary = _jak_json_printer_extended_val_binary;

        printer->comma = _jak_json_printer_extended_comma;

        printer->prop_null = _jak_json_printer_extended_prop_null;
        printer->prop_true = _jak_json_printer_extended_prop_true;
        printer->prop_false = _jak_json_printer_extended_prop_false;
        printer->prop_signed = _jak_json_printer_extended_prop_signed;
        printer->prop_unsigned = _jak_json_printer_extended_prop_unsigned;
        printer->prop_float = _jak_json_printer_extended_prop_float;
        printer->prop_string = _jak_json_printer_extended_prop_string;
        printer->prop_binary = _jak_json_printer_extended_prop_binary;
        printer->array_prop_name = _jak_json_printer_extended_array_prop_name;
        printer->column_prop_name = _jak_json_printer_extended_array_prop_name;
        printer->obj_prop_name = _jak_json_printer_extended_obj_prop_name;
        printer->obj_begin = _jak_json_printer_extended_obj_begin;
        printer->obj_end = _jak_json_printer_extended_obj_end;

        printer->extra = JAK_MALLOC(sizeof(struct jak_json_extended_extra));
        struct jak_json_extended_extra *extra = (struct jak_json_extended_extra *) printer->extra;
        *extra = (struct jak_json_extended_extra) {
                .buffer_size = INIT_BUFFER_LEN,
                .buffer = JAK_MALLOC(INIT_BUFFER_LEN)
        };
        JAK_ZERO_MEMORY(extra->buffer, extra->buffer_size);

        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_memblock.h>

typedef struct jak_memblock {
        jak_offset_t blockLength;
        jak_offset_t last_byte;
        void *base;
        jak_error err;
} jak_memblock;

bool jak_memblock_create(jak_memblock **block, size_t size)
{
        JAK_ERROR_IF_NULL(block)
        JAK_ERROR_PRINT_IF(size == 0, JAK_ERR_ILLEGALARG)
        jak_memblock *result = JAK_MALLOC(sizeof(jak_memblock));
        JAK_ZERO_MEMORY(result, sizeof(jak_memblock));
        JAK_ERROR_IF_NULL(result)
        result->blockLength = size;
        result->last_byte = 0;
        result->base = JAK_MALLOC(size);
        jak_error_init(&result->err);
        *block = result;
        return true;
}

bool jak_memblock_zero_out(jak_memblock *block)
{
        JAK_ERROR_IF_NULL(block);
        JAK_ZERO_MEMORY(block->base, block->blockLength);
        return true;
}

bool jak_memblock_from_file(jak_memblock **block, FILE *file, size_t nbytes)
{
        jak_memblock_create(block, nbytes);
        size_t numRead = fread((*block)->base, 1, nbytes, file);
        return numRead == nbytes ? true : false;
}

bool jak_memblock_drop(jak_memblock *block)
{
        JAK_ERROR_IF_NULL(block)
        free(block->base);
        free(block);
        return true;
}

bool jak_memblock_get_error(jak_error *out, jak_memblock *block)
{
        JAK_ERROR_IF_NULL(block);
        JAK_ERROR_IF_NULL(out);
        return jak_error_cpy(out, &block->err);
}

bool jak_memblock_size(jak_offset_t *size, const jak_memblock *block)
{
        JAK_ERROR_IF_NULL(block)
        *size = block->blockLength;
        return true;
}

jak_offset_t jak_memblock_last_used_byte(const jak_memblock *block)
{
        return block ? block->last_byte : 0;
}

bool jak_memblock_write_to_file(FILE *file, const jak_memblock *block)
{
        size_t nwritten = fwrite(block->base, block->blockLength, 1, file);
        return nwritten == 1 ? true : false;
}

const char *jak_memblock_raw_data(const jak_memblock *block)
{
        return (block && block->base ? block->base : NULL);
}

bool jak_memblock_resize(jak_memblock *block, size_t size)
{
        JAK_ERROR_IF_NULL(block)
        JAK_ERROR_PRINT_IF(size == 0, JAK_ERR_ILLEGALARG)
        block->base = realloc(block->base, size);
        if (size > block->blockLength) {
                JAK_ZERO_MEMORY(block->base + block->blockLength, (size - block->blockLength));
        }
        block->blockLength = size;
        return true;
}

bool jak_memblock_write(jak_memblock *block, jak_offset_t position, const char *data, jak_offset_t nbytes)
{
        JAK_ERROR_IF_NULL(block)
        JAK_ERROR_IF_NULL(data)
        if (JAK_LIKELY(position + nbytes < block->blockLength)) {
                memcpy(block->base + position, data, nbytes);
                block->last_byte = JAK_MAX(block->last_byte, position + nbytes);
                return true;
        } else {
                return false;
        }
}

bool jak_memblock_cpy(jak_memblock **dst, jak_memblock *src)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_CHECK_SUCCESS(jak_memblock_create(dst, src->blockLength));
        memcpy((*dst)->base, src->base, src->blockLength);
        JAK_ASSERT((*dst)->base);
        JAK_ASSERT((*dst)->blockLength == src->blockLength);
        JAK_ASSERT(memcmp((*dst)->base, src->base, src->blockLength) == 0);
        (*dst)->last_byte = src->last_byte;
        return true;
}

bool jak_memblock_shrink(jak_memblock *block)
{
        JAK_ERROR_IF_NULL(block)
        block->blockLength = block->last_byte;
        block->base = realloc(block->base, block->blockLength);
        return true;
}

bool jak_memblock_move_right(jak_memblock *block, jak_offset_t where, size_t nbytes)
{
        return jak_memblock_move_ex(block, where, nbytes, true);
}

bool jak_memblock_move_left(jak_memblock *block, jak_offset_t where, size_t nbytes)
{
        JAK_ERROR_IF_NULL(block)
        JAK_ERROR_IF(where + nbytes >= block->blockLength, &block->err, JAK_ERR_OUTOFBOUNDS)
        size_t remainder = block->blockLength - where - nbytes;
        if (remainder > 0) {
                memmove(block->base + where, block->base + where + nbytes, remainder);
                JAK_ASSERT(block->last_byte >= nbytes);
                block->last_byte -= nbytes;
                JAK_ZERO_MEMORY(block->base + block->blockLength - nbytes, nbytes)
                return true;
        } else {
                return false;
        }
}

bool jak_memblock_move_ex(jak_memblock *block, jak_offset_t where, size_t nbytes, bool zero_out)
{
        JAK_ERROR_IF_NULL(block)
        JAK_ERROR_IF(where >= block->blockLength, &block->err, JAK_ERR_OUTOFBOUNDS);
        JAK_ERROR_IF(nbytes == 0, &block->err, JAK_ERR_ILLEGALARG);

        /* resize (if needed) */
        if (block->last_byte + nbytes > block->blockLength) {
                size_t new_length = (block->last_byte + nbytes);
                block->base = realloc(block->base, new_length);
                JAK_ERROR_IF(!block->base, &block->err, JAK_ERR_REALLOCERR);
                if (zero_out) {
                        JAK_ZERO_MEMORY(block->base + block->blockLength, (new_length - block->blockLength));
                }
                block->blockLength = new_length;
        }

        memmove(block->base + where + nbytes, block->base + where, block->last_byte - where);
        if (zero_out) {
                JAK_ZERO_MEMORY(block->base + where, nbytes);
        }
        block->last_byte += nbytes;
        return true;
}

void *jak_memblock_move_contents_and_drop(jak_memblock *block)
{
        void *result = block->base;
        block->base = NULL;
        free(block);
        return result;
}

bool jak_memfile_update_last_byte(jak_memblock *block, size_t where)
{
        JAK_ERROR_IF_NULL(block);
        JAK_ERROR_IF(where >= block->blockLength, &block->err, JAK_ERR_ILLEGALSTATE);
        block->last_byte = JAK_MAX(block->last_byte, where);
        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_memfile.h>
#include <jak_uintvar_stream.h>

bool jak_memfile_open(jak_memfile *file, jak_memblock *block, jak_access_mode_e mode)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(block)
        JAK_ZERO_MEMORY(file, sizeof(jak_memfile))
        file->memblock = block;
        file->pos = 0;
        file->bit_mode = false;
        file->mode = mode;
        file->saved_pos_ptr = 0;
        jak_error_init(&file->err);
        return true;
}

bool jak_memfile_clone(jak_memfile *dst, jak_memfile *src)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        jak_memfile_open(dst, src->memblock, src->mode);
        jak_memfile_seek(dst, jak_memfile_tell(src));
        dst->bit_mode = src->bit_mode;
        dst->saved_pos_ptr = src->saved_pos_ptr;
        jak_error_cpy(&dst->err, &src->err);
        memcpy(&dst->saved_pos, &src->saved_pos, JAK_ARRAY_LENGTH(src->saved_pos));
        return true;
}

bool jak_memfile_seek(jak_memfile *file, jak_offset_t pos)
{
        JAK_ERROR_IF_NULL(file)
        jak_offset_t file_size = 0;
        jak_memblock_size(&file_size, file->memblock);
        if (JAK_UNLIKELY(pos >= file_size)) {
                if (file->mode == JAK_READ_WRITE) {
                        jak_offset_t new_size = pos + 1;
                        jak_memblock_resize(file->memblock, new_size);
                } else {
                        JAK_ERROR(&file->err, JAK_ERR_MEMSTATE)
                        return false;
                }
        }
        file->pos = pos;
        return true;
}

bool jak_memfile_seek_from_here(jak_memfile *file, signed_offset_t where)
{
        jak_offset_t now = jak_memfile_tell(file);
        jak_offset_t then = now + where;
        return jak_memfile_seek(file, then);
}

bool jak_memfile_rewind(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)
        file->pos = 0;
        return true;
}

bool jak_memfile_grow(jak_memfile *file_in, size_t grow_by_bytes)
{
        JAK_ERROR_IF_NULL(file_in)
        if (JAK_LIKELY(grow_by_bytes > 0)) {
                jak_offset_t block_size = 0;
                jak_memblock_size(&block_size, file_in->memblock);
                jak_memblock_resize(file_in->memblock, (block_size + grow_by_bytes));
        }
        return true;
}

bool jak_memfile_get_offset(jak_offset_t *pos, const jak_memfile *file)
{
        JAK_ERROR_IF_NULL(pos)
        JAK_ERROR_IF_NULL(file)
        *pos = file->pos;
        return true;
}

size_t jak_memfile_size(jak_memfile *file)
{
        if (!file || !file->memblock) {
                return 0;
        } else {
                jak_u64 size;
                jak_memblock_size(&size, file->memblock);
                return size;
        }
}

bool jak_memfile_cut(jak_memfile *file, size_t how_many_bytes)
{
        JAK_ERROR_IF_NULL(file);
        jak_offset_t block_size = 0;
        jak_memblock_size(&block_size, file->memblock);

        if (how_many_bytes > 0 && block_size > how_many_bytes) {
                size_t new_block_size = block_size - how_many_bytes;
                jak_memblock_resize(file->memblock, new_block_size);
                file->pos = JAK_MIN(file->pos, new_block_size);
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_ILLEGALARG);
                return false;
        }
}

size_t jak_memfile_remain_size(jak_memfile *file)
{
        JAK_ASSERT(file->pos <= jak_memfile_size(file));
        return jak_memfile_size(file) - file->pos;
}

bool jak_memfile_shrink(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file);
        if (file->mode == JAK_READ_WRITE) {
                int status = jak_memblock_shrink(file->memblock);
                jak_u64 size;
                jak_memblock_size(&size, file->memblock);
                JAK_ASSERT(size == file->pos);
                return status;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_WRITEPROT)
                return false;
        }
}

const char *jak_memfile_read(jak_memfile *file, jak_offset_t nbytes)
{
        const char *result = jak_memfile_peek(file, nbytes);
        file->pos += nbytes;
        return result;
}

jak_u8 jak_memfile_read_byte(jak_memfile *file)
{
        return *JAK_MEMFILE_READ_TYPE(file, jak_u8);
}

jak_u8 jak_memfile_peek_byte(jak_memfile *file)
{
        return *JAK_MEMFILE_PEEK(file, jak_u8);
}

jak_u64 jak_memfile_read_u64(jak_memfile *file)
{
        return *JAK_MEMFILE_READ_TYPE(file, jak_u64);
}

jak_i64 jak_memfile_read_i64(jak_memfile *file)
{
        return *JAK_MEMFILE_READ_TYPE(file, jak_i64);
}

bool jak_memfile_skip(jak_memfile *file, signed_offset_t nbytes)
{
        jak_offset_t required_size = file->pos + nbytes;
        file->pos += nbytes;
        jak_offset_t file_size = 0;
        jak_memblock_size(&file_size, file->memblock);

        if (JAK_UNLIKELY(required_size >= file_size)) {
                if (file->mode == JAK_READ_WRITE) {
                        jak_memblock_resize(file->memblock, required_size * 1.7f);
                } else {
                        JAK_ERROR(&file->err, JAK_ERR_WRITEPROT);
                        return false;
                }
        }
        jak_memfile_update_last_byte(file->memblock, file->pos);
        JAK_ASSERT(file->pos < jak_memfile_size(file));
        return true;
}

const char *jak_memfile_peek(jak_memfile *file, jak_offset_t nbytes)
{
        jak_offset_t file_size;
        jak_memblock_size(&file_size, file->memblock);
        if (JAK_UNLIKELY(file->pos + nbytes > file_size)) {
                JAK_ERROR(&file->err, JAK_ERR_READOUTOFBOUNDS);
                return NULL;
        } else {
                const char *result = jak_memblock_raw_data(file->memblock) + file->pos;
                return result;
        }
}

bool jak_memfile_write_byte(jak_memfile *file, jak_u8 data)
{
        return jak_memfile_write(file, &data, sizeof(jak_u8));
}

bool jak_memfile_write(jak_memfile *file, const void *data, jak_offset_t nbytes)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(data)
        if (file->mode == JAK_READ_WRITE) {
                if (JAK_LIKELY(nbytes != 0)) {
                        jak_offset_t file_size;
                        jak_memblock_size(&file_size, file->memblock);
                        jak_offset_t required_size = file->pos + nbytes;
                        if (JAK_UNLIKELY(required_size >= file_size)) {
                                jak_memblock_resize(file->memblock, required_size * 1.7f);
                        }

                        if (JAK_UNLIKELY(!jak_memblock_write(file->memblock, file->pos, data, nbytes))) {
                                return false;
                        }
                        file->pos += nbytes;
                }
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_WRITEPROT);
                return false;
        }
}

bool jak_memfile_write_zero(jak_memfile *file, size_t how_many)
{
        JAK_ERROR_IF_NULL(file);
        JAK_ERROR_IF_NULL(how_many);
        char empty = 0;
        while (how_many--) {
                jak_memfile_write(file, &empty, sizeof(char));
        }
        return true;
}

bool jak_memfile_begin_bit_mode(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file);
        if (file->mode == JAK_READ_WRITE) {
                file->bit_mode = true;
                file->current_read_bit = file->current_write_bit = file->bytes_completed = 0;
                file->bytes_completed = 0;
                jak_offset_t offset;
                char empty = '\0';
                jak_memfile_get_offset(&offset, file);
                jak_memfile_write(file, &empty, sizeof(char));
                jak_memfile_seek(file, offset);
        } else {
                JAK_ERROR(&file->err, JAK_ERR_WRITEPROT);
                return false;
        }

        return true;
}

bool jak_memfile_write_bit(jak_memfile *file, bool flag)
{
        JAK_ERROR_IF_NULL(file);
        file->current_read_bit = 0;

        if (file->bit_mode) {
                if (file->current_write_bit < 8) {
                        jak_offset_t offset;
                        jak_memfile_get_offset(&offset, file);
                        char byte = *jak_memfile_read(file, sizeof(char));
                        char mask = 1 << file->current_write_bit;
                        if (flag) {
                                JAK_SET_BITS(byte, mask);
                        } else {
                                JAK_UNSET_BITS(byte, mask);
                        }
                        jak_memfile_seek(file, offset);
                        jak_memfile_write(file, &byte, sizeof(char));
                        jak_memfile_seek(file, offset);
                        file->current_write_bit++;
                } else {
                        file->current_write_bit = 0;
                        file->bytes_completed++;
                        char empty = '\0';
                        jak_offset_t off;
                        jak_memfile_skip(file, 1);
                        jak_memfile_get_offset(&off, file);
                        jak_memfile_write(file, &empty, sizeof(char));
                        jak_memfile_seek(file, off);

                        return jak_memfile_write_bit(file, flag);
                }
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_NOBITMODE);
                return false;
        }
}

bool jak_memfile_read_bit(jak_memfile *file)
{
        if (!file) {
                return false;
        }

        file->current_write_bit = 0;

        if (file->bit_mode) {
                if (file->current_read_bit < 8) {
                        jak_offset_t offset;
                        jak_memfile_get_offset(&offset, file);

                        char mask = 1 << file->current_read_bit;
                        char byte = *jak_memfile_read(file, sizeof(char));
                        jak_memfile_seek(file, offset);
                        bool result = ((byte & mask) >> file->current_read_bit) == true;
                        file->current_read_bit++;
                        return result;
                } else {
                        file->current_read_bit = 0;
                        jak_memfile_skip(file, sizeof(char));
                        return jak_memfile_read_bit(file);
                }
        } else {
                JAK_ERROR(&file->err, JAK_ERR_NOBITMODE);
                return false;
        }
}

jak_offset_t jak_memfile_save_position(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file);
        jak_offset_t pos = jak_memfile_tell(file);
        if (JAK_LIKELY(file->saved_pos_ptr < (jak_i8) (JAK_ARRAY_LENGTH(file->saved_pos)))) {
                file->saved_pos[file->saved_pos_ptr++] = pos;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_STACK_OVERFLOW)
        }
        return pos;
}

bool jak_memfile_restore_position(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file);
        if (JAK_LIKELY(file->saved_pos_ptr >= 0)) {
                jak_offset_t pos = file->saved_pos[--file->saved_pos_ptr];
                jak_memfile_seek(file, pos);
                return true;
        } else {
                JAK_ERROR(&file->err, JAK_ERR_STACK_UNDERFLOW)
                return false;
        }
}

signed_offset_t jak_memfile_ensure_space(jak_memfile *memfile, jak_u64 nbytes)
{
        JAK_ERROR_IF_NULL(memfile)

        jak_offset_t block_size;
        jak_memblock_size(&block_size, memfile->memblock);
        JAK_ASSERT(memfile->pos < block_size);
        size_t diff = block_size - memfile->pos;
        if (diff < nbytes) {
                jak_memfile_grow(memfile, nbytes - diff);
        }

        jak_memfile_save_position(memfile);
        jak_offset_t current_off = jak_memfile_tell(memfile);
        signed_offset_t shift = 0;
        for (jak_u32 i = 0; i < nbytes; i++) {
                char c = *jak_memfile_read(memfile, 1);
                if (JAK_UNLIKELY(c != 0)) {
                        /* not enough space; enlarge container */
                        jak_memfile_seek(memfile, current_off);
                        jak_memfile_inplace_insert(memfile, nbytes - i);
                        shift += nbytes - i;
                        break;
                }
        }
        jak_memfile_restore_position(memfile);

        return shift;
}

jak_u64 jak_memfile_read_uintvar_stream(jak_u8 *nbytes, jak_memfile *memfile)
{
        jak_u8 nbytes_read;
        jak_u64 result = jak_uintvar_stream_read(&nbytes_read, (jak_uintvar_stream_t) jak_memfile_peek(memfile, sizeof(char)));
        jak_memfile_skip(memfile, nbytes_read);
        JAK_OPTIONAL_SET(nbytes, nbytes_read);
        return result;
}

bool jak_memfile_skip_uintvar_stream(jak_memfile *memfile)
{
        JAK_ERROR_IF_NULL(memfile)
        jak_memfile_read_uintvar_stream(NULL, memfile);
        return true;
}

jak_u64 jak_memfile_peek_uintvar_stream(jak_u8 *nbytes, jak_memfile *memfile)
{
        jak_memfile_save_position(memfile);
        jak_u64 result = jak_memfile_read_uintvar_stream(nbytes, memfile);
        jak_memfile_restore_position(memfile);
        return result;
}

jak_u64 jak_memfile_write_uintvar_stream(jak_u64 *nbytes_moved, jak_memfile *memfile, jak_u64 value)
{
        jak_u8 required_blocks = JAK_UINTVAR_STREAM_REQUIRED_BLOCKS(value);
        signed_offset_t shift = jak_memfile_ensure_space(memfile, required_blocks);
        jak_uintvar_stream_t dst = (jak_uintvar_stream_t) jak_memfile_peek(memfile, sizeof(char));
        jak_uintvar_stream_write(dst, value);
        jak_memfile_skip(memfile, required_blocks);
        JAK_OPTIONAL_SET(nbytes_moved, shift);
        return required_blocks;
}

signed_offset_t jak_memfile_update_uintvar_stream(jak_memfile *memfile, jak_u64 value)
{
        JAK_ERROR_IF_NULL(memfile);

        jak_u8 bytes_used_now, bytes_used_then;

        jak_memfile_peek_uintvar_stream(&bytes_used_now, memfile);
        bytes_used_then = JAK_UINTVAR_STREAM_REQUIRED_BLOCKS(value);

        if (bytes_used_now < bytes_used_then) {
                jak_u8 inc = bytes_used_then - bytes_used_now;
                jak_memfile_inplace_insert(memfile, inc);
        } else if (bytes_used_now > bytes_used_then) {
                jak_u8 dec = bytes_used_now - bytes_used_then;
                jak_memfile_inplace_remove(memfile, dec);
        }

        jak_uintvar_stream_t dst = (jak_uintvar_stream_t) jak_memfile_peek(memfile, sizeof(char));
        jak_u8 required_blocks = jak_uintvar_stream_write(dst, value);
        jak_memfile_skip(memfile, required_blocks);

        return bytes_used_then - bytes_used_now;
}

bool jak_memfile_seek_to_start(jak_memfile *file)
{
        return jak_memfile_seek(file, 0);
}

bool jak_memfile_seek_to_end(jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file)
        size_t size = jak_memblock_last_used_byte(file->memblock);
        return jak_memfile_seek(file, size);
}

bool jak_memfile_inplace_insert(jak_memfile *file, size_t nbytes)
{
        JAK_ERROR_IF_NULL(file);
        return jak_memblock_move_right(file->memblock, file->pos, nbytes);
}

bool jak_memfile_inplace_remove(jak_memfile *file, size_t nbytes_from_here)
{
        JAK_ERROR_IF_NULL(file);
        return jak_memblock_move_left(file->memblock, file->pos, nbytes_from_here);
}

bool jak_memfile_end_bit_mode(size_t *num_bytes_written, jak_memfile *file)
{
        JAK_ERROR_IF_NULL(file);
        file->bit_mode = false;
        if (file->current_write_bit <= 8) {
                jak_memfile_skip(file, 1);
                file->bytes_completed++;
        }
        JAK_OPTIONAL_SET(num_bytes_written, file->bytes_completed);
        file->current_write_bit = file->bytes_completed = 0;
        return true;
}

void *jak_memfile_current_pos(jak_memfile *file, jak_offset_t nbytes)
{
        if (file && nbytes > 0) {
                jak_offset_t file_size;
                jak_memblock_size(&file_size, file->memblock);
                jak_offset_t required_size = file->pos + nbytes;
                if (JAK_UNLIKELY(file->pos + nbytes >= file_size)) {
                        if (file->mode == JAK_READ_WRITE) {
                                jak_memblock_resize(file->memblock, required_size * 1.7f);
                        } else {
                                JAK_ERROR(&file->err, JAK_ERR_WRITEPROT);
                                return NULL;
                        }
                }
                void *data = (void *) jak_memfile_peek(file, nbytes);
                return data;
        } else {
                return NULL;
        }
}

bool jak_memfile_hexdump(jak_string *sb, jak_memfile *file)
{
        JAK_ERROR_IF_NULL(sb);
        JAK_ERROR_IF_NULL(file);
        jak_offset_t block_size;
        jak_memblock_size(&block_size, file->memblock);
        jak_hexdump(sb, jak_memblock_raw_data(file->memblock), block_size);
        return true;
}

bool jak_memfile_hexdump_printf(FILE *file, jak_memfile *memfile)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(memfile)
        jak_offset_t block_size;
        jak_memblock_size(&block_size, memfile->memblock);
        jak_hexdump_print(file, jak_memblock_raw_data(memfile->memblock), block_size);
        return true;
}

bool jak_memfile_hexdump_print(jak_memfile *memfile)
{
        return jak_memfile_hexdump_printf(stdout, memfile);
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_opt.h>

static jak_command_opt *option_by_name(jak_command_opt_mgr *manager, const char *name);

bool jak_opt_manager_create(jak_command_opt_mgr *manager, char *module_name, char *module_desc, jak_module_arg_policy policy,
                    bool (*fallback)(int argc, char **argv, FILE *file, jak_command_opt_mgr *manager))
{
        JAK_ERROR_IF_NULL(manager)
        JAK_ERROR_IF_NULL(module_name)
        JAK_ERROR_IF_NULL(fallback)
        manager->module_name = strdup(module_name);
        manager->module_desc = module_desc ? strdup(module_desc) : NULL;
        manager->policy = policy;
        manager->fallback = fallback;
        JAK_CHECK_SUCCESS(jak_vector_create(&manager->groups, NULL, sizeof(jak_command_opt_group), 5));
        return true;
}

bool jak_opt_manager_drop(jak_command_opt_mgr *manager)
{
        JAK_ERROR_IF_NULL(manager);
        for (size_t i = 0; i < manager->groups.num_elems; i++) {
                jak_command_opt_group *cmdGroup = JAK_VECTOR_GET(&manager->groups, i, jak_command_opt_group);
                for (size_t j = 0; j < cmdGroup->cmd_options.num_elems; j++) {
                        jak_command_opt *option = JAK_VECTOR_GET(&cmdGroup->cmd_options, j, jak_command_opt);
                        free(option->opt_name);
                        free(option->opt_desc);
                        free(option->opt_manfile);
                }
                JAK_CHECK_SUCCESS(jak_vector_drop(&cmdGroup->cmd_options));
                free(cmdGroup->desc);
        }

        JAK_CHECK_SUCCESS(jak_vector_drop(&manager->groups));
        free(manager->module_name);
        if (manager->module_desc) {
                free(manager->module_desc);
        }
        return true;
}

bool jak_opt_manager_process(jak_command_opt_mgr *manager, int argc, char **argv, FILE *file)
{
        JAK_ERROR_IF_NULL(manager)
        JAK_ERROR_IF_NULL(argv)
        JAK_ERROR_IF_NULL(file)

        if (argc == 0) {
                if (manager->policy == JAK_MOD_ARG_REQUIRED) {
                        jak_opt_manager_show_help(file, manager);
                } else {
                        return manager->fallback(argc, argv, file, manager);
                }
        } else {
                const char *arg = argv[0];
                jak_command_opt *option = option_by_name(manager, arg);
                if (option) {
                        return option->callback(argc - 1, argv + 1, file);
                } else {
                        return manager->fallback(argc, argv, file, manager);
                }
        }

        return true;
}

bool jak_opt_manager_create_group(jak_command_opt_group **group, const char *desc, jak_command_opt_mgr *manager)
{
        JAK_ERROR_IF_NULL(group)
        JAK_ERROR_IF_NULL(desc)
        JAK_ERROR_IF_NULL(manager)
        jak_command_opt_group *cmdGroup = JAK_VECTOR_NEW_AND_GET(&manager->groups, jak_command_opt_group);
        cmdGroup->desc = strdup(desc);
        JAK_CHECK_SUCCESS(jak_vector_create(&cmdGroup->cmd_options, NULL, sizeof(jak_command_opt), 10));
        *group = cmdGroup;
        return true;
}

bool opt_group_add_cmd(jak_command_opt_group *group, const char *opt_name, char *opt_desc, char *opt_manfile,
                       int (*callback)(int argc, char **argv, FILE *file))
{
        JAK_ERROR_IF_NULL(group)
        JAK_ERROR_IF_NULL(opt_name)
        JAK_ERROR_IF_NULL(opt_desc)
        JAK_ERROR_IF_NULL(opt_manfile)
        JAK_ERROR_IF_NULL(callback)

        jak_command_opt *command = JAK_VECTOR_NEW_AND_GET(&group->cmd_options, jak_command_opt);
        command->opt_desc = strdup(opt_desc);
        command->opt_manfile = strdup(opt_manfile);
        command->opt_name = strdup(opt_name);
        command->callback = callback;

        return true;
}

bool jak_opt_manager_show_help(FILE *file, jak_command_opt_mgr *manager)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(manager)

        if (manager->groups.num_elems > 0) {
                fprintf(file,
                        "usage: %s <command> %s\n\n",
                        manager->module_name,
                        (manager->policy == JAK_MOD_ARG_REQUIRED ? "<args>" : manager->policy
                                                                              == JAK_MOD_ARG_MAYBE_REQUIRED
                                                                              ? "[<args>]" : ""));

                if (manager->module_desc) {
                        fprintf(file, "%s\n\n", manager->module_desc);
                }
                fprintf(file, "These are common commands used in various situations:\n\n");
                for (size_t i = 0; i < manager->groups.num_elems; i++) {
                        jak_command_opt_group *cmdGroup = JAK_VECTOR_GET(&manager->groups, i, jak_command_opt_group);
                        fprintf(file, "%s\n", cmdGroup->desc);
                        for (size_t j = 0; j < cmdGroup->cmd_options.num_elems; j++) {
                                jak_command_opt *option = JAK_VECTOR_GET(&cmdGroup->cmd_options, j, jak_command_opt);
                                fprintf(file, "   %-15s%s\n", option->opt_name, option->opt_desc);
                        }
                        fprintf(file, "\n");
                }
                fprintf(file,
                        "\n'%s help' show this help, and '%s help <command>' to open \nmanpage of specific command.\n",
                        manager->module_name,
                        manager->module_name);
        } else {
                fprintf(file,
                        "usage: %s %s\n\n",
                        manager->module_name,
                        (manager->policy == JAK_MOD_ARG_REQUIRED ? "<args>" : manager->policy
                                                                              == JAK_MOD_ARG_MAYBE_REQUIRED
                                                                              ? "[<args>]" : ""));

                fprintf(file, "%s\n\n", manager->module_desc);
        }

        return true;
}

static jak_command_opt *option_by_name(jak_command_opt_mgr *manager, const char *name)
{
        for (size_t i = 0; i < manager->groups.num_elems; i++) {
                jak_command_opt_group *cmdGroup = JAK_VECTOR_GET(&manager->groups, i, jak_command_opt_group);
                for (size_t j = 0; j < cmdGroup->cmd_options.num_elems; j++) {
                        jak_command_opt *option = JAK_VECTOR_GET(&cmdGroup->cmd_options, j, jak_command_opt);
                        if (strcmp(option->opt_name, name) == 0) {
                                return option;
                        }
                }
        }
        return NULL;
}
/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_pack.h>

static bool create_strategy(size_t i, jak_packer *strategy)
{
        JAK_ASSERT(strategy);
        jak_global_pack_strategy_register[i].create(strategy);
        JAK_ASSERT (strategy->create);
        JAK_ASSERT (strategy->cpy);
        JAK_ASSERT (strategy->drop);
        JAK_ASSERT (strategy->write_extra);
        JAK_ASSERT (strategy->encode_string);
        JAK_ASSERT (strategy->decode_string);
        JAK_ASSERT (strategy->print_extra);
        return strategy->create(strategy);
}

bool jak_pack_by_type(jak_error *err, jak_packer *strategy, jak_packer_e type)
{
        for (size_t i = 0; i < JAK_ARRAY_LENGTH(jak_global_pack_strategy_register); i++) {
                if (jak_global_pack_strategy_register[i].type == type) {
                        return create_strategy(i, strategy);
                }
        }
        JAK_ERROR(err, JAK_ERR_NOCOMPRESSOR)
        return false;
}

jak_u8 jak_pack_flagbit_by_type(jak_packer_e type)
{
        for (size_t i = 0; i < JAK_ARRAY_LENGTH(jak_global_pack_strategy_register); i++) {
                if (jak_global_pack_strategy_register[i].type == type) {
                        return jak_global_pack_strategy_register[i].flag_bit;
                }
        }
        return 0;
}

bool jak_pack_by_flags(jak_packer *strategy, jak_u8 flags)
{
        for (size_t i = 0; i < JAK_ARRAY_LENGTH(jak_global_pack_strategy_register); i++) {
                if (jak_global_pack_strategy_register[i].flag_bit & flags) {
                        return create_strategy(i, strategy);
                }
        }
        return false;
}

bool jak_pack_by_name(jak_packer_e *type, const char *name)
{
        for (size_t i = 0; i < JAK_ARRAY_LENGTH(jak_global_pack_strategy_register); i++) {
                if (strcmp(jak_global_pack_strategy_register[i].name, name) == 0) {
                        *type = jak_global_pack_strategy_register[i].type;
                        return true;
                }
        }
        return false;
}

bool jak_pack_cpy(jak_error *err, jak_packer *dst, const jak_packer *src)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        JAK_ERROR_IF_NOT_IMPLEMENTED(err, src, cpy)
        return src->cpy(src, dst);
}

bool jak_pack_drop(jak_error *err, jak_packer *self)
{
        JAK_ERROR_IF_NULL(self)
        JAK_ERROR_IF_NOT_IMPLEMENTED(err, self, drop)
        return self->drop(self);
}

bool jak_pack_write_extra(jak_error *err, jak_packer *self, jak_memfile *dst,
                      const jak_vector ofType (const char *) *strings)
{
        JAK_ERROR_IF_NULL(self)
        JAK_ERROR_IF_NOT_IMPLEMENTED(err, self, write_extra)
        return self->write_extra(self, dst, strings);
}

bool jak_pack_read_extra(jak_error *err, jak_packer *self, FILE *src, size_t nbytes)
{
        JAK_ERROR_IF_NULL(self)
        JAK_ERROR_IF_NOT_IMPLEMENTED(err, self, read_extra)
        return self->read_extra(self, src, nbytes);
}

bool jak_pack_encode(jak_error *err, jak_packer *self, jak_memfile *dst, const char *string)
{
        JAK_ERROR_IF_NULL(self)
        JAK_ERROR_IF_NOT_IMPLEMENTED(err, self, encode_string)
        return self->encode_string(self, dst, err, string);
}

bool jak_pack_decode(jak_error *err, jak_packer *self, char *dst, size_t strlen, FILE *src)
{
        JAK_ERROR_IF_NULL(self)
        JAK_ERROR_IF_NOT_IMPLEMENTED(err, self, decode_string)
        return self->decode_string(self, dst, strlen, src);
}

bool jak_pack_print_extra(jak_error *err, jak_packer *self, FILE *file, jak_memfile *src)
{
        JAK_ERROR_IF_NULL(self)
        JAK_ERROR_IF_NOT_IMPLEMENTED(err, self, print_extra)
        return self->print_extra(self, file, src);
}

bool jak_pack_print_encoded(jak_error *err, jak_packer *self, FILE *file, jak_memfile *src,
                        jak_u32 decompressed_strlen)
{
        JAK_ERROR_IF_NULL(self)
        JAK_ERROR_IF_NOT_IMPLEMENTED(err, self, print_encoded)
        return self->print_encoded(self, file, src, decompressed_strlen);
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <limits.h>
#include <inttypes.h>

#include <jak_huffman.h>
#include <jak_bitmap.h>

struct huff_node {
        struct huff_node *prev, *next, *left, *right;
        jak_u64 freq;
        unsigned char letter;
};

static void huff_tree_create(jak_vector ofType(jak_pack_huffman_entry) *table,
                             const jak_vector ofType(jak_u32) *frequencies);

bool jak_coding_huffman_create(jak_huffman *dic)
{
        JAK_ERROR_IF_NULL(dic);

        jak_vector_create(&dic->table, NULL, sizeof(jak_pack_huffman_entry), UCHAR_MAX / 4);
        jak_error_init(&dic->err);

        return true;
}

bool jak_coding_huffman_cpy(jak_huffman *dst, jak_huffman *src)
{
        JAK_ERROR_IF_NULL(dst);
        JAK_ERROR_IF_NULL(src);
        if (!jak_vector_cpy(&dst->table, &src->table)) {
                JAK_ERROR(&src->err, JAK_ERR_HARDCOPYFAILED);
                return false;
        } else {
                return jak_error_cpy(&dst->err, &src->err);
        }
}

bool jak_coding_huffman_build(jak_huffman *encoder, const jak_string_jak_vector_t *strings)
{
        JAK_ERROR_IF_NULL(encoder);
        JAK_ERROR_IF_NULL(strings);

        jak_vector ofType(jak_u32) frequencies;
        jak_vector_create(&frequencies, NULL, sizeof(jak_u32), UCHAR_MAX);
        jak_vector_enlarge_size_to_capacity(&frequencies);

        jak_u32 *freq_data = JAK_VECTOR_ALL(&frequencies, jak_u32);
        JAK_ZERO_MEMORY(freq_data, UCHAR_MAX * sizeof(jak_u32));

        for (size_t i = 0; i < strings->num_elems; i++) {
                const char *string = *JAK_VECTOR_GET(strings, i, const char *);
                size_t jak_string_length = strlen(string);
                for (size_t k = 0; k < jak_string_length; k++) {
                        size_t c = (unsigned char) string[k];
                        freq_data[c]++;
                }
        }

        huff_tree_create(&encoder->table, &frequencies);
        jak_vector_drop(&frequencies);

        return true;
}

bool jak_coding_huffman_get_error(jak_error *err, const jak_huffman *dic)
{
        JAK_ERROR_IF_NULL(err)
        JAK_ERROR_IF_NULL(dic)
        jak_error_cpy(err, &dic->err);
        return true;
}

bool jak_coding_huffman_drop(jak_huffman *dic)
{
        JAK_ERROR_IF_NULL(dic);

        for (size_t i = 0; i < dic->table.num_elems; i++) {
                jak_pack_huffman_entry *entry = JAK_VECTOR_GET(&dic->table, i, jak_pack_huffman_entry);
                free(entry->blocks);
        }

        jak_vector_drop(&dic->table);

        free(dic);

        return true;
}

bool jak_coding_huffman_serialize(jak_memfile *file, const jak_huffman *dic, char marker_symbol)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(dic)

        for (size_t i = 0; i < dic->table.num_elems; i++) {
                jak_pack_huffman_entry *entry = JAK_VECTOR_GET(&dic->table, i, jak_pack_huffman_entry);
                jak_memfile_write(file, &marker_symbol, sizeof(char));
                jak_memfile_write(file, &entry->letter, sizeof(unsigned char));

                /** block one is the block that holds the significant part of the prefix code */
                jak_offset_t offset_meta, offset_continue;
                jak_memfile_get_offset(&offset_meta, file);
                /** this will be the number of bytes used to encode the significant part of the prefix code */
                jak_memfile_skip(file, sizeof(jak_u8));

                jak_memfile_begin_bit_mode(file);
                bool first_bit_found = false;
                for (int i = 31; entry->blocks && i >= 0; i--) {
                        jak_u32 mask = 1 << i;
                        jak_u32 k = entry->blocks[0] & mask;
                        bool bit_state = k != 0;
                        first_bit_found |= bit_state;

                        if (first_bit_found) {
                                jak_memfile_write_bit(file, bit_state);
                        }
                }
                size_t num_bytes_written;
                jak_memfile_end_bit_mode(&num_bytes_written, file);
                jak_memfile_get_offset(&offset_continue, file);
                jak_memfile_seek(file, offset_meta);
                jak_u8 num_bytes_written_uint8 = (jak_u8) num_bytes_written;
                jak_memfile_write(file, &num_bytes_written_uint8, sizeof(jak_u8));

                jak_memfile_seek(file, offset_continue);
        }

        return true;
}

static jak_pack_huffman_entry *find_dic_entry(jak_huffman *dic, unsigned char c)
{
        for (size_t i = 0; i < dic->table.num_elems; i++) {
                jak_pack_huffman_entry *entry = JAK_VECTOR_GET(&dic->table, i, jak_pack_huffman_entry);
                if (entry->letter == c) {
                        return entry;
                }
        }
        JAK_ERROR(&dic->err, JAK_ERR_HUFFERR)
        return NULL;
}

static size_t encodeString(jak_memfile *file, jak_huffman *dic, const char *string)
{
        jak_memfile_begin_bit_mode(file);

        for (const char *c = string; *c != '\0'; c++) {
                jak_pack_huffman_entry *entry = find_dic_entry(dic, (unsigned char) *c);
                if (!entry) {
                        return 0;
                }

                if (!entry->blocks) {
                        jak_memfile_write_bit(file, false);
                } else {
                        for (size_t j = 0; j < entry->nblocks; j++) {
                                jak_u32 block = entry->blocks[j];

                                bool first_bit_found = false;
                                for (int i = 31; i >= 0; i--) {
                                        jak_u32 mask = 1 << i;
                                        jak_u32 k = block & mask;
                                        bool bit_state = k != 0;
                                        first_bit_found |= bit_state;

                                        if (first_bit_found) {
                                                jak_memfile_write_bit(file, bit_state);
                                        }
                                }
                        }
                }
        }

        size_t num_written_bytes;
        jak_memfile_end_bit_mode(&num_written_bytes, file);
        return num_written_bytes;
}

bool jak_coding_huffman_encode(jak_memfile *file, jak_huffman *dic, const char *string)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(dic)
        JAK_ERROR_IF_NULL(string)

        jak_u32 num_bytes_encoded = 0;

        jak_offset_t num_bytes_encoded_off = jak_memfile_tell(file);
        jak_memfile_skip(file, sizeof(jak_u32));

        if ((num_bytes_encoded = (jak_u32) encodeString(file, dic, string)) == 0) {
                return false;
        }

        jak_offset_t continue_off = jak_memfile_tell(file);
        jak_memfile_seek(file, num_bytes_encoded_off);
        jak_memfile_write(file, &num_bytes_encoded, sizeof(jak_u32));
        jak_memfile_seek(file, continue_off);

        return true;
}

bool jak_coding_huffman_read_string(jak_pack_huffman_str_info *info, jak_memfile *src)
{
        info->nbytes_encoded = *JAK_MEMFILE_READ_TYPE(src, jak_u32);
        info->encoded_bytes = JAK_MEMFILE_READ(src, info->nbytes_encoded);
        return true;
}

bool jak_coding_huffman_read_entry(jak_pack_huffman_info *info, jak_memfile *file, char marker_symbol)
{
        char marker = *JAK_MEMFILE_PEEK(file, char);
        if (marker == marker_symbol) {
                jak_memfile_skip(file, sizeof(char));
                info->letter = *JAK_MEMFILE_READ_TYPE(file, unsigned char);
                info->nbytes_prefix = *JAK_MEMFILE_READ_TYPE(file, jak_u8);
                info->prefix_code = JAK_MEMFILE_PEEK(file, char);

                jak_memfile_skip(file, info->nbytes_prefix);

                return true;
        } else {
                return false;
        }
}

static const jak_u32 *get_num_used_blocks(jak_u16 *numUsedBlocks, jak_pack_huffman_entry *entry, jak_u16 num_blocks,
                                          const jak_u32 *blocks)
{
        for (entry->nblocks = 0; entry->nblocks < num_blocks; entry->nblocks++) {
                const jak_u32 *block = blocks + entry->nblocks;
                if (*block != 0) {
                        *numUsedBlocks = (num_blocks - entry->nblocks);
                        return block;
                }
        }
        return NULL;
}

static void
import_into_entry(jak_pack_huffman_entry *entry, const struct huff_node *node, const jak_bitmap *map)
{
        entry->letter = node->letter;
        jak_u32 *blocks, num_blocks;
        const jak_u32 *used_blocks;
        jak_bitmap_blocks(&blocks, &num_blocks, map);
        used_blocks = get_num_used_blocks(&entry->nblocks, entry, num_blocks, blocks);
        entry->blocks = JAK_MALLOC(entry->nblocks * sizeof(jak_u32));
        if (num_blocks > 0) {
                memcpy(entry->blocks, used_blocks, entry->nblocks * sizeof(jak_u32));
        } else {
                entry->blocks = NULL;
        }
        free(blocks);
}

static struct huff_node *seek_to_begin(struct huff_node *handle)
{
        for (; handle->prev != NULL; handle = handle->prev) {}
        return handle;
}

static struct huff_node *seek_to_end(struct huff_node *handle)
{
        for (; handle->next != NULL; handle = handle->next) {}
        return handle;
}

JAK_FUNC_UNUSED
static void __diag_print_insight(struct huff_node *n)
{
        printf("(");
        if (!n->left && !n->right) {
                printf("%c", n->letter);
        } else {
                if (n->left) {
                        __diag_print_insight(n->left);
                }
                printf(",");
                if (n->right) {
                        __diag_print_insight(n->right);
                }
        }
        printf(")");
        printf(": %"PRIu64"", n->freq);
}

JAK_FUNC_UNUSED
static void __diag_dump_remaining_candidates(struct huff_node *n)
{
        struct huff_node *it = seek_to_begin(n);
        while (it->next != NULL) {
                __diag_print_insight(it);
                printf(" | ");
                it = it->next;
        }
}

static struct huff_node *find_smallest(struct huff_node *begin, jak_u64 lowerBound, struct huff_node *skip)
{
        jak_u64 smallest = UINT64_MAX;
        struct huff_node *result = NULL;
        for (struct huff_node *it = begin; it != NULL; it = it->next) {
                if (it != skip && it->freq >= lowerBound && it->freq <= smallest) {
                        smallest = it->freq;
                        result = it;
                }
        }
        return result;
}

static void assign_code(struct huff_node *node, const jak_bitmap *path,
                        jak_vector ofType(jak_pack_huffman_entry) *table)
{
        if (!node->left && !node->right) {
                jak_pack_huffman_entry *entry = JAK_VECTOR_NEW_AND_GET(table, jak_pack_huffman_entry);
                import_into_entry(entry, node, path);
        } else {
                if (node->left) {
                        jak_bitmap left;
                        jak_bitmap_cpy(&left, path);
                        jak_bitmap_lshift(&left);
                        jak_bitmap_set(&left, 0, false);
                        assign_code(node->left, &left, table);
                        jak_bitmap_drop(&left);
                }
                if (node->right) {
                        jak_bitmap right;
                        jak_bitmap_cpy(&right, path);
                        jak_bitmap_lshift(&right);
                        jak_bitmap_set(&right, 0, true);
                        assign_code(node->right, &right, table);
                        jak_bitmap_drop(&right);
                }
        }
}

static struct huff_node *trim_and_begin(jak_vector ofType(HuffNode) *candidates)
{
        struct huff_node *begin = NULL;
        for (struct huff_node *it = JAK_VECTOR_GET(candidates, 0, struct huff_node);; it++) {
                if (it->freq == 0) {
                        if (it->prev) {
                                it->prev->next = it->next;
                        }
                        if (it->next) {
                                it->next->prev = it->prev;
                        }
                } else {
                        if (!begin) {
                                begin = it;
                        }
                }
                if (!it->next) {
                        break;
                }
        }
        return begin;
}

static void huff_tree_create(jak_vector ofType(jak_pack_huffman_entry) *table,
                             const jak_vector ofType(jak_u32) *frequencies)
{
        JAK_ASSERT(UCHAR_MAX == frequencies->num_elems);

        jak_vector ofType(HuffNode) candidates;
        jak_vector_create(&candidates, NULL, sizeof(struct huff_node), UCHAR_MAX * UCHAR_MAX);
        size_t appender_idx = UCHAR_MAX;

        for (unsigned char i = 0; i < UCHAR_MAX; i++) {
                struct huff_node *node = JAK_VECTOR_NEW_AND_GET(&candidates, struct huff_node);
                node->letter = i;
                node->freq = *JAK_VECTOR_GET(frequencies, i, jak_u32);
        }

        for (unsigned char i = 0; i < UCHAR_MAX; i++) {
                struct huff_node *node = JAK_VECTOR_GET(&candidates, i, struct huff_node);
                struct huff_node *prev = i > 0 ? JAK_VECTOR_GET(&candidates, i - 1, struct huff_node) : NULL;
                struct huff_node *next = i + 1 < UCHAR_MAX ? JAK_VECTOR_GET(&candidates, i + 1, struct huff_node) : NULL;
                node->next = next;
                node->prev = prev;
                node->left = node->right = NULL;
        }

        struct huff_node *smallest, *small;
        struct huff_node *handle = trim_and_begin(&candidates);
        struct huff_node *new_node = NULL;

        while (handle->next != NULL) {
                smallest = find_smallest(handle, 0, NULL);
                small = find_smallest(handle, smallest->freq, smallest);

                appender_idx++;
                new_node = JAK_VECTOR_NEW_AND_GET(&candidates, struct huff_node);
                new_node->freq = small->freq + smallest->freq;
                new_node->letter = '\0';
                new_node->left = small;
                new_node->right = smallest;

                if ((small->prev == NULL && smallest->next == NULL) && small->next == smallest) {
                        break;
                }

                if ((smallest->prev == NULL && small->next == NULL) && smallest->next == small) {
                        break;
                }
                if (smallest->prev) {
                        smallest->prev->next = smallest->next;
                }
                if (smallest->next) {
                        smallest->next->prev = smallest->prev;
                }
                if (small->prev) {
                        small->prev->next = small->next;
                }
                if (small->next) {
                        small->next->prev = small->prev;
                }

                if (small->prev) {
                        handle = seek_to_begin(small->prev);
                } else if (smallest->prev) {
                        handle = seek_to_begin(smallest->prev);
                } else if (small->next) {
                        handle = seek_to_begin(small->next);
                } else if (smallest->next) {
                        handle = seek_to_begin(smallest->next);
                } else {
                        JAK_ERROR_PRINT_AND_DIE(JAK_ERR_INTERNALERR);
                }

                JAK_ASSERT (!handle->prev);
                struct huff_node *end = seek_to_end(handle);
                JAK_ASSERT(!end->next);
                end->next = new_node;
                new_node->prev = end;
                new_node->next = NULL;

#ifdef DIAG_HUFFMAN_ENABLE_DEBUG
                printf("in-memory huff-tree: ");
                __diag_print_insight(new_node);
                printf("\n");
                printf("remaining candidates: ");
                __diag_dump_remaining_candidates(handle);
                printf("\n");
#endif
        }

        seek_to_begin(handle);
        if (handle->next) {
                struct huff_node *finalNode = JAK_VECTOR_NEW_AND_GET(&candidates, struct huff_node);
                finalNode->freq = small->freq + smallest->freq;
                finalNode->letter = '\0';
                if (handle->freq > handle->next->freq) {
                        finalNode->left = handle;
                        finalNode->right = handle->next;
                } else {
                        finalNode->left = handle->next;
                        finalNode->right = handle;
                }
                new_node = finalNode;
        }

#ifdef DIAG_HUFFMAN_ENABLE_DEBUG
        printf("final in-memory huff-tree: ");
        __diag_print_insight(new_node);
        printf("\n");
#endif

        jak_bitmap root_path;
        jak_bitmap_create(&root_path, UCHAR_MAX);
        jak_bitmap_set(&root_path, 0, true);
        assign_code(new_node, &root_path, table);
        jak_bitmap_drop(&root_path);

        jak_vector_drop(&candidates);
}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>
#include <jak_pack.h>
#include <jak_pack_none.h>

bool jak_pack_none_init(jak_packer *self)
{
        JAK_UNUSED(self);
        /* nothing to do for uncompressed dictionaries */
        return true;
}

bool jak_pack_none_cpy(const jak_packer *self, jak_packer *dst)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_NONE);

        /* nothing to hard copy but the function pointers */
        *dst = *self;
        return true;
}

bool jak_pack_none_drop(jak_packer *self)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_NONE);

        JAK_UNUSED(self);
        /* nothing to do for uncompressed dictionaries */
        return true;
}

bool jak_pack_none_write_extra(jak_packer *self, jak_memfile *dst,
                           const jak_vector ofType (const char *) *strings)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_NONE);

        JAK_UNUSED(self);
        JAK_UNUSED(dst);
        JAK_UNUSED(strings);
        /* nothing to do for uncompressed dictionaries */
        return true;
}

bool jak_pack_none_read_extra(jak_packer *self, FILE *src, size_t nbytes)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_NONE);

        JAK_UNUSED(self);
        JAK_UNUSED(src);
        JAK_UNUSED(nbytes);
        /* nothing to do for uncompressed dictionaries */
        return true;
}

bool jak_pack_none_print_extra(jak_packer *self, FILE *file, jak_memfile *src)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_NONE);

        JAK_UNUSED(self);
        JAK_UNUSED(file);
        JAK_UNUSED(src);
        /* nothing to do for uncompressed dictionaries */
        return true;
}

bool jak_pack_none_print_encoded_string(jak_packer *self, FILE *file, jak_memfile *src,
                                    jak_u32 decompressed_strlen)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_NONE);

        JAK_UNUSED(self);

        const char *string = JAK_MEMFILE_READ(src, decompressed_strlen);

        char *printableString = JAK_MALLOC(decompressed_strlen + 1);
        memcpy(printableString, string, decompressed_strlen);
        printableString[decompressed_strlen] = '\0';

        fprintf(file, "[string: %s]", printableString);

        free(printableString);

        return true;
}

bool jak_pack_none_encode_string(jak_packer *self, jak_memfile *dst, jak_error *err,
                             const char *string)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_NONE);

        JAK_UNUSED(self);

        jak_u32 jak_string_length = strlen(string);

        JAK_SUCCESS_OR_JUMP(jak_memfile_write(dst, string, jak_string_length), error_handling)

        return true;

        error_handling:
        JAK_ERROR(err, JAK_ERR_IO)
        return false;
}

bool jak_pack_none_decode_string(jak_packer *self, char *dst, size_t strlen, FILE *src)
{
        JAK_CHECK_TAG(self->tag, JAK_PACK_NONE);

        JAK_UNUSED(self);

        size_t num_read = fread(dst, sizeof(char), strlen, src);
        return (num_read == strlen);
}
/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdlib.h>
#include <jak_string.h>

#include <jak_priority_queue.h>

void jak_priority_queue_init(jak_priority_queue *queue)
{
        queue->num_elements = 0;
        pthread_mutex_init(&queue->mutex, NULL);
        queue->capacity = 0;
        queue->data = NULL;
}

void jak_priority_queue_free(jak_priority_queue *queue)
{
        free(queue->data);
}

void jak_priority_queue_resize(jak_priority_queue *queue, size_t size)
{
        jak_priority_queue_element_info *new_data = JAK_MALLOC(sizeof(jak_priority_queue_element_info) * size);

        memcpy(new_data, queue->data, sizeof(jak_priority_queue_element_info) * queue->num_elements);
        free(queue->data);

        queue->data = new_data;
}

inline static void swap(jak_priority_queue_element_info *el1, jak_priority_queue_element_info *el2)
{
        jak_priority_queue_element_info tmp = *el1;
        *el1 = *el2;
        *el2 = tmp;
}

static void down_heap(jak_priority_queue_element_info *heap, size_t size)
{
        size_t cur = 0;
        size_t id = 1;
        for (size_t next = 3;; next = (next << 1) + 1) {
                size_t min = 0xffffffff;
                size_t minId = 0;
                while (id != next && id < size) {
                        if (heap[id].priority < min) {
                                min = heap[id].priority;
                                minId = id;
                        }
                        ++id;
                }
                if (heap[cur].priority <= heap[minId].priority) { break; }
                swap(&heap[cur], &heap[minId]);
                cur = minId;
                if (id == size) { break; }
        }
}

static void up_heap(jak_priority_queue_element_info *heap, size_t size)
{
        if (size == 1) { return; }
        size_t log = 31 - __builtin_clz(size);

        size_t begin = 1 << (log - 1);
        size_t cur = size - 1;

        for (;;) {
                size_t end = (begin << 1) + 1;
                if (end > size) { end = size; }
                size_t max = heap[begin].priority;
                size_t id = begin;
                for (size_t i = begin + 1; i < end; ++i) {
                        if (heap[i].priority >= max) {
                                max = heap[i].priority;
                                id = i;
                        }
                }
                if (heap[id].priority <= heap[cur].priority) { break; }
                else {
                        swap(&heap[cur], &heap[id]);
                        cur = id;
                }
                if (!begin) { break; }
                begin >>= 1;
        }
}

void jak_priority_queue_push(jak_priority_queue *queue, void *data, size_t priority)
{
        pthread_mutex_lock(&queue->mutex);

        if (queue->num_elements >= queue->capacity) {
                jak_priority_queue_resize(queue, ((queue->num_elements + 1) * 3) / 2);
        }

        queue->data[queue->num_elements].element = data;
        queue->data[queue->num_elements].priority = priority;
        ++queue->num_elements;
        up_heap(queue->data, queue->num_elements);

        pthread_mutex_unlock(&queue->mutex);
}

void *jak_priority_queue_pop(jak_priority_queue *queue)
{
        pthread_mutex_lock(&queue->mutex);

        void *ptr = NULL;

        if (queue->num_elements) {
                --queue->num_elements;

                ptr = queue->data[0].element;
                queue->data[0] = queue->data[queue->num_elements];
                down_heap(queue->data, queue->num_elements + 1);
        }

        pthread_mutex_unlock(&queue->mutex);
        return ptr;
}

int jak_priority_queue_is_empty(jak_priority_queue *queue)
{
        pthread_mutex_lock(&queue->mutex);

        int result = !queue->num_elements;

        pthread_mutex_unlock(&queue->mutex);
        return result;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>

#include <jak_slicelist.h>
#include <jak_hash.h>

#define JAK_SLICE_LIST_TAG "slice-list"

#define get_hashcode(key)    JAK_HASH_ADDITIVE(strlen(key), key)

/** OPTIMIZATION: we have only one item to find. Use branch-less scan instead of branching scan */
/** OPTIMIZATION: find function as macro */
#define SLICE_SCAN(slice, needle_hash, needle_str)                                                                     \
({                                                                                                                     \
    JAK_TRACE(JAK_SLICE_LIST_TAG, "SLICE_SCAN for '%s' started", needle_str);                                    \
    JAK_ASSERT(slice);                                                                                                     \
    JAK_ASSERT(needle_str);                                                                                                \
                                                                                                                       \
    register bool continueScan, keysMatch, keyHashsNoMatch, endReached;                                                \
    register bool cacheAvailable = (slice->cache_idx != (jak_u32) -1);                                                 \
    register bool hashsEq = cacheAvailable && (slice->key_hash_column[slice->cache_idx] == needle_hash);                  \
    register bool cacheHit = hashsEq && (strcmp(slice->key_column[slice->cache_idx], needle_str) == 0);                 \
    register uint_fast32_t i = 0;                                                                                      \
    if (!cacheHit) {                                                                                                   \
        do {                                                                                                           \
            while ((keyHashsNoMatch = (slice->key_hash_column[i]!=needle_hash)) && i++<slice->num_elems) { ; }           \
            endReached    = ((i+1)>slice->num_elems);                                                                  \
            keysMatch      = endReached || (!keyHashsNoMatch && (strcmp(slice->key_column[i], needle_str)==0));        \
            continueScan  = !endReached && !keysMatch;                                                                 \
            i             += continueScan;                                                                             \
        }                                                                                                              \
        while (continueScan);                                                                                          \
        slice->cache_idx = !endReached && keysMatch ? i : slice->cache_idx;                                              \
    }                                                                                                                  \
    cacheHit ? slice->cache_idx : (!endReached && keysMatch ? i : slice->num_elems);                                    \
})

#define SLICE_BESEARCH(slice, needle_hash, needle_str)                                                                 \
({                                                                                                                     \
    0; \
})

static void appenderNew(jak_slice_list_t *list);

static void appenderSeal(jak_slice *slice);

static void _jak_slicelist_lock(jak_slice_list_t *list);

static void _jak_slicelist_unlock(jak_slice_list_t *list);

bool jak_slice_list_create(jak_slice_list_t *list, const jak_allocator *alloc, size_t slice_capacity)
{
        JAK_ERROR_IF_NULL(list)
        JAK_ERROR_IF_NULL(slice_capacity)

        jak_alloc_this_or_std(&list->alloc, alloc);
        jak_spinlock_init(&list->lock);
        jak_error_init(&list->err);

        jak_vector_create(&list->slices, &list->alloc, sizeof(jak_slice), slice_capacity);
        jak_vector_create(&list->descriptors, &list->alloc, sizeof(jak_slice_descriptor), slice_capacity);
        jak_vector_create(&list->filters, &list->alloc, sizeof(jak_bitmap), slice_capacity);
        jak_vector_create(&list->bounds, &list->alloc, sizeof(jak_hash_bounds), slice_capacity);

        JAK_ZERO_MEMORY(jak_vector_data(&list->slices), slice_capacity * sizeof(jak_slice));
        JAK_ZERO_MEMORY(jak_vector_data(&list->descriptors), slice_capacity * sizeof(jak_slice_descriptor));
        JAK_ZERO_MEMORY(jak_vector_data(&list->filters), slice_capacity * sizeof(jak_bitmap));
        JAK_ZERO_MEMORY(jak_vector_data(&list->bounds), slice_capacity * sizeof(jak_hash_bounds));

        appenderNew(list);

        return true;
}

bool jak_slice_list_drop(jak_slice_list_t *list)
{
        JAK_UNUSED(list);

        jak_vector_drop(&list->slices);
        jak_vector_drop(&list->descriptors);
        jak_vector_drop(&list->bounds);
        for (size_t i = 0; i < list->filters.num_elems; i++) {
                jak_bitmap *filter = JAK_VECTOR_GET(&list->filters, i, jak_bitmap);
                jak_bloom_drop(filter);
        }
        jak_vector_drop(&list->filters);
        return true;
}

bool jak_slice_list_is_empty(const jak_slice_list_t *list)
{
        return (jak_vector_is_empty(&list->slices));
}

bool jak_slice_list_insert(jak_slice_list_t *list, char **strings, jak_archive_field_sid_t *ids, size_t num_pairs)
{
        _jak_slicelist_lock(list);

        while (num_pairs--) {
                const char *key = *strings++;
                jak_archive_field_sid_t value = *ids++;
                hash32_t keyHash = get_hashcode(key);
                jak_slice_handle handle;
                int status;

                JAK_ASSERT (key);

                /** check whether the keys-values pair is already contained in one slice */
                status = jak_slice_list_lookup(&handle, list, key);

                if (status == true) {
                        /** pair was found, do not insert it twice */
                        JAK_ASSERT (value == handle.value);
                        continue;
                } else {
                        /** pair is not found; append it */
                        jak_hash_bounds *restrict bounds = JAK_VECTOR_ALL(&list->bounds, jak_hash_bounds);
                        jak_bitmap *restrict filters = JAK_VECTOR_ALL(&list->filters, jak_bitmap);
                        jak_slice *restrict slices = JAK_VECTOR_ALL(&list->slices, jak_slice);

                        jak_slice *restrict appender = slices + list->appender_idx;
                        jak_bitmap *restrict appenderFilter = filters + list->appender_idx;
                        jak_hash_bounds *restrict appenderBounds = bounds + list->appender_idx;

                        JAK_DEBUG(JAK_SLICE_LIST_TAG,
                                  "appender # of elems: %zu, limit: %zu",
                                  appender->num_elems,
                                  SLICE_KEY_COLUMN_MAX_ELEMS);
                        JAK_ASSERT(appender->num_elems < SLICE_KEY_COLUMN_MAX_ELEMS);
                        appender->key_column[appender->num_elems] = key;
                        appender->key_hash_column[appender->num_elems] = keyHash;
                        appender->jak_string_id_column[appender->num_elems] = value;
                        appenderBounds->min_hash = appenderBounds->min_hash < keyHash ? appenderBounds->min_hash : keyHash;
                        appenderBounds->max_hash = appenderBounds->max_hash > keyHash ? appenderBounds->max_hash : keyHash;
                        JAK_BLOOM_SET(appenderFilter, &keyHash, sizeof(hash32_t));
                        appender->num_elems++;
                        if (JAK_UNLIKELY(appender->num_elems == SLICE_KEY_COLUMN_MAX_ELEMS)) {
                                appenderSeal(appender);
                                appenderNew(list);
                        }
                }
        }

        _jak_slicelist_unlock(list);
        return true;
}

bool jak_slice_list_lookup(jak_slice_handle *handle, jak_slice_list_t *list, const char *needle)
{
        JAK_UNUSED(list);
        JAK_UNUSED(handle);
        JAK_UNUSED(needle);

        hash32_t keyHash = get_hashcode(needle);
        jak_u32 numSlices = jak_vector_length(&list->slices);

        /** check whether the keys-values pair is already contained in one slice */
        jak_hash_bounds *restrict bounds = JAK_VECTOR_ALL(&list->bounds, jak_hash_bounds);
        jak_bitmap *restrict filters = JAK_VECTOR_ALL(&list->filters, jak_bitmap);
        jak_slice *restrict slices = JAK_VECTOR_ALL(&list->slices, jak_slice);
        jak_slice_descriptor *restrict descs = JAK_VECTOR_ALL(&list->descriptors, jak_slice_descriptor);

        for (register jak_u32 i = 0; i < numSlices; i++) {
                jak_slice_descriptor *restrict desc = descs + i;
                jak_hash_bounds *restrict bound = bounds + i;
                jak_slice *restrict slice = slices + i;

                desc->num_reads_all++;

                if (slice->num_elems > 0) {
                        bool keyHashIn = keyHash >= bound->min_hash && keyHash <= bound->max_hash;
                        if (keyHashIn) {
                                jak_bitmap *restrict filter = filters + i;
                                bool maybeContained = JAK_BLOOM_TEST(filter, &keyHash, sizeof(hash32_t));
                                if (maybeContained) {
                                        JAK_DEBUG(JAK_SLICE_LIST_TAG,
                                                  "JAK_jak_slice_list_lookup_by_key keys(%s) -> ?",
                                                  needle);
                                        jak_u32 pairPosition;

                                        switch (slice->strat) {
                                                case JAK_SLICE_LOOKUP_SCAN:
                                                        pairPosition = SLICE_SCAN(slice, keyHash, needle);
                                                        break;
                                                case JAK_SLICE_LOOKUP_BESEARCH:
                                                        pairPosition = SLICE_BESEARCH(slice, keyHash, needle);
                                                        break;
                                                default: JAK_ERROR(&list->err, JAK_ERR_UNSUPFINDSTRAT)
                                                        return false;
                                        }

                                        JAK_DEBUG(JAK_SLICE_LIST_TAG,
                                                  "JAK_jak_slice_list_lookup_by_key keys(%s) -> pos(%zu in slice #%zu)",
                                                  needle,
                                                  pairPosition,
                                                  i);
                                        if (pairPosition < slice->num_elems) {
                                                /** pair is contained */
                                                desc->num_reads_hit++;
                                                handle->is_contained = true;
                                                handle->value = slice->jak_string_id_column[pairPosition];
                                                handle->key = needle;
                                                handle->container = slice;

                                                desc->num_reads_hit++;
                                                return true;
                                        }
                                } else {
                                        /** jak_bitmap is sure that pair is not contained */
                                        continue;
                                }
                        } else {
                                /** keys hash is not inside bounds of hashes in slice */
                                continue;
                        }
                }
        }

        handle->is_contained = false;

        return false;
}

bool jak_slice_list_remove(jak_slice_list_t *list, jak_slice_handle *handle)
{
        JAK_UNUSED(list);
        JAK_UNUSED(handle);
        JAK_NOT_IMPLEMENTED
}

static void appenderNew(jak_slice_list_t *list)
{
        /** ANTI-OPTIMIZATION: madvising sequential access to columns in slice decrease performance */

        /** the slice itself */
        jak_slice slice = {.strat     = JAK_SLICE_LOOKUP_SCAN, .num_elems = 0, .cache_idx = (jak_u32) -1};

        jak_u32 numSlices = jak_vector_length(&list->slices);
        jak_vector_push(&list->slices, &slice, 1);

        JAK_ASSERT(SLICE_KEY_COLUMN_MAX_ELEMS > 0);

        /** the descriptor */
        jak_slice_descriptor desc = {.num_reads_hit  = 0, .num_reads_all  = 0,};

        jak_vector_push(&list->descriptors, &desc, 1);

        /** the lookup guards */
        JAK_ASSERT(sizeof(jak_bitmap) <= JAK_SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_SIZE_IN_BYTE);
        jak_bitmap filter;

        /** NOTE: the size of each jak_bitmap lead to a false positive probability of 100%, i.e., number of items in the
         * slice is around 32644 depending on the CPU cache size, the number of actual bits in the filter (Cache line size
         * in bits minus the header for the jak_bitmap) along with the number of used hash functions (4), lead to that
         * probability. However, the reason a jak_bitmap is used is to skip slices whch definitively do NOT contain the
         * keys-values pair - and that still works ;) */
        jak_bloom_create(&filter,
                         (JAK_SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_SIZE_IN_BYTE - sizeof(jak_bitmap)) * 8);
        jak_vector_push(&list->filters, &filter, 1);
        jak_hash_bounds bounds = {.min_hash        = (hash32_t) -1, .max_hash        = (hash32_t) 0};
        jak_vector_push(&list->bounds, &bounds, 1);

        JAK_INFO(JAK_SLICE_LIST_TAG,
                 "created new appender in slice list %p\n\t"
                 "# of slices (incl. appender) in total...............: %zu\n\t"
                 "jak_slice target memory size............................: %zuB (%s)\n\t"
                 "jak_bitmap target memory size......................: %zuB (%s)\n\t"
                 "Max # of (keys, hash, string) in appender/slice......: %zu\n\t"
                 "Bits used in per-slice jak_bitmap..................: %zu\n\t"
                 "Prob. of jak_bitmap to produce false-positives.....: %f\n\t"
                 "Single slice type size..............................: %zuB\n\t"
                 "Total slice-list size...............................: %f MiB",
                 list,
                 list->slices.num_elems,
                 (size_t) JAK_SLICE_LIST_TARGET_MEMORY_SIZE_IN_BYTE,
                 JAK_SLICE_LIST_TARGET_MEMORY_NAME,
                 (size_t) JAK_SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_SIZE_IN_BYTE,
                 JAK_SLICE_LIST_BLOOMFILTER_TARGET_MEMORY_NAME,
                 (size_t) SLICE_KEY_COLUMN_MAX_ELEMS,
                 jak_bitmap_nbits(&filter),
                 (pow(1 - exp(-(double) jak_bloom_nhashs()
                              / ((double) jak_bitmap_nbits(&filter) / (double) SLICE_KEY_COLUMN_MAX_ELEMS)),
                      jak_bitmap_nbits(&filter))),
                 sizeof(jak_slice),
                 (sizeof(jak_slice_list_t) + list->slices.num_elems
                                         * (sizeof(jak_slice) + sizeof(jak_slice_descriptor) +
                                            (sizeof(jak_u32) * list->descriptors.num_elems)
                                            + sizeof(jak_bitmap) + jak_bitmap_nbits(&filter) / 8 +
                                            sizeof(jak_hash_bounds))) /
                 1024.0 / 1024.0);

        /** register new slice as the current appender */
        list->appender_idx = numSlices;
}

static void appenderSeal(jak_slice *slice)
{
        JAK_UNUSED(slice);
        // TODO: sealing means sort and then replace 'find' with bsearch or something.
        // Not yet implemented: sealed slices are also search in a linear fashion
}

static void _jak_slicelist_lock(jak_slice_list_t *list)
{
        jak_spinlock_acquire(&list->lock);
}

static void _jak_slicelist_unlock(jak_slice_list_t *list)
{
        jak_spinlock_release(&list->lock);
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_spinlock.h>
#include <jak_time.h>

#define SPINLOCK_TAG "spinlock"

bool jak_spinlock_init(jak_spinlock *spinlock)
{
        JAK_ERROR_IF_NULL(spinlock)
        atomic_flag_clear(&spinlock->lock);

        memset(&spinlock->owner, 0, sizeof(pthread_t));

        return true;
}

bool jak_spinlock_acquire(jak_spinlock *spinlock)
{
        jak_timestamp begin = jak_wallclock();
        JAK_ERROR_IF_NULL(spinlock)
        if (!pthread_equal(spinlock->owner, pthread_self())) {
                while (atomic_flag_test_and_set(&spinlock->lock)) {}
                /** remeber the thread that aquires this lock */
                spinlock->owner = pthread_self();
        }
        jak_timestamp end = jak_wallclock();
        float duration = (end - begin) / 1000.0f;
        if (duration > 0.01f) {
                JAK_WARN(SPINLOCK_TAG, "spin lock acquisition took exceptionally long: %f seconds", duration);
        }

        return true;
}

bool jak_spinlock_release(jak_spinlock *spinlock)
{
        JAK_ERROR_IF_NULL(spinlock)
        atomic_flag_clear(&spinlock->lock);
        memset(&spinlock->owner, 0, sizeof(pthread_t));
        return true;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_str_hash_mem.h>
#include <jak_spinlock.h>
#include <jak_utils_sort.h>
#include <jak_alloc_trace.h>
#include <jak_time.h>
#include <jak_bloom.h>
#include <jak_slicelist.h>
#include <jak_hash.h>

#define JAK_STR_HASH_MEM_HASHCODE_OF(key)      JAK_HASH_BERNSTEIN(strlen(key), key)

#define SMART_MAP_TAG "strhash-mem"

struct bucket {
        jak_slice_list_t slice_list;
};

struct mem_extra {
        jak_vector ofType(bucket) buckets;
};

static int _jak_str_hash_mem_drop(jak_str_hash *self);

static int this_put_safe_bulk(jak_str_hash *self, char *const *keys, const jak_archive_field_sid_t *values,
                              size_t num_pairs);

static int this_put_fast_bulk(jak_str_hash *self, char *const *keys, const jak_archive_field_sid_t *values,
                              size_t num_pairs);

static int this_put_safe_exact(jak_str_hash *self, const char *key, jak_archive_field_sid_t value);

static int this_put_fast_exact(jak_str_hash *self, const char *key, jak_archive_field_sid_t value);

static int
this_get_safe(jak_str_hash *self, jak_archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
              char *const *keys, size_t num_keys);

static int
this_get_safe_exact(jak_str_hash *self, jak_archive_field_sid_t *out, bool *found_mask, const char *key);

static int this_get_fast(jak_str_hash *self, jak_archive_field_sid_t **out, char *const *keys, size_t num_keys);

static int this_update_key_fast(jak_str_hash *self, const jak_archive_field_sid_t *values, char *const *keys,
                                size_t num_keys);

static int _jak_str_hash_mem_remove(jak_str_hash *self, char *const *keys, size_t num_keys);

static int _jak_str_hash_mem_free(jak_str_hash *self, void *ptr);

static int this_insert_bulk(jak_vector ofType(bucket) *buckets, char *const *restrict keys,
                            const jak_archive_field_sid_t *restrict values, size_t *restrict bucket_idxs,
                            size_t num_pairs,
                            jak_allocator *alloc,
                            jak_str_hash_counters *counter);

static int
this_insert_exact(jak_vector ofType(bucket) *buckets, const char *restrict key, jak_archive_field_sid_t value,
                  size_t bucket_idx, jak_allocator *alloc, jak_str_hash_counters *counter);

static int
this_fetch_bulk(jak_vector ofType(bucket) *buckets, jak_archive_field_sid_t *values_out, bool *key_found_mask,
                size_t *num_keys_not_found, size_t *bucket_idxs, char *const *keys, size_t num_keys,
                jak_allocator *alloc,
                jak_str_hash_counters *counter);

static int
this_fetch_single(jak_vector ofType(bucket) *buckets, jak_archive_field_sid_t *value_out, bool *key_found,
                  const size_t bucket_idx, const char *key, jak_str_hash_counters *counter);

static int _jak_str_hash_mem_create_extra(jak_str_hash *self, size_t num_buckets, size_t cap_buckets);

static struct mem_extra *this_get_exta(jak_str_hash *self);

static int bucket_create(struct bucket *buckets, size_t num_buckets, size_t bucket_cap, jak_allocator *alloc);

static int bucket_drop(struct bucket *buckets, size_t num_buckets, jak_allocator *alloc);

static int bucket_insert(struct bucket *bucket, const char *restrict key, jak_archive_field_sid_t value,
                         jak_allocator *alloc,
                         jak_str_hash_counters *counter);

bool
jak_str_hash_create_inmemory(jak_str_hash *str_hash, const jak_allocator *alloc, size_t num_buckets,
                             size_t cap_buckets)
{
        JAK_CHECK_SUCCESS(jak_alloc_this_or_std(&str_hash->allocator, alloc));

        num_buckets = num_buckets < 1 ? 1 : num_buckets;
        cap_buckets = cap_buckets < 1 ? 1 : cap_buckets;

        str_hash->tag = JAK_MEMORY_RESIDENT;
        str_hash->drop = _jak_str_hash_mem_drop;
        str_hash->put_bulk_safe = this_put_safe_bulk;
        str_hash->put_bulk_fast = this_put_fast_bulk;
        str_hash->put_exact_safe = this_put_safe_exact;
        str_hash->put_exact_fast = this_put_fast_exact;
        str_hash->get_bulk_safe = this_get_safe;
        str_hash->get_fast = this_get_fast;
        str_hash->update_key_fast = this_update_key_fast;
        str_hash->remove = _jak_str_hash_mem_remove;
        str_hash->free = _jak_str_hash_mem_free;
        str_hash->get_exact_safe = this_get_safe_exact;
        jak_error_init(&str_hash->err);

        jak_str_hash_reset_counters(str_hash);
        JAK_CHECK_SUCCESS(_jak_str_hash_mem_create_extra(str_hash, num_buckets, cap_buckets));
        return true;
}

static int _jak_str_hash_mem_drop(jak_str_hash *self)
{
        JAK_ASSERT(self->tag == JAK_MEMORY_RESIDENT);
        struct mem_extra *extra = this_get_exta(self);
        struct bucket *data = (struct bucket *) jak_vector_data(&extra->buckets);
        JAK_CHECK_SUCCESS(bucket_drop(data, extra->buckets.cap_elems, &self->allocator));
        jak_vector_drop(&extra->buckets);
        jak_alloc_free(&self->allocator, self->extra);
        return true;
}

static int this_put_safe_bulk(jak_str_hash *self, char *const *keys, const jak_archive_field_sid_t *values,
                              size_t num_pairs)
{
        JAK_ASSERT(self->tag == JAK_MEMORY_RESIDENT);
        struct mem_extra *extra = this_get_exta(self);
        size_t *bucket_idxs = jak_alloc_malloc(&self->allocator, num_pairs * sizeof(size_t));

        JAK_PREFETCH_WRITE(bucket_idxs);

        for (size_t i = 0; i < num_pairs; i++) {
                const char *key = keys[i];
                hash32_t hash = JAK_STR_HASH_MEM_HASHCODE_OF(key);
                bucket_idxs[i] = hash % extra->buckets.cap_elems;
        }

        JAK_PREFETCH_READ(bucket_idxs);
        JAK_PREFETCH_READ(keys);
        JAK_PREFETCH_READ(values);

        JAK_CHECK_SUCCESS(this_insert_bulk(&extra->buckets,
                                           keys,
                                           values,
                                           bucket_idxs,
                                           num_pairs,
                                           &self->allocator,
                                           &self->counters));
        JAK_CHECK_SUCCESS(jak_alloc_free(&self->allocator, bucket_idxs));
        return true;
}

static int this_put_safe_exact(jak_str_hash *self, const char *key, jak_archive_field_sid_t value)
{
        JAK_ASSERT(self->tag == JAK_MEMORY_RESIDENT);
        struct mem_extra *extra = this_get_exta(self);

        hash32_t hash = strcmp("", key) != 0 ? JAK_STR_HASH_MEM_HASHCODE_OF(key) : 0;
        size_t bucket_idx = hash % extra->buckets.cap_elems;

        JAK_PREFETCH_READ(key);

        JAK_CHECK_SUCCESS(this_insert_exact(&extra->buckets,
                                            key,
                                            value,
                                            bucket_idx,
                                            &self->allocator,
                                            &self->counters));

        return true;
}

static int this_put_fast_exact(jak_str_hash *self, const char *key, jak_archive_field_sid_t value)
{
        return this_put_safe_exact(self, key, value);
}

static int this_put_fast_bulk(jak_str_hash *self, char *const *keys, const jak_archive_field_sid_t *values,
                              size_t num_pairs)
{
        return this_put_safe_bulk(self, keys, values, num_pairs);
}

static int
this_fetch_bulk(jak_vector ofType(bucket) *buckets, jak_archive_field_sid_t *values_out, bool *key_found_mask,
                size_t *num_keys_not_found, size_t *bucket_idxs, char *const *keys, size_t num_keys,
                jak_allocator *alloc,
                jak_str_hash_counters *counter)
{
        JAK_UNUSED(counter);
        JAK_UNUSED(alloc);

        jak_slice_handle result_handle;
        size_t num_not_found = 0;
        struct bucket *data = (struct bucket *) jak_vector_data(buckets);

        JAK_PREFETCH_WRITE(values_out);

        for (size_t i = 0; i < num_keys; i++) {
                struct bucket *bucket = data + bucket_idxs[i];
                const char *key = keys[i];
                if (JAK_LIKELY(key != NULL)) {
                        jak_slice_list_lookup(&result_handle, &bucket->slice_list, key);
                } else {
                        result_handle.is_contained = true;
                        result_handle.value = JAK_NULL_ENCODED_STRING;
                }

                num_not_found += result_handle.is_contained ? 0 : 1;
                key_found_mask[i] = result_handle.is_contained;
                values_out[i] = result_handle.is_contained ? result_handle.value : ((jak_archive_field_sid_t) -1);
        }

        *num_keys_not_found = num_not_found;
        return true;
}

static int
this_fetch_single(jak_vector ofType(bucket) *buckets, jak_archive_field_sid_t *value_out, bool *key_found,
                  const size_t bucket_idx, const char *key, jak_str_hash_counters *counter)
{
        JAK_UNUSED(counter);

        jak_slice_handle handle;
        struct bucket *data = (struct bucket *) jak_vector_data(buckets);

        JAK_PREFETCH_WRITE(value_out);
        JAK_PREFETCH_WRITE(key_found);

        struct bucket *bucket = data + bucket_idx;

        /** Optimization 1/5: EMPTY GUARD (but before "find" call); if this bucket has no occupied slots, do not perform any lookup and comparison */
        jak_slice_list_lookup(&handle, &bucket->slice_list, key);
        *key_found = !jak_slice_list_is_empty(&bucket->slice_list) && handle.is_contained;
        *value_out = (*key_found) ? handle.value : ((jak_archive_field_sid_t) -1);

        return true;
}

static int
this_get_safe(jak_str_hash *self, jak_archive_field_sid_t **out, bool **found_mask, size_t *num_not_found,
              char *const *keys, size_t num_keys)
{
        JAK_ASSERT(self->tag == JAK_MEMORY_RESIDENT);

        jak_timestamp begin = jak_wallclock();
        JAK_TRACE(SMART_MAP_TAG, "'get_safe' function invoked for %zu strings", num_keys)

        jak_allocator jak_hashtable_alloc;
#if defined(JAK_CONFIG_TRACE_STRING_DIC_ALLOC) && !defined(NDEBUG)
        CHECK_SUCCESS(allocator_TRACE(&jak_hashtable_alloc));
#else
        JAK_CHECK_SUCCESS(jak_alloc_this_or_std(&jak_hashtable_alloc, &self->allocator));
#endif

        struct mem_extra *extra = this_get_exta(self);
        size_t *bucket_idxs = jak_alloc_malloc(&self->allocator, num_keys * sizeof(size_t));
        jak_archive_field_sid_t *values_out = jak_alloc_malloc(&self->allocator,
                                                               num_keys * sizeof(jak_archive_field_sid_t));
        bool *found_mask_out = jak_alloc_malloc(&self->allocator, num_keys * sizeof(bool));

        JAK_ASSERT(bucket_idxs != NULL);
        JAK_ASSERT(values_out != NULL);
        JAK_ASSERT(found_mask_out != NULL);

        for (register size_t i = 0; i < num_keys; i++) {
                const char *key = keys[i];
                hash32_t hash = key && strcmp("", key) != 0 ? JAK_STR_HASH_MEM_HASHCODE_OF(key) : 0;
                bucket_idxs[i] = hash % extra->buckets.cap_elems;
                JAK_PREFETCH_READ((struct bucket *) jak_vector_data(&extra->buckets) + bucket_idxs[i]);
        }

        JAK_TRACE(SMART_MAP_TAG, "'get_safe' function invoke fetch...for %zu strings", num_keys)
        JAK_CHECK_SUCCESS(this_fetch_bulk(&extra->buckets,
                                          values_out,
                                          found_mask_out,
                                          num_not_found,
                                          bucket_idxs,
                                          keys,
                                          num_keys,
                                          &self->allocator,
                                          &self->counters));
        JAK_CHECK_SUCCESS(jak_alloc_free(&self->allocator, bucket_idxs));
        JAK_TRACE(SMART_MAP_TAG, "'get_safe' function invok fetch: done for %zu strings", num_keys)

        JAK_ASSERT(values_out != NULL);
        JAK_ASSERT(found_mask_out != NULL);

        *out = values_out;
        *found_mask = found_mask_out;

        jak_timestamp end = jak_wallclock();
        JAK_UNUSED(begin);
        JAK_UNUSED(end);
        JAK_TRACE(SMART_MAP_TAG, "'get_safe' function done: %f seconds spent here", (end - begin) / 1000.0f)

        return true;
}

static int
this_get_safe_exact(jak_str_hash *self, jak_archive_field_sid_t *out, bool *found_mask, const char *key)
{
        JAK_ASSERT(self->tag == JAK_MEMORY_RESIDENT);

        jak_allocator jak_hashtable_alloc;
#if defined(JAK_CONFIG_TRACE_STRING_DIC_ALLOC) && !defined(NDEBUG)
        CHECK_SUCCESS(allocator_TRACE(&jak_hashtable_alloc));
#else
        JAK_CHECK_SUCCESS(jak_alloc_this_or_std(&jak_hashtable_alloc, &self->allocator));
#endif

        struct mem_extra *extra = this_get_exta(self);

        hash32_t hash = strcmp("", key) != 0 ? JAK_STR_HASH_MEM_HASHCODE_OF(key) : 0;
        size_t bucket_idx = hash % extra->buckets.cap_elems;
        JAK_PREFETCH_READ((struct bucket *) jak_vector_data(&extra->buckets) + bucket_idx);

        JAK_CHECK_SUCCESS(this_fetch_single(&extra->buckets, out, found_mask, bucket_idx, key, &self->counters));

        return true;
}

static int this_get_fast(jak_str_hash *self, jak_archive_field_sid_t **out, char *const *keys, size_t num_keys)
{
        bool *found_mask;
        size_t num_not_found;
        int status = this_get_safe(self, out, &found_mask, &num_not_found, keys, num_keys);
        _jak_str_hash_mem_free(self, found_mask);
        return status;
}

static int this_update_key_fast(jak_str_hash *self, const jak_archive_field_sid_t *values, char *const *keys,
                                size_t num_keys)
{
        JAK_UNUSED(self);
        JAK_UNUSED(values);
        JAK_UNUSED(keys);
        JAK_UNUSED(num_keys);
        JAK_ERROR(&self->err, JAK_ERR_NOTIMPL);
        jak_error_print_to_stderr(&self->err);
        return false;
}

static int simple_map_remove(struct mem_extra *extra, size_t *bucket_idxs, char *const *keys, size_t num_keys,
                             jak_allocator *alloc, jak_str_hash_counters *counter)
{
        JAK_UNUSED(counter);
        JAK_UNUSED(alloc);

        jak_slice_handle handle;
        struct bucket *data = (struct bucket *) jak_vector_data(&extra->buckets);

        for (register size_t i = 0; i < num_keys; i++) {
                struct bucket *bucket = data + bucket_idxs[i];
                const char *key = keys[i];

                /** Optimization 1/5: EMPTY GUARD (but before "find" call); if this bucket has no occupied slots, do not perform any lookup and comparison */
                jak_slice_list_lookup(&handle, &bucket->slice_list, key);
                if (JAK_LIKELY(handle.is_contained)) {
                        jak_slice_list_remove(&bucket->slice_list, &handle);
                }
        }
        return true;
}

static int _jak_str_hash_mem_remove(jak_str_hash *self, char *const *keys, size_t num_keys)
{
        JAK_ASSERT(self->tag == JAK_MEMORY_RESIDENT);

        struct mem_extra *extra = this_get_exta(self);
        size_t *bucket_idxs = jak_alloc_malloc(&self->allocator, num_keys * sizeof(size_t));
        for (register size_t i = 0; i < num_keys; i++) {
                const char *key = keys[i];
                hash32_t hash = JAK_STR_HASH_MEM_HASHCODE_OF(key);
                bucket_idxs[i] = hash % extra->buckets.cap_elems;
        }

        JAK_CHECK_SUCCESS(simple_map_remove(extra, bucket_idxs, keys, num_keys, &self->allocator, &self->counters));
        JAK_CHECK_SUCCESS(jak_alloc_free(&self->allocator, bucket_idxs));
        return true;
}

static int _jak_str_hash_mem_free(jak_str_hash *self, void *ptr)
{
        JAK_ASSERT(self->tag == JAK_MEMORY_RESIDENT);
        JAK_CHECK_SUCCESS(jak_alloc_free(&self->allocator, ptr));
        return true;
}

JAK_FUNC_UNUSED
static int _jak_str_hash_mem_create_extra(jak_str_hash *self, size_t num_buckets, size_t cap_buckets)
{
        if ((self->extra = jak_alloc_malloc(&self->allocator, sizeof(struct mem_extra))) != NULL) {
                struct mem_extra *extra = this_get_exta(self);
                jak_vector_create(&extra->buckets, &self->allocator, sizeof(struct bucket), num_buckets);

                /** Optimization: notify the kernel that the list of buckets are accessed randomly (since hash based access)*/
                jak_vector_memadvice(&extra->buckets, MADV_RANDOM | MADV_WILLNEED);

                struct bucket *data = (struct bucket *) jak_vector_data(&extra->buckets);
                JAK_CHECK_SUCCESS(bucket_create(data, num_buckets, cap_buckets, &self->allocator));
                return true;
        } else {
                JAK_ERROR(&self->err, JAK_ERR_MALLOCERR);
                return false;
        }
}

JAK_FUNC_UNUSED
static struct mem_extra *this_get_exta(jak_str_hash *self)
{
        JAK_ASSERT (self->tag == JAK_MEMORY_RESIDENT);
        return (struct mem_extra *) (self->extra);
}

JAK_FUNC_UNUSED
static int bucket_create(struct bucket *buckets, size_t num_buckets, size_t bucket_cap, jak_allocator *alloc)
{
        JAK_ERROR_IF_NULL(buckets);

        // TODO: parallize this!
        while (num_buckets--) {
                struct bucket *bucket = buckets++;
                jak_slice_list_create(&bucket->slice_list, alloc, bucket_cap);
        }

        return true;
}

static int bucket_drop(struct bucket *buckets, size_t num_buckets, jak_allocator *alloc)
{
        JAK_UNUSED(alloc);
        JAK_ERROR_IF_NULL(buckets);

        while (num_buckets--) {
                struct bucket *bucket = buckets++;
                jak_slice_list_drop(&bucket->slice_list);
        }

        return true;
}

static int bucket_insert(struct bucket *bucket, const char *restrict key, jak_archive_field_sid_t value,
                         jak_allocator *alloc,
                         jak_str_hash_counters *counter)
{
        JAK_UNUSED(counter);
        JAK_UNUSED(alloc);

        JAK_ERROR_IF_NULL(bucket);
        JAK_ERROR_IF_NULL(key);

        jak_slice_handle handle;

        /** Optimization 1/5: EMPTY GUARD (but before "find" call); if this bucket has no occupied slots, do not perform any lookup and comparison */
        jak_slice_list_lookup(&handle, &bucket->slice_list, key);

        if (handle.is_contained) {
                /** entry found by keys */
                JAK_ASSERT(value == handle.value);
                //debug(SMART_MAP_TAG, "debug(SMART_MAP_TAG, \"*** put *** '%s' into bucket [new]\", keys);*** put *** '%s' into bucket [already contained]", keys);
        } else {
                /** no entry found */
                //debug(SMART_MAP_TAG, "*** put *** '%s' into bucket [new]", keys);
                jak_slice_list_insert(&bucket->slice_list, (char **) &key, &value, 1);
        }

        return true;
}

static int this_insert_bulk(jak_vector ofType(bucket) *buckets, char *const *restrict keys,
                            const jak_archive_field_sid_t *restrict values, size_t *restrict bucket_idxs,
                            size_t num_pairs,
                            jak_allocator *alloc,
                            jak_str_hash_counters *counter)
{
        JAK_ERROR_IF_NULL(buckets)
        JAK_ERROR_IF_NULL(keys)
        JAK_ERROR_IF_NULL(values)
        JAK_ERROR_IF_NULL(bucket_idxs)

        struct bucket *buckets_data = (struct bucket *) jak_vector_data(buckets);
        int status = true;
        for (register size_t i = 0; status == true && i < num_pairs; i++) {
                size_t bucket_idx = bucket_idxs[i];
                const char *key = keys[i];
                jak_archive_field_sid_t value = values[i];

                struct bucket *bucket = buckets_data + bucket_idx;
                status = bucket_insert(bucket, key, value, alloc, counter);
        }

        return status;
}

static int
this_insert_exact(jak_vector ofType(bucket) *buckets, const char *restrict key, jak_archive_field_sid_t value,
                  size_t bucket_idx, jak_allocator *alloc, jak_str_hash_counters *counter)
{
        JAK_ERROR_IF_NULL(buckets)
        JAK_ERROR_IF_NULL(key)

        struct bucket *buckets_data = (struct bucket *) jak_vector_data(buckets);
        struct bucket *bucket = buckets_data + bucket_idx;
        return bucket_insert(bucket, key, value, alloc, counter);
}
/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>
#include <jak_string.h>

bool jak_string_create(jak_string *builder)
{
        return jak_string_create_ex(builder, 1024);
}

bool jak_string_create_ex(jak_string *builder, size_t capacity)
{
        JAK_ERROR_IF_NULL(builder)
        JAK_ERROR_IF_NULL(capacity)
        jak_error_init(&builder->err);
        builder->cap = capacity;
        builder->end = 0;
        builder->data = JAK_MALLOC(capacity);
        JAK_ERROR_IF_AND_RETURN(!builder->data, &builder->err, JAK_ERR_MALLOCERR, false);
        JAK_ZERO_MEMORY(builder->data, builder->cap);
        return true;
}

bool jak_string_add(jak_string *builder, const char *str)
{
        JAK_ERROR_IF_NULL(builder)
        JAK_ERROR_IF_NULL(str)
        jak_u64 len = strlen(str);
        return jak_string_add_nchar(builder, str, len);
}

bool jak_string_add_nchar(jak_string *builder, const char *str, jak_u64 strlen)
{
        JAK_ERROR_IF_NULL(builder)
        JAK_ERROR_IF_NULL(str)

        /* resize if needed */
        if (JAK_UNLIKELY(builder->end + strlen >= builder->cap)) {
                size_t new_cap = (builder->end + strlen) * 1.7f;
                builder->data = realloc(builder->data, new_cap);
                JAK_ERROR_IF_AND_RETURN(!builder->data, &builder->err, JAK_ERR_REALLOCERR, false);
                JAK_ZERO_MEMORY(builder->data + builder->cap, (new_cap - builder->cap));
                builder->cap = new_cap;
        }

        /* append string */
        memcpy(builder->data + builder->end, str, strlen);
        builder->end += strlen;

        return true;
}

bool jak_string_add_char(jak_string *builder, char c)
{
        JAK_ERROR_IF_NULL(builder)
        char buffer[2];
        sprintf(buffer, "%c", c);
        return jak_string_add(builder, buffer);
        return true;
}

bool jak_string_add_u8(jak_string *builder, jak_u8 value)
{
        char buffer[21];
        JAK_ZERO_MEMORY(buffer, JAK_ARRAY_LENGTH(buffer));
        sprintf(buffer, "%u", value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_u16(jak_string *builder, jak_u16 value)
{
        char buffer[21];
        sprintf(buffer, "%u", value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_u32(jak_string *builder, jak_u32 value)
{
        char buffer[21];
        sprintf(buffer, "%u", value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_u64(jak_string *builder, jak_u64 value)
{
        char buffer[21];
        sprintf(buffer, "%" PRIu64, value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_i8(jak_string *builder, jak_i8 value)
{
        char buffer[21];
        sprintf(buffer, "%d", value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_i16(jak_string *builder, jak_i16 value)
{
        char buffer[21];
        sprintf(buffer, "%d", value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_i32(jak_string *builder, jak_i32 value)
{
        char buffer[21];
        sprintf(buffer, "%d", value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_i64(jak_string *builder, jak_i64 value)
{
        char buffer[21];
        sprintf(buffer, "%" PRIi64, value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_u64_as_hex(jak_string *builder, jak_u64 value)
{
        char buffer[17];
        sprintf(buffer, "%016"PRIx64, value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_u64_as_hex_0x_prefix_compact(jak_string *builder, jak_u64 value)
{
        char buffer[17];
        sprintf(buffer, "0x%"PRIx64, value);
        return jak_string_add(builder, buffer);
}

bool jak_string_add_float(jak_string *builder, float value)
{
        char buffer[2046];
        sprintf(buffer, "%0.2f", value);
        return jak_string_add(builder, buffer);
}

bool jak_string_clear(jak_string *builder)
{
        JAK_ERROR_IF_NULL(builder)
        JAK_ZERO_MEMORY(builder->data, builder->cap);
        builder->end = 0;
        return true;
}

bool jak_string_ensure_capacity(jak_string *builder, jak_u64 cap)
{
        JAK_ERROR_IF_NULL(builder)
        /* resize if needed */
        if (JAK_UNLIKELY(cap > builder->cap)) {
                size_t new_cap = cap * 1.7f;
                builder->data = realloc(builder->data, new_cap);
                JAK_ERROR_IF_AND_RETURN(!builder->data, &builder->err, JAK_ERR_REALLOCERR, false);
                JAK_ZERO_MEMORY(builder->data + builder->cap, (new_cap - builder->cap));
                builder->cap = new_cap;
        }
        return true;
}

size_t jak_string_len(jak_string *builder)
{
        JAK_ERROR_IF_NULL(builder)
        return builder->end;
}

bool jak_string_drop(jak_string *builder)
{
        JAK_ERROR_IF_NULL(builder)
        free(builder->data);
        return true;
}

bool jak_string_print(jak_string *builder)
{
        return jak_string_fprint(stdout, builder);
}

bool jak_string_fprint(FILE *file, jak_string *builder)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(builder)
        fprintf(file, "%s\n", jak_string_cstr(builder));
        return true;
}

const char *jak_string_cstr(jak_string *builder)
{
        return builder->data;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <ctype.h>
#include <jak_string_utils.h>

bool jak_strings_contains_blank_char(const char *str)
{
        if (JAK_LIKELY(str != NULL)) {
                for (const char *it = str; *it != '\0'; it++) {
                        if (isspace(*it)) {
                                return true;
                        }
                }
                return false;
        } else {
                return false;
        }
}

bool jak_strings_is_enquoted(const char *str)
{
        return jak_strings_is_enquoted_wlen(str, strlen(str));
}

bool jak_strings_is_enquoted_wlen(const char *str, size_t len)
{
        if (*str == '"') {
                if (len > 1) {
                        return str[len - 1] == '"';
                } else {
                        return false;
                }
        } else {
                return false;
        }
}

char *jak_strings_remove_tailing_blanks(char *str_in)
{
        size_t sl = strlen(str_in);
        size_t i = sl > 0 ? sl - 1 : 0;
        while (i) {
                char c = str_in[i];
                if (isblank(c)) {
                        str_in[i] = '\0';
                } else {
                        break;
                }
                i--;
        }
        return str_in;
}

const char *jak_strings_skip_blanks(const char *str)
{
        if (JAK_LIKELY(str != NULL)) {
                const char *ret = str;
                while (*ret != '\0') {
                        char c = *ret;
                        if (JAK_LIKELY(!isblank(c))) {
                                return ret;
                        }
                        ret++;
                }
                return ret;
        } else {
                return NULL;
        }
}/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdlib.h>
#include <jak_string.h>
#include <stdio.h>
#include <signal.h>

#include <jak_thread_pool.h>

static inline void __execute_task();

jak_thread_pool *jak_thread_pool_create(size_t num_threads, int enable_monitoring)
{
        jak_thread_pool *pool = JAK_MALLOC(sizeof(jak_thread_pool));

        pool->name = NULL;
        pool->size = num_threads;
        pool->capacity = num_threads * 2;
        jak_priority_queue_init(&pool->waiting_tasks);

        pool->thread_tasks = calloc(num_threads, sizeof(jak_thread_task *));
        pool->thread_infos = calloc(sizeof(jak_thread_info *) * pool->capacity, 1);
        pool->task_state_capacity = JAK_THREAD_POOL_MAX_TASKS;
        pool->task_group_states = calloc(pool->task_state_capacity, sizeof(jak_task_state));
        pool->enable_monitoring = enable_monitoring;

        pthread_t *threads = JAK_MALLOC(sizeof(pthread_t) * pool->capacity);
        pool->pool = threads;

        if (enable_monitoring) {
                pool->statistics = calloc(1, sizeof(jak_thread_pool_stats));
        }

        for (size_t i = 0; i < pool->capacity; i++) {
                // one block per thread to reduce risk of two threads sharing the same cache line
                jak_thread_info *thread_info = JAK_MALLOC(sizeof(jak_thread_info));
                pool->thread_infos[i] = thread_info;
                thread_info->pool = pool;
                thread_info->id = i;
                thread_info->status = JAK_THREAD_STATUS_EMPTY;
                sprintf(thread_info->name, "worker-%zu", i); // "worker%I64d" lead to segfault on linux

                if (enable_monitoring) {
                        thread_info->statistics = calloc(1, sizeof(jak_thread_stats));
                }

        }
        for (size_t i = 0; i < num_threads; ++i) {
                __jak_create_thread(pool->thread_infos[i], &pool->pool[i]);
        }

        return pool;
}

jak_thread_pool *jak_thread_pool_create_named(size_t num_threads, const char *name, int enable_monitoring)
{
        jak_thread_pool *pool = jak_thread_pool_create(num_threads, enable_monitoring);

        if (name) {
                jak_thread_pool_set_name(pool, name);
        }

        return pool;
}

void jak_thread_pool_free(jak_thread_pool *pool)
{
        // Update all status
        for (size_t i = 0; i < pool->size; ++i) {
                pool->thread_infos[i]->status = JAK_THREAD_STATUS_WILL_TERMINATE;
        }
        // wait for threads to finish
        for (size_t i = 0; i < pool->size; ++i) {
                pthread_join(pool->pool[i], NULL);
                if (pool->enable_monitoring) {
                        free(pool->thread_infos[i]->statistics);
                }

                free(pool->thread_infos[i]);
        }
        for (size_t i = pool->size; i < pool->capacity; ++i) {
                if (pool->enable_monitoring) {
                        free(pool->thread_infos[i]->statistics);
                }

                free(pool->thread_infos[i]);
        }

        jak_priority_queue_free(&pool->waiting_tasks);
        free(pool->pool);
        free(pool->thread_tasks);
        free(pool->thread_infos);
        free(pool->task_group_states);
        if (pool->name) {
                free(pool->name);
        }
        if (pool->enable_monitoring) {
                free(pool->statistics);
        }
        free(pool);
}

void jak_thread_pool_set_name(jak_thread_pool *pool, const char *name)
{
        if (pool->name) {
                free(pool->name);
        }

        size_t s = strlen(name);
        char *str = JAK_MALLOC(s + 1);
        strcpy(str, name);
        pool->name = str;
}

bool jak_thread_pool_resize(jak_thread_pool *pool, size_t num_threads)
{
        if (num_threads > pool->size) {
                if (num_threads > pool->capacity) {
                        return false;
                }

                for (size_t i = pool->size; i < num_threads; ++i) {
                        //try to revive thread
                        int will_terminate = JAK_THREAD_STATUS_WILL_TERMINATE;
                        if (atomic_compare_exchange_strong(&pool->thread_infos[i]->status,
                                                           &will_terminate,
                                                           JAK_THREAD_STATUS_IDLE)) {}
                        else {
                                // create a new
                                if (pool->enable_monitoring && !pool->thread_infos[i]->statistics) {
                                        pool->thread_infos[i]->statistics = calloc(1, sizeof(jak_thread_stats));
                                }
                                __jak_create_thread(pool->thread_infos[i], &pool->pool[i]);
                        }
                }
        } else if (num_threads < pool->size) {
                for (size_t i = num_threads; i < pool->size; ++i) {
                        // mark threads for termination
                        pool->thread_infos[i]->status = JAK_THREAD_STATUS_WILL_TERMINATE;
                }
        }

        pool->size = num_threads;

        return true;
}

bool jak_thread_pool_enqueue_tasks(jak_thread_task *tasks, jak_thread_pool *pool, size_t num_tasks,
                               jak_task_handle *hndl)
{
        // find JAK_UNUSED slot
        size_t ind = 0;

        for (; pool->task_group_states[ind].task_count; ind = (ind + 8) % JAK_THREAD_POOL_MAX_TASKS) {}

        // increment generation first to always be identifiable as finished
        ++pool->task_group_states[ind].generation;
        pool->task_group_states[ind].task_count = num_tasks;

        for (size_t i = 0; i < num_tasks; i++) {

                if (pool->enable_monitoring) {
                        //tasks[i].statistics = calloc(1, sizeof(task_stats));
                        clock_gettime(CLOCK_MONOTONIC, &tasks[i].statistics.enqueue_time);
                        pool->statistics->task_enqueued_count++;
                }

                tasks[i].group_id = ind;
                jak_priority_queue_push(&pool->waiting_tasks, &tasks[i], tasks[i].priority);
        }

        if (hndl) {
                hndl->index = ind;
                hndl->generation = pool->task_group_states[ind].generation;
        }

        return true;
}

bool jak_thread_pool_enqueue_task(jak_thread_task *task, jak_thread_pool *pool, jak_task_handle *hndl)
{
        return jak_thread_pool_enqueue_tasks(task, pool, 1, hndl);
}

bool jak_thread_pool_enqueue_tasks_wait(jak_thread_task *tasks, jak_thread_pool *pool, size_t num_tasks)
{
        // Pass all tasks except the last one to the queue
        jak_task_handle hndl;
        jak_thread_pool_enqueue_tasks(tasks, pool, num_tasks - 1, &hndl);

        // Execute the last tasks in the calling thread
        jak_thread_task *main_task = &tasks[num_tasks - 1];

        if (pool->enable_monitoring) {
                pool->statistics->task_enqueued_count++;
                //main_task->statistics = calloc(1, sizeof(task_stats));

                // No waiting if the calling thread executes the task
                clock_gettime(CLOCK_MONOTONIC, &main_task->statistics.enqueue_time);
                main_task->statistics.execution_time = main_task->statistics.enqueue_time;

                (*main_task->routine)(main_task->args);
                clock_gettime(CLOCK_MONOTONIC, &main_task->statistics.complete_time);
                pool->statistics->task_complete_count++;
        } else {
                (*main_task->routine)(main_task->args);
        }

        return jak_thread_pool_wait_for_task(pool, &hndl);
}

bool jak_thread_pool_wait_for_task(jak_thread_pool *pool, jak_task_handle *hndl)
{
        volatile unsigned *gen = &pool->task_group_states[hndl->index].generation;
        while (*gen == hndl->generation && pool->task_group_states[hndl->index].task_count) {}
        return true;
}

bool jak_thread_pool_wait_for_all(jak_thread_pool *pool)
{
        jak_thread_task *next_task;
        while ((next_task = __jak_get_next_task(pool))) {

                if (pool->enable_monitoring) {
                        clock_gettime(CLOCK_MONOTONIC, &next_task->statistics.execution_time);
                        __execute_task(pool, next_task);
                        clock_gettime(CLOCK_MONOTONIC, &next_task->statistics.complete_time);
                        pool->statistics->task_complete_count++;

                        // Just add the time, calculate the average at evaluation time
                        pool->statistics->wait_time += __jak_get_time_diff(&next_task->statistics.enqueue_time,
                                                                       &next_task->statistics.execution_time);
                        pool->statistics->complete_time += __jak_get_time_diff(&next_task->statistics.execution_time,
                                                                           &next_task->statistics.complete_time);
                } else {
                        __execute_task(pool, next_task);
                }

        }
        for (;;) {
                size_t sum = 0;
                for (size_t i = 0; i < pool->task_state_capacity; ++i) {
                        sum += pool->task_group_states[i].task_count;
                }
                if (!sum) { return true; }
        }
        return false;
}

void *__jak_thread_main(void *args)
{
        jak_thread_info *thread_info = (jak_thread_info *) args;

        // Fill statistics if available
        struct timespec begin;
        if (thread_info->pool->enable_monitoring) {
                clock_gettime(CLOCK_MONOTONIC, &thread_info->statistics->creation_time);
                begin = thread_info->statistics->creation_time;
        }

        while (1) {
                jak_thread_task *next_task = __jak_get_next_task(thread_info->pool);
                // the task has to be executed since it has been taken out of the queue
                if (next_task) {

                        // Fill statistics if available
                        if (thread_info->pool->enable_monitoring) {
                                // measure time outside to prevent incorrect times while in execution
                                struct timespec end;
                                clock_gettime(CLOCK_MONOTONIC, &end);
                                next_task->statistics.execution_time = end;
                                thread_info->statistics->idle_time += __jak_get_time_diff(&begin, &end);

                                __execute_task(thread_info->pool, next_task);
                                clock_gettime(CLOCK_MONOTONIC, &begin);
                                next_task->statistics.complete_time = begin;
                                thread_info->statistics->task_count++;
                                thread_info->pool->statistics->task_complete_count++;

                                // Just add the time, calculate the average at evaluation time
                                thread_info->pool->statistics->wait_time +=
                                        __jak_get_time_diff(&next_task->statistics.enqueue_time,
                                                        &next_task->statistics.execution_time);
                                thread_info->pool->statistics->complete_time +=
                                        __jak_get_time_diff(&next_task->statistics.execution_time,
                                                        &next_task->statistics.complete_time);

                        } else {
                                __execute_task(thread_info->pool, next_task);
                        }

                }

                // Check if this thread has to terminate, set the status and leave the loop
                int will_terminate = JAK_THREAD_STATUS_WILL_TERMINATE;
                if (atomic_compare_exchange_strong(&thread_info->status, &will_terminate, JAK_THREAD_STATUS_KILLED)) {
                        break;
                }


//    if(!next_task)
//      nanosleep(&waiting_time_start, &waiting_time_end);
        }

        thread_info->status = JAK_THREAD_STATUS_FINISHED;

        // Be sure to free the passed thread_information since no other reference exists
        // free(thread_info);

        return (void *) 0;
}

jak_thread_task *__jak_get_next_task(jak_thread_pool *pool)
{
        jak_thread_task *next_task = jak_priority_queue_pop(&pool->waiting_tasks);
        return next_task;
}

bool __jak_create_thread(jak_thread_info *thread_info, pthread_t *pp)
{
        thread_info->status = JAK_THREAD_STATUS_CREATED;
        pthread_create(pp, NULL, &__jak_thread_main, thread_info);

        return true;
}

void *faulty;

size_t num;

void __execute_task(jak_thread_pool *pool, jak_thread_task *task)
{
        faulty = task->routine;
        num++;
        (*task->routine)(task->args);
        --pool->task_group_states[task->group_id].task_count;
}

void __jak_sig_seg(int sig)
{
        if (sig != SIGSEGV) {
                return;
        } else {
                printf("%p \n", faulty);
                printf("occured after: %li", num);
                exit(1);
        }
}/**
 * Copyright 2019 Marcus Pinnecke, Robert Jendersie, Johannes Wuensche, Johann Wagner, and Marten Wallewein-Eising
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without ion, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <stdio.h>

#include <jak_stdinc.h>
#include <jak_thread_pool.h>

jak_thread_pool_stats jak_thread_pool_get_stats(jak_thread_pool *pool)
{
        // In case no tasks care completed, no averages can be calculated
        if (pool->statistics->task_complete_count) {
                pool->statistics->avg_complete_time =
                        pool->statistics->complete_time / pool->statistics->task_complete_count;
                pool->statistics->avg_wait_time = pool->statistics->wait_time / pool->statistics->task_complete_count;
        }
        return *pool->statistics;
}

jak_thread_stats jak_thread_pool_get_thread_stats(jak_thread_pool *pool, size_t id)
{
        jak_thread_stats *thread_stats = pool->thread_infos[id]->statistics;

        // busy_time = running_time - idle_time
        struct timespec current;
        clock_gettime(CLOCK_MONOTONIC, &current);
        thread_stats->busy_time = __jak_get_time_diff(&thread_stats->creation_time, &current) - thread_stats->idle_time;
        return *thread_stats;
}

double jak_thread_pool_get_time_working(jak_thread_pool *pool)
{
        struct timespec end;

        clock_gettime(CLOCK_MONOTONIC, &end);
        double avg = 0.f;
        for (size_t i = 0; i < pool->size; ++i) {
                struct timespec begin = pool->thread_infos[i]->statistics->creation_time;
                double t = __jak_get_time_diff(&begin, &end);
                avg += t / (t + pool->thread_infos[i]->statistics->idle_time);
        }
        return avg / pool->size;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <math.h>

#include <jak_time.h>

jak_timestamp jak_wallclock()
{
        long ms;
        time_t s;
        struct timespec spec;
        clock_gettime(CLOCK_REALTIME, &spec);
        s = spec.tv_sec;
        ms = round(spec.tv_nsec / 1.0e6);
        return s * 1000 + ((ms > 999) ? 1000 : ms);
}/**
 * A variable-length unsigned integer type that encodes the number of used bytes by a preceding marker byte
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_uintvar_marker.h>

bool uintvar_marker_write(jak_uintvar_marker_t dst, jak_u64 value);

jak_u64 uintvar_marker_read(jak_u8 *nbytes_read, jak_uintvar_marker_t src);

jak_uintvar_marker_e uintvar_marker_type_for(jak_u64 value);

bool uintvar_marker_type(const void *data);

size_t uintvar_marker_sizeof(jak_uintvar_marker_t value);

size_t uintvar_marker_required_size(jak_u64 value);/**
 * A variable-length unsigned integer type (varuint)
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_uintvar_stream.h>

#define MASK_LAST_BYTE                  (0 | ((char) ~0u))
#define MASK_FORWARD_BIT                ((char) (1u << 7))
#define MASK_BLOCK_DATA                 (~MASK_FORWARD_BIT)

#define extract_data(x, byte_shift)     (MASK_BLOCK_DATA & (MASK_LAST_BYTE & (x >> byte_shift)))

jak_u8 jak_uintvar_stream_write(jak_uintvar_stream_t dst, jak_u64 value)
{
        if (JAK_LIKELY(dst != NULL)) {
                jak_u8 num_bytes = 0;
                for (jak_i8 i = 9; i > 0; i--) {
                        char block_data = extract_data(value, i * 7);
                        if (block_data || num_bytes) {
                                *(char *) dst = MASK_FORWARD_BIT | block_data;
                                num_bytes = num_bytes ? num_bytes : i + 1;
                                dst++;
                        }
                }
                *(char *) dst = extract_data(value, 0);
                return num_bytes ? num_bytes : 1;
        } else {
                return 0;
        }
}

jak_u64 jak_uintvar_stream_read(jak_u8 *nbytes, jak_uintvar_stream_t src)
{
        jak_u64 value = 0;
        bool has_next = true;
        jak_u8 ndecoded = 0;

        for (char it = *(char *) src, block_val = 0; has_next; has_next = (it & MASK_FORWARD_BIT) == MASK_FORWARD_BIT,
                block_val = it & MASK_BLOCK_DATA, value = (value << 7) | block_val, src++,
                ndecoded++, it = *(char *) src) {}


        JAK_OPTIONAL_SET(nbytes, ndecoded);
        return value;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_unique_id.h>
#include <jak_time.h>
#include <jak_error.h>
#include <jak_hash.h>

_Thread_local bool thread_local_init;

_Thread_local jak_u64 thread_local_id;

_Thread_local jak_u8 thread_local_magic;

_Thread_local jak_u32 thread_local_counter;

_Thread_local jak_u32 thread_local_counter_limit;

/**
 * Below is the best effort to create a world-unique, fast and scalable to compute identifier.
 *
 * An 64bit global identifier is constructed using process-local, thread-local and
 * call-local state-dependent and state-independent components. Additionally, a global time
 * component is added to minimize the risk of producing two equal identifier across multiple
 * machines.
 */
union global_id {
        struct {
                /* global */
                jak_u64 global_wallclock
                        : 5;   /* increasing wall clock time (ms) */
                jak_u64 global_build_date
                        : 1;   /* fix bit dependent on compilation time */
                jak_u64 global_build_path
                        : 1;   /* fix bit dependent on compilation path */

                /* per-process */
                jak_u64 process_id
                        : 7;   /* fix id */
                jak_u64 process_magic
                        : 2;   /* random fix value */
                jak_u64 process_counter
                        : 8;   /* increasing counter */

                /* per-thread  */
                jak_u64 thread_id
                        : 7;   /* fix id */
                jak_u64 thread_magic
                        : 2;   /* random fix value */
                jak_u64 thread_counter
                        : 29;  /* increasing counter (< 536mio ids per thread) */

                /* per-call */
                jak_u64 call_random
                        :  2;  /* random value */
        };

        jak_u64 value;
};

bool jak_unique_id_create(jak_uid_t *out)
{
        JAK_ASSERT(out);

        static bool process_init;
        static jak_u64 process_local_id;
        static jak_u8 process_magic;
        static jak_u64 process_counter;

        static jak_u8 global_build_date_bit;
        static jak_u8 global_build_path_bit;

        if (!process_init) {
                srand(time(NULL));
                process_magic = rand();
                process_init = true;
                process_counter = rand();

                const char *file = __FILE__;
                const char *time = __TIME__;

                global_build_path_bit = JAK_HASH_BERNSTEIN(strlen(file), file) % 2;
                global_build_date_bit = JAK_HASH_BERNSTEIN(strlen(time), time) % 2;
        }

        if (!thread_local_init) {
                thread_local_counter = rand();
                thread_local_counter_limit = thread_local_counter++;
                thread_local_id = (jak_u64) pthread_self();
                process_local_id = getpid();
                thread_local_magic = rand();
                thread_local_init = true;
        }

        bool capacity_left = (thread_local_counter != thread_local_counter_limit);
        JAK_ERROR_PRINT_IF(!capacity_left, JAK_ERR_THREADOOOBJIDS)
        if (JAK_LIKELY(capacity_left)) {
                union global_id internal =
                        {.global_wallclock  = jak_wallclock(),
                                .global_build_date = global_build_date_bit,
                                .global_build_path = global_build_path_bit,
                                .process_id        = process_local_id,
                                .process_magic     = process_magic,
                                .process_counter   = process_counter++,
                                .thread_id         = (jak_u64) thread_local_id,
                                .thread_magic      = thread_local_magic,
                                .thread_counter    = thread_local_counter++,
                                .call_random       = rand()};
                *out = internal.value;
        } else {
                *out = 0;
        }
        return capacity_left;
}

bool jak_unique_id_get_global_wallclocktime(uint_fast8_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->global_wallclock;
        return true;
}

bool jak_unique_id_get_global_build_path_bit(uint_fast8_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->global_build_path;
        return true;
}

bool jak_unique_id_get_global_build_time_bit(uint_fast8_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->global_build_date;
        return true;
}

bool jak_unique_id_get_process_id(uint_fast8_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->process_id;
        return true;
}

bool jak_unique_id_get_process_magic(uint_fast8_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->process_magic;
        return true;
}

bool jak_unique_id_get_process_counter(uint_fast16_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->process_counter;
        return true;
}

bool jak_unique_id_get_thread_id(uint_fast8_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->thread_id;
        return true;
}

bool jak_unique_id_get_thread_magic(uint_fast8_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->thread_magic;
        return true;
}

bool jak_unique_id_get_thread_counter(uint_fast32_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->thread_counter;
        return true;
}

bool jak_unique_id_get_call_random(uint_fast8_t *out, jak_uid_t id)
{
        JAK_ERROR_IF_NULL(out);
        *out = ((union global_id *) &id)->call_random;
        return true;
}


/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>

#include <jak_utils_convert.h>

jak_i64 jak_convert_atoi64(const char *string)
{
        jak_i64 number;
        char character;
        int status = sscanf(string, "%" SCNd64 "%c", &number, &character);
        if (status == 1) {
                return number;
        } else if (status > 1) {
                return number;
        } else {
                return 0;
        }
}

jak_u64 jak_convert_atoiu64(const char *string)
{
        jak_u64 number;
        char character;
        int status = sscanf(string, "%" SCNu64 "%c", &number, &character);
        if (status == 1) {
                return number;
        } else if (status > 1) {
                return number;
        } else {
                return 0;
        }
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <ctype.h>
#include <jak_utils_hexdump.h>

bool jak_hexdump(jak_string *dst, const void *base, jak_u64 nbytes)
{
        JAK_ERROR_IF_NULL(dst);
        JAK_ERROR_IF_NULL(base);
        char buffer[11];

        sprintf(buffer, "%08x  ", 0);
        jak_string_add(dst, buffer);

        for (jak_u64 hex_block_id = 0; hex_block_id < nbytes;) {

                jak_u8 step = JAK_MIN(16, nbytes - hex_block_id);

                for (jak_u64 i = 0; i < step; i++) {
                        char c = *((const char *) (base + hex_block_id + i));
                        sprintf(buffer, "%02x ", (unsigned char) c);
                        jak_string_add(dst, buffer);
                        if (i == 7) {
                                jak_string_add_char(dst, ' ');
                        }
                }

                if (JAK_UNLIKELY(step == 7)) {
                        jak_string_add_char(dst, ' ');
                }

                if (JAK_UNLIKELY(step < 16)) {
                        for (jak_u8 pad = 0; pad < 16 - step; pad++) {
                                sprintf(buffer, "   ");
                                jak_string_add(dst, buffer);
                        }
                }

                jak_string_add(dst, " | ");

                for (jak_u64 i = 0; i < step; i++) {
                        char c = *((const char *) (base + hex_block_id + i));
                        if (isgraph(c)) {
                                sprintf(buffer, "%c", c);
                        } else {
                                sprintf(buffer, ".");
                        }

                        jak_string_add(dst, buffer);
                }

                if (JAK_UNLIKELY(step < 16)) {
                        for (jak_u8 pad = 0; pad < 16 - step; pad++) {
                                sprintf(buffer, " ");
                                jak_string_add(dst, buffer);
                        }
                }

                jak_string_add_char(dst, '|');


                if (JAK_LIKELY(hex_block_id + step < nbytes)) {
                        jak_string_add(dst, "\n");
                        sprintf(buffer, "%08x  ", ((jak_u32) hex_block_id + 16));
                        jak_string_add(dst, buffer);
                }


                hex_block_id += step;
        }

        jak_string_add(dst, "\n");

        return true;
}

bool jak_hexdump_print(FILE *file, const void *base, jak_u64 nbytes)
{
        bool status;
        jak_string sb;
        jak_string_create(&sb);
        if ((status = jak_hexdump(&sb, base, nbytes))) {
                fprintf(file, "%s", jak_string_cstr(&sb));
        }
        jak_string_drop(&sb);
        return status;

}/**
 * Copyright 2019 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_utils_numbers.h>

jak_number_min_type_e jak_number_min_type_unsigned(jak_u64 value)
{
        if (value <= JAK_CARBON_U8_MAX) {
                return JAK_NUMBER_U8;
        } else if (value <= JAK_CARBON_U16_MAX) {
                return JAK_NUMBER_U16;
        } else if (value <= JAK_CARBON_U32_MAX) {
                return JAK_NUMBER_U32;
        } else if (value <= JAK_CARBON_U64_MAX) {
                return JAK_NUMBER_U64;
        } else {
                return JAK_NUMBER_UNKNOWN;
        }
}

jak_number_min_type_e jak_number_min_type_signed(jak_i64 value)
{
        if (value >= JAK_CARBON_I8_MIN && value <= JAK_CARBON_I8_MAX) {
                return JAK_NUMBER_I8;
        } else if (value >= JAK_CARBON_I16_MIN && value <= JAK_CARBON_I16_MAX) {
                return JAK_NUMBER_I16;
        } else if (value >= JAK_CARBON_I32_MIN && value <= JAK_CARBON_I32_MAX) {
                return JAK_NUMBER_I32;
        } else if (value >= JAK_CARBON_I64_MIN && value <= JAK_CARBON_I64_MAX) {
                return JAK_NUMBER_I64;
        } else {
                return JAK_NUMBER_UNKNOWN;
        }
}

/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <jak_utils_sort.h>

bool jak_sort_qsort_indicies(size_t *indices, const void *base, size_t width, jak_less_eq_func_t comp,
                         size_t nelemns, jak_allocator *alloc)
{
        JAK_ERROR_IF_NULL(base);
        JAK_ERROR_IF_NULL(alloc);

        if (nelemns <= 1) {
                return true;
        }

        jak_i64 h = nelemns - 1;
        jak_i64 *stack = (jak_i64 *) jak_alloc_malloc(alloc, (h + 1) * sizeof(jak_i64));
        jak_i64 top = -1;
        jak_i64 l = 0;

        stack[++top] = l;
        stack[++top] = h;

        while (top >= 0) {
                h = stack[top--];
                l = stack[top--];

                jak_i64 p = JAK_QSORT_INDICIES_PARTITION(indices, base, width, comp, l, h);

                if (p - 1 > l) {
                        stack[++top] = l;
                        stack[++top] = p - 1;
                }

                if (p + 1 < h) {
                        stack[++top] = p + 1;
                        stack[++top] = h;
                }
        }

        JAK_CHECK_SUCCESS(jak_alloc_free(alloc, stack));
        return true;
}

int jak_sort_qsort_indicies_wargs(size_t *indices, const void *base, size_t width, jak_less_eq_wargs_func_t comp,
                              size_t nelemens, jak_allocator *alloc, void *args)
{
        JAK_ERROR_IF_NULL(base);
        JAK_ERROR_IF_NULL(alloc);

        if (nelemens <= 1) {
                return true;
        }

        jak_i64 h = nelemens - 1;
        jak_i64 *stack = jak_alloc_malloc(alloc, (h + 1) * sizeof(jak_i64));
        JAK_ASSERT (stack);

        jak_i64 top = -1;
        jak_i64 l = 0;

        stack[++top] = l;
        stack[++top] = h;

        while (top >= 0) {
                h = stack[top--];
                l = stack[top--];

                jak_i64 p = JAK_QSORT_INDICIES_PARTITION_WARGS(indices, base, width, comp, l, h, args);

                if (p - 1 > l) {
                        stack[++top] = l;
                        stack[++top] = p - 1;
                }

                if (p + 1 < h) {
                        stack[++top] = p + 1;
                        stack[++top] = h;
                }
        }

        JAK_CHECK_SUCCESS(jak_alloc_free(alloc, stack));
        return true;
}

size_t jak_sort_bsearch_indicies(const size_t *indicies, const void *base, size_t width, size_t nelemens,
                             const void *neelde, jak_eq_func_t compEq, jak_less_func_t compLess)
{
        size_t l = 0;
        size_t r = nelemens - 1;
        while (l <= r && r < SIZE_MAX) {
                size_t m = l + (r - l) / 2;

                // Check if x is present at mid
                if (compEq(base + indicies[m] * width, neelde)) {
                        return m;
                }

                // If x greater, ignore left half
                if (compLess(base + indicies[m] * width, neelde)) {
                        l = m + 1;

                        // If x is smaller, ignore right half
                } else {
                        r = m - 1;
                }
        }

        // if we reach here, then element was
        // not present
        return nelemens;
}

size_t jak_sort_get_min(const size_t *elements, size_t nelemens)
{
        size_t min = (size_t) -1;
        while (nelemens--) {
                min = min < *elements ? min : *elements;
                elements++;
        }
        return min;
}

size_t jak_sort_get_max(const size_t *elements, size_t nelemens)
{
        size_t max = 0;
        while (nelemens--) {
                max = max > *elements ? max : *elements;
                elements++;
        }
        return max;
}

double jak_sort_get_sum(const size_t *elements, size_t nelemens)
{
        double sum = 0;
        while (nelemens--) {
                sum += *elements;
                elements++;
        }
        return sum;
}

double jak_sort_get_avg(const size_t *elements, size_t nelemens)
{
        return jak_sort_get_sum(elements, nelemens) / (double) nelemens;
}/**
 * Copyright 2018 Marcus Pinnecke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <inttypes.h>
#include <sys/mman.h>

#include <jak_memfile.h>
#include <jak_vector.h>

#define DEFINE_PRINTER_FUNCTION_WCAST(type, castType, format_string)                                                   \
void jak_vector_##type##_printer_func(jak_memfile *dst, void ofType(T) *values, size_t num_elems)                      \
{                                                                                                                      \
    char *data;                                                                                                        \
    type *typedValues = (type *) values;                                                                               \
                                                                                                                       \
    data = jak_memfile_current_pos(dst, sizeof(char));                                                              \
    int nchars = sprintf(data, "[");                                                                                   \
    jak_memfile_skip(dst, nchars);                                                                                  \
    for (size_t i = 0; i < num_elems; i++) {                                                                           \
        data = jak_memfile_current_pos(dst, sizeof(type));                                                          \
        nchars = sprintf(data, format_string"%s", (castType) typedValues[i], i + 1 < num_elems ? ", " : "");           \
        jak_memfile_skip(dst, nchars);                                                                              \
    }                                                                                                                  \
    data = jak_memfile_current_pos(dst, sizeof(char));                                                              \
    nchars = sprintf(data, "]");                                                                                       \
    jak_memfile_skip(dst, nchars);                                                                                  \
}

#define DEFINE_PRINTER_FUNCTION(type, format_string)                                                                   \
    DEFINE_PRINTER_FUNCTION_WCAST(type, type, format_string)

DEFINE_PRINTER_FUNCTION_WCAST(u_char, jak_i8, "%d")

DEFINE_PRINTER_FUNCTION(jak_i8, "%d")

DEFINE_PRINTER_FUNCTION(jak_i16, "%d")

DEFINE_PRINTER_FUNCTION(jak_i32, "%d")

DEFINE_PRINTER_FUNCTION(jak_i64, "%"
        PRIi64)

DEFINE_PRINTER_FUNCTION(jak_u8, "%d")

DEFINE_PRINTER_FUNCTION(jak_u16, "%d")

DEFINE_PRINTER_FUNCTION(jak_u32, "%d")

DEFINE_PRINTER_FUNCTION(jak_u64, "%"
        PRIu64)

DEFINE_PRINTER_FUNCTION(size_t, "%zu")

bool jak_vector_create(jak_vector *out, const jak_allocator *alloc, size_t elem_size, size_t cap_elems)
{
        JAK_ERROR_IF_NULL(out)
        out->allocator = JAK_MALLOC(sizeof(jak_allocator));
        jak_alloc_this_or_std(out->allocator, alloc);
        out->base = jak_alloc_malloc(out->allocator, cap_elems * elem_size);
        out->num_elems = 0;
        out->cap_elems = cap_elems;
        out->elem_size = elem_size;
        out->grow_factor = 1.7f;
        jak_error_init(&out->err);
        return true;
}

typedef struct jak_vector_serialize_header {
        char marker;
        jak_u32 elem_size;
        jak_u32 num_elems;
        jak_u32 cap_elems;
        float grow_factor;
} jak_vector_serialize_header;

bool jak_vector_serialize(FILE *file, jak_vector *vec)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(vec)

        jak_vector_serialize_header header =
                {.marker = JAK_MARKER_SYMBOL_VECTOR_HEADER, .elem_size = vec->elem_size, .num_elems = vec
                        ->num_elems, .cap_elems = vec->cap_elems, .grow_factor = vec->grow_factor};
        int nwrite = fwrite(&header, sizeof(jak_vector_serialize_header), 1, file);
        JAK_ERROR_IF(nwrite != 1, &vec->err, JAK_ERR_FWRITE_FAILED);
        nwrite = fwrite(vec->base, vec->elem_size, vec->num_elems, file);
        JAK_ERROR_IF(nwrite != (int) vec->num_elems, &vec->err, JAK_ERR_FWRITE_FAILED);

        return true;
}

bool jak_vector_deserialize(jak_vector *vec, jak_error *err, FILE *file)
{
        JAK_ERROR_IF_NULL(file)
        JAK_ERROR_IF_NULL(err)
        JAK_ERROR_IF_NULL(vec)

        jak_offset_t start = ftell(file);
        int err_code = JAK_ERR_NOERR;

        jak_vector_serialize_header header;
        if (fread(&header, sizeof(jak_vector_serialize_header), 1, file) != 1) {
                err_code = JAK_ERR_FREAD_FAILED;
                goto error_handling;
        }

        if (header.marker != JAK_MARKER_SYMBOL_VECTOR_HEADER) {
                err_code = JAK_ERR_CORRUPTED;
                goto error_handling;
        }

        vec->allocator = JAK_MALLOC(sizeof(jak_allocator));
        jak_alloc_this_or_std(vec->allocator, NULL);
        vec->base = jak_alloc_malloc(vec->allocator, header.cap_elems * header.elem_size);
        vec->num_elems = header.num_elems;
        vec->cap_elems = header.cap_elems;
        vec->elem_size = header.elem_size;
        vec->grow_factor = header.grow_factor;
        jak_error_init(&vec->err);

        if (fread(vec->base, header.elem_size, vec->num_elems, file) != vec->num_elems) {
                err_code = JAK_ERR_FREAD_FAILED;
                goto error_handling;
        }

        return true;

        error_handling:
        fseek(file, start, SEEK_SET);
        JAK_ERROR(err, err_code);
        return false;
}

bool jak_vector_memadvice(jak_vector *vec, int madviseAdvice)
{
        JAK_ERROR_IF_NULL(vec);
        JAK_UNUSED(vec);
        JAK_UNUSED(madviseAdvice);
        madvise(vec->base, vec->cap_elems * vec->elem_size, madviseAdvice);
        return true;
}

bool jak_vector_set_grow_factor(jak_vector *vec, float factor)
{
        JAK_ERROR_IF_NULL(vec);
        JAK_ERROR_PRINT_IF(factor <= 1.01f, JAK_ERR_ILLEGALARG)
        vec->grow_factor = factor;
        return true;
}

bool jak_vector_drop(jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec)
        jak_alloc_free(vec->allocator, vec->base);
        free(vec->allocator);
        vec->base = NULL;
        return true;
}

bool jak_vector_is_empty(const jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec)
        return vec->num_elems == 0 ? true : false;
}

bool jak_vector_push(jak_vector *vec, const void *data, size_t num_elems)
{
        JAK_ERROR_IF_NULL(vec && data)
        size_t next_num = vec->num_elems + num_elems;
        while (next_num > vec->cap_elems) {
                size_t more = next_num - vec->cap_elems;
                vec->cap_elems = (vec->cap_elems + more) * vec->grow_factor;
                vec->base = jak_alloc_realloc(vec->allocator, vec->base, vec->cap_elems * vec->elem_size);
        }
        memcpy(vec->base + vec->num_elems * vec->elem_size, data, num_elems * vec->elem_size);
        vec->num_elems += num_elems;
        return true;
}

const void *jak_vector_peek(jak_vector *vec)
{
        if (!vec) {
                return NULL;
        } else {
                return (vec->num_elems > 0) ? jak_vector_at(vec, vec->num_elems - 1) : NULL;
        }
}

bool jak_vector_repeated_push(jak_vector *vec, const void *data, size_t how_often)
{
        JAK_ERROR_IF_NULL(vec && data)
        size_t next_num = vec->num_elems + how_often;
        while (next_num > vec->cap_elems) {
                size_t more = next_num - vec->cap_elems;
                vec->cap_elems = (vec->cap_elems + more) * vec->grow_factor;
                vec->base = jak_alloc_realloc(vec->allocator, vec->base, vec->cap_elems * vec->elem_size);
        }
        for (size_t i = 0; i < how_often; i++) {
                memcpy(vec->base + (vec->num_elems + i) * vec->elem_size, data, vec->elem_size);
        }

        vec->num_elems += how_often;
        return true;
}

const void *jak_vector_pop(jak_vector *vec)
{
        void *result;
        if (JAK_LIKELY((result = (vec ? (vec->num_elems > 0 ? vec->base + (vec->num_elems - 1) * vec->elem_size : NULL)
                                      : NULL)) != NULL)) {
                vec->num_elems--;
        }
        return result;
}

bool jak_vector_clear(jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec)
        vec->num_elems = 0;
        return true;
}

bool jak_vector_shrink(jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec);
        if (vec->num_elems < vec->cap_elems) {
                vec->cap_elems = JAK_MAX(1, vec->num_elems);
                vec->base = jak_alloc_realloc(vec->allocator, vec->base, vec->cap_elems * vec->elem_size);
        }
        return true;
}

bool jak_vector_grow(size_t *numNewSlots, jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec)
        size_t freeSlotsBefore = vec->cap_elems - vec->num_elems;

        vec->cap_elems = (vec->cap_elems * vec->grow_factor) + 1;
        vec->base = jak_alloc_realloc(vec->allocator, vec->base, vec->cap_elems * vec->elem_size);
        size_t freeSlotsAfter = vec->cap_elems - vec->num_elems;
        if (JAK_LIKELY(numNewSlots != NULL)) {
                *numNewSlots = freeSlotsAfter - freeSlotsBefore;
        }
        return true;
}

bool jak_vector_grow_to(jak_vector *vec, size_t capacity)
{
        JAK_ERROR_IF_NULL(vec);
        vec->cap_elems = JAK_MAX(vec->cap_elems, capacity);
        vec->base = jak_alloc_realloc(vec->allocator, vec->base, vec->cap_elems * vec->elem_size);
        return true;
}

size_t jak_vector_length(const jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec)
        return vec->num_elems;
}

const void *jak_vector_at(const jak_vector *vec, size_t pos)
{
        return (vec && pos < vec->num_elems) ? vec->base + pos * vec->elem_size : NULL;
}

size_t jak_vector_capacity(const jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec)
        return vec->cap_elems;
}

bool jak_vector_enlarge_size_to_capacity(jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec);
        vec->num_elems = vec->cap_elems;
        return true;
}

bool jak_vector_zero_memory(jak_vector *vec)
{
        JAK_ERROR_IF_NULL(vec);
        JAK_ZERO_MEMORY(vec->base, vec->elem_size * vec->num_elems);
        return true;
}

bool jak_vector_zero_memory_in_range(jak_vector *vec, size_t from, size_t to)
{
        JAK_ERROR_IF_NULL(vec);
        JAK_ASSERT(from < to);
        JAK_ASSERT(to <= vec->cap_elems);
        JAK_ZERO_MEMORY(vec->base + from * vec->elem_size, vec->elem_size * (to - from));
        return true;
}

bool jak_vector_set(jak_vector *vec, size_t pos, const void *data)
{
        JAK_ERROR_IF_NULL(vec)
        JAK_ASSERT(pos < vec->num_elems);
        memcpy(vec->base + pos * vec->elem_size, data, vec->elem_size);
        return true;
}

bool jak_vector_cpy(jak_vector *dst, const jak_vector *src)
{
        JAK_CHECK_SUCCESS(jak_vector_create(dst, NULL, src->elem_size, src->num_elems));
        dst->num_elems = src->num_elems;
        if (dst->num_elems > 0) {
                memcpy(dst->base, src->base, src->elem_size * src->num_elems);
        }
        return true;
}

bool jak_vector_cpy_to(jak_vector *dst, jak_vector *src)
{
        JAK_ERROR_IF_NULL(dst)
        JAK_ERROR_IF_NULL(src)
        void *handle = realloc(dst->base, src->cap_elems * src->elem_size);
        if (handle) {
                dst->elem_size = src->elem_size;
                dst->num_elems = src->num_elems;
                dst->cap_elems = src->cap_elems;
                dst->grow_factor = src->grow_factor;
                dst->base = handle;
                memcpy(dst->base, src->base, src->cap_elems * src->elem_size);
                jak_error_cpy(&dst->err, &src->err);
                return true;
        } else {
                JAK_ERROR(&src->err, JAK_ERR_HARDCOPYFAILED)
                return false;
        }
}

const void *jak_vector_data(const jak_vector *vec)
{
        return vec ? vec->base : NULL;
}

char *jak_vector_string(const jak_vector ofType(T) *vec,
                    void (*printerFunc)(jak_memfile *dst, void ofType(T) *values, size_t num_elems))
{
        jak_memblock *block;
        jak_memfile file;
        jak_memblock_create(&block, vec->num_elems * vec->elem_size);
        jak_memfile_open(&file, block, JAK_READ_WRITE);
        printerFunc(&file, vec->base, vec->num_elems);
        return jak_memblock_move_contents_and_drop(block);
}
